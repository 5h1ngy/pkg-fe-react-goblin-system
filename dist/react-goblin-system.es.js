var Gv = Object.defineProperty;
var jv = (e, t, n) => t in e ? Gv(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n;
var Ac = (e, t, n) => jv(e, typeof t != "symbol" ? t + "" : t, n);
import * as F from "react";
import De, { useState as _t, useCallback as Dt, forwardRef as Ue, useContext as Fl, useLayoutEffect as Uv, useRef as gn, useMemo as Nr, createContext as Bl, Component as Hv, Fragment as Tu, useEffect as er, lazy as dm, Suspense as fm } from "react";
import { chakra as Xo, useFieldContext as Wv, Box as jt, useSlotRecipe as jr, Span as pa, useChakraContext as pm, Spinner as Yo, Separator as Zv, useRecipe as $v, IconButton as Li, useBreakpointValue as Xv, Field as za, Checkbox as Va, VStack as qn, Input as Yv, Flex as pn, Button as Nd, AbsoluteCenter as Jv, HStack as ha, Table as hr, createRecipeContext as qv, createContext as Kv, Pagination as Ta, usePaginationContext as zl, Text as ra, Portal as Vl, ActionBar as ga, Kbd as pp, Stack as Ws, Card as ia, Image as Od, Heading as Md, EmptyState as Gi, Skeleton as Zs, Circle as Qv, Avatar as hs, Group as ex, Icon as Pd, Spacer as Ru, Popover as ji, Progress as gs, createToaster as tx, Toaster as nx, Toast as Ui, ClientOnly as hm, Tabs as gi, Drawer as Wn } from "@chakra-ui/react";
import { createPortal as rx } from "react-dom";
function Dd(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var uo = { exports: {} }, Ga = {};
/**
 * @license React
 * react-jsx-runtime.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hp;
function ix() {
  if (hp) return Ga;
  hp = 1;
  var e = Symbol.for("react.transitional.element"), t = Symbol.for("react.fragment");
  function n(r, i, a) {
    var s = null;
    if (a !== void 0 && (s = "" + a), i.key !== void 0 && (s = "" + i.key), "key" in i) {
      a = {};
      for (var o in i)
        o !== "key" && (a[o] = i[o]);
    } else a = i;
    return i = a.ref, {
      $$typeof: e,
      type: r,
      key: s,
      ref: i !== void 0 ? i : null,
      props: a
    };
  }
  return Ga.Fragment = t, Ga.jsx = n, Ga.jsxs = n, Ga;
}
var ja = {};
/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var gp;
function ax() {
  return gp || (gp = 1, process.env.NODE_ENV !== "production" && function() {
    function e(C) {
      if (C == null) return null;
      if (typeof C == "function")
        return C.$$typeof === K ? null : C.displayName || C.name || null;
      if (typeof C == "string") return C;
      switch (C) {
        case x:
          return "Fragment";
        case _:
          return "Portal";
        case T:
          return "Profiler";
        case I:
          return "StrictMode";
        case M:
          return "Suspense";
        case L:
          return "SuspenseList";
      }
      if (typeof C == "object")
        switch (typeof C.tag == "number" && console.error(
          "Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."
        ), C.$$typeof) {
          case k:
            return (C.displayName || "Context") + ".Provider";
          case O:
            return (C._context.displayName || "Context") + ".Consumer";
          case W:
            var G = C.render;
            return C = C.displayName, C || (C = G.displayName || G.name || "", C = C !== "" ? "ForwardRef(" + C + ")" : "ForwardRef"), C;
          case z:
            return G = C.displayName || null, G !== null ? G : e(C.type) || "Memo";
          case U:
            G = C._payload, C = C._init;
            try {
              return e(C(G));
            } catch {
            }
        }
      return null;
    }
    function t(C) {
      return "" + C;
    }
    function n(C) {
      try {
        t(C);
        var G = !1;
      } catch {
        G = !0;
      }
      if (G) {
        G = console;
        var B = G.error, Y = typeof Symbol == "function" && Symbol.toStringTag && C[Symbol.toStringTag] || C.constructor.name || "Object";
        return B.call(
          G,
          "The provided key is an unsupported type %s. This value must be coerced to a string before using it here.",
          Y
        ), t(C);
      }
    }
    function r() {
    }
    function i() {
      if (ve === 0) {
        Te = console.log, Ce = console.info, Je = console.warn, Be = console.error, it = console.group, at = console.groupCollapsed, mt = console.groupEnd;
        var C = {
          configurable: !0,
          enumerable: !0,
          value: r,
          writable: !0
        };
        Object.defineProperties(console, {
          info: C,
          log: C,
          warn: C,
          error: C,
          group: C,
          groupCollapsed: C,
          groupEnd: C
        });
      }
      ve++;
    }
    function a() {
      if (ve--, ve === 0) {
        var C = { configurable: !0, enumerable: !0, writable: !0 };
        Object.defineProperties(console, {
          log: me({}, C, { value: Te }),
          info: me({}, C, { value: Ce }),
          warn: me({}, C, { value: Je }),
          error: me({}, C, { value: Be }),
          group: me({}, C, { value: it }),
          groupCollapsed: me({}, C, { value: at }),
          groupEnd: me({}, C, { value: mt })
        });
      }
      0 > ve && console.error(
        "disabledDepth fell below zero. This is a bug in React. Please file an issue."
      );
    }
    function s(C) {
      if (ie === void 0)
        try {
          throw Error();
        } catch (B) {
          var G = B.stack.trim().match(/\n( *(at )?)/);
          ie = G && G[1] || "", Rt = -1 < B.stack.indexOf(`
    at`) ? " (<anonymous>)" : -1 < B.stack.indexOf("@") ? "@unknown:0:0" : "";
        }
      return `
` + ie + C + Rt;
    }
    function o(C, G) {
      if (!C || ft) return "";
      var B = wt.get(C);
      if (B !== void 0) return B;
      ft = !0, B = Error.prepareStackTrace, Error.prepareStackTrace = void 0;
      var Y = null;
      Y = fe.H, fe.H = null, i();
      try {
        var ce = {
          DetermineComponentFrameRoot: function() {
            try {
              if (G) {
                var ot = function() {
                  throw Error();
                };
                if (Object.defineProperty(ot.prototype, "props", {
                  set: function() {
                    throw Error();
                  }
                }), typeof Reflect == "object" && Reflect.construct) {
                  try {
                    Reflect.construct(ot, []);
                  } catch (Ct) {
                    var tn = Ct;
                  }
                  Reflect.construct(C, [], ot);
                } else {
                  try {
                    ot.call();
                  } catch (Ct) {
                    tn = Ct;
                  }
                  C.call(ot.prototype);
                }
              } else {
                try {
                  throw Error();
                } catch (Ct) {
                  tn = Ct;
                }
                (ot = C()) && typeof ot.catch == "function" && ot.catch(function() {
                });
              }
            } catch (Ct) {
              if (Ct && tn && typeof Ct.stack == "string")
                return [Ct.stack, tn.stack];
            }
            return [null, null];
          }
        };
        ce.DetermineComponentFrameRoot.displayName = "DetermineComponentFrameRoot";
        var P = Object.getOwnPropertyDescriptor(
          ce.DetermineComponentFrameRoot,
          "name"
        );
        P && P.configurable && Object.defineProperty(
          ce.DetermineComponentFrameRoot,
          "name",
          { value: "DetermineComponentFrameRoot" }
        );
        var j = ce.DetermineComponentFrameRoot(), oe = j[0], Ie = j[1];
        if (oe && Ie) {
          var xe = oe.split(`
`), rt = Ie.split(`
`);
          for (j = P = 0; P < xe.length && !xe[P].includes(
            "DetermineComponentFrameRoot"
          ); )
            P++;
          for (; j < rt.length && !rt[j].includes(
            "DetermineComponentFrameRoot"
          ); )
            j++;
          if (P === xe.length || j === rt.length)
            for (P = xe.length - 1, j = rt.length - 1; 1 <= P && 0 <= j && xe[P] !== rt[j]; )
              j--;
          for (; 1 <= P && 0 <= j; P--, j--)
            if (xe[P] !== rt[j]) {
              if (P !== 1 || j !== 1)
                do
                  if (P--, j--, 0 > j || xe[P] !== rt[j]) {
                    var Ft = `
` + xe[P].replace(
                      " at new ",
                      " at "
                    );
                    return C.displayName && Ft.includes("<anonymous>") && (Ft = Ft.replace("<anonymous>", C.displayName)), typeof C == "function" && wt.set(C, Ft), Ft;
                  }
                while (1 <= P && 0 <= j);
              break;
            }
        }
      } finally {
        ft = !1, fe.H = Y, a(), Error.prepareStackTrace = B;
      }
      return xe = (xe = C ? C.displayName || C.name : "") ? s(xe) : "", typeof C == "function" && wt.set(C, xe), xe;
    }
    function l(C) {
      if (C == null) return "";
      if (typeof C == "function") {
        var G = C.prototype;
        return o(
          C,
          !(!G || !G.isReactComponent)
        );
      }
      if (typeof C == "string") return s(C);
      switch (C) {
        case M:
          return s("Suspense");
        case L:
          return s("SuspenseList");
      }
      if (typeof C == "object")
        switch (C.$$typeof) {
          case W:
            return C = o(C.render, !1), C;
          case z:
            return l(C.type);
          case U:
            G = C._payload, C = C._init;
            try {
              return l(C(G));
            } catch {
            }
        }
      return "";
    }
    function c() {
      var C = fe.A;
      return C === null ? null : C.getOwner();
    }
    function u(C) {
      if (S.call(C, "key")) {
        var G = Object.getOwnPropertyDescriptor(C, "key").get;
        if (G && G.isReactWarning) return !1;
      }
      return C.key !== void 0;
    }
    function d(C, G) {
      function B() {
        en || (en = !0, console.error(
          "%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://react.dev/link/special-props)",
          G
        ));
      }
      B.isReactWarning = !0, Object.defineProperty(C, "key", {
        get: B,
        configurable: !0
      });
    }
    function f() {
      var C = e(this.type);
      return R[C] || (R[C] = !0, console.error(
        "Accessing element.ref was removed in React 19. ref is now a regular prop. It will be removed from the JSX Element type in a future release."
      )), C = this.props.ref, C !== void 0 ? C : null;
    }
    function p(C, G, B, Y, ce, P) {
      return B = P.ref, C = {
        $$typeof: E,
        type: C,
        key: G,
        props: P,
        _owner: ce
      }, (B !== void 0 ? B : null) !== null ? Object.defineProperty(C, "ref", {
        enumerable: !1,
        get: f
      }) : Object.defineProperty(C, "ref", { enumerable: !1, value: null }), C._store = {}, Object.defineProperty(C._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: 0
      }), Object.defineProperty(C, "_debugInfo", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: null
      }), Object.freeze && (Object.freeze(C.props), Object.freeze(C)), C;
    }
    function h(C, G, B, Y, ce, P) {
      if (typeof C == "string" || typeof C == "function" || C === x || C === T || C === I || C === M || C === L || C === $ || typeof C == "object" && C !== null && (C.$$typeof === U || C.$$typeof === z || C.$$typeof === k || C.$$typeof === O || C.$$typeof === W || C.$$typeof === se || C.getModuleId !== void 0)) {
        var j = G.children;
        if (j !== void 0)
          if (Y)
            if (A(j)) {
              for (Y = 0; Y < j.length; Y++)
                g(j[Y], C);
              Object.freeze && Object.freeze(j);
            } else
              console.error(
                "React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead."
              );
          else g(j, C);
      } else
        j = "", (C === void 0 || typeof C == "object" && C !== null && Object.keys(C).length === 0) && (j += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports."), C === null ? Y = "null" : A(C) ? Y = "array" : C !== void 0 && C.$$typeof === E ? (Y = "<" + (e(C.type) || "Unknown") + " />", j = " Did you accidentally export a JSX literal instead of a component?") : Y = typeof C, console.error(
          "React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s",
          Y,
          j
        );
      if (S.call(G, "key")) {
        j = e(C);
        var oe = Object.keys(G).filter(function(xe) {
          return xe !== "key";
        });
        Y = 0 < oe.length ? "{key: someKey, " + oe.join(": ..., ") + ": ...}" : "{key: someKey}", D[j + Y] || (oe = 0 < oe.length ? "{" + oe.join(": ..., ") + ": ...}" : "{}", console.error(
          `A props object containing a "key" prop is being spread into JSX:
  let props = %s;
  <%s {...props} />
React keys must be passed directly to JSX without using spread:
  let props = %s;
  <%s key={someKey} {...props} />`,
          Y,
          j,
          oe,
          j
        ), D[j + Y] = !0);
      }
      if (j = null, B !== void 0 && (n(B), j = "" + B), u(G) && (n(G.key), j = "" + G.key), "key" in G) {
        B = {};
        for (var Ie in G)
          Ie !== "key" && (B[Ie] = G[Ie]);
      } else B = G;
      return j && d(
        B,
        typeof C == "function" ? C.displayName || C.name || "Unknown" : C
      ), p(C, j, P, ce, c(), B);
    }
    function g(C, G) {
      if (typeof C == "object" && C && C.$$typeof !== Fe) {
        if (A(C))
          for (var B = 0; B < C.length; B++) {
            var Y = C[B];
            m(Y) && b(Y, G);
          }
        else if (m(C))
          C._store && (C._store.validated = 1);
        else if (C === null || typeof C != "object" ? B = null : (B = Q && C[Q] || C["@@iterator"], B = typeof B == "function" ? B : null), typeof B == "function" && B !== C.entries && (B = B.call(C), B !== C))
          for (; !(C = B.next()).done; )
            m(C.value) && b(C.value, G);
      }
    }
    function m(C) {
      return typeof C == "object" && C !== null && C.$$typeof === E;
    }
    function b(C, G) {
      if (C._store && !C._store.validated && C.key == null && (C._store.validated = 1, G = y(G), !V[G])) {
        V[G] = !0;
        var B = "";
        C && C._owner != null && C._owner !== c() && (B = null, typeof C._owner.tag == "number" ? B = e(C._owner.type) : typeof C._owner.name == "string" && (B = C._owner.name), B = " It was passed a child from " + B + ".");
        var Y = fe.getCurrentStack;
        fe.getCurrentStack = function() {
          var ce = l(C.type);
          return Y && (ce += Y() || ""), ce;
        }, console.error(
          'Each child in a list should have a unique "key" prop.%s%s See https://react.dev/link/warning-keys for more information.',
          G,
          B
        ), fe.getCurrentStack = Y;
      }
    }
    function y(C) {
      var G = "", B = c();
      return B && (B = e(B.type)) && (G = `

Check the render method of \`` + B + "`."), G || (C = e(C)) && (G = `

Check the top-level render call using <` + C + ">."), G;
    }
    var v = De, E = Symbol.for("react.transitional.element"), _ = Symbol.for("react.portal"), x = Symbol.for("react.fragment"), I = Symbol.for("react.strict_mode"), T = Symbol.for("react.profiler"), O = Symbol.for("react.consumer"), k = Symbol.for("react.context"), W = Symbol.for("react.forward_ref"), M = Symbol.for("react.suspense"), L = Symbol.for("react.suspense_list"), z = Symbol.for("react.memo"), U = Symbol.for("react.lazy"), $ = Symbol.for("react.offscreen"), Q = Symbol.iterator, K = Symbol.for("react.client.reference"), fe = v.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, S = Object.prototype.hasOwnProperty, me = Object.assign, se = Symbol.for("react.client.reference"), A = Array.isArray, ve = 0, Te, Ce, Je, Be, it, at, mt;
    r.__reactDisabledLog = !0;
    var ie, Rt, ft = !1, wt = new (typeof WeakMap == "function" ? WeakMap : Map)(), Fe = Symbol.for("react.client.reference"), en, R = {}, D = {}, V = {};
    ja.Fragment = x, ja.jsx = function(C, G, B, Y, ce) {
      return h(C, G, B, !1, Y, ce);
    }, ja.jsxs = function(C, G, B, Y, ce) {
      return h(C, G, B, !0, Y, ce);
    };
  }()), ja;
}
var mp;
function sx() {
  return mp || (mp = 1, process.env.NODE_ENV === "production" ? uo.exports = ix() : uo.exports = ax()), uo.exports;
}
var w = sx(), $s = (e) => e.type === "checkbox", mi = (e) => e instanceof Date, sn = (e) => e == null;
const gm = (e) => typeof e == "object";
var Et = (e) => !sn(e) && !Array.isArray(e) && gm(e) && !mi(e), mm = (e) => Et(e) && e.target ? $s(e.target) ? e.target.checked : e.target.value : e, ox = (e) => e.substring(0, e.search(/\.\d+(\.|$)/)) || e, bm = (e, t) => e.has(ox(t)), lx = (e) => {
  const t = e.constructor && e.constructor.prototype;
  return Et(t) && t.hasOwnProperty("isPrototypeOf");
}, Ld = typeof window < "u" && typeof window.HTMLElement < "u" && typeof document < "u";
function dn(e) {
  let t;
  const n = Array.isArray(e), r = typeof FileList < "u" ? e instanceof FileList : !1;
  if (e instanceof Date)
    t = new Date(e);
  else if (e instanceof Set)
    t = new Set(e);
  else if (!(Ld && (e instanceof Blob || r)) && (n || Et(e)))
    if (t = n ? [] : {}, !n && !lx(e))
      t = e;
    else
      for (const i in e)
        e.hasOwnProperty(i) && (t[i] = dn(e[i]));
  else
    return e;
  return t;
}
var Gl = (e) => Array.isArray(e) ? e.filter(Boolean) : [], vt = (e) => e === void 0, ee = (e, t, n) => {
  if (!t || !Et(e))
    return n;
  const r = Gl(t.split(/[,[\].]+?/)).reduce((i, a) => sn(i) ? i : i[a], e);
  return vt(r) || r === e ? vt(e[t]) ? n : e[t] : r;
}, Gn = (e) => typeof e == "boolean", Fd = (e) => /^\w*$/.test(e), ym = (e) => Gl(e.replace(/["|']|\]/g, "").split(/\.|\[/)), Xe = (e, t, n) => {
  let r = -1;
  const i = Fd(t) ? [t] : ym(t), a = i.length, s = a - 1;
  for (; ++r < a; ) {
    const o = i[r];
    let l = n;
    if (r !== s) {
      const c = e[o];
      l = Et(c) || Array.isArray(c) ? c : isNaN(+i[r + 1]) ? {} : [];
    }
    if (o === "__proto__" || o === "constructor" || o === "prototype")
      return;
    e[o] = l, e = e[o];
  }
  return e;
};
const Jo = {
  BLUR: "blur",
  FOCUS_OUT: "focusout",
  CHANGE: "change"
}, Yn = {
  onBlur: "onBlur",
  onChange: "onChange",
  onSubmit: "onSubmit",
  onTouched: "onTouched",
  all: "all"
}, Sr = {
  max: "max",
  min: "min",
  maxLength: "maxLength",
  minLength: "minLength",
  pattern: "pattern",
  required: "required",
  validate: "validate"
}, _m = De.createContext(null), Bd = () => De.useContext(_m), cx = (e) => {
  const { children: t, ...n } = e;
  return De.createElement(_m.Provider, { value: n }, t);
};
var vm = (e, t, n, r = !0) => {
  const i = {
    defaultValues: t._defaultValues
  };
  for (const a in e)
    Object.defineProperty(i, a, {
      get: () => {
        const s = a;
        return t._proxyFormState[s] !== Yn.all && (t._proxyFormState[s] = !r || Yn.all), n && (n[s] = !0), e[s];
      }
    });
  return i;
}, fn = (e) => Et(e) && !Object.keys(e).length, xm = (e, t, n, r) => {
  n(e);
  const { name: i, ...a } = e;
  return fn(a) || Object.keys(a).length >= Object.keys(t).length || Object.keys(a).find((s) => t[s] === (!r || Yn.all));
}, as = (e) => Array.isArray(e) ? e : [e], Em = (e, t, n) => !e || !t || e === t || as(e).some((r) => r && (n ? r === t : r.startsWith(t) || t.startsWith(r)));
function zd(e) {
  const t = De.useRef(e);
  t.current = e, De.useEffect(() => {
    const n = !e.disabled && t.current.subject && t.current.subject.subscribe({
      next: t.current.next
    });
    return () => {
      n && n.unsubscribe();
    };
  }, [e.disabled]);
}
function ux(e) {
  const t = Bd(), { control: n = t.control, disabled: r, name: i, exact: a } = e || {}, [s, o] = De.useState(n._formState), l = De.useRef(!0), c = De.useRef({
    isDirty: !1,
    isLoading: !1,
    dirtyFields: !1,
    touchedFields: !1,
    validatingFields: !1,
    isValidating: !1,
    isValid: !1,
    errors: !1
  }), u = De.useRef(i);
  return u.current = i, zd({
    disabled: r,
    next: (d) => l.current && Em(u.current, d.name, a) && xm(d, c.current, n._updateFormState) && o({
      ...n._formState,
      ...d
    }),
    subject: n._subjects.state
  }), De.useEffect(() => (l.current = !0, c.current.isValid && n._updateValid(!0), () => {
    l.current = !1;
  }), [n]), De.useMemo(() => vm(s, n, c.current, !1), [s, n]);
}
var gr = (e) => typeof e == "string", wm = (e, t, n, r, i) => gr(e) ? (r && t.watch.add(e), ee(n, e, i)) : Array.isArray(e) ? e.map((a) => (r && t.watch.add(a), ee(n, a))) : (r && (t.watchAll = !0), n);
function dx(e) {
  const t = Bd(), { control: n = t.control, name: r, defaultValue: i, disabled: a, exact: s } = e || {}, o = De.useRef(r);
  o.current = r, zd({
    disabled: a,
    subject: n._subjects.values,
    next: (u) => {
      Em(o.current, u.name, s) && c(dn(wm(o.current, n._names, u.values || n._formValues, !1, i)));
    }
  });
  const [l, c] = De.useState(n._getWatch(r, i));
  return De.useEffect(() => n._removeUnmounted()), l;
}
function fx(e) {
  const t = Bd(), { name: n, disabled: r, control: i = t.control, shouldUnregister: a } = e, s = bm(i._names.array, n), o = dx({
    control: i,
    name: n,
    defaultValue: ee(i._formValues, n, ee(i._defaultValues, n, e.defaultValue)),
    exact: !0
  }), l = ux({
    control: i,
    name: n,
    exact: !0
  }), c = De.useRef(i.register(n, {
    ...e.rules,
    value: o,
    ...Gn(e.disabled) ? { disabled: e.disabled } : {}
  })), u = De.useMemo(() => Object.defineProperties({}, {
    invalid: {
      enumerable: !0,
      get: () => !!ee(l.errors, n)
    },
    isDirty: {
      enumerable: !0,
      get: () => !!ee(l.dirtyFields, n)
    },
    isTouched: {
      enumerable: !0,
      get: () => !!ee(l.touchedFields, n)
    },
    isValidating: {
      enumerable: !0,
      get: () => !!ee(l.validatingFields, n)
    },
    error: {
      enumerable: !0,
      get: () => ee(l.errors, n)
    }
  }), [l, n]), d = De.useMemo(() => ({
    name: n,
    value: o,
    ...Gn(r) || l.disabled ? { disabled: l.disabled || r } : {},
    onChange: (f) => c.current.onChange({
      target: {
        value: mm(f),
        name: n
      },
      type: Jo.CHANGE
    }),
    onBlur: () => c.current.onBlur({
      target: {
        value: ee(i._formValues, n),
        name: n
      },
      type: Jo.BLUR
    }),
    ref: (f) => {
      const p = ee(i._fields, n);
      p && f && (p._f.ref = {
        focus: () => f.focus(),
        select: () => f.select(),
        setCustomValidity: (h) => f.setCustomValidity(h),
        reportValidity: () => f.reportValidity()
      });
    }
  }), [
    n,
    i._formValues,
    r,
    l.disabled,
    o,
    i._fields
  ]);
  return De.useEffect(() => {
    const f = i._options.shouldUnregister || a, p = (h, g) => {
      const m = ee(i._fields, h);
      m && m._f && (m._f.mount = g);
    };
    if (p(n, !0), f) {
      const h = dn(ee(i._options.defaultValues, n));
      Xe(i._defaultValues, n, h), vt(ee(i._formValues, n)) && Xe(i._formValues, n, h);
    }
    return !s && i.register(n), () => {
      (s ? f && !i._state.action : f) ? i.unregister(n) : p(n, !1);
    };
  }, [n, i, s, a]), De.useEffect(() => {
    i._updateDisabledField({
      disabled: r,
      fields: i._fields,
      name: n
    });
  }, [r, n, i]), De.useMemo(() => ({
    field: d,
    formState: l,
    fieldState: u
  }), [d, l, u]);
}
const px = (e) => e.render(fx(e));
var Cm = (e, t, n, r, i) => t ? {
  ...n[e],
  types: {
    ...n[e] && n[e].types ? n[e].types : {},
    [r]: i || !0
  }
} : {}, bp = (e) => ({
  isOnSubmit: !e || e === Yn.onSubmit,
  isOnBlur: e === Yn.onBlur,
  isOnChange: e === Yn.onChange,
  isOnAll: e === Yn.all,
  isOnTouch: e === Yn.onTouched
}), yp = (e, t, n) => !n && (t.watchAll || t.watch.has(e) || [...t.watch].some((r) => e.startsWith(r) && /^\.\w+/.test(e.slice(r.length))));
const ss = (e, t, n, r) => {
  for (const i of n || Object.keys(e)) {
    const a = ee(e, i);
    if (a) {
      const { _f: s, ...o } = a;
      if (s) {
        if (s.refs && s.refs[0] && t(s.refs[0], i) && !r)
          return !0;
        if (s.ref && t(s.ref, s.name) && !r)
          return !0;
        if (ss(o, t))
          break;
      } else if (Et(o) && ss(o, t))
        break;
    }
  }
};
var hx = (e, t, n) => {
  const r = as(ee(e, n));
  return Xe(r, "root", t[n]), Xe(e, n, r), e;
}, Vd = (e) => e.type === "file", fr = (e) => typeof e == "function", qo = (e) => {
  if (!Ld)
    return !1;
  const t = e ? e.ownerDocument : 0;
  return e instanceof (t && t.defaultView ? t.defaultView.HTMLElement : HTMLElement);
}, No = (e) => gr(e), Gd = (e) => e.type === "radio", Ko = (e) => e instanceof RegExp;
const _p = {
  value: !1,
  isValid: !1
}, vp = { value: !0, isValid: !0 };
var Im = (e) => {
  if (Array.isArray(e)) {
    if (e.length > 1) {
      const t = e.filter((n) => n && n.checked && !n.disabled).map((n) => n.value);
      return { value: t, isValid: !!t.length };
    }
    return e[0].checked && !e[0].disabled ? (
      // @ts-expect-error expected to work in the browser
      e[0].attributes && !vt(e[0].attributes.value) ? vt(e[0].value) || e[0].value === "" ? vp : { value: e[0].value, isValid: !0 } : vp
    ) : _p;
  }
  return _p;
};
const xp = {
  isValid: !1,
  value: null
};
var Sm = (e) => Array.isArray(e) ? e.reduce((t, n) => n && n.checked && !n.disabled ? {
  isValid: !0,
  value: n.value
} : t, xp) : xp;
function Ep(e, t, n = "validate") {
  if (No(e) || Array.isArray(e) && e.every(No) || Gn(e) && !e)
    return {
      type: n,
      message: No(e) ? e : "",
      ref: t
    };
}
var Hi = (e) => Et(e) && !Ko(e) ? e : {
  value: e,
  message: ""
}, wp = async (e, t, n, r, i, a) => {
  const { ref: s, refs: o, required: l, maxLength: c, minLength: u, min: d, max: f, pattern: p, validate: h, name: g, valueAsNumber: m, mount: b } = e._f, y = ee(n, g);
  if (!b || t.has(g))
    return {};
  const v = o ? o[0] : s, E = (M) => {
    i && v.reportValidity && (v.setCustomValidity(Gn(M) ? "" : M || ""), v.reportValidity());
  }, _ = {}, x = Gd(s), I = $s(s), T = x || I, O = (m || Vd(s)) && vt(s.value) && vt(y) || qo(s) && s.value === "" || y === "" || Array.isArray(y) && !y.length, k = Cm.bind(null, g, r, _), W = (M, L, z, U = Sr.maxLength, $ = Sr.minLength) => {
    const Q = M ? L : z;
    _[g] = {
      type: M ? U : $,
      message: Q,
      ref: s,
      ...k(M ? U : $, Q)
    };
  };
  if (a ? !Array.isArray(y) || !y.length : l && (!T && (O || sn(y)) || Gn(y) && !y || I && !Im(o).isValid || x && !Sm(o).isValid)) {
    const { value: M, message: L } = No(l) ? { value: !!l, message: l } : Hi(l);
    if (M && (_[g] = {
      type: Sr.required,
      message: L,
      ref: v,
      ...k(Sr.required, L)
    }, !r))
      return E(L), _;
  }
  if (!O && (!sn(d) || !sn(f))) {
    let M, L;
    const z = Hi(f), U = Hi(d);
    if (!sn(y) && !isNaN(y)) {
      const $ = s.valueAsNumber || y && +y;
      sn(z.value) || (M = $ > z.value), sn(U.value) || (L = $ < U.value);
    } else {
      const $ = s.valueAsDate || new Date(y), Q = (S) => /* @__PURE__ */ new Date((/* @__PURE__ */ new Date()).toDateString() + " " + S), K = s.type == "time", fe = s.type == "week";
      gr(z.value) && y && (M = K ? Q(y) > Q(z.value) : fe ? y > z.value : $ > new Date(z.value)), gr(U.value) && y && (L = K ? Q(y) < Q(U.value) : fe ? y < U.value : $ < new Date(U.value));
    }
    if ((M || L) && (W(!!M, z.message, U.message, Sr.max, Sr.min), !r))
      return E(_[g].message), _;
  }
  if ((c || u) && !O && (gr(y) || a && Array.isArray(y))) {
    const M = Hi(c), L = Hi(u), z = !sn(M.value) && y.length > +M.value, U = !sn(L.value) && y.length < +L.value;
    if ((z || U) && (W(z, M.message, L.message), !r))
      return E(_[g].message), _;
  }
  if (p && !O && gr(y)) {
    const { value: M, message: L } = Hi(p);
    if (Ko(M) && !y.match(M) && (_[g] = {
      type: Sr.pattern,
      message: L,
      ref: s,
      ...k(Sr.pattern, L)
    }, !r))
      return E(L), _;
  }
  if (h) {
    if (fr(h)) {
      const M = await h(y, n), L = Ep(M, v);
      if (L && (_[g] = {
        ...L,
        ...k(Sr.validate, L.message)
      }, !r))
        return E(L.message), _;
    } else if (Et(h)) {
      let M = {};
      for (const L in h) {
        if (!fn(M) && !r)
          break;
        const z = Ep(await h[L](y, n), v, L);
        z && (M = {
          ...z,
          ...k(L, z.message)
        }, E(z.message), r && (_[g] = M));
      }
      if (!fn(M) && (_[g] = {
        ref: v,
        ...M
      }, !r))
        return _;
    }
  }
  return E(!0), _;
};
function gx(e, t) {
  const n = t.slice(0, -1).length;
  let r = 0;
  for (; r < n; )
    e = vt(e) ? r++ : e[t[r++]];
  return e;
}
function mx(e) {
  for (const t in e)
    if (e.hasOwnProperty(t) && !vt(e[t]))
      return !1;
  return !0;
}
function Ot(e, t) {
  const n = Array.isArray(t) ? t : Fd(t) ? [t] : ym(t), r = n.length === 1 ? e : gx(e, n), i = n.length - 1, a = n[i];
  return r && delete r[a], i !== 0 && (Et(r) && fn(r) || Array.isArray(r) && mx(r)) && Ot(e, n.slice(0, -1)), e;
}
var kc = () => {
  let e = [];
  return {
    get observers() {
      return e;
    },
    next: (i) => {
      for (const a of e)
        a.next && a.next(i);
    },
    subscribe: (i) => (e.push(i), {
      unsubscribe: () => {
        e = e.filter((a) => a !== i);
      }
    }),
    unsubscribe: () => {
      e = [];
    }
  };
}, Nu = (e) => sn(e) || !gm(e);
function Jr(e, t) {
  if (Nu(e) || Nu(t))
    return e === t;
  if (mi(e) && mi(t))
    return e.getTime() === t.getTime();
  const n = Object.keys(e), r = Object.keys(t);
  if (n.length !== r.length)
    return !1;
  for (const i of n) {
    const a = e[i];
    if (!r.includes(i))
      return !1;
    if (i !== "ref") {
      const s = t[i];
      if (mi(a) && mi(s) || Et(a) && Et(s) || Array.isArray(a) && Array.isArray(s) ? !Jr(a, s) : a !== s)
        return !1;
    }
  }
  return !0;
}
var Am = (e) => e.type === "select-multiple", bx = (e) => Gd(e) || $s(e), Tc = (e) => qo(e) && e.isConnected, km = (e) => {
  for (const t in e)
    if (fr(e[t]))
      return !0;
  return !1;
};
function Qo(e, t = {}) {
  const n = Array.isArray(e);
  if (Et(e) || n)
    for (const r in e)
      Array.isArray(e[r]) || Et(e[r]) && !km(e[r]) ? (t[r] = Array.isArray(e[r]) ? [] : {}, Qo(e[r], t[r])) : sn(e[r]) || (t[r] = !0);
  return t;
}
function Tm(e, t, n) {
  const r = Array.isArray(e);
  if (Et(e) || r)
    for (const i in e)
      Array.isArray(e[i]) || Et(e[i]) && !km(e[i]) ? vt(t) || Nu(n[i]) ? n[i] = Array.isArray(e[i]) ? Qo(e[i], []) : { ...Qo(e[i]) } : Tm(e[i], sn(t) ? {} : t[i], n[i]) : n[i] = !Jr(e[i], t[i]);
  return n;
}
var Ua = (e, t) => Tm(e, t, Qo(t)), Rm = (e, { valueAsNumber: t, valueAsDate: n, setValueAs: r }) => vt(e) ? e : t ? e === "" ? NaN : e && +e : n && gr(e) ? new Date(e) : r ? r(e) : e;
function Rc(e) {
  const t = e.ref;
  return Vd(t) ? t.files : Gd(t) ? Sm(e.refs).value : Am(t) ? [...t.selectedOptions].map(({ value: n }) => n) : $s(t) ? Im(e.refs).value : Rm(vt(t.value) ? e.ref.value : t.value, e);
}
var yx = (e, t, n, r) => {
  const i = {};
  for (const a of e) {
    const s = ee(t, a);
    s && Xe(i, a, s._f);
  }
  return {
    criteriaMode: n,
    names: [...e],
    fields: i,
    shouldUseNativeValidation: r
  };
}, Ha = (e) => vt(e) ? e : Ko(e) ? e.source : Et(e) ? Ko(e.value) ? e.value.source : e.value : e;
const Cp = "AsyncFunction";
var _x = (e) => !!e && !!e.validate && !!(fr(e.validate) && e.validate.constructor.name === Cp || Et(e.validate) && Object.values(e.validate).find((t) => t.constructor.name === Cp)), vx = (e) => e.mount && (e.required || e.min || e.max || e.maxLength || e.minLength || e.pattern || e.validate);
function Ip(e, t, n) {
  const r = ee(e, n);
  if (r || Fd(n))
    return {
      error: r,
      name: n
    };
  const i = n.split(".");
  for (; i.length; ) {
    const a = i.join("."), s = ee(t, a), o = ee(e, a);
    if (s && !Array.isArray(s) && n !== a)
      return { name: n };
    if (o && o.type)
      return {
        name: a,
        error: o
      };
    i.pop();
  }
  return {
    name: n
  };
}
var xx = (e, t, n, r, i) => i.isOnAll ? !1 : !n && i.isOnTouch ? !(t || e) : (n ? r.isOnBlur : i.isOnBlur) ? !e : (n ? r.isOnChange : i.isOnChange) ? e : !0, Ex = (e, t) => !Gl(ee(e, t)).length && Ot(e, t);
const wx = {
  mode: Yn.onSubmit,
  reValidateMode: Yn.onChange,
  shouldFocusError: !0
};
function Cx(e = {}) {
  let t = {
    ...wx,
    ...e
  }, n = {
    submitCount: 0,
    isDirty: !1,
    isLoading: fr(t.defaultValues),
    isValidating: !1,
    isSubmitted: !1,
    isSubmitting: !1,
    isSubmitSuccessful: !1,
    isValid: !1,
    touchedFields: {},
    dirtyFields: {},
    validatingFields: {},
    errors: t.errors || {},
    disabled: t.disabled || !1
  }, r = {}, i = Et(t.defaultValues) || Et(t.values) ? dn(t.defaultValues || t.values) || {} : {}, a = t.shouldUnregister ? {} : dn(i), s = {
    action: !1,
    mount: !1,
    watch: !1
  }, o = {
    mount: /* @__PURE__ */ new Set(),
    disabled: /* @__PURE__ */ new Set(),
    unMount: /* @__PURE__ */ new Set(),
    array: /* @__PURE__ */ new Set(),
    watch: /* @__PURE__ */ new Set()
  }, l, c = 0;
  const u = {
    isDirty: !1,
    dirtyFields: !1,
    validatingFields: !1,
    touchedFields: !1,
    isValidating: !1,
    isValid: !1,
    errors: !1
  }, d = {
    values: kc(),
    array: kc(),
    state: kc()
  }, f = bp(t.mode), p = bp(t.reValidateMode), h = t.criteriaMode === Yn.all, g = (R) => (D) => {
    clearTimeout(c), c = setTimeout(R, D);
  }, m = async (R) => {
    if (!t.disabled && (u.isValid || R)) {
      const D = t.resolver ? fn((await T()).errors) : await k(r, !0);
      D !== n.isValid && d.state.next({
        isValid: D
      });
    }
  }, b = (R, D) => {
    !t.disabled && (u.isValidating || u.validatingFields) && ((R || Array.from(o.mount)).forEach((V) => {
      V && (D ? Xe(n.validatingFields, V, D) : Ot(n.validatingFields, V));
    }), d.state.next({
      validatingFields: n.validatingFields,
      isValidating: !fn(n.validatingFields)
    }));
  }, y = (R, D = [], V, C, G = !0, B = !0) => {
    if (C && V && !t.disabled) {
      if (s.action = !0, B && Array.isArray(ee(r, R))) {
        const Y = V(ee(r, R), C.argA, C.argB);
        G && Xe(r, R, Y);
      }
      if (B && Array.isArray(ee(n.errors, R))) {
        const Y = V(ee(n.errors, R), C.argA, C.argB);
        G && Xe(n.errors, R, Y), Ex(n.errors, R);
      }
      if (u.touchedFields && B && Array.isArray(ee(n.touchedFields, R))) {
        const Y = V(ee(n.touchedFields, R), C.argA, C.argB);
        G && Xe(n.touchedFields, R, Y);
      }
      u.dirtyFields && (n.dirtyFields = Ua(i, a)), d.state.next({
        name: R,
        isDirty: M(R, D),
        dirtyFields: n.dirtyFields,
        errors: n.errors,
        isValid: n.isValid
      });
    } else
      Xe(a, R, D);
  }, v = (R, D) => {
    Xe(n.errors, R, D), d.state.next({
      errors: n.errors
    });
  }, E = (R) => {
    n.errors = R, d.state.next({
      errors: n.errors,
      isValid: !1
    });
  }, _ = (R, D, V, C) => {
    const G = ee(r, R);
    if (G) {
      const B = ee(a, R, vt(V) ? ee(i, R) : V);
      vt(B) || C && C.defaultChecked || D ? Xe(a, R, D ? B : Rc(G._f)) : U(R, B), s.mount && m();
    }
  }, x = (R, D, V, C, G) => {
    let B = !1, Y = !1;
    const ce = {
      name: R
    };
    if (!t.disabled) {
      const P = !!(ee(r, R) && ee(r, R)._f && ee(r, R)._f.disabled);
      if (!V || C) {
        u.isDirty && (Y = n.isDirty, n.isDirty = ce.isDirty = M(), B = Y !== ce.isDirty);
        const j = P || Jr(ee(i, R), D);
        Y = !!(!P && ee(n.dirtyFields, R)), j || P ? Ot(n.dirtyFields, R) : Xe(n.dirtyFields, R, !0), ce.dirtyFields = n.dirtyFields, B = B || u.dirtyFields && Y !== !j;
      }
      if (V) {
        const j = ee(n.touchedFields, R);
        j || (Xe(n.touchedFields, R, V), ce.touchedFields = n.touchedFields, B = B || u.touchedFields && j !== V);
      }
      B && G && d.state.next(ce);
    }
    return B ? ce : {};
  }, I = (R, D, V, C) => {
    const G = ee(n.errors, R), B = u.isValid && Gn(D) && n.isValid !== D;
    if (t.delayError && V ? (l = g(() => v(R, V)), l(t.delayError)) : (clearTimeout(c), l = null, V ? Xe(n.errors, R, V) : Ot(n.errors, R)), (V ? !Jr(G, V) : G) || !fn(C) || B) {
      const Y = {
        ...C,
        ...B && Gn(D) ? { isValid: D } : {},
        errors: n.errors,
        name: R
      };
      n = {
        ...n,
        ...Y
      }, d.state.next(Y);
    }
  }, T = async (R) => {
    b(R, !0);
    const D = await t.resolver(a, t.context, yx(R || o.mount, r, t.criteriaMode, t.shouldUseNativeValidation));
    return b(R), D;
  }, O = async (R) => {
    const { errors: D } = await T(R);
    if (R)
      for (const V of R) {
        const C = ee(D, V);
        C ? Xe(n.errors, V, C) : Ot(n.errors, V);
      }
    else
      n.errors = D;
    return D;
  }, k = async (R, D, V = {
    valid: !0
  }) => {
    for (const C in R) {
      const G = R[C];
      if (G) {
        const { _f: B, ...Y } = G;
        if (B) {
          const ce = o.array.has(B.name), P = G._f && _x(G._f);
          P && u.validatingFields && b([C], !0);
          const j = await wp(G, o.disabled, a, h, t.shouldUseNativeValidation && !D, ce);
          if (P && u.validatingFields && b([C]), j[B.name] && (V.valid = !1, D))
            break;
          !D && (ee(j, B.name) ? ce ? hx(n.errors, j, B.name) : Xe(n.errors, B.name, j[B.name]) : Ot(n.errors, B.name));
        }
        !fn(Y) && await k(Y, D, V);
      }
    }
    return V.valid;
  }, W = () => {
    for (const R of o.unMount) {
      const D = ee(r, R);
      D && (D._f.refs ? D._f.refs.every((V) => !Tc(V)) : !Tc(D._f.ref)) && Ce(R);
    }
    o.unMount = /* @__PURE__ */ new Set();
  }, M = (R, D) => !t.disabled && (R && D && Xe(a, R, D), !Jr(me(), i)), L = (R, D, V) => wm(R, o, {
    ...s.mount ? a : vt(D) ? i : gr(R) ? { [R]: D } : D
  }, V, D), z = (R) => Gl(ee(s.mount ? a : i, R, t.shouldUnregister ? ee(i, R, []) : [])), U = (R, D, V = {}) => {
    const C = ee(r, R);
    let G = D;
    if (C) {
      const B = C._f;
      B && (!B.disabled && Xe(a, R, Rm(D, B)), G = qo(B.ref) && sn(D) ? "" : D, Am(B.ref) ? [...B.ref.options].forEach((Y) => Y.selected = G.includes(Y.value)) : B.refs ? $s(B.ref) ? B.refs.length > 1 ? B.refs.forEach((Y) => (!Y.defaultChecked || !Y.disabled) && (Y.checked = Array.isArray(G) ? !!G.find((ce) => ce === Y.value) : G === Y.value)) : B.refs[0] && (B.refs[0].checked = !!G) : B.refs.forEach((Y) => Y.checked = Y.value === G) : Vd(B.ref) ? B.ref.value = "" : (B.ref.value = G, B.ref.type || d.values.next({
        name: R,
        values: { ...a }
      })));
    }
    (V.shouldDirty || V.shouldTouch) && x(R, G, V.shouldTouch, V.shouldDirty, !0), V.shouldValidate && S(R);
  }, $ = (R, D, V) => {
    for (const C in D) {
      const G = D[C], B = `${R}.${C}`, Y = ee(r, B);
      (o.array.has(R) || Et(G) || Y && !Y._f) && !mi(G) ? $(B, G, V) : U(B, G, V);
    }
  }, Q = (R, D, V = {}) => {
    const C = ee(r, R), G = o.array.has(R), B = dn(D);
    Xe(a, R, B), G ? (d.array.next({
      name: R,
      values: { ...a }
    }), (u.isDirty || u.dirtyFields) && V.shouldDirty && d.state.next({
      name: R,
      dirtyFields: Ua(i, a),
      isDirty: M(R, B)
    })) : C && !C._f && !sn(B) ? $(R, B, V) : U(R, B, V), yp(R, o) && d.state.next({ ...n }), d.values.next({
      name: s.mount ? R : void 0,
      values: { ...a }
    });
  }, K = async (R) => {
    s.mount = !0;
    const D = R.target;
    let V = D.name, C = !0;
    const G = ee(r, V), B = () => D.type ? Rc(G._f) : mm(R), Y = (ce) => {
      C = Number.isNaN(ce) || mi(ce) && isNaN(ce.getTime()) || Jr(ce, ee(a, V, ce));
    };
    if (G) {
      let ce, P;
      const j = B(), oe = R.type === Jo.BLUR || R.type === Jo.FOCUS_OUT, Ie = !vx(G._f) && !t.resolver && !ee(n.errors, V) && !G._f.deps || xx(oe, ee(n.touchedFields, V), n.isSubmitted, p, f), xe = yp(V, o, oe);
      Xe(a, V, j), oe ? (G._f.onBlur && G._f.onBlur(R), l && l(0)) : G._f.onChange && G._f.onChange(R);
      const rt = x(V, j, oe, !1), Ft = !fn(rt) || xe;
      if (!oe && d.values.next({
        name: V,
        type: R.type,
        values: { ...a }
      }), Ie)
        return u.isValid && (t.mode === "onBlur" && oe ? m() : oe || m()), Ft && d.state.next({ name: V, ...xe ? {} : rt });
      if (!oe && xe && d.state.next({ ...n }), t.resolver) {
        const { errors: ot } = await T([V]);
        if (Y(j), C) {
          const tn = Ip(n.errors, r, V), Ct = Ip(ot, r, tn.name || V);
          ce = Ct.error, V = Ct.name, P = fn(ot);
        }
      } else
        b([V], !0), ce = (await wp(G, o.disabled, a, h, t.shouldUseNativeValidation))[V], b([V]), Y(j), C && (ce ? P = !1 : u.isValid && (P = await k(r, !0)));
      C && (G._f.deps && S(G._f.deps), I(V, P, ce, rt));
    }
  }, fe = (R, D) => {
    if (ee(n.errors, D) && R.focus)
      return R.focus(), 1;
  }, S = async (R, D = {}) => {
    let V, C;
    const G = as(R);
    if (t.resolver) {
      const B = await O(vt(R) ? R : G);
      V = fn(B), C = R ? !G.some((Y) => ee(B, Y)) : V;
    } else R ? (C = (await Promise.all(G.map(async (B) => {
      const Y = ee(r, B);
      return await k(Y && Y._f ? { [B]: Y } : Y);
    }))).every(Boolean), !(!C && !n.isValid) && m()) : C = V = await k(r);
    return d.state.next({
      ...!gr(R) || u.isValid && V !== n.isValid ? {} : { name: R },
      ...t.resolver || !R ? { isValid: V } : {},
      errors: n.errors
    }), D.shouldFocus && !C && ss(r, fe, R ? G : o.mount), C;
  }, me = (R) => {
    const D = {
      ...s.mount ? a : i
    };
    return vt(R) ? D : gr(R) ? ee(D, R) : R.map((V) => ee(D, V));
  }, se = (R, D) => ({
    invalid: !!ee((D || n).errors, R),
    isDirty: !!ee((D || n).dirtyFields, R),
    error: ee((D || n).errors, R),
    isValidating: !!ee(n.validatingFields, R),
    isTouched: !!ee((D || n).touchedFields, R)
  }), A = (R) => {
    R && as(R).forEach((D) => Ot(n.errors, D)), d.state.next({
      errors: R ? n.errors : {}
    });
  }, ve = (R, D, V) => {
    const C = (ee(r, R, { _f: {} })._f || {}).ref, G = ee(n.errors, R) || {}, { ref: B, message: Y, type: ce, ...P } = G;
    Xe(n.errors, R, {
      ...P,
      ...D,
      ref: C
    }), d.state.next({
      name: R,
      errors: n.errors,
      isValid: !1
    }), V && V.shouldFocus && C && C.focus && C.focus();
  }, Te = (R, D) => fr(R) ? d.values.subscribe({
    next: (V) => R(L(void 0, D), V)
  }) : L(R, D, !0), Ce = (R, D = {}) => {
    for (const V of R ? as(R) : o.mount)
      o.mount.delete(V), o.array.delete(V), D.keepValue || (Ot(r, V), Ot(a, V)), !D.keepError && Ot(n.errors, V), !D.keepDirty && Ot(n.dirtyFields, V), !D.keepTouched && Ot(n.touchedFields, V), !D.keepIsValidating && Ot(n.validatingFields, V), !t.shouldUnregister && !D.keepDefaultValue && Ot(i, V);
    d.values.next({
      values: { ...a }
    }), d.state.next({
      ...n,
      ...D.keepDirty ? { isDirty: M() } : {}
    }), !D.keepIsValid && m();
  }, Je = ({ disabled: R, name: D, field: V, fields: C }) => {
    (Gn(R) && s.mount || R || o.disabled.has(D)) && (R ? o.disabled.add(D) : o.disabled.delete(D), x(D, Rc(V ? V._f : ee(C, D)._f), !1, !1, !0));
  }, Be = (R, D = {}) => {
    let V = ee(r, R);
    const C = Gn(D.disabled) || Gn(t.disabled);
    return Xe(r, R, {
      ...V || {},
      _f: {
        ...V && V._f ? V._f : { ref: { name: R } },
        name: R,
        mount: !0,
        ...D
      }
    }), o.mount.add(R), V ? Je({
      field: V,
      disabled: Gn(D.disabled) ? D.disabled : t.disabled,
      name: R
    }) : _(R, !0, D.value), {
      ...C ? { disabled: D.disabled || t.disabled } : {},
      ...t.progressive ? {
        required: !!D.required,
        min: Ha(D.min),
        max: Ha(D.max),
        minLength: Ha(D.minLength),
        maxLength: Ha(D.maxLength),
        pattern: Ha(D.pattern)
      } : {},
      name: R,
      onChange: K,
      onBlur: K,
      ref: (G) => {
        if (G) {
          Be(R, D), V = ee(r, R);
          const B = vt(G.value) && G.querySelectorAll && G.querySelectorAll("input,select,textarea")[0] || G, Y = bx(B), ce = V._f.refs || [];
          if (Y ? ce.find((P) => P === B) : B === V._f.ref)
            return;
          Xe(r, R, {
            _f: {
              ...V._f,
              ...Y ? {
                refs: [
                  ...ce.filter(Tc),
                  B,
                  ...Array.isArray(ee(i, R)) ? [{}] : []
                ],
                ref: { type: B.type, name: R }
              } : { ref: B }
            }
          }), _(R, !1, void 0, B);
        } else
          V = ee(r, R, {}), V._f && (V._f.mount = !1), (t.shouldUnregister || D.shouldUnregister) && !(bm(o.array, R) && s.action) && o.unMount.add(R);
      }
    };
  }, it = () => t.shouldFocusError && ss(r, fe, o.mount), at = (R) => {
    Gn(R) && (d.state.next({ disabled: R }), ss(r, (D, V) => {
      const C = ee(r, V);
      C && (D.disabled = C._f.disabled || R, Array.isArray(C._f.refs) && C._f.refs.forEach((G) => {
        G.disabled = C._f.disabled || R;
      }));
    }, 0, !1));
  }, mt = (R, D) => async (V) => {
    let C;
    V && (V.preventDefault && V.preventDefault(), V.persist && V.persist());
    let G = dn(a);
    if (o.disabled.size)
      for (const B of o.disabled)
        Xe(G, B, void 0);
    if (d.state.next({
      isSubmitting: !0
    }), t.resolver) {
      const { errors: B, values: Y } = await T();
      n.errors = B, G = Y;
    } else
      await k(r);
    if (Ot(n.errors, "root"), fn(n.errors)) {
      d.state.next({
        errors: {}
      });
      try {
        await R(G, V);
      } catch (B) {
        C = B;
      }
    } else
      D && await D({ ...n.errors }, V), it(), setTimeout(it);
    if (d.state.next({
      isSubmitted: !0,
      isSubmitting: !1,
      isSubmitSuccessful: fn(n.errors) && !C,
      submitCount: n.submitCount + 1,
      errors: n.errors
    }), C)
      throw C;
  }, ie = (R, D = {}) => {
    ee(r, R) && (vt(D.defaultValue) ? Q(R, dn(ee(i, R))) : (Q(R, D.defaultValue), Xe(i, R, dn(D.defaultValue))), D.keepTouched || Ot(n.touchedFields, R), D.keepDirty || (Ot(n.dirtyFields, R), n.isDirty = D.defaultValue ? M(R, dn(ee(i, R))) : M()), D.keepError || (Ot(n.errors, R), u.isValid && m()), d.state.next({ ...n }));
  }, Rt = (R, D = {}) => {
    const V = R ? dn(R) : i, C = dn(V), G = fn(R), B = G ? i : C;
    if (D.keepDefaultValues || (i = V), !D.keepValues) {
      if (D.keepDirtyValues) {
        const Y = /* @__PURE__ */ new Set([
          ...o.mount,
          ...Object.keys(Ua(i, a))
        ]);
        for (const ce of Array.from(Y))
          ee(n.dirtyFields, ce) ? Xe(B, ce, ee(a, ce)) : Q(ce, ee(B, ce));
      } else {
        if (Ld && vt(R))
          for (const Y of o.mount) {
            const ce = ee(r, Y);
            if (ce && ce._f) {
              const P = Array.isArray(ce._f.refs) ? ce._f.refs[0] : ce._f.ref;
              if (qo(P)) {
                const j = P.closest("form");
                if (j) {
                  j.reset();
                  break;
                }
              }
            }
          }
        r = {};
      }
      a = t.shouldUnregister ? D.keepDefaultValues ? dn(i) : {} : dn(B), d.array.next({
        values: { ...B }
      }), d.values.next({
        values: { ...B }
      });
    }
    o = {
      mount: D.keepDirtyValues ? o.mount : /* @__PURE__ */ new Set(),
      unMount: /* @__PURE__ */ new Set(),
      array: /* @__PURE__ */ new Set(),
      disabled: /* @__PURE__ */ new Set(),
      watch: /* @__PURE__ */ new Set(),
      watchAll: !1,
      focus: ""
    }, s.mount = !u.isValid || !!D.keepIsValid || !!D.keepDirtyValues, s.watch = !!t.shouldUnregister, d.state.next({
      submitCount: D.keepSubmitCount ? n.submitCount : 0,
      isDirty: G ? !1 : D.keepDirty ? n.isDirty : !!(D.keepDefaultValues && !Jr(R, i)),
      isSubmitted: D.keepIsSubmitted ? n.isSubmitted : !1,
      dirtyFields: G ? {} : D.keepDirtyValues ? D.keepDefaultValues && a ? Ua(i, a) : n.dirtyFields : D.keepDefaultValues && R ? Ua(i, R) : D.keepDirty ? n.dirtyFields : {},
      touchedFields: D.keepTouched ? n.touchedFields : {},
      errors: D.keepErrors ? n.errors : {},
      isSubmitSuccessful: D.keepIsSubmitSuccessful ? n.isSubmitSuccessful : !1,
      isSubmitting: !1
    });
  }, ft = (R, D) => Rt(fr(R) ? R(a) : R, D);
  return {
    control: {
      register: Be,
      unregister: Ce,
      getFieldState: se,
      handleSubmit: mt,
      setError: ve,
      _executeSchema: T,
      _getWatch: L,
      _getDirty: M,
      _updateValid: m,
      _removeUnmounted: W,
      _updateFieldArray: y,
      _updateDisabledField: Je,
      _getFieldArray: z,
      _reset: Rt,
      _resetDefaultValues: () => fr(t.defaultValues) && t.defaultValues().then((R) => {
        ft(R, t.resetOptions), d.state.next({
          isLoading: !1
        });
      }),
      _updateFormState: (R) => {
        n = {
          ...n,
          ...R
        };
      },
      _disableForm: at,
      _subjects: d,
      _proxyFormState: u,
      _setErrors: E,
      get _fields() {
        return r;
      },
      get _formValues() {
        return a;
      },
      get _state() {
        return s;
      },
      set _state(R) {
        s = R;
      },
      get _defaultValues() {
        return i;
      },
      get _names() {
        return o;
      },
      set _names(R) {
        o = R;
      },
      get _formState() {
        return n;
      },
      set _formState(R) {
        n = R;
      },
      get _options() {
        return t;
      },
      set _options(R) {
        t = {
          ...t,
          ...R
        };
      }
    },
    trigger: S,
    register: Be,
    handleSubmit: mt,
    watch: Te,
    setValue: Q,
    getValues: me,
    reset: ft,
    resetField: ie,
    clearErrors: A,
    unregister: Ce,
    setError: ve,
    setFocus: (R, D = {}) => {
      const V = ee(r, R), C = V && V._f;
      if (C) {
        const G = C.refs ? C.refs[0] : C.ref;
        G.focus && (G.focus(), D.shouldSelect && fr(G.select) && G.select());
      }
    },
    getFieldState: se
  };
}
function Ix(e = {}) {
  const t = De.useRef(void 0), n = De.useRef(void 0), [r, i] = De.useState({
    isDirty: !1,
    isValidating: !1,
    isLoading: fr(e.defaultValues),
    isSubmitted: !1,
    isSubmitting: !1,
    isSubmitSuccessful: !1,
    isValid: !1,
    submitCount: 0,
    dirtyFields: {},
    touchedFields: {},
    validatingFields: {},
    errors: e.errors || {},
    disabled: e.disabled || !1,
    defaultValues: fr(e.defaultValues) ? void 0 : e.defaultValues
  });
  t.current || (t.current = {
    ...Cx(e),
    formState: r
  });
  const a = t.current.control;
  return a._options = e, zd({
    subject: a._subjects.state,
    next: (s) => {
      xm(s, a._proxyFormState, a._updateFormState, !0) && i({ ...a._formState });
    }
  }), De.useEffect(() => a._disableForm(e.disabled), [a, e.disabled]), De.useEffect(() => {
    if (a._proxyFormState.isDirty) {
      const s = a._getDirty();
      s !== r.isDirty && a._subjects.state.next({
        isDirty: s
      });
    }
  }, [a, r.isDirty]), De.useEffect(() => {
    e.values && !Jr(e.values, n.current) ? (a._reset(e.values, a._options.resetOptions), n.current = e.values, i((s) => ({ ...s }))) : a._resetDefaultValues();
  }, [e.values, a]), De.useEffect(() => {
    e.errors && a._setErrors(e.errors);
  }, [e.errors, a]), De.useEffect(() => {
    a._state.mount || (a._updateValid(), a._state.mount = !0), a._state.watch && (a._state.watch = !1, a._subjects.state.next({ ...a._formState })), a._removeUnmounted();
  }), De.useEffect(() => {
    e.shouldUnregister && a._subjects.values.next({
      values: a._getWatch()
    });
  }, [e.shouldUnregister, a]), t.current.formState = vm(r, a), t.current;
}
const Sp = (e, t, n) => {
  if (e && "reportValidity" in e) {
    const r = ee(n, t);
    e.setCustomValidity(r && r.message || ""), e.reportValidity();
  }
}, Nm = (e, t) => {
  for (const n in t.fields) {
    const r = t.fields[n];
    r && r.ref && "reportValidity" in r.ref ? Sp(r.ref, n, e) : r && r.refs && r.refs.forEach((i) => Sp(i, n, e));
  }
}, Sx = (e, t) => {
  t.shouldUseNativeValidation && Nm(e, t);
  const n = {};
  for (const r in e) {
    const i = ee(t.fields, r), a = Object.assign(e[r] || {}, { ref: i && i.ref });
    if (Ax(t.names || Object.keys(e), r)) {
      const s = Object.assign({}, ee(n, r));
      Xe(s, "root", a), Xe(n, r, s);
    } else Xe(n, r, a);
  }
  return n;
}, Ax = (e, t) => e.some((n) => n.match(`^${t}\\.\\d+`));
var kx = function(e, t) {
  for (var n = {}; e.length; ) {
    var r = e[0], i = r.code, a = r.message, s = r.path.join(".");
    if (!n[s]) if ("unionErrors" in r) {
      var o = r.unionErrors[0].errors[0];
      n[s] = { message: o.message, type: o.code };
    } else n[s] = { message: a, type: i };
    if ("unionErrors" in r && r.unionErrors.forEach(function(u) {
      return u.errors.forEach(function(d) {
        return e.push(d);
      });
    }), t) {
      var l = n[s].types, c = l && l[r.code];
      n[s] = Cm(s, t, n, i, c ? [].concat(c, r.message) : r.message);
    }
    e.shift();
  }
  return n;
}, Tx = function(e, t, n) {
  return n === void 0 && (n = {}), function(r, i, a) {
    try {
      return Promise.resolve(function(s, o) {
        try {
          var l = Promise.resolve(e[n.mode === "sync" ? "parse" : "parseAsync"](r, t)).then(function(c) {
            return a.shouldUseNativeValidation && Nm({}, a), { errors: {}, values: n.raw ? Object.assign({}, r) : c };
          });
        } catch (c) {
          return o(c);
        }
        return l && l.then ? l.then(void 0, o) : l;
      }(0, function(s) {
        if (function(o) {
          return Array.isArray(o == null ? void 0 : o.errors);
        }(s)) return { values: {}, errors: Sx(kx(s.errors, !a.shouldUseNativeValidation && a.criteriaMode === "all"), a) };
        throw s;
      }));
    } catch (s) {
      return Promise.reject(s);
    }
  };
};
function Rx(e, t) {
  const n = Ix({
    resolver: Tx(e),
    defaultValues: t
  });
  return { fields: e.innerType().shape ? Object.entries(e.innerType().shape).reduce((i, [a, s]) => {
    var d, f, p;
    const o = s, l = ((d = o.meta) == null ? void 0 : d.step) || 0, c = ((p = (f = o.meta) == null ? void 0 : f.row) == null ? void 0 : p.toString()) || "__NO_ROW__", u = [a, s];
    if (i[l] || (i[l] = {}), !i[l][`${c}`])
      i[l][`${c}`] = [u];
    else {
      const h = i[l][`${c}`];
      i[l][`${c}`] = [...h, u];
    }
    return i;
  }, []) : [], methods: n };
}
var Ge;
(function(e) {
  e.assertEqual = (i) => i;
  function t(i) {
  }
  e.assertIs = t;
  function n(i) {
    throw new Error();
  }
  e.assertNever = n, e.arrayToEnum = (i) => {
    const a = {};
    for (const s of i)
      a[s] = s;
    return a;
  }, e.getValidEnumValues = (i) => {
    const a = e.objectKeys(i).filter((o) => typeof i[i[o]] != "number"), s = {};
    for (const o of a)
      s[o] = i[o];
    return e.objectValues(s);
  }, e.objectValues = (i) => e.objectKeys(i).map(function(a) {
    return i[a];
  }), e.objectKeys = typeof Object.keys == "function" ? (i) => Object.keys(i) : (i) => {
    const a = [];
    for (const s in i)
      Object.prototype.hasOwnProperty.call(i, s) && a.push(s);
    return a;
  }, e.find = (i, a) => {
    for (const s of i)
      if (a(s))
        return s;
  }, e.isInteger = typeof Number.isInteger == "function" ? (i) => Number.isInteger(i) : (i) => typeof i == "number" && isFinite(i) && Math.floor(i) === i;
  function r(i, a = " | ") {
    return i.map((s) => typeof s == "string" ? `'${s}'` : s).join(a);
  }
  e.joinValues = r, e.jsonStringifyReplacer = (i, a) => typeof a == "bigint" ? a.toString() : a;
})(Ge || (Ge = {}));
var Ou;
(function(e) {
  e.mergeShapes = (t, n) => ({
    ...t,
    ...n
    // second overwrites first
  });
})(Ou || (Ou = {}));
const ae = Ge.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set"
]), Tr = (e) => {
  switch (typeof e) {
    case "undefined":
      return ae.undefined;
    case "string":
      return ae.string;
    case "number":
      return isNaN(e) ? ae.nan : ae.number;
    case "boolean":
      return ae.boolean;
    case "function":
      return ae.function;
    case "bigint":
      return ae.bigint;
    case "symbol":
      return ae.symbol;
    case "object":
      return Array.isArray(e) ? ae.array : e === null ? ae.null : e.then && typeof e.then == "function" && e.catch && typeof e.catch == "function" ? ae.promise : typeof Map < "u" && e instanceof Map ? ae.map : typeof Set < "u" && e instanceof Set ? ae.set : typeof Date < "u" && e instanceof Date ? ae.date : ae.object;
    default:
      return ae.unknown;
  }
}, X = Ge.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite"
]), Nx = (e) => JSON.stringify(e, null, 2).replace(/"([^"]+)":/g, "$1:");
class Tn extends Error {
  get errors() {
    return this.issues;
  }
  constructor(t) {
    super(), this.issues = [], this.addIssue = (r) => {
      this.issues = [...this.issues, r];
    }, this.addIssues = (r = []) => {
      this.issues = [...this.issues, ...r];
    };
    const n = new.target.prototype;
    Object.setPrototypeOf ? Object.setPrototypeOf(this, n) : this.__proto__ = n, this.name = "ZodError", this.issues = t;
  }
  format(t) {
    const n = t || function(a) {
      return a.message;
    }, r = { _errors: [] }, i = (a) => {
      for (const s of a.issues)
        if (s.code === "invalid_union")
          s.unionErrors.map(i);
        else if (s.code === "invalid_return_type")
          i(s.returnTypeError);
        else if (s.code === "invalid_arguments")
          i(s.argumentsError);
        else if (s.path.length === 0)
          r._errors.push(n(s));
        else {
          let o = r, l = 0;
          for (; l < s.path.length; ) {
            const c = s.path[l];
            l === s.path.length - 1 ? (o[c] = o[c] || { _errors: [] }, o[c]._errors.push(n(s))) : o[c] = o[c] || { _errors: [] }, o = o[c], l++;
          }
        }
    };
    return i(this), r;
  }
  static assert(t) {
    if (!(t instanceof Tn))
      throw new Error(`Not a ZodError: ${t}`);
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, Ge.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(t = (n) => n.message) {
    const n = {}, r = [];
    for (const i of this.issues)
      i.path.length > 0 ? (n[i.path[0]] = n[i.path[0]] || [], n[i.path[0]].push(t(i))) : r.push(t(i));
    return { formErrors: r, fieldErrors: n };
  }
  get formErrors() {
    return this.flatten();
  }
}
Tn.create = (e) => new Tn(e);
const ma = (e, t) => {
  let n;
  switch (e.code) {
    case X.invalid_type:
      e.received === ae.undefined ? n = "Required" : n = `Expected ${e.expected}, received ${e.received}`;
      break;
    case X.invalid_literal:
      n = `Invalid literal value, expected ${JSON.stringify(e.expected, Ge.jsonStringifyReplacer)}`;
      break;
    case X.unrecognized_keys:
      n = `Unrecognized key(s) in object: ${Ge.joinValues(e.keys, ", ")}`;
      break;
    case X.invalid_union:
      n = "Invalid input";
      break;
    case X.invalid_union_discriminator:
      n = `Invalid discriminator value. Expected ${Ge.joinValues(e.options)}`;
      break;
    case X.invalid_enum_value:
      n = `Invalid enum value. Expected ${Ge.joinValues(e.options)}, received '${e.received}'`;
      break;
    case X.invalid_arguments:
      n = "Invalid function arguments";
      break;
    case X.invalid_return_type:
      n = "Invalid function return type";
      break;
    case X.invalid_date:
      n = "Invalid date";
      break;
    case X.invalid_string:
      typeof e.validation == "object" ? "includes" in e.validation ? (n = `Invalid input: must include "${e.validation.includes}"`, typeof e.validation.position == "number" && (n = `${n} at one or more positions greater than or equal to ${e.validation.position}`)) : "startsWith" in e.validation ? n = `Invalid input: must start with "${e.validation.startsWith}"` : "endsWith" in e.validation ? n = `Invalid input: must end with "${e.validation.endsWith}"` : Ge.assertNever(e.validation) : e.validation !== "regex" ? n = `Invalid ${e.validation}` : n = "Invalid";
      break;
    case X.too_small:
      e.type === "array" ? n = `Array must contain ${e.exact ? "exactly" : e.inclusive ? "at least" : "more than"} ${e.minimum} element(s)` : e.type === "string" ? n = `String must contain ${e.exact ? "exactly" : e.inclusive ? "at least" : "over"} ${e.minimum} character(s)` : e.type === "number" ? n = `Number must be ${e.exact ? "exactly equal to " : e.inclusive ? "greater than or equal to " : "greater than "}${e.minimum}` : e.type === "date" ? n = `Date must be ${e.exact ? "exactly equal to " : e.inclusive ? "greater than or equal to " : "greater than "}${new Date(Number(e.minimum))}` : n = "Invalid input";
      break;
    case X.too_big:
      e.type === "array" ? n = `Array must contain ${e.exact ? "exactly" : e.inclusive ? "at most" : "less than"} ${e.maximum} element(s)` : e.type === "string" ? n = `String must contain ${e.exact ? "exactly" : e.inclusive ? "at most" : "under"} ${e.maximum} character(s)` : e.type === "number" ? n = `Number must be ${e.exact ? "exactly" : e.inclusive ? "less than or equal to" : "less than"} ${e.maximum}` : e.type === "bigint" ? n = `BigInt must be ${e.exact ? "exactly" : e.inclusive ? "less than or equal to" : "less than"} ${e.maximum}` : e.type === "date" ? n = `Date must be ${e.exact ? "exactly" : e.inclusive ? "smaller than or equal to" : "smaller than"} ${new Date(Number(e.maximum))}` : n = "Invalid input";
      break;
    case X.custom:
      n = "Invalid input";
      break;
    case X.invalid_intersection_types:
      n = "Intersection results could not be merged";
      break;
    case X.not_multiple_of:
      n = `Number must be a multiple of ${e.multipleOf}`;
      break;
    case X.not_finite:
      n = "Number must be finite";
      break;
    default:
      n = t.defaultError, Ge.assertNever(e);
  }
  return { message: n };
};
let Om = ma;
function Ox(e) {
  Om = e;
}
function el() {
  return Om;
}
const tl = (e) => {
  const { data: t, path: n, errorMaps: r, issueData: i } = e, a = [...n, ...i.path || []], s = {
    ...i,
    path: a
  };
  if (i.message !== void 0)
    return {
      ...i,
      path: a,
      message: i.message
    };
  let o = "";
  const l = r.filter((c) => !!c).slice().reverse();
  for (const c of l)
    o = c(s, { data: t, defaultError: o }).message;
  return {
    ...i,
    path: a,
    message: o
  };
}, Mx = [];
function ne(e, t) {
  const n = el(), r = tl({
    issueData: t,
    data: e.data,
    path: e.path,
    errorMaps: [
      e.common.contextualErrorMap,
      // contextual error map is first priority
      e.schemaErrorMap,
      // then schema-bound map if available
      n,
      // then global override map
      n === ma ? void 0 : ma
      // then global default map
    ].filter((i) => !!i)
  });
  e.common.issues.push(r);
}
class Kt {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    this.value === "valid" && (this.value = "dirty");
  }
  abort() {
    this.value !== "aborted" && (this.value = "aborted");
  }
  static mergeArray(t, n) {
    const r = [];
    for (const i of n) {
      if (i.status === "aborted")
        return we;
      i.status === "dirty" && t.dirty(), r.push(i.value);
    }
    return { status: t.value, value: r };
  }
  static async mergeObjectAsync(t, n) {
    const r = [];
    for (const i of n) {
      const a = await i.key, s = await i.value;
      r.push({
        key: a,
        value: s
      });
    }
    return Kt.mergeObjectSync(t, r);
  }
  static mergeObjectSync(t, n) {
    const r = {};
    for (const i of n) {
      const { key: a, value: s } = i;
      if (a.status === "aborted" || s.status === "aborted")
        return we;
      a.status === "dirty" && t.dirty(), s.status === "dirty" && t.dirty(), a.value !== "__proto__" && (typeof s.value < "u" || i.alwaysSet) && (r[a.value] = s.value);
    }
    return { status: t.value, value: r };
  }
}
const we = Object.freeze({
  status: "aborted"
}), Qi = (e) => ({ status: "dirty", value: e }), cn = (e) => ({ status: "valid", value: e }), Mu = (e) => e.status === "aborted", Pu = (e) => e.status === "dirty", Si = (e) => e.status === "valid", ms = (e) => typeof Promise < "u" && e instanceof Promise;
function nl(e, t, n, r) {
  if (typeof t == "function" ? e !== t || !0 : !t.has(e)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return t.get(e);
}
function Mm(e, t, n, r, i) {
  if (typeof t == "function" ? e !== t || !0 : !t.has(e)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return t.set(e, n), n;
}
var de;
(function(e) {
  e.errToObj = (t) => typeof t == "string" ? { message: t } : t || {}, e.toString = (t) => typeof t == "string" ? t : t == null ? void 0 : t.message;
})(de || (de = {}));
var es, ts;
class xr {
  constructor(t, n, r, i) {
    this._cachedPath = [], this.parent = t, this.data = n, this._path = r, this._key = i;
  }
  get path() {
    return this._cachedPath.length || (this._key instanceof Array ? this._cachedPath.push(...this._path, ...this._key) : this._cachedPath.push(...this._path, this._key)), this._cachedPath;
  }
}
const Ap = (e, t) => {
  if (Si(t))
    return { success: !0, data: t.value };
  if (!e.common.issues.length)
    throw new Error("Validation failed but no issues detected.");
  return {
    success: !1,
    get error() {
      if (this._error)
        return this._error;
      const n = new Tn(e.common.issues);
      return this._error = n, this._error;
    }
  };
};
function Oe(e) {
  if (!e)
    return {};
  const { errorMap: t, invalid_type_error: n, required_error: r, description: i } = e;
  if (t && (n || r))
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  return t ? { errorMap: t, description: i } : { errorMap: (s, o) => {
    var l, c;
    const { message: u } = e;
    return s.code === "invalid_enum_value" ? { message: u ?? o.defaultError } : typeof o.data > "u" ? { message: (l = u ?? r) !== null && l !== void 0 ? l : o.defaultError } : s.code !== "invalid_type" ? { message: o.defaultError } : { message: (c = u ?? n) !== null && c !== void 0 ? c : o.defaultError };
  }, description: i };
}
class Me {
  get description() {
    return this._def.description;
  }
  _getType(t) {
    return Tr(t.data);
  }
  _getOrReturnCtx(t, n) {
    return n || {
      common: t.parent.common,
      data: t.data,
      parsedType: Tr(t.data),
      schemaErrorMap: this._def.errorMap,
      path: t.path,
      parent: t.parent
    };
  }
  _processInputParams(t) {
    return {
      status: new Kt(),
      ctx: {
        common: t.parent.common,
        data: t.data,
        parsedType: Tr(t.data),
        schemaErrorMap: this._def.errorMap,
        path: t.path,
        parent: t.parent
      }
    };
  }
  _parseSync(t) {
    const n = this._parse(t);
    if (ms(n))
      throw new Error("Synchronous parse encountered promise.");
    return n;
  }
  _parseAsync(t) {
    const n = this._parse(t);
    return Promise.resolve(n);
  }
  parse(t, n) {
    const r = this.safeParse(t, n);
    if (r.success)
      return r.data;
    throw r.error;
  }
  safeParse(t, n) {
    var r;
    const i = {
      common: {
        issues: [],
        async: (r = n == null ? void 0 : n.async) !== null && r !== void 0 ? r : !1,
        contextualErrorMap: n == null ? void 0 : n.errorMap
      },
      path: (n == null ? void 0 : n.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data: t,
      parsedType: Tr(t)
    }, a = this._parseSync({ data: t, path: i.path, parent: i });
    return Ap(i, a);
  }
  "~validate"(t) {
    var n, r;
    const i = {
      common: {
        issues: [],
        async: !!this["~standard"].async
      },
      path: [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data: t,
      parsedType: Tr(t)
    };
    if (!this["~standard"].async)
      try {
        const a = this._parseSync({ data: t, path: [], parent: i });
        return Si(a) ? {
          value: a.value
        } : {
          issues: i.common.issues
        };
      } catch (a) {
        !((r = (n = a == null ? void 0 : a.message) === null || n === void 0 ? void 0 : n.toLowerCase()) === null || r === void 0) && r.includes("encountered") && (this["~standard"].async = !0), i.common = {
          issues: [],
          async: !0
        };
      }
    return this._parseAsync({ data: t, path: [], parent: i }).then((a) => Si(a) ? {
      value: a.value
    } : {
      issues: i.common.issues
    });
  }
  async parseAsync(t, n) {
    const r = await this.safeParseAsync(t, n);
    if (r.success)
      return r.data;
    throw r.error;
  }
  async safeParseAsync(t, n) {
    const r = {
      common: {
        issues: [],
        contextualErrorMap: n == null ? void 0 : n.errorMap,
        async: !0
      },
      path: (n == null ? void 0 : n.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data: t,
      parsedType: Tr(t)
    }, i = this._parse({ data: t, path: r.path, parent: r }), a = await (ms(i) ? i : Promise.resolve(i));
    return Ap(r, a);
  }
  refine(t, n) {
    const r = (i) => typeof n == "string" || typeof n > "u" ? { message: n } : typeof n == "function" ? n(i) : n;
    return this._refinement((i, a) => {
      const s = t(i), o = () => a.addIssue({
        code: X.custom,
        ...r(i)
      });
      return typeof Promise < "u" && s instanceof Promise ? s.then((l) => l ? !0 : (o(), !1)) : s ? !0 : (o(), !1);
    });
  }
  refinement(t, n) {
    return this._refinement((r, i) => t(r) ? !0 : (i.addIssue(typeof n == "function" ? n(r, i) : n), !1));
  }
  _refinement(t) {
    return new Zn({
      schema: this,
      typeName: Ee.ZodEffects,
      effect: { type: "refinement", refinement: t }
    });
  }
  superRefine(t) {
    return this._refinement(t);
  }
  constructor(t) {
    this.spa = this.safeParseAsync, this._def = t, this.parse = this.parse.bind(this), this.safeParse = this.safeParse.bind(this), this.parseAsync = this.parseAsync.bind(this), this.safeParseAsync = this.safeParseAsync.bind(this), this.spa = this.spa.bind(this), this.refine = this.refine.bind(this), this.refinement = this.refinement.bind(this), this.superRefine = this.superRefine.bind(this), this.optional = this.optional.bind(this), this.nullable = this.nullable.bind(this), this.nullish = this.nullish.bind(this), this.array = this.array.bind(this), this.promise = this.promise.bind(this), this.or = this.or.bind(this), this.and = this.and.bind(this), this.transform = this.transform.bind(this), this.brand = this.brand.bind(this), this.default = this.default.bind(this), this.catch = this.catch.bind(this), this.describe = this.describe.bind(this), this.pipe = this.pipe.bind(this), this.readonly = this.readonly.bind(this), this.isNullable = this.isNullable.bind(this), this.isOptional = this.isOptional.bind(this), this["~standard"] = {
      version: 1,
      vendor: "zod",
      validate: (n) => this["~validate"](n)
    };
  }
  optional() {
    return Kn.create(this, this._def);
  }
  nullable() {
    return Lr.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return Hn.create(this);
  }
  promise() {
    return ya.create(this, this._def);
  }
  or(t) {
    return vs.create([this, t], this._def);
  }
  and(t) {
    return xs.create(this, t, this._def);
  }
  transform(t) {
    return new Zn({
      ...Oe(this._def),
      schema: this,
      typeName: Ee.ZodEffects,
      effect: { type: "transform", transform: t }
    });
  }
  default(t) {
    const n = typeof t == "function" ? t : () => t;
    return new _a({
      ...Oe(this._def),
      innerType: this,
      defaultValue: n,
      typeName: Ee.ZodDefault
    });
  }
  brand() {
    return new jd({
      typeName: Ee.ZodBranded,
      type: this,
      ...Oe(this._def)
    });
  }
  catch(t) {
    const n = typeof t == "function" ? t : () => t;
    return new Ss({
      ...Oe(this._def),
      innerType: this,
      catchValue: n,
      typeName: Ee.ZodCatch
    });
  }
  describe(t) {
    const n = this.constructor;
    return new n({
      ...this._def,
      description: t
    });
  }
  pipe(t) {
    return Xs.create(this, t);
  }
  readonly() {
    return As.create(this);
  }
  isOptional() {
    return this.safeParse(void 0).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
}
const Px = /^c[^\s-]{8,}$/i, Dx = /^[0-9a-z]+$/, Lx = /^[0-9A-HJKMNP-TV-Z]{26}$/i, Fx = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i, Bx = /^[a-z0-9_-]{21}$/i, zx = /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/, Vx = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/, Gx = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i, jx = "^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$";
let Nc;
const Ux = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/, Hx = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/, Wx = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/, Zx = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/, $x = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/, Xx = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/, Pm = "((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))", Yx = new RegExp(`^${Pm}$`);
function Dm(e) {
  let t = "([01]\\d|2[0-3]):[0-5]\\d:[0-5]\\d";
  return e.precision ? t = `${t}\\.\\d{${e.precision}}` : e.precision == null && (t = `${t}(\\.\\d+)?`), t;
}
function Jx(e) {
  return new RegExp(`^${Dm(e)}$`);
}
function Lm(e) {
  let t = `${Pm}T${Dm(e)}`;
  const n = [];
  return n.push(e.local ? "Z?" : "Z"), e.offset && n.push("([+-]\\d{2}:?\\d{2})"), t = `${t}(${n.join("|")})`, new RegExp(`^${t}$`);
}
function qx(e, t) {
  return !!((t === "v4" || !t) && Ux.test(e) || (t === "v6" || !t) && Wx.test(e));
}
function Kx(e, t) {
  if (!zx.test(e))
    return !1;
  try {
    const [n] = e.split("."), r = n.replace(/-/g, "+").replace(/_/g, "/").padEnd(n.length + (4 - n.length % 4) % 4, "="), i = JSON.parse(atob(r));
    return !(typeof i != "object" || i === null || !i.typ || !i.alg || t && i.alg !== t);
  } catch {
    return !1;
  }
}
function Qx(e, t) {
  return !!((t === "v4" || !t) && Hx.test(e) || (t === "v6" || !t) && Zx.test(e));
}
class Jn extends Me {
  _parse(t) {
    if (this._def.coerce && (t.data = String(t.data)), this._getType(t) !== ae.string) {
      const a = this._getOrReturnCtx(t);
      return ne(a, {
        code: X.invalid_type,
        expected: ae.string,
        received: a.parsedType
      }), we;
    }
    const r = new Kt();
    let i;
    for (const a of this._def.checks)
      if (a.kind === "min")
        t.data.length < a.value && (i = this._getOrReturnCtx(t, i), ne(i, {
          code: X.too_small,
          minimum: a.value,
          type: "string",
          inclusive: !0,
          exact: !1,
          message: a.message
        }), r.dirty());
      else if (a.kind === "max")
        t.data.length > a.value && (i = this._getOrReturnCtx(t, i), ne(i, {
          code: X.too_big,
          maximum: a.value,
          type: "string",
          inclusive: !0,
          exact: !1,
          message: a.message
        }), r.dirty());
      else if (a.kind === "length") {
        const s = t.data.length > a.value, o = t.data.length < a.value;
        (s || o) && (i = this._getOrReturnCtx(t, i), s ? ne(i, {
          code: X.too_big,
          maximum: a.value,
          type: "string",
          inclusive: !0,
          exact: !0,
          message: a.message
        }) : o && ne(i, {
          code: X.too_small,
          minimum: a.value,
          type: "string",
          inclusive: !0,
          exact: !0,
          message: a.message
        }), r.dirty());
      } else if (a.kind === "email")
        Gx.test(t.data) || (i = this._getOrReturnCtx(t, i), ne(i, {
          validation: "email",
          code: X.invalid_string,
          message: a.message
        }), r.dirty());
      else if (a.kind === "emoji")
        Nc || (Nc = new RegExp(jx, "u")), Nc.test(t.data) || (i = this._getOrReturnCtx(t, i), ne(i, {
          validation: "emoji",
          code: X.invalid_string,
          message: a.message
        }), r.dirty());
      else if (a.kind === "uuid")
        Fx.test(t.data) || (i = this._getOrReturnCtx(t, i), ne(i, {
          validation: "uuid",
          code: X.invalid_string,
          message: a.message
        }), r.dirty());
      else if (a.kind === "nanoid")
        Bx.test(t.data) || (i = this._getOrReturnCtx(t, i), ne(i, {
          validation: "nanoid",
          code: X.invalid_string,
          message: a.message
        }), r.dirty());
      else if (a.kind === "cuid")
        Px.test(t.data) || (i = this._getOrReturnCtx(t, i), ne(i, {
          validation: "cuid",
          code: X.invalid_string,
          message: a.message
        }), r.dirty());
      else if (a.kind === "cuid2")
        Dx.test(t.data) || (i = this._getOrReturnCtx(t, i), ne(i, {
          validation: "cuid2",
          code: X.invalid_string,
          message: a.message
        }), r.dirty());
      else if (a.kind === "ulid")
        Lx.test(t.data) || (i = this._getOrReturnCtx(t, i), ne(i, {
          validation: "ulid",
          code: X.invalid_string,
          message: a.message
        }), r.dirty());
      else if (a.kind === "url")
        try {
          new URL(t.data);
        } catch {
          i = this._getOrReturnCtx(t, i), ne(i, {
            validation: "url",
            code: X.invalid_string,
            message: a.message
          }), r.dirty();
        }
      else a.kind === "regex" ? (a.regex.lastIndex = 0, a.regex.test(t.data) || (i = this._getOrReturnCtx(t, i), ne(i, {
        validation: "regex",
        code: X.invalid_string,
        message: a.message
      }), r.dirty())) : a.kind === "trim" ? t.data = t.data.trim() : a.kind === "includes" ? t.data.includes(a.value, a.position) || (i = this._getOrReturnCtx(t, i), ne(i, {
        code: X.invalid_string,
        validation: { includes: a.value, position: a.position },
        message: a.message
      }), r.dirty()) : a.kind === "toLowerCase" ? t.data = t.data.toLowerCase() : a.kind === "toUpperCase" ? t.data = t.data.toUpperCase() : a.kind === "startsWith" ? t.data.startsWith(a.value) || (i = this._getOrReturnCtx(t, i), ne(i, {
        code: X.invalid_string,
        validation: { startsWith: a.value },
        message: a.message
      }), r.dirty()) : a.kind === "endsWith" ? t.data.endsWith(a.value) || (i = this._getOrReturnCtx(t, i), ne(i, {
        code: X.invalid_string,
        validation: { endsWith: a.value },
        message: a.message
      }), r.dirty()) : a.kind === "datetime" ? Lm(a).test(t.data) || (i = this._getOrReturnCtx(t, i), ne(i, {
        code: X.invalid_string,
        validation: "datetime",
        message: a.message
      }), r.dirty()) : a.kind === "date" ? Yx.test(t.data) || (i = this._getOrReturnCtx(t, i), ne(i, {
        code: X.invalid_string,
        validation: "date",
        message: a.message
      }), r.dirty()) : a.kind === "time" ? Jx(a).test(t.data) || (i = this._getOrReturnCtx(t, i), ne(i, {
        code: X.invalid_string,
        validation: "time",
        message: a.message
      }), r.dirty()) : a.kind === "duration" ? Vx.test(t.data) || (i = this._getOrReturnCtx(t, i), ne(i, {
        validation: "duration",
        code: X.invalid_string,
        message: a.message
      }), r.dirty()) : a.kind === "ip" ? qx(t.data, a.version) || (i = this._getOrReturnCtx(t, i), ne(i, {
        validation: "ip",
        code: X.invalid_string,
        message: a.message
      }), r.dirty()) : a.kind === "jwt" ? Kx(t.data, a.alg) || (i = this._getOrReturnCtx(t, i), ne(i, {
        validation: "jwt",
        code: X.invalid_string,
        message: a.message
      }), r.dirty()) : a.kind === "cidr" ? Qx(t.data, a.version) || (i = this._getOrReturnCtx(t, i), ne(i, {
        validation: "cidr",
        code: X.invalid_string,
        message: a.message
      }), r.dirty()) : a.kind === "base64" ? $x.test(t.data) || (i = this._getOrReturnCtx(t, i), ne(i, {
        validation: "base64",
        code: X.invalid_string,
        message: a.message
      }), r.dirty()) : a.kind === "base64url" ? Xx.test(t.data) || (i = this._getOrReturnCtx(t, i), ne(i, {
        validation: "base64url",
        code: X.invalid_string,
        message: a.message
      }), r.dirty()) : Ge.assertNever(a);
    return { status: r.value, value: t.data };
  }
  _regex(t, n, r) {
    return this.refinement((i) => t.test(i), {
      validation: n,
      code: X.invalid_string,
      ...de.errToObj(r)
    });
  }
  _addCheck(t) {
    return new Jn({
      ...this._def,
      checks: [...this._def.checks, t]
    });
  }
  email(t) {
    return this._addCheck({ kind: "email", ...de.errToObj(t) });
  }
  url(t) {
    return this._addCheck({ kind: "url", ...de.errToObj(t) });
  }
  emoji(t) {
    return this._addCheck({ kind: "emoji", ...de.errToObj(t) });
  }
  uuid(t) {
    return this._addCheck({ kind: "uuid", ...de.errToObj(t) });
  }
  nanoid(t) {
    return this._addCheck({ kind: "nanoid", ...de.errToObj(t) });
  }
  cuid(t) {
    return this._addCheck({ kind: "cuid", ...de.errToObj(t) });
  }
  cuid2(t) {
    return this._addCheck({ kind: "cuid2", ...de.errToObj(t) });
  }
  ulid(t) {
    return this._addCheck({ kind: "ulid", ...de.errToObj(t) });
  }
  base64(t) {
    return this._addCheck({ kind: "base64", ...de.errToObj(t) });
  }
  base64url(t) {
    return this._addCheck({
      kind: "base64url",
      ...de.errToObj(t)
    });
  }
  jwt(t) {
    return this._addCheck({ kind: "jwt", ...de.errToObj(t) });
  }
  ip(t) {
    return this._addCheck({ kind: "ip", ...de.errToObj(t) });
  }
  cidr(t) {
    return this._addCheck({ kind: "cidr", ...de.errToObj(t) });
  }
  datetime(t) {
    var n, r;
    return typeof t == "string" ? this._addCheck({
      kind: "datetime",
      precision: null,
      offset: !1,
      local: !1,
      message: t
    }) : this._addCheck({
      kind: "datetime",
      precision: typeof (t == null ? void 0 : t.precision) > "u" ? null : t == null ? void 0 : t.precision,
      offset: (n = t == null ? void 0 : t.offset) !== null && n !== void 0 ? n : !1,
      local: (r = t == null ? void 0 : t.local) !== null && r !== void 0 ? r : !1,
      ...de.errToObj(t == null ? void 0 : t.message)
    });
  }
  date(t) {
    return this._addCheck({ kind: "date", message: t });
  }
  time(t) {
    return typeof t == "string" ? this._addCheck({
      kind: "time",
      precision: null,
      message: t
    }) : this._addCheck({
      kind: "time",
      precision: typeof (t == null ? void 0 : t.precision) > "u" ? null : t == null ? void 0 : t.precision,
      ...de.errToObj(t == null ? void 0 : t.message)
    });
  }
  duration(t) {
    return this._addCheck({ kind: "duration", ...de.errToObj(t) });
  }
  regex(t, n) {
    return this._addCheck({
      kind: "regex",
      regex: t,
      ...de.errToObj(n)
    });
  }
  includes(t, n) {
    return this._addCheck({
      kind: "includes",
      value: t,
      position: n == null ? void 0 : n.position,
      ...de.errToObj(n == null ? void 0 : n.message)
    });
  }
  startsWith(t, n) {
    return this._addCheck({
      kind: "startsWith",
      value: t,
      ...de.errToObj(n)
    });
  }
  endsWith(t, n) {
    return this._addCheck({
      kind: "endsWith",
      value: t,
      ...de.errToObj(n)
    });
  }
  min(t, n) {
    return this._addCheck({
      kind: "min",
      value: t,
      ...de.errToObj(n)
    });
  }
  max(t, n) {
    return this._addCheck({
      kind: "max",
      value: t,
      ...de.errToObj(n)
    });
  }
  length(t, n) {
    return this._addCheck({
      kind: "length",
      value: t,
      ...de.errToObj(n)
    });
  }
  /**
   * Equivalent to `.min(1)`
   */
  nonempty(t) {
    return this.min(1, de.errToObj(t));
  }
  trim() {
    return new Jn({
      ...this._def,
      checks: [...this._def.checks, { kind: "trim" }]
    });
  }
  toLowerCase() {
    return new Jn({
      ...this._def,
      checks: [...this._def.checks, { kind: "toLowerCase" }]
    });
  }
  toUpperCase() {
    return new Jn({
      ...this._def,
      checks: [...this._def.checks, { kind: "toUpperCase" }]
    });
  }
  get isDatetime() {
    return !!this._def.checks.find((t) => t.kind === "datetime");
  }
  get isDate() {
    return !!this._def.checks.find((t) => t.kind === "date");
  }
  get isTime() {
    return !!this._def.checks.find((t) => t.kind === "time");
  }
  get isDuration() {
    return !!this._def.checks.find((t) => t.kind === "duration");
  }
  get isEmail() {
    return !!this._def.checks.find((t) => t.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((t) => t.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find((t) => t.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find((t) => t.kind === "uuid");
  }
  get isNANOID() {
    return !!this._def.checks.find((t) => t.kind === "nanoid");
  }
  get isCUID() {
    return !!this._def.checks.find((t) => t.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((t) => t.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find((t) => t.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find((t) => t.kind === "ip");
  }
  get isCIDR() {
    return !!this._def.checks.find((t) => t.kind === "cidr");
  }
  get isBase64() {
    return !!this._def.checks.find((t) => t.kind === "base64");
  }
  get isBase64url() {
    return !!this._def.checks.find((t) => t.kind === "base64url");
  }
  get minLength() {
    let t = null;
    for (const n of this._def.checks)
      n.kind === "min" && (t === null || n.value > t) && (t = n.value);
    return t;
  }
  get maxLength() {
    let t = null;
    for (const n of this._def.checks)
      n.kind === "max" && (t === null || n.value < t) && (t = n.value);
    return t;
  }
}
Jn.create = (e) => {
  var t;
  return new Jn({
    checks: [],
    typeName: Ee.ZodString,
    coerce: (t = e == null ? void 0 : e.coerce) !== null && t !== void 0 ? t : !1,
    ...Oe(e)
  });
};
function eE(e, t) {
  const n = (e.toString().split(".")[1] || "").length, r = (t.toString().split(".")[1] || "").length, i = n > r ? n : r, a = parseInt(e.toFixed(i).replace(".", "")), s = parseInt(t.toFixed(i).replace(".", ""));
  return a % s / Math.pow(10, i);
}
class ri extends Me {
  constructor() {
    super(...arguments), this.min = this.gte, this.max = this.lte, this.step = this.multipleOf;
  }
  _parse(t) {
    if (this._def.coerce && (t.data = Number(t.data)), this._getType(t) !== ae.number) {
      const a = this._getOrReturnCtx(t);
      return ne(a, {
        code: X.invalid_type,
        expected: ae.number,
        received: a.parsedType
      }), we;
    }
    let r;
    const i = new Kt();
    for (const a of this._def.checks)
      a.kind === "int" ? Ge.isInteger(t.data) || (r = this._getOrReturnCtx(t, r), ne(r, {
        code: X.invalid_type,
        expected: "integer",
        received: "float",
        message: a.message
      }), i.dirty()) : a.kind === "min" ? (a.inclusive ? t.data < a.value : t.data <= a.value) && (r = this._getOrReturnCtx(t, r), ne(r, {
        code: X.too_small,
        minimum: a.value,
        type: "number",
        inclusive: a.inclusive,
        exact: !1,
        message: a.message
      }), i.dirty()) : a.kind === "max" ? (a.inclusive ? t.data > a.value : t.data >= a.value) && (r = this._getOrReturnCtx(t, r), ne(r, {
        code: X.too_big,
        maximum: a.value,
        type: "number",
        inclusive: a.inclusive,
        exact: !1,
        message: a.message
      }), i.dirty()) : a.kind === "multipleOf" ? eE(t.data, a.value) !== 0 && (r = this._getOrReturnCtx(t, r), ne(r, {
        code: X.not_multiple_of,
        multipleOf: a.value,
        message: a.message
      }), i.dirty()) : a.kind === "finite" ? Number.isFinite(t.data) || (r = this._getOrReturnCtx(t, r), ne(r, {
        code: X.not_finite,
        message: a.message
      }), i.dirty()) : Ge.assertNever(a);
    return { status: i.value, value: t.data };
  }
  gte(t, n) {
    return this.setLimit("min", t, !0, de.toString(n));
  }
  gt(t, n) {
    return this.setLimit("min", t, !1, de.toString(n));
  }
  lte(t, n) {
    return this.setLimit("max", t, !0, de.toString(n));
  }
  lt(t, n) {
    return this.setLimit("max", t, !1, de.toString(n));
  }
  setLimit(t, n, r, i) {
    return new ri({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind: t,
          value: n,
          inclusive: r,
          message: de.toString(i)
        }
      ]
    });
  }
  _addCheck(t) {
    return new ri({
      ...this._def,
      checks: [...this._def.checks, t]
    });
  }
  int(t) {
    return this._addCheck({
      kind: "int",
      message: de.toString(t)
    });
  }
  positive(t) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: !1,
      message: de.toString(t)
    });
  }
  negative(t) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: !1,
      message: de.toString(t)
    });
  }
  nonpositive(t) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: !0,
      message: de.toString(t)
    });
  }
  nonnegative(t) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: !0,
      message: de.toString(t)
    });
  }
  multipleOf(t, n) {
    return this._addCheck({
      kind: "multipleOf",
      value: t,
      message: de.toString(n)
    });
  }
  finite(t) {
    return this._addCheck({
      kind: "finite",
      message: de.toString(t)
    });
  }
  safe(t) {
    return this._addCheck({
      kind: "min",
      inclusive: !0,
      value: Number.MIN_SAFE_INTEGER,
      message: de.toString(t)
    })._addCheck({
      kind: "max",
      inclusive: !0,
      value: Number.MAX_SAFE_INTEGER,
      message: de.toString(t)
    });
  }
  get minValue() {
    let t = null;
    for (const n of this._def.checks)
      n.kind === "min" && (t === null || n.value > t) && (t = n.value);
    return t;
  }
  get maxValue() {
    let t = null;
    for (const n of this._def.checks)
      n.kind === "max" && (t === null || n.value < t) && (t = n.value);
    return t;
  }
  get isInt() {
    return !!this._def.checks.find((t) => t.kind === "int" || t.kind === "multipleOf" && Ge.isInteger(t.value));
  }
  get isFinite() {
    let t = null, n = null;
    for (const r of this._def.checks) {
      if (r.kind === "finite" || r.kind === "int" || r.kind === "multipleOf")
        return !0;
      r.kind === "min" ? (n === null || r.value > n) && (n = r.value) : r.kind === "max" && (t === null || r.value < t) && (t = r.value);
    }
    return Number.isFinite(n) && Number.isFinite(t);
  }
}
ri.create = (e) => new ri({
  checks: [],
  typeName: Ee.ZodNumber,
  coerce: (e == null ? void 0 : e.coerce) || !1,
  ...Oe(e)
});
class ii extends Me {
  constructor() {
    super(...arguments), this.min = this.gte, this.max = this.lte;
  }
  _parse(t) {
    if (this._def.coerce)
      try {
        t.data = BigInt(t.data);
      } catch {
        return this._getInvalidInput(t);
      }
    if (this._getType(t) !== ae.bigint)
      return this._getInvalidInput(t);
    let r;
    const i = new Kt();
    for (const a of this._def.checks)
      a.kind === "min" ? (a.inclusive ? t.data < a.value : t.data <= a.value) && (r = this._getOrReturnCtx(t, r), ne(r, {
        code: X.too_small,
        type: "bigint",
        minimum: a.value,
        inclusive: a.inclusive,
        message: a.message
      }), i.dirty()) : a.kind === "max" ? (a.inclusive ? t.data > a.value : t.data >= a.value) && (r = this._getOrReturnCtx(t, r), ne(r, {
        code: X.too_big,
        type: "bigint",
        maximum: a.value,
        inclusive: a.inclusive,
        message: a.message
      }), i.dirty()) : a.kind === "multipleOf" ? t.data % a.value !== BigInt(0) && (r = this._getOrReturnCtx(t, r), ne(r, {
        code: X.not_multiple_of,
        multipleOf: a.value,
        message: a.message
      }), i.dirty()) : Ge.assertNever(a);
    return { status: i.value, value: t.data };
  }
  _getInvalidInput(t) {
    const n = this._getOrReturnCtx(t);
    return ne(n, {
      code: X.invalid_type,
      expected: ae.bigint,
      received: n.parsedType
    }), we;
  }
  gte(t, n) {
    return this.setLimit("min", t, !0, de.toString(n));
  }
  gt(t, n) {
    return this.setLimit("min", t, !1, de.toString(n));
  }
  lte(t, n) {
    return this.setLimit("max", t, !0, de.toString(n));
  }
  lt(t, n) {
    return this.setLimit("max", t, !1, de.toString(n));
  }
  setLimit(t, n, r, i) {
    return new ii({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind: t,
          value: n,
          inclusive: r,
          message: de.toString(i)
        }
      ]
    });
  }
  _addCheck(t) {
    return new ii({
      ...this._def,
      checks: [...this._def.checks, t]
    });
  }
  positive(t) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: !1,
      message: de.toString(t)
    });
  }
  negative(t) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: !1,
      message: de.toString(t)
    });
  }
  nonpositive(t) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: !0,
      message: de.toString(t)
    });
  }
  nonnegative(t) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: !0,
      message: de.toString(t)
    });
  }
  multipleOf(t, n) {
    return this._addCheck({
      kind: "multipleOf",
      value: t,
      message: de.toString(n)
    });
  }
  get minValue() {
    let t = null;
    for (const n of this._def.checks)
      n.kind === "min" && (t === null || n.value > t) && (t = n.value);
    return t;
  }
  get maxValue() {
    let t = null;
    for (const n of this._def.checks)
      n.kind === "max" && (t === null || n.value < t) && (t = n.value);
    return t;
  }
}
ii.create = (e) => {
  var t;
  return new ii({
    checks: [],
    typeName: Ee.ZodBigInt,
    coerce: (t = e == null ? void 0 : e.coerce) !== null && t !== void 0 ? t : !1,
    ...Oe(e)
  });
};
class bs extends Me {
  _parse(t) {
    if (this._def.coerce && (t.data = !!t.data), this._getType(t) !== ae.boolean) {
      const r = this._getOrReturnCtx(t);
      return ne(r, {
        code: X.invalid_type,
        expected: ae.boolean,
        received: r.parsedType
      }), we;
    }
    return cn(t.data);
  }
}
bs.create = (e) => new bs({
  typeName: Ee.ZodBoolean,
  coerce: (e == null ? void 0 : e.coerce) || !1,
  ...Oe(e)
});
class Ai extends Me {
  _parse(t) {
    if (this._def.coerce && (t.data = new Date(t.data)), this._getType(t) !== ae.date) {
      const a = this._getOrReturnCtx(t);
      return ne(a, {
        code: X.invalid_type,
        expected: ae.date,
        received: a.parsedType
      }), we;
    }
    if (isNaN(t.data.getTime())) {
      const a = this._getOrReturnCtx(t);
      return ne(a, {
        code: X.invalid_date
      }), we;
    }
    const r = new Kt();
    let i;
    for (const a of this._def.checks)
      a.kind === "min" ? t.data.getTime() < a.value && (i = this._getOrReturnCtx(t, i), ne(i, {
        code: X.too_small,
        message: a.message,
        inclusive: !0,
        exact: !1,
        minimum: a.value,
        type: "date"
      }), r.dirty()) : a.kind === "max" ? t.data.getTime() > a.value && (i = this._getOrReturnCtx(t, i), ne(i, {
        code: X.too_big,
        message: a.message,
        inclusive: !0,
        exact: !1,
        maximum: a.value,
        type: "date"
      }), r.dirty()) : Ge.assertNever(a);
    return {
      status: r.value,
      value: new Date(t.data.getTime())
    };
  }
  _addCheck(t) {
    return new Ai({
      ...this._def,
      checks: [...this._def.checks, t]
    });
  }
  min(t, n) {
    return this._addCheck({
      kind: "min",
      value: t.getTime(),
      message: de.toString(n)
    });
  }
  max(t, n) {
    return this._addCheck({
      kind: "max",
      value: t.getTime(),
      message: de.toString(n)
    });
  }
  get minDate() {
    let t = null;
    for (const n of this._def.checks)
      n.kind === "min" && (t === null || n.value > t) && (t = n.value);
    return t != null ? new Date(t) : null;
  }
  get maxDate() {
    let t = null;
    for (const n of this._def.checks)
      n.kind === "max" && (t === null || n.value < t) && (t = n.value);
    return t != null ? new Date(t) : null;
  }
}
Ai.create = (e) => new Ai({
  checks: [],
  coerce: (e == null ? void 0 : e.coerce) || !1,
  typeName: Ee.ZodDate,
  ...Oe(e)
});
class rl extends Me {
  _parse(t) {
    if (this._getType(t) !== ae.symbol) {
      const r = this._getOrReturnCtx(t);
      return ne(r, {
        code: X.invalid_type,
        expected: ae.symbol,
        received: r.parsedType
      }), we;
    }
    return cn(t.data);
  }
}
rl.create = (e) => new rl({
  typeName: Ee.ZodSymbol,
  ...Oe(e)
});
class ys extends Me {
  _parse(t) {
    if (this._getType(t) !== ae.undefined) {
      const r = this._getOrReturnCtx(t);
      return ne(r, {
        code: X.invalid_type,
        expected: ae.undefined,
        received: r.parsedType
      }), we;
    }
    return cn(t.data);
  }
}
ys.create = (e) => new ys({
  typeName: Ee.ZodUndefined,
  ...Oe(e)
});
class _s extends Me {
  _parse(t) {
    if (this._getType(t) !== ae.null) {
      const r = this._getOrReturnCtx(t);
      return ne(r, {
        code: X.invalid_type,
        expected: ae.null,
        received: r.parsedType
      }), we;
    }
    return cn(t.data);
  }
}
_s.create = (e) => new _s({
  typeName: Ee.ZodNull,
  ...Oe(e)
});
class ba extends Me {
  constructor() {
    super(...arguments), this._any = !0;
  }
  _parse(t) {
    return cn(t.data);
  }
}
ba.create = (e) => new ba({
  typeName: Ee.ZodAny,
  ...Oe(e)
});
class _i extends Me {
  constructor() {
    super(...arguments), this._unknown = !0;
  }
  _parse(t) {
    return cn(t.data);
  }
}
_i.create = (e) => new _i({
  typeName: Ee.ZodUnknown,
  ...Oe(e)
});
class Pr extends Me {
  _parse(t) {
    const n = this._getOrReturnCtx(t);
    return ne(n, {
      code: X.invalid_type,
      expected: ae.never,
      received: n.parsedType
    }), we;
  }
}
Pr.create = (e) => new Pr({
  typeName: Ee.ZodNever,
  ...Oe(e)
});
class il extends Me {
  _parse(t) {
    if (this._getType(t) !== ae.undefined) {
      const r = this._getOrReturnCtx(t);
      return ne(r, {
        code: X.invalid_type,
        expected: ae.void,
        received: r.parsedType
      }), we;
    }
    return cn(t.data);
  }
}
il.create = (e) => new il({
  typeName: Ee.ZodVoid,
  ...Oe(e)
});
class Hn extends Me {
  _parse(t) {
    const { ctx: n, status: r } = this._processInputParams(t), i = this._def;
    if (n.parsedType !== ae.array)
      return ne(n, {
        code: X.invalid_type,
        expected: ae.array,
        received: n.parsedType
      }), we;
    if (i.exactLength !== null) {
      const s = n.data.length > i.exactLength.value, o = n.data.length < i.exactLength.value;
      (s || o) && (ne(n, {
        code: s ? X.too_big : X.too_small,
        minimum: o ? i.exactLength.value : void 0,
        maximum: s ? i.exactLength.value : void 0,
        type: "array",
        inclusive: !0,
        exact: !0,
        message: i.exactLength.message
      }), r.dirty());
    }
    if (i.minLength !== null && n.data.length < i.minLength.value && (ne(n, {
      code: X.too_small,
      minimum: i.minLength.value,
      type: "array",
      inclusive: !0,
      exact: !1,
      message: i.minLength.message
    }), r.dirty()), i.maxLength !== null && n.data.length > i.maxLength.value && (ne(n, {
      code: X.too_big,
      maximum: i.maxLength.value,
      type: "array",
      inclusive: !0,
      exact: !1,
      message: i.maxLength.message
    }), r.dirty()), n.common.async)
      return Promise.all([...n.data].map((s, o) => i.type._parseAsync(new xr(n, s, n.path, o)))).then((s) => Kt.mergeArray(r, s));
    const a = [...n.data].map((s, o) => i.type._parseSync(new xr(n, s, n.path, o)));
    return Kt.mergeArray(r, a);
  }
  get element() {
    return this._def.type;
  }
  min(t, n) {
    return new Hn({
      ...this._def,
      minLength: { value: t, message: de.toString(n) }
    });
  }
  max(t, n) {
    return new Hn({
      ...this._def,
      maxLength: { value: t, message: de.toString(n) }
    });
  }
  length(t, n) {
    return new Hn({
      ...this._def,
      exactLength: { value: t, message: de.toString(n) }
    });
  }
  nonempty(t) {
    return this.min(1, t);
  }
}
Hn.create = (e, t) => new Hn({
  type: e,
  minLength: null,
  maxLength: null,
  exactLength: null,
  typeName: Ee.ZodArray,
  ...Oe(t)
});
function Yi(e) {
  if (e instanceof lt) {
    const t = {};
    for (const n in e.shape) {
      const r = e.shape[n];
      t[n] = Kn.create(Yi(r));
    }
    return new lt({
      ...e._def,
      shape: () => t
    });
  } else return e instanceof Hn ? new Hn({
    ...e._def,
    type: Yi(e.element)
  }) : e instanceof Kn ? Kn.create(Yi(e.unwrap())) : e instanceof Lr ? Lr.create(Yi(e.unwrap())) : e instanceof Er ? Er.create(e.items.map((t) => Yi(t))) : e;
}
class lt extends Me {
  constructor() {
    super(...arguments), this._cached = null, this.nonstrict = this.passthrough, this.augment = this.extend;
  }
  _getCached() {
    if (this._cached !== null)
      return this._cached;
    const t = this._def.shape(), n = Ge.objectKeys(t);
    return this._cached = { shape: t, keys: n };
  }
  _parse(t) {
    if (this._getType(t) !== ae.object) {
      const c = this._getOrReturnCtx(t);
      return ne(c, {
        code: X.invalid_type,
        expected: ae.object,
        received: c.parsedType
      }), we;
    }
    const { status: r, ctx: i } = this._processInputParams(t), { shape: a, keys: s } = this._getCached(), o = [];
    if (!(this._def.catchall instanceof Pr && this._def.unknownKeys === "strip"))
      for (const c in i.data)
        s.includes(c) || o.push(c);
    const l = [];
    for (const c of s) {
      const u = a[c], d = i.data[c];
      l.push({
        key: { status: "valid", value: c },
        value: u._parse(new xr(i, d, i.path, c)),
        alwaysSet: c in i.data
      });
    }
    if (this._def.catchall instanceof Pr) {
      const c = this._def.unknownKeys;
      if (c === "passthrough")
        for (const u of o)
          l.push({
            key: { status: "valid", value: u },
            value: { status: "valid", value: i.data[u] }
          });
      else if (c === "strict")
        o.length > 0 && (ne(i, {
          code: X.unrecognized_keys,
          keys: o
        }), r.dirty());
      else if (c !== "strip") throw new Error("Internal ZodObject error: invalid unknownKeys value.");
    } else {
      const c = this._def.catchall;
      for (const u of o) {
        const d = i.data[u];
        l.push({
          key: { status: "valid", value: u },
          value: c._parse(
            new xr(i, d, i.path, u)
            //, ctx.child(key), value, getParsedType(value)
          ),
          alwaysSet: u in i.data
        });
      }
    }
    return i.common.async ? Promise.resolve().then(async () => {
      const c = [];
      for (const u of l) {
        const d = await u.key, f = await u.value;
        c.push({
          key: d,
          value: f,
          alwaysSet: u.alwaysSet
        });
      }
      return c;
    }).then((c) => Kt.mergeObjectSync(r, c)) : Kt.mergeObjectSync(r, l);
  }
  get shape() {
    return this._def.shape();
  }
  strict(t) {
    return de.errToObj, new lt({
      ...this._def,
      unknownKeys: "strict",
      ...t !== void 0 ? {
        errorMap: (n, r) => {
          var i, a, s, o;
          const l = (s = (a = (i = this._def).errorMap) === null || a === void 0 ? void 0 : a.call(i, n, r).message) !== null && s !== void 0 ? s : r.defaultError;
          return n.code === "unrecognized_keys" ? {
            message: (o = de.errToObj(t).message) !== null && o !== void 0 ? o : l
          } : {
            message: l
          };
        }
      } : {}
    });
  }
  strip() {
    return new lt({
      ...this._def,
      unknownKeys: "strip"
    });
  }
  passthrough() {
    return new lt({
      ...this._def,
      unknownKeys: "passthrough"
    });
  }
  // const AugmentFactory =
  //   <Def extends ZodObjectDef>(def: Def) =>
  //   <Augmentation extends ZodRawShape>(
  //     augmentation: Augmentation
  //   ): ZodObject<
  //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
  //     Def["unknownKeys"],
  //     Def["catchall"]
  //   > => {
  //     return new ZodObject({
  //       ...def,
  //       shape: () => ({
  //         ...def.shape(),
  //         ...augmentation,
  //       }),
  //     }) as any;
  //   };
  extend(t) {
    return new lt({
      ...this._def,
      shape: () => ({
        ...this._def.shape(),
        ...t
      })
    });
  }
  /**
   * Prior to zod@1.0.12 there was a bug in the
   * inferred type of merged objects. Please
   * upgrade if you are experiencing issues.
   */
  merge(t) {
    return new lt({
      unknownKeys: t._def.unknownKeys,
      catchall: t._def.catchall,
      shape: () => ({
        ...this._def.shape(),
        ...t._def.shape()
      }),
      typeName: Ee.ZodObject
    });
  }
  // merge<
  //   Incoming extends AnyZodObject,
  //   Augmentation extends Incoming["shape"],
  //   NewOutput extends {
  //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
  //       ? Augmentation[k]["_output"]
  //       : k extends keyof Output
  //       ? Output[k]
  //       : never;
  //   },
  //   NewInput extends {
  //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
  //       ? Augmentation[k]["_input"]
  //       : k extends keyof Input
  //       ? Input[k]
  //       : never;
  //   }
  // >(
  //   merging: Incoming
  // ): ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"],
  //   NewOutput,
  //   NewInput
  // > {
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  setKey(t, n) {
    return this.augment({ [t]: n });
  }
  // merge<Incoming extends AnyZodObject>(
  //   merging: Incoming
  // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
  // ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"]
  // > {
  //   // const mergedShape = objectUtil.mergeShapes(
  //   //   this._def.shape(),
  //   //   merging._def.shape()
  //   // );
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  catchall(t) {
    return new lt({
      ...this._def,
      catchall: t
    });
  }
  pick(t) {
    const n = {};
    return Ge.objectKeys(t).forEach((r) => {
      t[r] && this.shape[r] && (n[r] = this.shape[r]);
    }), new lt({
      ...this._def,
      shape: () => n
    });
  }
  omit(t) {
    const n = {};
    return Ge.objectKeys(this.shape).forEach((r) => {
      t[r] || (n[r] = this.shape[r]);
    }), new lt({
      ...this._def,
      shape: () => n
    });
  }
  /**
   * @deprecated
   */
  deepPartial() {
    return Yi(this);
  }
  partial(t) {
    const n = {};
    return Ge.objectKeys(this.shape).forEach((r) => {
      const i = this.shape[r];
      t && !t[r] ? n[r] = i : n[r] = i.optional();
    }), new lt({
      ...this._def,
      shape: () => n
    });
  }
  required(t) {
    const n = {};
    return Ge.objectKeys(this.shape).forEach((r) => {
      if (t && !t[r])
        n[r] = this.shape[r];
      else {
        let a = this.shape[r];
        for (; a instanceof Kn; )
          a = a._def.innerType;
        n[r] = a;
      }
    }), new lt({
      ...this._def,
      shape: () => n
    });
  }
  keyof() {
    return Fm(Ge.objectKeys(this.shape));
  }
}
lt.create = (e, t) => new lt({
  shape: () => e,
  unknownKeys: "strip",
  catchall: Pr.create(),
  typeName: Ee.ZodObject,
  ...Oe(t)
});
lt.strictCreate = (e, t) => new lt({
  shape: () => e,
  unknownKeys: "strict",
  catchall: Pr.create(),
  typeName: Ee.ZodObject,
  ...Oe(t)
});
lt.lazycreate = (e, t) => new lt({
  shape: e,
  unknownKeys: "strip",
  catchall: Pr.create(),
  typeName: Ee.ZodObject,
  ...Oe(t)
});
class vs extends Me {
  _parse(t) {
    const { ctx: n } = this._processInputParams(t), r = this._def.options;
    function i(a) {
      for (const o of a)
        if (o.result.status === "valid")
          return o.result;
      for (const o of a)
        if (o.result.status === "dirty")
          return n.common.issues.push(...o.ctx.common.issues), o.result;
      const s = a.map((o) => new Tn(o.ctx.common.issues));
      return ne(n, {
        code: X.invalid_union,
        unionErrors: s
      }), we;
    }
    if (n.common.async)
      return Promise.all(r.map(async (a) => {
        const s = {
          ...n,
          common: {
            ...n.common,
            issues: []
          },
          parent: null
        };
        return {
          result: await a._parseAsync({
            data: n.data,
            path: n.path,
            parent: s
          }),
          ctx: s
        };
      })).then(i);
    {
      let a;
      const s = [];
      for (const l of r) {
        const c = {
          ...n,
          common: {
            ...n.common,
            issues: []
          },
          parent: null
        }, u = l._parseSync({
          data: n.data,
          path: n.path,
          parent: c
        });
        if (u.status === "valid")
          return u;
        u.status === "dirty" && !a && (a = { result: u, ctx: c }), c.common.issues.length && s.push(c.common.issues);
      }
      if (a)
        return n.common.issues.push(...a.ctx.common.issues), a.result;
      const o = s.map((l) => new Tn(l));
      return ne(n, {
        code: X.invalid_union,
        unionErrors: o
      }), we;
    }
  }
  get options() {
    return this._def.options;
  }
}
vs.create = (e, t) => new vs({
  options: e,
  typeName: Ee.ZodUnion,
  ...Oe(t)
});
const Ar = (e) => e instanceof ws ? Ar(e.schema) : e instanceof Zn ? Ar(e.innerType()) : e instanceof Cs ? [e.value] : e instanceof Dr ? e.options : e instanceof Is ? Ge.objectValues(e.enum) : e instanceof _a ? Ar(e._def.innerType) : e instanceof ys ? [void 0] : e instanceof _s ? [null] : e instanceof Kn ? [void 0, ...Ar(e.unwrap())] : e instanceof Lr ? [null, ...Ar(e.unwrap())] : e instanceof jd || e instanceof As ? Ar(e.unwrap()) : e instanceof Ss ? Ar(e._def.innerType) : [];
class jl extends Me {
  _parse(t) {
    const { ctx: n } = this._processInputParams(t);
    if (n.parsedType !== ae.object)
      return ne(n, {
        code: X.invalid_type,
        expected: ae.object,
        received: n.parsedType
      }), we;
    const r = this.discriminator, i = n.data[r], a = this.optionsMap.get(i);
    return a ? n.common.async ? a._parseAsync({
      data: n.data,
      path: n.path,
      parent: n
    }) : a._parseSync({
      data: n.data,
      path: n.path,
      parent: n
    }) : (ne(n, {
      code: X.invalid_union_discriminator,
      options: Array.from(this.optionsMap.keys()),
      path: [r]
    }), we);
  }
  get discriminator() {
    return this._def.discriminator;
  }
  get options() {
    return this._def.options;
  }
  get optionsMap() {
    return this._def.optionsMap;
  }
  /**
   * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
   * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
   * have a different value for each object in the union.
   * @param discriminator the name of the discriminator property
   * @param types an array of object schemas
   * @param params
   */
  static create(t, n, r) {
    const i = /* @__PURE__ */ new Map();
    for (const a of n) {
      const s = Ar(a.shape[t]);
      if (!s.length)
        throw new Error(`A discriminator value for key \`${t}\` could not be extracted from all schema options`);
      for (const o of s) {
        if (i.has(o))
          throw new Error(`Discriminator property ${String(t)} has duplicate value ${String(o)}`);
        i.set(o, a);
      }
    }
    return new jl({
      typeName: Ee.ZodDiscriminatedUnion,
      discriminator: t,
      options: n,
      optionsMap: i,
      ...Oe(r)
    });
  }
}
function Du(e, t) {
  const n = Tr(e), r = Tr(t);
  if (e === t)
    return { valid: !0, data: e };
  if (n === ae.object && r === ae.object) {
    const i = Ge.objectKeys(t), a = Ge.objectKeys(e).filter((o) => i.indexOf(o) !== -1), s = { ...e, ...t };
    for (const o of a) {
      const l = Du(e[o], t[o]);
      if (!l.valid)
        return { valid: !1 };
      s[o] = l.data;
    }
    return { valid: !0, data: s };
  } else if (n === ae.array && r === ae.array) {
    if (e.length !== t.length)
      return { valid: !1 };
    const i = [];
    for (let a = 0; a < e.length; a++) {
      const s = e[a], o = t[a], l = Du(s, o);
      if (!l.valid)
        return { valid: !1 };
      i.push(l.data);
    }
    return { valid: !0, data: i };
  } else return n === ae.date && r === ae.date && +e == +t ? { valid: !0, data: e } : { valid: !1 };
}
class xs extends Me {
  _parse(t) {
    const { status: n, ctx: r } = this._processInputParams(t), i = (a, s) => {
      if (Mu(a) || Mu(s))
        return we;
      const o = Du(a.value, s.value);
      return o.valid ? ((Pu(a) || Pu(s)) && n.dirty(), { status: n.value, value: o.data }) : (ne(r, {
        code: X.invalid_intersection_types
      }), we);
    };
    return r.common.async ? Promise.all([
      this._def.left._parseAsync({
        data: r.data,
        path: r.path,
        parent: r
      }),
      this._def.right._parseAsync({
        data: r.data,
        path: r.path,
        parent: r
      })
    ]).then(([a, s]) => i(a, s)) : i(this._def.left._parseSync({
      data: r.data,
      path: r.path,
      parent: r
    }), this._def.right._parseSync({
      data: r.data,
      path: r.path,
      parent: r
    }));
  }
}
xs.create = (e, t, n) => new xs({
  left: e,
  right: t,
  typeName: Ee.ZodIntersection,
  ...Oe(n)
});
class Er extends Me {
  _parse(t) {
    const { status: n, ctx: r } = this._processInputParams(t);
    if (r.parsedType !== ae.array)
      return ne(r, {
        code: X.invalid_type,
        expected: ae.array,
        received: r.parsedType
      }), we;
    if (r.data.length < this._def.items.length)
      return ne(r, {
        code: X.too_small,
        minimum: this._def.items.length,
        inclusive: !0,
        exact: !1,
        type: "array"
      }), we;
    !this._def.rest && r.data.length > this._def.items.length && (ne(r, {
      code: X.too_big,
      maximum: this._def.items.length,
      inclusive: !0,
      exact: !1,
      type: "array"
    }), n.dirty());
    const a = [...r.data].map((s, o) => {
      const l = this._def.items[o] || this._def.rest;
      return l ? l._parse(new xr(r, s, r.path, o)) : null;
    }).filter((s) => !!s);
    return r.common.async ? Promise.all(a).then((s) => Kt.mergeArray(n, s)) : Kt.mergeArray(n, a);
  }
  get items() {
    return this._def.items;
  }
  rest(t) {
    return new Er({
      ...this._def,
      rest: t
    });
  }
}
Er.create = (e, t) => {
  if (!Array.isArray(e))
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  return new Er({
    items: e,
    typeName: Ee.ZodTuple,
    rest: null,
    ...Oe(t)
  });
};
class Es extends Me {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(t) {
    const { status: n, ctx: r } = this._processInputParams(t);
    if (r.parsedType !== ae.object)
      return ne(r, {
        code: X.invalid_type,
        expected: ae.object,
        received: r.parsedType
      }), we;
    const i = [], a = this._def.keyType, s = this._def.valueType;
    for (const o in r.data)
      i.push({
        key: a._parse(new xr(r, o, r.path, o)),
        value: s._parse(new xr(r, r.data[o], r.path, o)),
        alwaysSet: o in r.data
      });
    return r.common.async ? Kt.mergeObjectAsync(n, i) : Kt.mergeObjectSync(n, i);
  }
  get element() {
    return this._def.valueType;
  }
  static create(t, n, r) {
    return n instanceof Me ? new Es({
      keyType: t,
      valueType: n,
      typeName: Ee.ZodRecord,
      ...Oe(r)
    }) : new Es({
      keyType: Jn.create(),
      valueType: t,
      typeName: Ee.ZodRecord,
      ...Oe(n)
    });
  }
}
class al extends Me {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(t) {
    const { status: n, ctx: r } = this._processInputParams(t);
    if (r.parsedType !== ae.map)
      return ne(r, {
        code: X.invalid_type,
        expected: ae.map,
        received: r.parsedType
      }), we;
    const i = this._def.keyType, a = this._def.valueType, s = [...r.data.entries()].map(([o, l], c) => ({
      key: i._parse(new xr(r, o, r.path, [c, "key"])),
      value: a._parse(new xr(r, l, r.path, [c, "value"]))
    }));
    if (r.common.async) {
      const o = /* @__PURE__ */ new Map();
      return Promise.resolve().then(async () => {
        for (const l of s) {
          const c = await l.key, u = await l.value;
          if (c.status === "aborted" || u.status === "aborted")
            return we;
          (c.status === "dirty" || u.status === "dirty") && n.dirty(), o.set(c.value, u.value);
        }
        return { status: n.value, value: o };
      });
    } else {
      const o = /* @__PURE__ */ new Map();
      for (const l of s) {
        const c = l.key, u = l.value;
        if (c.status === "aborted" || u.status === "aborted")
          return we;
        (c.status === "dirty" || u.status === "dirty") && n.dirty(), o.set(c.value, u.value);
      }
      return { status: n.value, value: o };
    }
  }
}
al.create = (e, t, n) => new al({
  valueType: t,
  keyType: e,
  typeName: Ee.ZodMap,
  ...Oe(n)
});
class ki extends Me {
  _parse(t) {
    const { status: n, ctx: r } = this._processInputParams(t);
    if (r.parsedType !== ae.set)
      return ne(r, {
        code: X.invalid_type,
        expected: ae.set,
        received: r.parsedType
      }), we;
    const i = this._def;
    i.minSize !== null && r.data.size < i.minSize.value && (ne(r, {
      code: X.too_small,
      minimum: i.minSize.value,
      type: "set",
      inclusive: !0,
      exact: !1,
      message: i.minSize.message
    }), n.dirty()), i.maxSize !== null && r.data.size > i.maxSize.value && (ne(r, {
      code: X.too_big,
      maximum: i.maxSize.value,
      type: "set",
      inclusive: !0,
      exact: !1,
      message: i.maxSize.message
    }), n.dirty());
    const a = this._def.valueType;
    function s(l) {
      const c = /* @__PURE__ */ new Set();
      for (const u of l) {
        if (u.status === "aborted")
          return we;
        u.status === "dirty" && n.dirty(), c.add(u.value);
      }
      return { status: n.value, value: c };
    }
    const o = [...r.data.values()].map((l, c) => a._parse(new xr(r, l, r.path, c)));
    return r.common.async ? Promise.all(o).then((l) => s(l)) : s(o);
  }
  min(t, n) {
    return new ki({
      ...this._def,
      minSize: { value: t, message: de.toString(n) }
    });
  }
  max(t, n) {
    return new ki({
      ...this._def,
      maxSize: { value: t, message: de.toString(n) }
    });
  }
  size(t, n) {
    return this.min(t, n).max(t, n);
  }
  nonempty(t) {
    return this.min(1, t);
  }
}
ki.create = (e, t) => new ki({
  valueType: e,
  minSize: null,
  maxSize: null,
  typeName: Ee.ZodSet,
  ...Oe(t)
});
class aa extends Me {
  constructor() {
    super(...arguments), this.validate = this.implement;
  }
  _parse(t) {
    const { ctx: n } = this._processInputParams(t);
    if (n.parsedType !== ae.function)
      return ne(n, {
        code: X.invalid_type,
        expected: ae.function,
        received: n.parsedType
      }), we;
    function r(o, l) {
      return tl({
        data: o,
        path: n.path,
        errorMaps: [
          n.common.contextualErrorMap,
          n.schemaErrorMap,
          el(),
          ma
        ].filter((c) => !!c),
        issueData: {
          code: X.invalid_arguments,
          argumentsError: l
        }
      });
    }
    function i(o, l) {
      return tl({
        data: o,
        path: n.path,
        errorMaps: [
          n.common.contextualErrorMap,
          n.schemaErrorMap,
          el(),
          ma
        ].filter((c) => !!c),
        issueData: {
          code: X.invalid_return_type,
          returnTypeError: l
        }
      });
    }
    const a = { errorMap: n.common.contextualErrorMap }, s = n.data;
    if (this._def.returns instanceof ya) {
      const o = this;
      return cn(async function(...l) {
        const c = new Tn([]), u = await o._def.args.parseAsync(l, a).catch((p) => {
          throw c.addIssue(r(l, p)), c;
        }), d = await Reflect.apply(s, this, u);
        return await o._def.returns._def.type.parseAsync(d, a).catch((p) => {
          throw c.addIssue(i(d, p)), c;
        });
      });
    } else {
      const o = this;
      return cn(function(...l) {
        const c = o._def.args.safeParse(l, a);
        if (!c.success)
          throw new Tn([r(l, c.error)]);
        const u = Reflect.apply(s, this, c.data), d = o._def.returns.safeParse(u, a);
        if (!d.success)
          throw new Tn([i(u, d.error)]);
        return d.data;
      });
    }
  }
  parameters() {
    return this._def.args;
  }
  returnType() {
    return this._def.returns;
  }
  args(...t) {
    return new aa({
      ...this._def,
      args: Er.create(t).rest(_i.create())
    });
  }
  returns(t) {
    return new aa({
      ...this._def,
      returns: t
    });
  }
  implement(t) {
    return this.parse(t);
  }
  strictImplement(t) {
    return this.parse(t);
  }
  static create(t, n, r) {
    return new aa({
      args: t || Er.create([]).rest(_i.create()),
      returns: n || _i.create(),
      typeName: Ee.ZodFunction,
      ...Oe(r)
    });
  }
}
class ws extends Me {
  get schema() {
    return this._def.getter();
  }
  _parse(t) {
    const { ctx: n } = this._processInputParams(t);
    return this._def.getter()._parse({ data: n.data, path: n.path, parent: n });
  }
}
ws.create = (e, t) => new ws({
  getter: e,
  typeName: Ee.ZodLazy,
  ...Oe(t)
});
class Cs extends Me {
  _parse(t) {
    if (t.data !== this._def.value) {
      const n = this._getOrReturnCtx(t);
      return ne(n, {
        received: n.data,
        code: X.invalid_literal,
        expected: this._def.value
      }), we;
    }
    return { status: "valid", value: t.data };
  }
  get value() {
    return this._def.value;
  }
}
Cs.create = (e, t) => new Cs({
  value: e,
  typeName: Ee.ZodLiteral,
  ...Oe(t)
});
function Fm(e, t) {
  return new Dr({
    values: e,
    typeName: Ee.ZodEnum,
    ...Oe(t)
  });
}
class Dr extends Me {
  constructor() {
    super(...arguments), es.set(this, void 0);
  }
  _parse(t) {
    if (typeof t.data != "string") {
      const n = this._getOrReturnCtx(t), r = this._def.values;
      return ne(n, {
        expected: Ge.joinValues(r),
        received: n.parsedType,
        code: X.invalid_type
      }), we;
    }
    if (nl(this, es) || Mm(this, es, new Set(this._def.values)), !nl(this, es).has(t.data)) {
      const n = this._getOrReturnCtx(t), r = this._def.values;
      return ne(n, {
        received: n.data,
        code: X.invalid_enum_value,
        options: r
      }), we;
    }
    return cn(t.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    const t = {};
    for (const n of this._def.values)
      t[n] = n;
    return t;
  }
  get Values() {
    const t = {};
    for (const n of this._def.values)
      t[n] = n;
    return t;
  }
  get Enum() {
    const t = {};
    for (const n of this._def.values)
      t[n] = n;
    return t;
  }
  extract(t, n = this._def) {
    return Dr.create(t, {
      ...this._def,
      ...n
    });
  }
  exclude(t, n = this._def) {
    return Dr.create(this.options.filter((r) => !t.includes(r)), {
      ...this._def,
      ...n
    });
  }
}
es = /* @__PURE__ */ new WeakMap();
Dr.create = Fm;
class Is extends Me {
  constructor() {
    super(...arguments), ts.set(this, void 0);
  }
  _parse(t) {
    const n = Ge.getValidEnumValues(this._def.values), r = this._getOrReturnCtx(t);
    if (r.parsedType !== ae.string && r.parsedType !== ae.number) {
      const i = Ge.objectValues(n);
      return ne(r, {
        expected: Ge.joinValues(i),
        received: r.parsedType,
        code: X.invalid_type
      }), we;
    }
    if (nl(this, ts) || Mm(this, ts, new Set(Ge.getValidEnumValues(this._def.values))), !nl(this, ts).has(t.data)) {
      const i = Ge.objectValues(n);
      return ne(r, {
        received: r.data,
        code: X.invalid_enum_value,
        options: i
      }), we;
    }
    return cn(t.data);
  }
  get enum() {
    return this._def.values;
  }
}
ts = /* @__PURE__ */ new WeakMap();
Is.create = (e, t) => new Is({
  values: e,
  typeName: Ee.ZodNativeEnum,
  ...Oe(t)
});
class ya extends Me {
  unwrap() {
    return this._def.type;
  }
  _parse(t) {
    const { ctx: n } = this._processInputParams(t);
    if (n.parsedType !== ae.promise && n.common.async === !1)
      return ne(n, {
        code: X.invalid_type,
        expected: ae.promise,
        received: n.parsedType
      }), we;
    const r = n.parsedType === ae.promise ? n.data : Promise.resolve(n.data);
    return cn(r.then((i) => this._def.type.parseAsync(i, {
      path: n.path,
      errorMap: n.common.contextualErrorMap
    })));
  }
}
ya.create = (e, t) => new ya({
  type: e,
  typeName: Ee.ZodPromise,
  ...Oe(t)
});
class Zn extends Me {
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === Ee.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
  }
  _parse(t) {
    const { status: n, ctx: r } = this._processInputParams(t), i = this._def.effect || null, a = {
      addIssue: (s) => {
        ne(r, s), s.fatal ? n.abort() : n.dirty();
      },
      get path() {
        return r.path;
      }
    };
    if (a.addIssue = a.addIssue.bind(a), i.type === "preprocess") {
      const s = i.transform(r.data, a);
      if (r.common.async)
        return Promise.resolve(s).then(async (o) => {
          if (n.value === "aborted")
            return we;
          const l = await this._def.schema._parseAsync({
            data: o,
            path: r.path,
            parent: r
          });
          return l.status === "aborted" ? we : l.status === "dirty" || n.value === "dirty" ? Qi(l.value) : l;
        });
      {
        if (n.value === "aborted")
          return we;
        const o = this._def.schema._parseSync({
          data: s,
          path: r.path,
          parent: r
        });
        return o.status === "aborted" ? we : o.status === "dirty" || n.value === "dirty" ? Qi(o.value) : o;
      }
    }
    if (i.type === "refinement") {
      const s = (o) => {
        const l = i.refinement(o, a);
        if (r.common.async)
          return Promise.resolve(l);
        if (l instanceof Promise)
          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        return o;
      };
      if (r.common.async === !1) {
        const o = this._def.schema._parseSync({
          data: r.data,
          path: r.path,
          parent: r
        });
        return o.status === "aborted" ? we : (o.status === "dirty" && n.dirty(), s(o.value), { status: n.value, value: o.value });
      } else
        return this._def.schema._parseAsync({ data: r.data, path: r.path, parent: r }).then((o) => o.status === "aborted" ? we : (o.status === "dirty" && n.dirty(), s(o.value).then(() => ({ status: n.value, value: o.value }))));
    }
    if (i.type === "transform")
      if (r.common.async === !1) {
        const s = this._def.schema._parseSync({
          data: r.data,
          path: r.path,
          parent: r
        });
        if (!Si(s))
          return s;
        const o = i.transform(s.value, a);
        if (o instanceof Promise)
          throw new Error("Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.");
        return { status: n.value, value: o };
      } else
        return this._def.schema._parseAsync({ data: r.data, path: r.path, parent: r }).then((s) => Si(s) ? Promise.resolve(i.transform(s.value, a)).then((o) => ({ status: n.value, value: o })) : s);
    Ge.assertNever(i);
  }
}
Zn.create = (e, t, n) => new Zn({
  schema: e,
  typeName: Ee.ZodEffects,
  effect: t,
  ...Oe(n)
});
Zn.createWithPreprocess = (e, t, n) => new Zn({
  schema: t,
  effect: { type: "preprocess", transform: e },
  typeName: Ee.ZodEffects,
  ...Oe(n)
});
class Kn extends Me {
  _parse(t) {
    return this._getType(t) === ae.undefined ? cn(void 0) : this._def.innerType._parse(t);
  }
  unwrap() {
    return this._def.innerType;
  }
}
Kn.create = (e, t) => new Kn({
  innerType: e,
  typeName: Ee.ZodOptional,
  ...Oe(t)
});
class Lr extends Me {
  _parse(t) {
    return this._getType(t) === ae.null ? cn(null) : this._def.innerType._parse(t);
  }
  unwrap() {
    return this._def.innerType;
  }
}
Lr.create = (e, t) => new Lr({
  innerType: e,
  typeName: Ee.ZodNullable,
  ...Oe(t)
});
class _a extends Me {
  _parse(t) {
    const { ctx: n } = this._processInputParams(t);
    let r = n.data;
    return n.parsedType === ae.undefined && (r = this._def.defaultValue()), this._def.innerType._parse({
      data: r,
      path: n.path,
      parent: n
    });
  }
  removeDefault() {
    return this._def.innerType;
  }
}
_a.create = (e, t) => new _a({
  innerType: e,
  typeName: Ee.ZodDefault,
  defaultValue: typeof t.default == "function" ? t.default : () => t.default,
  ...Oe(t)
});
class Ss extends Me {
  _parse(t) {
    const { ctx: n } = this._processInputParams(t), r = {
      ...n,
      common: {
        ...n.common,
        issues: []
      }
    }, i = this._def.innerType._parse({
      data: r.data,
      path: r.path,
      parent: {
        ...r
      }
    });
    return ms(i) ? i.then((a) => ({
      status: "valid",
      value: a.status === "valid" ? a.value : this._def.catchValue({
        get error() {
          return new Tn(r.common.issues);
        },
        input: r.data
      })
    })) : {
      status: "valid",
      value: i.status === "valid" ? i.value : this._def.catchValue({
        get error() {
          return new Tn(r.common.issues);
        },
        input: r.data
      })
    };
  }
  removeCatch() {
    return this._def.innerType;
  }
}
Ss.create = (e, t) => new Ss({
  innerType: e,
  typeName: Ee.ZodCatch,
  catchValue: typeof t.catch == "function" ? t.catch : () => t.catch,
  ...Oe(t)
});
class sl extends Me {
  _parse(t) {
    if (this._getType(t) !== ae.nan) {
      const r = this._getOrReturnCtx(t);
      return ne(r, {
        code: X.invalid_type,
        expected: ae.nan,
        received: r.parsedType
      }), we;
    }
    return { status: "valid", value: t.data };
  }
}
sl.create = (e) => new sl({
  typeName: Ee.ZodNaN,
  ...Oe(e)
});
const tE = Symbol("zod_brand");
class jd extends Me {
  _parse(t) {
    const { ctx: n } = this._processInputParams(t), r = n.data;
    return this._def.type._parse({
      data: r,
      path: n.path,
      parent: n
    });
  }
  unwrap() {
    return this._def.type;
  }
}
class Xs extends Me {
  _parse(t) {
    const { status: n, ctx: r } = this._processInputParams(t);
    if (r.common.async)
      return (async () => {
        const a = await this._def.in._parseAsync({
          data: r.data,
          path: r.path,
          parent: r
        });
        return a.status === "aborted" ? we : a.status === "dirty" ? (n.dirty(), Qi(a.value)) : this._def.out._parseAsync({
          data: a.value,
          path: r.path,
          parent: r
        });
      })();
    {
      const i = this._def.in._parseSync({
        data: r.data,
        path: r.path,
        parent: r
      });
      return i.status === "aborted" ? we : i.status === "dirty" ? (n.dirty(), {
        status: "dirty",
        value: i.value
      }) : this._def.out._parseSync({
        data: i.value,
        path: r.path,
        parent: r
      });
    }
  }
  static create(t, n) {
    return new Xs({
      in: t,
      out: n,
      typeName: Ee.ZodPipeline
    });
  }
}
class As extends Me {
  _parse(t) {
    const n = this._def.innerType._parse(t), r = (i) => (Si(i) && (i.value = Object.freeze(i.value)), i);
    return ms(n) ? n.then((i) => r(i)) : r(n);
  }
  unwrap() {
    return this._def.innerType;
  }
}
As.create = (e, t) => new As({
  innerType: e,
  typeName: Ee.ZodReadonly,
  ...Oe(t)
});
function kp(e, t) {
  const n = typeof e == "function" ? e(t) : typeof e == "string" ? { message: e } : e;
  return typeof n == "string" ? { message: n } : n;
}
function Bm(e, t = {}, n) {
  return e ? ba.create().superRefine((r, i) => {
    var a, s;
    const o = e(r);
    if (o instanceof Promise)
      return o.then((l) => {
        var c, u;
        if (!l) {
          const d = kp(t, r), f = (u = (c = d.fatal) !== null && c !== void 0 ? c : n) !== null && u !== void 0 ? u : !0;
          i.addIssue({ code: "custom", ...d, fatal: f });
        }
      });
    if (!o) {
      const l = kp(t, r), c = (s = (a = l.fatal) !== null && a !== void 0 ? a : n) !== null && s !== void 0 ? s : !0;
      i.addIssue({ code: "custom", ...l, fatal: c });
    }
  }) : ba.create();
}
const nE = {
  object: lt.lazycreate
};
var Ee;
(function(e) {
  e.ZodString = "ZodString", e.ZodNumber = "ZodNumber", e.ZodNaN = "ZodNaN", e.ZodBigInt = "ZodBigInt", e.ZodBoolean = "ZodBoolean", e.ZodDate = "ZodDate", e.ZodSymbol = "ZodSymbol", e.ZodUndefined = "ZodUndefined", e.ZodNull = "ZodNull", e.ZodAny = "ZodAny", e.ZodUnknown = "ZodUnknown", e.ZodNever = "ZodNever", e.ZodVoid = "ZodVoid", e.ZodArray = "ZodArray", e.ZodObject = "ZodObject", e.ZodUnion = "ZodUnion", e.ZodDiscriminatedUnion = "ZodDiscriminatedUnion", e.ZodIntersection = "ZodIntersection", e.ZodTuple = "ZodTuple", e.ZodRecord = "ZodRecord", e.ZodMap = "ZodMap", e.ZodSet = "ZodSet", e.ZodFunction = "ZodFunction", e.ZodLazy = "ZodLazy", e.ZodLiteral = "ZodLiteral", e.ZodEnum = "ZodEnum", e.ZodEffects = "ZodEffects", e.ZodNativeEnum = "ZodNativeEnum", e.ZodOptional = "ZodOptional", e.ZodNullable = "ZodNullable", e.ZodDefault = "ZodDefault", e.ZodCatch = "ZodCatch", e.ZodPromise = "ZodPromise", e.ZodBranded = "ZodBranded", e.ZodPipeline = "ZodPipeline", e.ZodReadonly = "ZodReadonly";
})(Ee || (Ee = {}));
const rE = (e, t = {
  message: `Input not instance of ${e.name}`
}) => Bm((n) => n instanceof e, t), zm = Jn.create, Vm = ri.create, iE = sl.create, aE = ii.create, Gm = bs.create, sE = Ai.create, oE = rl.create, lE = ys.create, cE = _s.create, uE = ba.create, dE = _i.create, fE = Pr.create, pE = il.create, hE = Hn.create, gE = lt.create, mE = lt.strictCreate, bE = vs.create, yE = jl.create, _E = xs.create, vE = Er.create, xE = Es.create, EE = al.create, wE = ki.create, CE = aa.create, IE = ws.create, SE = Cs.create, AE = Dr.create, kE = Is.create, TE = ya.create, Tp = Zn.create, RE = Kn.create, NE = Lr.create, OE = Zn.createWithPreprocess, ME = Xs.create, PE = () => zm().optional(), DE = () => Vm().optional(), LE = () => Gm().optional(), FE = {
  string: (e) => Jn.create({ ...e, coerce: !0 }),
  number: (e) => ri.create({ ...e, coerce: !0 }),
  boolean: (e) => bs.create({
    ...e,
    coerce: !0
  }),
  bigint: (e) => ii.create({ ...e, coerce: !0 }),
  date: (e) => Ai.create({ ...e, coerce: !0 })
}, BE = we;
var pt = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  defaultErrorMap: ma,
  setErrorMap: Ox,
  getErrorMap: el,
  makeIssue: tl,
  EMPTY_PATH: Mx,
  addIssueToContext: ne,
  ParseStatus: Kt,
  INVALID: we,
  DIRTY: Qi,
  OK: cn,
  isAborted: Mu,
  isDirty: Pu,
  isValid: Si,
  isAsync: ms,
  get util() {
    return Ge;
  },
  get objectUtil() {
    return Ou;
  },
  ZodParsedType: ae,
  getParsedType: Tr,
  ZodType: Me,
  datetimeRegex: Lm,
  ZodString: Jn,
  ZodNumber: ri,
  ZodBigInt: ii,
  ZodBoolean: bs,
  ZodDate: Ai,
  ZodSymbol: rl,
  ZodUndefined: ys,
  ZodNull: _s,
  ZodAny: ba,
  ZodUnknown: _i,
  ZodNever: Pr,
  ZodVoid: il,
  ZodArray: Hn,
  ZodObject: lt,
  ZodUnion: vs,
  ZodDiscriminatedUnion: jl,
  ZodIntersection: xs,
  ZodTuple: Er,
  ZodRecord: Es,
  ZodMap: al,
  ZodSet: ki,
  ZodFunction: aa,
  ZodLazy: ws,
  ZodLiteral: Cs,
  ZodEnum: Dr,
  ZodNativeEnum: Is,
  ZodPromise: ya,
  ZodEffects: Zn,
  ZodTransformer: Zn,
  ZodOptional: Kn,
  ZodNullable: Lr,
  ZodDefault: _a,
  ZodCatch: Ss,
  ZodNaN: sl,
  BRAND: tE,
  ZodBranded: jd,
  ZodPipeline: Xs,
  ZodReadonly: As,
  custom: Bm,
  Schema: Me,
  ZodSchema: Me,
  late: nE,
  get ZodFirstPartyTypeKind() {
    return Ee;
  },
  coerce: FE,
  any: uE,
  array: hE,
  bigint: aE,
  boolean: Gm,
  date: sE,
  discriminatedUnion: yE,
  effect: Tp,
  enum: AE,
  function: CE,
  instanceof: rE,
  intersection: _E,
  lazy: IE,
  literal: SE,
  map: EE,
  nan: iE,
  nativeEnum: kE,
  never: fE,
  null: cE,
  nullable: NE,
  number: Vm,
  object: gE,
  oboolean: LE,
  onumber: DE,
  optional: RE,
  ostring: PE,
  pipeline: ME,
  preprocess: OE,
  promise: TE,
  record: xE,
  set: wE,
  strictObject: mE,
  string: zm,
  symbol: oE,
  transformer: Tp,
  tuple: vE,
  undefined: lE,
  union: bE,
  unknown: dE,
  void: pE,
  NEVER: BE,
  ZodIssueCode: X,
  quotelessJson: Nx,
  ZodError: Tn
});
const Rp = (e) => {
  var r;
  let t = -1 / 0;
  const n = e.shape;
  for (const i in n) {
    const a = (r = n[i]) == null ? void 0 : r.meta;
    (a == null ? void 0 : a.step) !== void 0 && (a == null ? void 0 : a.step) > t && (t = a.step);
  }
  return t === -1 / 0 ? 0 : t;
};
function zE(e) {
  for (; ; )
    if (e instanceof Kn || e instanceof Lr)
      e = e.unwrap();
    else if (e instanceof _a)
      e = e.removeDefault();
    else if (e instanceof Hn)
      e = e.element;
    else if (e instanceof Zn)
      e = e.innerType();
    else
      break;
  return e;
}
function Ti(e) {
  "@babel/helpers - typeof";
  return Ti = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Ti(e);
}
function VE(e, t) {
  if (Ti(e) != "object" || !e) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t);
    if (Ti(r) != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function jm(e) {
  var t = VE(e, "string");
  return Ti(t) == "symbol" ? t : t + "";
}
function ea(e, t, n) {
  return (t = jm(t)) in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
function Np(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(i) {
      return Object.getOwnPropertyDescriptor(e, i).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function pe(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Np(Object(n), !0).forEach(function(r) {
      ea(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Np(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function GE(e) {
  if (Array.isArray(e)) return e;
}
function jE(e, t) {
  var n = e == null ? null : typeof Symbol < "u" && e[Symbol.iterator] || e["@@iterator"];
  if (n != null) {
    var r, i, a, s, o = [], l = !0, c = !1;
    try {
      if (a = (n = n.call(e)).next, t === 0) {
        if (Object(n) !== n) return;
        l = !1;
      } else for (; !(l = (r = a.call(n)).done) && (o.push(r.value), o.length !== t); l = !0) ;
    } catch (u) {
      c = !0, i = u;
    } finally {
      try {
        if (!l && n.return != null && (s = n.return(), Object(s) !== s)) return;
      } finally {
        if (c) throw i;
      }
    }
    return o;
  }
}
function Lu(e, t) {
  (t == null || t > e.length) && (t = e.length);
  for (var n = 0, r = Array(t); n < t; n++) r[n] = e[n];
  return r;
}
function Um(e, t) {
  if (e) {
    if (typeof e == "string") return Lu(e, t);
    var n = {}.toString.call(e).slice(8, -1);
    return n === "Object" && e.constructor && (n = e.constructor.name), n === "Map" || n === "Set" ? Array.from(e) : n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? Lu(e, t) : void 0;
  }
}
function UE() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function Pt(e, t) {
  return GE(e) || jE(e, t) || Um(e, t) || UE();
}
function HE(e, t) {
  if (e == null) return {};
  var n = {};
  for (var r in e) if ({}.hasOwnProperty.call(e, r)) {
    if (t.indexOf(r) !== -1) continue;
    n[r] = e[r];
  }
  return n;
}
function tr(e, t) {
  if (e == null) return {};
  var n, r, i = HE(e, t);
  if (Object.getOwnPropertySymbols) {
    var a = Object.getOwnPropertySymbols(e);
    for (r = 0; r < a.length; r++) n = a[r], t.indexOf(n) === -1 && {}.propertyIsEnumerable.call(e, n) && (i[n] = e[n]);
  }
  return i;
}
var WE = ["defaultInputValue", "defaultMenuIsOpen", "defaultValue", "inputValue", "menuIsOpen", "onChange", "onInputChange", "onMenuClose", "onMenuOpen", "value"];
function Ul(e) {
  var t = e.defaultInputValue, n = t === void 0 ? "" : t, r = e.defaultMenuIsOpen, i = r === void 0 ? !1 : r, a = e.defaultValue, s = a === void 0 ? null : a, o = e.inputValue, l = e.menuIsOpen, c = e.onChange, u = e.onInputChange, d = e.onMenuClose, f = e.onMenuOpen, p = e.value, h = tr(e, WE), g = _t(o !== void 0 ? o : n), m = Pt(g, 2), b = m[0], y = m[1], v = _t(l !== void 0 ? l : i), E = Pt(v, 2), _ = E[0], x = E[1], I = _t(p !== void 0 ? p : s), T = Pt(I, 2), O = T[0], k = T[1], W = Dt(function(K, fe) {
    typeof c == "function" && c(K, fe), k(K);
  }, [c]), M = Dt(function(K, fe) {
    var S;
    typeof u == "function" && (S = u(K, fe)), y(S !== void 0 ? S : K);
  }, [u]), L = Dt(function() {
    typeof f == "function" && f(), x(!0);
  }, [f]), z = Dt(function() {
    typeof d == "function" && d(), x(!1);
  }, [d]), U = o !== void 0 ? o : b, $ = l !== void 0 ? l : _, Q = p !== void 0 ? p : O;
  return pe(pe({}, h), {}, {
    inputValue: U,
    menuIsOpen: $,
    onChange: W,
    onInputChange: M,
    onMenuClose: z,
    onMenuOpen: L,
    value: Q
  });
}
function ye() {
  return ye = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n) ({}).hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, ye.apply(null, arguments);
}
function ZE(e, t) {
  if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function");
}
function Op(e, t) {
  for (var n = 0; n < t.length; n++) {
    var r = t[n];
    r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, jm(r.key), r);
  }
}
function $E(e, t, n) {
  return t && Op(e.prototype, t), n && Op(e, n), Object.defineProperty(e, "prototype", {
    writable: !1
  }), e;
}
function Fu(e, t) {
  return Fu = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(n, r) {
    return n.__proto__ = r, n;
  }, Fu(e, t);
}
function XE(e, t) {
  if (typeof t != "function" && t !== null) throw new TypeError("Super expression must either be null or a function");
  e.prototype = Object.create(t && t.prototype, {
    constructor: {
      value: e,
      writable: !0,
      configurable: !0
    }
  }), Object.defineProperty(e, "prototype", {
    writable: !1
  }), t && Fu(e, t);
}
function ol(e) {
  return ol = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t) {
    return t.__proto__ || Object.getPrototypeOf(t);
  }, ol(e);
}
function Hm() {
  try {
    var e = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch {
  }
  return (Hm = function() {
    return !!e;
  })();
}
function YE(e) {
  if (e === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e;
}
function JE(e, t) {
  if (t && (Ti(t) == "object" || typeof t == "function")) return t;
  if (t !== void 0) throw new TypeError("Derived constructors may only return object or undefined");
  return YE(e);
}
function qE(e) {
  var t = Hm();
  return function() {
    var n, r = ol(e);
    if (t) {
      var i = ol(this).constructor;
      n = Reflect.construct(r, arguments, i);
    } else n = r.apply(this, arguments);
    return JE(this, n);
  };
}
function KE(e) {
  if (Array.isArray(e)) return Lu(e);
}
function QE(e) {
  if (typeof Symbol < "u" && e[Symbol.iterator] != null || e["@@iterator"] != null) return Array.from(e);
}
function e1() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function sa(e) {
  return KE(e) || QE(e) || Um(e) || e1();
}
function t1(e) {
  if (e.sheet)
    return e.sheet;
  for (var t = 0; t < document.styleSheets.length; t++)
    if (document.styleSheets[t].ownerNode === e)
      return document.styleSheets[t];
}
function n1(e) {
  var t = document.createElement("style");
  return t.setAttribute("data-emotion", e.key), e.nonce !== void 0 && t.setAttribute("nonce", e.nonce), t.appendChild(document.createTextNode("")), t.setAttribute("data-s", ""), t;
}
var r1 = /* @__PURE__ */ function() {
  function e(n) {
    var r = this;
    this._insertTag = function(i) {
      var a;
      r.tags.length === 0 ? r.insertionPoint ? a = r.insertionPoint.nextSibling : r.prepend ? a = r.container.firstChild : a = r.before : a = r.tags[r.tags.length - 1].nextSibling, r.container.insertBefore(i, a), r.tags.push(i);
    }, this.isSpeedy = n.speedy === void 0 ? !0 : n.speedy, this.tags = [], this.ctr = 0, this.nonce = n.nonce, this.key = n.key, this.container = n.container, this.prepend = n.prepend, this.insertionPoint = n.insertionPoint, this.before = null;
  }
  var t = e.prototype;
  return t.hydrate = function(r) {
    r.forEach(this._insertTag);
  }, t.insert = function(r) {
    this.ctr % (this.isSpeedy ? 65e3 : 1) === 0 && this._insertTag(n1(this));
    var i = this.tags[this.tags.length - 1];
    if (this.isSpeedy) {
      var a = t1(i);
      try {
        a.insertRule(r, a.cssRules.length);
      } catch {
      }
    } else
      i.appendChild(document.createTextNode(r));
    this.ctr++;
  }, t.flush = function() {
    this.tags.forEach(function(r) {
      var i;
      return (i = r.parentNode) == null ? void 0 : i.removeChild(r);
    }), this.tags = [], this.ctr = 0;
  }, e;
}(), Ht = "-ms-", ll = "-moz-", He = "-webkit-", Wm = "comm", Ud = "rule", Hd = "decl", i1 = "@import", Zm = "@keyframes", a1 = "@layer", s1 = Math.abs, Hl = String.fromCharCode, o1 = Object.assign;
function l1(e, t) {
  return zt(e, 0) ^ 45 ? (((t << 2 ^ zt(e, 0)) << 2 ^ zt(e, 1)) << 2 ^ zt(e, 2)) << 2 ^ zt(e, 3) : 0;
}
function $m(e) {
  return e.trim();
}
function c1(e, t) {
  return (e = t.exec(e)) ? e[0] : e;
}
function We(e, t, n) {
  return e.replace(t, n);
}
function Bu(e, t) {
  return e.indexOf(t);
}
function zt(e, t) {
  return e.charCodeAt(t) | 0;
}
function ks(e, t, n) {
  return e.slice(t, n);
}
function ur(e) {
  return e.length;
}
function Wd(e) {
  return e.length;
}
function fo(e, t) {
  return t.push(e), e;
}
function u1(e, t) {
  return e.map(t).join("");
}
var Wl = 1, va = 1, Xm = 0, xn = 0, Tt = 0, Ra = "";
function Zl(e, t, n, r, i, a, s) {
  return { value: e, root: t, parent: n, type: r, props: i, children: a, line: Wl, column: va, length: s, return: "" };
}
function Wa(e, t) {
  return o1(Zl("", null, null, "", null, null, 0), e, { length: -e.length }, t);
}
function d1() {
  return Tt;
}
function f1() {
  return Tt = xn > 0 ? zt(Ra, --xn) : 0, va--, Tt === 10 && (va = 1, Wl--), Tt;
}
function Rn() {
  return Tt = xn < Xm ? zt(Ra, xn++) : 0, va++, Tt === 10 && (va = 1, Wl++), Tt;
}
function yr() {
  return zt(Ra, xn);
}
function Oo() {
  return xn;
}
function Ys(e, t) {
  return ks(Ra, e, t);
}
function Ts(e) {
  switch (e) {
    // \0 \t \n \r \s whitespace token
    case 0:
    case 9:
    case 10:
    case 13:
    case 32:
      return 5;
    // ! + , / > @ ~ isolate token
    case 33:
    case 43:
    case 44:
    case 47:
    case 62:
    case 64:
    case 126:
    // ; { } breakpoint token
    case 59:
    case 123:
    case 125:
      return 4;
    // : accompanied token
    case 58:
      return 3;
    // " ' ( [ opening delimit token
    case 34:
    case 39:
    case 40:
    case 91:
      return 2;
    // ) ] closing delimit token
    case 41:
    case 93:
      return 1;
  }
  return 0;
}
function Ym(e) {
  return Wl = va = 1, Xm = ur(Ra = e), xn = 0, [];
}
function Jm(e) {
  return Ra = "", e;
}
function Mo(e) {
  return $m(Ys(xn - 1, zu(e === 91 ? e + 2 : e === 40 ? e + 1 : e)));
}
function p1(e) {
  for (; (Tt = yr()) && Tt < 33; )
    Rn();
  return Ts(e) > 2 || Ts(Tt) > 3 ? "" : " ";
}
function h1(e, t) {
  for (; --t && Rn() && !(Tt < 48 || Tt > 102 || Tt > 57 && Tt < 65 || Tt > 70 && Tt < 97); )
    ;
  return Ys(e, Oo() + (t < 6 && yr() == 32 && Rn() == 32));
}
function zu(e) {
  for (; Rn(); )
    switch (Tt) {
      // ] ) " '
      case e:
        return xn;
      // " '
      case 34:
      case 39:
        e !== 34 && e !== 39 && zu(Tt);
        break;
      // (
      case 40:
        e === 41 && zu(e);
        break;
      // \
      case 92:
        Rn();
        break;
    }
  return xn;
}
function g1(e, t) {
  for (; Rn() && e + Tt !== 57; )
    if (e + Tt === 84 && yr() === 47)
      break;
  return "/*" + Ys(t, xn - 1) + "*" + Hl(e === 47 ? e : Rn());
}
function m1(e) {
  for (; !Ts(yr()); )
    Rn();
  return Ys(e, xn);
}
function b1(e) {
  return Jm(Po("", null, null, null, [""], e = Ym(e), 0, [0], e));
}
function Po(e, t, n, r, i, a, s, o, l) {
  for (var c = 0, u = 0, d = s, f = 0, p = 0, h = 0, g = 1, m = 1, b = 1, y = 0, v = "", E = i, _ = a, x = r, I = v; m; )
    switch (h = y, y = Rn()) {
      // (
      case 40:
        if (h != 108 && zt(I, d - 1) == 58) {
          Bu(I += We(Mo(y), "&", "&\f"), "&\f") != -1 && (b = -1);
          break;
        }
      // " ' [
      case 34:
      case 39:
      case 91:
        I += Mo(y);
        break;
      // \t \n \r \s
      case 9:
      case 10:
      case 13:
      case 32:
        I += p1(h);
        break;
      // \
      case 92:
        I += h1(Oo() - 1, 7);
        continue;
      // /
      case 47:
        switch (yr()) {
          case 42:
          case 47:
            fo(y1(g1(Rn(), Oo()), t, n), l);
            break;
          default:
            I += "/";
        }
        break;
      // {
      case 123 * g:
        o[c++] = ur(I) * b;
      // } ; \0
      case 125 * g:
      case 59:
      case 0:
        switch (y) {
          // \0 }
          case 0:
          case 125:
            m = 0;
          // ;
          case 59 + u:
            b == -1 && (I = We(I, /\f/g, "")), p > 0 && ur(I) - d && fo(p > 32 ? Pp(I + ";", r, n, d - 1) : Pp(We(I, " ", "") + ";", r, n, d - 2), l);
            break;
          // @ ;
          case 59:
            I += ";";
          // { rule/at-rule
          default:
            if (fo(x = Mp(I, t, n, c, u, i, o, v, E = [], _ = [], d), a), y === 123)
              if (u === 0)
                Po(I, t, x, x, E, a, d, o, _);
              else
                switch (f === 99 && zt(I, 3) === 110 ? 100 : f) {
                  // d l m s
                  case 100:
                  case 108:
                  case 109:
                  case 115:
                    Po(e, x, x, r && fo(Mp(e, x, x, 0, 0, i, o, v, i, E = [], d), _), i, _, d, o, r ? E : _);
                    break;
                  default:
                    Po(I, x, x, x, [""], _, 0, o, _);
                }
        }
        c = u = p = 0, g = b = 1, v = I = "", d = s;
        break;
      // :
      case 58:
        d = 1 + ur(I), p = h;
      default:
        if (g < 1) {
          if (y == 123)
            --g;
          else if (y == 125 && g++ == 0 && f1() == 125)
            continue;
        }
        switch (I += Hl(y), y * g) {
          // &
          case 38:
            b = u > 0 ? 1 : (I += "\f", -1);
            break;
          // ,
          case 44:
            o[c++] = (ur(I) - 1) * b, b = 1;
            break;
          // @
          case 64:
            yr() === 45 && (I += Mo(Rn())), f = yr(), u = d = ur(v = I += m1(Oo())), y++;
            break;
          // -
          case 45:
            h === 45 && ur(I) == 2 && (g = 0);
        }
    }
  return a;
}
function Mp(e, t, n, r, i, a, s, o, l, c, u) {
  for (var d = i - 1, f = i === 0 ? a : [""], p = Wd(f), h = 0, g = 0, m = 0; h < r; ++h)
    for (var b = 0, y = ks(e, d + 1, d = s1(g = s[h])), v = e; b < p; ++b)
      (v = $m(g > 0 ? f[b] + " " + y : We(y, /&\f/g, f[b]))) && (l[m++] = v);
  return Zl(e, t, n, i === 0 ? Ud : o, l, c, u);
}
function y1(e, t, n) {
  return Zl(e, t, n, Wm, Hl(d1()), ks(e, 2, -2), 0);
}
function Pp(e, t, n, r) {
  return Zl(e, t, n, Hd, ks(e, 0, r), ks(e, r + 1, -1), r);
}
function oa(e, t) {
  for (var n = "", r = Wd(e), i = 0; i < r; i++)
    n += t(e[i], i, e, t) || "";
  return n;
}
function _1(e, t, n, r) {
  switch (e.type) {
    case a1:
      if (e.children.length) break;
    case i1:
    case Hd:
      return e.return = e.return || e.value;
    case Wm:
      return "";
    case Zm:
      return e.return = e.value + "{" + oa(e.children, r) + "}";
    case Ud:
      e.value = e.props.join(",");
  }
  return ur(n = oa(e.children, r)) ? e.return = e.value + "{" + n + "}" : "";
}
function v1(e) {
  var t = Wd(e);
  return function(n, r, i, a) {
    for (var s = "", o = 0; o < t; o++)
      s += e[o](n, r, i, a) || "";
    return s;
  };
}
function x1(e) {
  return function(t) {
    t.root || (t = t.return) && e(t);
  };
}
function E1(e) {
  var t = /* @__PURE__ */ Object.create(null);
  return function(n) {
    return t[n] === void 0 && (t[n] = e(n)), t[n];
  };
}
var w1 = function(t, n, r) {
  for (var i = 0, a = 0; i = a, a = yr(), i === 38 && a === 12 && (n[r] = 1), !Ts(a); )
    Rn();
  return Ys(t, xn);
}, C1 = function(t, n) {
  var r = -1, i = 44;
  do
    switch (Ts(i)) {
      case 0:
        i === 38 && yr() === 12 && (n[r] = 1), t[r] += w1(xn - 1, n, r);
        break;
      case 2:
        t[r] += Mo(i);
        break;
      case 4:
        if (i === 44) {
          t[++r] = yr() === 58 ? "&\f" : "", n[r] = t[r].length;
          break;
        }
      // fallthrough
      default:
        t[r] += Hl(i);
    }
  while (i = Rn());
  return t;
}, I1 = function(t, n) {
  return Jm(C1(Ym(t), n));
}, Dp = /* @__PURE__ */ new WeakMap(), S1 = function(t) {
  if (!(t.type !== "rule" || !t.parent || // positive .length indicates that this rule contains pseudo
  // negative .length indicates that this rule has been already prefixed
  t.length < 1)) {
    for (var n = t.value, r = t.parent, i = t.column === r.column && t.line === r.line; r.type !== "rule"; )
      if (r = r.parent, !r) return;
    if (!(t.props.length === 1 && n.charCodeAt(0) !== 58 && !Dp.get(r)) && !i) {
      Dp.set(t, !0);
      for (var a = [], s = I1(n, a), o = r.props, l = 0, c = 0; l < s.length; l++)
        for (var u = 0; u < o.length; u++, c++)
          t.props[c] = a[l] ? s[l].replace(/&\f/g, o[u]) : o[u] + " " + s[l];
    }
  }
}, A1 = function(t) {
  if (t.type === "decl") {
    var n = t.value;
    // charcode for l
    n.charCodeAt(0) === 108 && // charcode for b
    n.charCodeAt(2) === 98 && (t.return = "", t.value = "");
  }
};
function qm(e, t) {
  switch (l1(e, t)) {
    // color-adjust
    case 5103:
      return He + "print-" + e + e;
    // animation, animation-(delay|direction|duration|fill-mode|iteration-count|name|play-state|timing-function)
    case 5737:
    case 4201:
    case 3177:
    case 3433:
    case 1641:
    case 4457:
    case 2921:
    // text-decoration, filter, clip-path, backface-visibility, column, box-decoration-break
    case 5572:
    case 6356:
    case 5844:
    case 3191:
    case 6645:
    case 3005:
    // mask, mask-image, mask-(mode|clip|size), mask-(repeat|origin), mask-position, mask-composite,
    case 6391:
    case 5879:
    case 5623:
    case 6135:
    case 4599:
    case 4855:
    // background-clip, columns, column-(count|fill|gap|rule|rule-color|rule-style|rule-width|span|width)
    case 4215:
    case 6389:
    case 5109:
    case 5365:
    case 5621:
    case 3829:
      return He + e + e;
    // appearance, user-select, transform, hyphens, text-size-adjust
    case 5349:
    case 4246:
    case 4810:
    case 6968:
    case 2756:
      return He + e + ll + e + Ht + e + e;
    // flex, flex-direction
    case 6828:
    case 4268:
      return He + e + Ht + e + e;
    // order
    case 6165:
      return He + e + Ht + "flex-" + e + e;
    // align-items
    case 5187:
      return He + e + We(e, /(\w+).+(:[^]+)/, He + "box-$1$2" + Ht + "flex-$1$2") + e;
    // align-self
    case 5443:
      return He + e + Ht + "flex-item-" + We(e, /flex-|-self/, "") + e;
    // align-content
    case 4675:
      return He + e + Ht + "flex-line-pack" + We(e, /align-content|flex-|-self/, "") + e;
    // flex-shrink
    case 5548:
      return He + e + Ht + We(e, "shrink", "negative") + e;
    // flex-basis
    case 5292:
      return He + e + Ht + We(e, "basis", "preferred-size") + e;
    // flex-grow
    case 6060:
      return He + "box-" + We(e, "-grow", "") + He + e + Ht + We(e, "grow", "positive") + e;
    // transition
    case 4554:
      return He + We(e, /([^-])(transform)/g, "$1" + He + "$2") + e;
    // cursor
    case 6187:
      return We(We(We(e, /(zoom-|grab)/, He + "$1"), /(image-set)/, He + "$1"), e, "") + e;
    // background, background-image
    case 5495:
    case 3959:
      return We(e, /(image-set\([^]*)/, He + "$1$`$1");
    // justify-content
    case 4968:
      return We(We(e, /(.+:)(flex-)?(.*)/, He + "box-pack:$3" + Ht + "flex-pack:$3"), /s.+-b[^;]+/, "justify") + He + e + e;
    // (margin|padding)-inline-(start|end)
    case 4095:
    case 3583:
    case 4068:
    case 2532:
      return We(e, /(.+)-inline(.+)/, He + "$1$2") + e;
    // (min|max)?(width|height|inline-size|block-size)
    case 8116:
    case 7059:
    case 5753:
    case 5535:
    case 5445:
    case 5701:
    case 4933:
    case 4677:
    case 5533:
    case 5789:
    case 5021:
    case 4765:
      if (ur(e) - 1 - t > 6) switch (zt(e, t + 1)) {
        // (m)ax-content, (m)in-content
        case 109:
          if (zt(e, t + 4) !== 45) break;
        // (f)ill-available, (f)it-content
        case 102:
          return We(e, /(.+:)(.+)-([^]+)/, "$1" + He + "$2-$3$1" + ll + (zt(e, t + 3) == 108 ? "$3" : "$2-$3")) + e;
        // (s)tretch
        case 115:
          return ~Bu(e, "stretch") ? qm(We(e, "stretch", "fill-available"), t) + e : e;
      }
      break;
    // position: sticky
    case 4949:
      if (zt(e, t + 1) !== 115) break;
    // display: (flex|inline-flex)
    case 6444:
      switch (zt(e, ur(e) - 3 - (~Bu(e, "!important") && 10))) {
        // stic(k)y
        case 107:
          return We(e, ":", ":" + He) + e;
        // (inline-)?fl(e)x
        case 101:
          return We(e, /(.+:)([^;!]+)(;|!.+)?/, "$1" + He + (zt(e, 14) === 45 ? "inline-" : "") + "box$3$1" + He + "$2$3$1" + Ht + "$2box$3") + e;
      }
      break;
    // writing-mode
    case 5936:
      switch (zt(e, t + 11)) {
        // vertical-l(r)
        case 114:
          return He + e + Ht + We(e, /[svh]\w+-[tblr]{2}/, "tb") + e;
        // vertical-r(l)
        case 108:
          return He + e + Ht + We(e, /[svh]\w+-[tblr]{2}/, "tb-rl") + e;
        // horizontal(-)tb
        case 45:
          return He + e + Ht + We(e, /[svh]\w+-[tblr]{2}/, "lr") + e;
      }
      return He + e + Ht + e + e;
  }
  return e;
}
var k1 = function(t, n, r, i) {
  if (t.length > -1 && !t.return) switch (t.type) {
    case Hd:
      t.return = qm(t.value, t.length);
      break;
    case Zm:
      return oa([Wa(t, {
        value: We(t.value, "@", "@" + He)
      })], i);
    case Ud:
      if (t.length) return u1(t.props, function(a) {
        switch (c1(a, /(::plac\w+|:read-\w+)/)) {
          // :read-(only|write)
          case ":read-only":
          case ":read-write":
            return oa([Wa(t, {
              props: [We(a, /:(read-\w+)/, ":" + ll + "$1")]
            })], i);
          // :placeholder
          case "::placeholder":
            return oa([Wa(t, {
              props: [We(a, /:(plac\w+)/, ":" + He + "input-$1")]
            }), Wa(t, {
              props: [We(a, /:(plac\w+)/, ":" + ll + "$1")]
            }), Wa(t, {
              props: [We(a, /:(plac\w+)/, Ht + "input-$1")]
            })], i);
        }
        return "";
      });
  }
}, T1 = [k1], R1 = function(t) {
  var n = t.key;
  if (n === "css") {
    var r = document.querySelectorAll("style[data-emotion]:not([data-s])");
    Array.prototype.forEach.call(r, function(g) {
      var m = g.getAttribute("data-emotion");
      m.indexOf(" ") !== -1 && (document.head.appendChild(g), g.setAttribute("data-s", ""));
    });
  }
  var i = t.stylisPlugins || T1, a = {}, s, o = [];
  s = t.container || document.head, Array.prototype.forEach.call(
    // this means we will ignore elements which don't have a space in them which
    // means that the style elements we're looking at are only Emotion 11 server-rendered style elements
    document.querySelectorAll('style[data-emotion^="' + n + ' "]'),
    function(g) {
      for (var m = g.getAttribute("data-emotion").split(" "), b = 1; b < m.length; b++)
        a[m[b]] = !0;
      o.push(g);
    }
  );
  var l, c = [S1, A1];
  {
    var u, d = [_1, x1(function(g) {
      u.insert(g);
    })], f = v1(c.concat(i, d)), p = function(m) {
      return oa(b1(m), f);
    };
    l = function(m, b, y, v) {
      u = y, p(m ? m + "{" + b.styles + "}" : b.styles), v && (h.inserted[b.name] = !0);
    };
  }
  var h = {
    key: n,
    sheet: new r1({
      key: n,
      container: s,
      nonce: t.nonce,
      speedy: t.speedy,
      prepend: t.prepend,
      insertionPoint: t.insertionPoint
    }),
    nonce: t.nonce,
    inserted: a,
    registered: {},
    insert: l
  };
  return h.sheet.hydrate(o), h;
}, po = { exports: {} }, Ze = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Lp;
function N1() {
  if (Lp) return Ze;
  Lp = 1;
  var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, n = e ? Symbol.for("react.portal") : 60106, r = e ? Symbol.for("react.fragment") : 60107, i = e ? Symbol.for("react.strict_mode") : 60108, a = e ? Symbol.for("react.profiler") : 60114, s = e ? Symbol.for("react.provider") : 60109, o = e ? Symbol.for("react.context") : 60110, l = e ? Symbol.for("react.async_mode") : 60111, c = e ? Symbol.for("react.concurrent_mode") : 60111, u = e ? Symbol.for("react.forward_ref") : 60112, d = e ? Symbol.for("react.suspense") : 60113, f = e ? Symbol.for("react.suspense_list") : 60120, p = e ? Symbol.for("react.memo") : 60115, h = e ? Symbol.for("react.lazy") : 60116, g = e ? Symbol.for("react.block") : 60121, m = e ? Symbol.for("react.fundamental") : 60117, b = e ? Symbol.for("react.responder") : 60118, y = e ? Symbol.for("react.scope") : 60119;
  function v(_) {
    if (typeof _ == "object" && _ !== null) {
      var x = _.$$typeof;
      switch (x) {
        case t:
          switch (_ = _.type, _) {
            case l:
            case c:
            case r:
            case a:
            case i:
            case d:
              return _;
            default:
              switch (_ = _ && _.$$typeof, _) {
                case o:
                case u:
                case h:
                case p:
                case s:
                  return _;
                default:
                  return x;
              }
          }
        case n:
          return x;
      }
    }
  }
  function E(_) {
    return v(_) === c;
  }
  return Ze.AsyncMode = l, Ze.ConcurrentMode = c, Ze.ContextConsumer = o, Ze.ContextProvider = s, Ze.Element = t, Ze.ForwardRef = u, Ze.Fragment = r, Ze.Lazy = h, Ze.Memo = p, Ze.Portal = n, Ze.Profiler = a, Ze.StrictMode = i, Ze.Suspense = d, Ze.isAsyncMode = function(_) {
    return E(_) || v(_) === l;
  }, Ze.isConcurrentMode = E, Ze.isContextConsumer = function(_) {
    return v(_) === o;
  }, Ze.isContextProvider = function(_) {
    return v(_) === s;
  }, Ze.isElement = function(_) {
    return typeof _ == "object" && _ !== null && _.$$typeof === t;
  }, Ze.isForwardRef = function(_) {
    return v(_) === u;
  }, Ze.isFragment = function(_) {
    return v(_) === r;
  }, Ze.isLazy = function(_) {
    return v(_) === h;
  }, Ze.isMemo = function(_) {
    return v(_) === p;
  }, Ze.isPortal = function(_) {
    return v(_) === n;
  }, Ze.isProfiler = function(_) {
    return v(_) === a;
  }, Ze.isStrictMode = function(_) {
    return v(_) === i;
  }, Ze.isSuspense = function(_) {
    return v(_) === d;
  }, Ze.isValidElementType = function(_) {
    return typeof _ == "string" || typeof _ == "function" || _ === r || _ === c || _ === a || _ === i || _ === d || _ === f || typeof _ == "object" && _ !== null && (_.$$typeof === h || _.$$typeof === p || _.$$typeof === s || _.$$typeof === o || _.$$typeof === u || _.$$typeof === m || _.$$typeof === b || _.$$typeof === y || _.$$typeof === g);
  }, Ze.typeOf = v, Ze;
}
var $e = {};
/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Fp;
function O1() {
  return Fp || (Fp = 1, process.env.NODE_ENV !== "production" && function() {
    var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, n = e ? Symbol.for("react.portal") : 60106, r = e ? Symbol.for("react.fragment") : 60107, i = e ? Symbol.for("react.strict_mode") : 60108, a = e ? Symbol.for("react.profiler") : 60114, s = e ? Symbol.for("react.provider") : 60109, o = e ? Symbol.for("react.context") : 60110, l = e ? Symbol.for("react.async_mode") : 60111, c = e ? Symbol.for("react.concurrent_mode") : 60111, u = e ? Symbol.for("react.forward_ref") : 60112, d = e ? Symbol.for("react.suspense") : 60113, f = e ? Symbol.for("react.suspense_list") : 60120, p = e ? Symbol.for("react.memo") : 60115, h = e ? Symbol.for("react.lazy") : 60116, g = e ? Symbol.for("react.block") : 60121, m = e ? Symbol.for("react.fundamental") : 60117, b = e ? Symbol.for("react.responder") : 60118, y = e ? Symbol.for("react.scope") : 60119;
    function v(ie) {
      return typeof ie == "string" || typeof ie == "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
      ie === r || ie === c || ie === a || ie === i || ie === d || ie === f || typeof ie == "object" && ie !== null && (ie.$$typeof === h || ie.$$typeof === p || ie.$$typeof === s || ie.$$typeof === o || ie.$$typeof === u || ie.$$typeof === m || ie.$$typeof === b || ie.$$typeof === y || ie.$$typeof === g);
    }
    function E(ie) {
      if (typeof ie == "object" && ie !== null) {
        var Rt = ie.$$typeof;
        switch (Rt) {
          case t:
            var ft = ie.type;
            switch (ft) {
              case l:
              case c:
              case r:
              case a:
              case i:
              case d:
                return ft;
              default:
                var wt = ft && ft.$$typeof;
                switch (wt) {
                  case o:
                  case u:
                  case h:
                  case p:
                  case s:
                    return wt;
                  default:
                    return Rt;
                }
            }
          case n:
            return Rt;
        }
      }
    }
    var _ = l, x = c, I = o, T = s, O = t, k = u, W = r, M = h, L = p, z = n, U = a, $ = i, Q = d, K = !1;
    function fe(ie) {
      return K || (K = !0, console.warn("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.")), S(ie) || E(ie) === l;
    }
    function S(ie) {
      return E(ie) === c;
    }
    function me(ie) {
      return E(ie) === o;
    }
    function se(ie) {
      return E(ie) === s;
    }
    function A(ie) {
      return typeof ie == "object" && ie !== null && ie.$$typeof === t;
    }
    function ve(ie) {
      return E(ie) === u;
    }
    function Te(ie) {
      return E(ie) === r;
    }
    function Ce(ie) {
      return E(ie) === h;
    }
    function Je(ie) {
      return E(ie) === p;
    }
    function Be(ie) {
      return E(ie) === n;
    }
    function it(ie) {
      return E(ie) === a;
    }
    function at(ie) {
      return E(ie) === i;
    }
    function mt(ie) {
      return E(ie) === d;
    }
    $e.AsyncMode = _, $e.ConcurrentMode = x, $e.ContextConsumer = I, $e.ContextProvider = T, $e.Element = O, $e.ForwardRef = k, $e.Fragment = W, $e.Lazy = M, $e.Memo = L, $e.Portal = z, $e.Profiler = U, $e.StrictMode = $, $e.Suspense = Q, $e.isAsyncMode = fe, $e.isConcurrentMode = S, $e.isContextConsumer = me, $e.isContextProvider = se, $e.isElement = A, $e.isForwardRef = ve, $e.isFragment = Te, $e.isLazy = Ce, $e.isMemo = Je, $e.isPortal = Be, $e.isProfiler = it, $e.isStrictMode = at, $e.isSuspense = mt, $e.isValidElementType = v, $e.typeOf = E;
  }()), $e;
}
var Bp;
function M1() {
  return Bp || (Bp = 1, process.env.NODE_ENV === "production" ? po.exports = N1() : po.exports = O1()), po.exports;
}
var Oc, zp;
function P1() {
  if (zp) return Oc;
  zp = 1;
  var e = M1(), t = {
    childContextTypes: !0,
    contextType: !0,
    contextTypes: !0,
    defaultProps: !0,
    displayName: !0,
    getDefaultProps: !0,
    getDerivedStateFromError: !0,
    getDerivedStateFromProps: !0,
    mixins: !0,
    propTypes: !0,
    type: !0
  }, n = {
    name: !0,
    length: !0,
    prototype: !0,
    caller: !0,
    callee: !0,
    arguments: !0,
    arity: !0
  }, r = {
    $$typeof: !0,
    render: !0,
    defaultProps: !0,
    displayName: !0,
    propTypes: !0
  }, i = {
    $$typeof: !0,
    compare: !0,
    defaultProps: !0,
    displayName: !0,
    propTypes: !0,
    type: !0
  }, a = {};
  a[e.ForwardRef] = r, a[e.Memo] = i;
  function s(h) {
    return e.isMemo(h) ? i : a[h.$$typeof] || t;
  }
  var o = Object.defineProperty, l = Object.getOwnPropertyNames, c = Object.getOwnPropertySymbols, u = Object.getOwnPropertyDescriptor, d = Object.getPrototypeOf, f = Object.prototype;
  function p(h, g, m) {
    if (typeof g != "string") {
      if (f) {
        var b = d(g);
        b && b !== f && p(h, b, m);
      }
      var y = l(g);
      c && (y = y.concat(c(g)));
      for (var v = s(h), E = s(g), _ = 0; _ < y.length; ++_) {
        var x = y[_];
        if (!n[x] && !(m && m[x]) && !(E && E[x]) && !(v && v[x])) {
          var I = u(g, x);
          try {
            o(h, x, I);
          } catch {
          }
        }
      }
    }
    return h;
  }
  return Oc = p, Oc;
}
P1();
var D1 = !0;
function L1(e, t, n) {
  var r = "";
  return n.split(" ").forEach(function(i) {
    e[i] !== void 0 ? t.push(e[i] + ";") : i && (r += i + " ");
  }), r;
}
var Km = function(t, n, r) {
  var i = t.key + "-" + n.name;
  // we only need to add the styles to the registered cache if the
  // class name could be used further down
  // the tree but if it's a string tag, we know it won't
  // so we don't have to add it to registered cache.
  // this improves memory usage since we can avoid storing the whole style string
  (r === !1 || // we need to always store it if we're in compat mode and
  // in node since emotion-server relies on whether a style is in
  // the registered cache to know whether a style is global or not
  // also, note that this check will be dead code eliminated in the browser
  D1 === !1) && t.registered[i] === void 0 && (t.registered[i] = n.styles);
}, F1 = function(t, n, r) {
  Km(t, n, r);
  var i = t.key + "-" + n.name;
  if (t.inserted[n.name] === void 0) {
    var a = n;
    do
      t.insert(n === a ? "." + i : "", a, t.sheet, !0), a = a.next;
    while (a !== void 0);
  }
};
function B1(e) {
  for (var t = 0, n, r = 0, i = e.length; i >= 4; ++r, i -= 4)
    n = e.charCodeAt(r) & 255 | (e.charCodeAt(++r) & 255) << 8 | (e.charCodeAt(++r) & 255) << 16 | (e.charCodeAt(++r) & 255) << 24, n = /* Math.imul(k, m): */
    (n & 65535) * 1540483477 + ((n >>> 16) * 59797 << 16), n ^= /* k >>> r: */
    n >>> 24, t = /* Math.imul(k, m): */
    (n & 65535) * 1540483477 + ((n >>> 16) * 59797 << 16) ^ /* Math.imul(h, m): */
    (t & 65535) * 1540483477 + ((t >>> 16) * 59797 << 16);
  switch (i) {
    case 3:
      t ^= (e.charCodeAt(r + 2) & 255) << 16;
    case 2:
      t ^= (e.charCodeAt(r + 1) & 255) << 8;
    case 1:
      t ^= e.charCodeAt(r) & 255, t = /* Math.imul(h, m): */
      (t & 65535) * 1540483477 + ((t >>> 16) * 59797 << 16);
  }
  return t ^= t >>> 13, t = /* Math.imul(h, m): */
  (t & 65535) * 1540483477 + ((t >>> 16) * 59797 << 16), ((t ^ t >>> 15) >>> 0).toString(36);
}
var z1 = {
  animationIterationCount: 1,
  aspectRatio: 1,
  borderImageOutset: 1,
  borderImageSlice: 1,
  borderImageWidth: 1,
  boxFlex: 1,
  boxFlexGroup: 1,
  boxOrdinalGroup: 1,
  columnCount: 1,
  columns: 1,
  flex: 1,
  flexGrow: 1,
  flexPositive: 1,
  flexShrink: 1,
  flexNegative: 1,
  flexOrder: 1,
  gridRow: 1,
  gridRowEnd: 1,
  gridRowSpan: 1,
  gridRowStart: 1,
  gridColumn: 1,
  gridColumnEnd: 1,
  gridColumnSpan: 1,
  gridColumnStart: 1,
  msGridRow: 1,
  msGridRowSpan: 1,
  msGridColumn: 1,
  msGridColumnSpan: 1,
  fontWeight: 1,
  lineHeight: 1,
  opacity: 1,
  order: 1,
  orphans: 1,
  scale: 1,
  tabSize: 1,
  widows: 1,
  zIndex: 1,
  zoom: 1,
  WebkitLineClamp: 1,
  // SVG-related properties
  fillOpacity: 1,
  floodOpacity: 1,
  stopOpacity: 1,
  strokeDasharray: 1,
  strokeDashoffset: 1,
  strokeMiterlimit: 1,
  strokeOpacity: 1,
  strokeWidth: 1
}, V1 = /[A-Z]|^ms/g, G1 = /_EMO_([^_]+?)_([^]*?)_EMO_/g, Qm = function(t) {
  return t.charCodeAt(1) === 45;
}, Vp = function(t) {
  return t != null && typeof t != "boolean";
}, Mc = /* @__PURE__ */ E1(function(e) {
  return Qm(e) ? e : e.replace(V1, "-$&").toLowerCase();
}), Gp = function(t, n) {
  switch (t) {
    case "animation":
    case "animationName":
      if (typeof n == "string")
        return n.replace(G1, function(r, i, a) {
          return dr = {
            name: i,
            styles: a,
            next: dr
          }, i;
        });
  }
  return z1[t] !== 1 && !Qm(t) && typeof n == "number" && n !== 0 ? n + "px" : n;
};
function Rs(e, t, n) {
  if (n == null)
    return "";
  var r = n;
  if (r.__emotion_styles !== void 0)
    return r;
  switch (typeof n) {
    case "boolean":
      return "";
    case "object": {
      var i = n;
      if (i.anim === 1)
        return dr = {
          name: i.name,
          styles: i.styles,
          next: dr
        }, i.name;
      var a = n;
      if (a.styles !== void 0) {
        var s = a.next;
        if (s !== void 0)
          for (; s !== void 0; )
            dr = {
              name: s.name,
              styles: s.styles,
              next: dr
            }, s = s.next;
        var o = a.styles + ";";
        return o;
      }
      return j1(e, t, n);
    }
    case "function": {
      if (e !== void 0) {
        var l = dr, c = n(e);
        return dr = l, Rs(e, t, c);
      }
      break;
    }
  }
  var u = n;
  return u;
}
function j1(e, t, n) {
  var r = "";
  if (Array.isArray(n))
    for (var i = 0; i < n.length; i++)
      r += Rs(e, t, n[i]) + ";";
  else
    for (var a in n) {
      var s = n[a];
      if (typeof s != "object") {
        var o = s;
        Vp(o) && (r += Mc(a) + ":" + Gp(a, o) + ";");
      } else if (Array.isArray(s) && typeof s[0] == "string" && t == null)
        for (var l = 0; l < s.length; l++)
          Vp(s[l]) && (r += Mc(a) + ":" + Gp(a, s[l]) + ";");
      else {
        var c = Rs(e, t, s);
        switch (a) {
          case "animation":
          case "animationName": {
            r += Mc(a) + ":" + c + ";";
            break;
          }
          default:
            r += a + "{" + c + "}";
        }
      }
    }
  return r;
}
var jp = /label:\s*([^\s;{]+)\s*(;|$)/g, dr;
function eb(e, t, n) {
  if (e.length === 1 && typeof e[0] == "object" && e[0] !== null && e[0].styles !== void 0)
    return e[0];
  var r = !0, i = "";
  dr = void 0;
  var a = e[0];
  if (a == null || a.raw === void 0)
    r = !1, i += Rs(n, t, a);
  else {
    var s = a;
    i += s[0];
  }
  for (var o = 1; o < e.length; o++)
    if (i += Rs(n, t, e[o]), r) {
      var l = a;
      i += l[o];
    }
  jp.lastIndex = 0;
  for (var c = "", u; (u = jp.exec(i)) !== null; )
    c += "-" + u[1];
  var d = B1(i) + c;
  return {
    name: d,
    styles: i,
    next: dr
  };
}
var U1 = function(t) {
  return t();
}, H1 = F.useInsertionEffect ? F.useInsertionEffect : !1, W1 = H1 || U1, tb = /* @__PURE__ */ F.createContext(
  // we're doing this to avoid preconstruct's dead code elimination in this one case
  // because this module is primarily intended for the browser and node
  // but it's also required in react native and similar environments sometimes
  // and we could have a special build just for that
  // but this is much easier and the native packages
  // might use a different theme context in the future anyway
  typeof HTMLElement < "u" ? /* @__PURE__ */ R1({
    key: "css"
  }) : null
);
tb.Provider;
var Z1 = function(t) {
  return /* @__PURE__ */ Ue(function(n, r) {
    var i = Fl(tb);
    return t(n, i, r);
  });
}, $1 = /* @__PURE__ */ F.createContext({}), Zd = {}.hasOwnProperty, Vu = "__EMOTION_TYPE_PLEASE_DO_NOT_USE__", X1 = function(t, n) {
  var r = {};
  for (var i in n)
    Zd.call(n, i) && (r[i] = n[i]);
  return r[Vu] = t, r;
}, Y1 = function(t) {
  var n = t.cache, r = t.serialized, i = t.isStringTag;
  return Km(n, r, i), W1(function() {
    return F1(n, r, i);
  }), null;
}, J1 = /* @__PURE__ */ Z1(function(e, t, n) {
  var r = e.css;
  typeof r == "string" && t.registered[r] !== void 0 && (r = t.registered[r]);
  var i = e[Vu], a = [r], s = "";
  typeof e.className == "string" ? s = L1(t.registered, a, e.className) : e.className != null && (s = e.className + " ");
  var o = eb(a, void 0, F.useContext($1));
  s += t.key + "-" + o.name;
  var l = {};
  for (var c in e)
    Zd.call(e, c) && c !== "css" && c !== Vu && (l[c] = e[c]);
  return l.className = s, n && (l.ref = n), /* @__PURE__ */ F.createElement(F.Fragment, null, /* @__PURE__ */ F.createElement(Y1, {
    cache: t,
    serialized: o,
    isStringTag: typeof i == "string"
  }), /* @__PURE__ */ F.createElement(i, l));
}), q1 = J1, ge = function(t, n) {
  var r = arguments;
  if (n == null || !Zd.call(n, "css"))
    return F.createElement.apply(void 0, r);
  var i = r.length, a = new Array(i);
  a[0] = q1, a[1] = X1(t, n);
  for (var s = 2; s < i; s++)
    a[s] = r[s];
  return F.createElement.apply(null, a);
};
(function(e) {
  var t;
  t || (t = e.JSX || (e.JSX = {}));
})(ge || (ge = {}));
function $d() {
  for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
    t[n] = arguments[n];
  return eb(t);
}
function K1() {
  var e = $d.apply(void 0, arguments), t = "animation-" + e.name;
  return {
    name: t,
    styles: "@keyframes " + t + "{" + e.styles + "}",
    anim: 1,
    toString: function() {
      return "_EMO_" + this.name + "_" + this.styles + "_EMO_";
    }
  };
}
function Q1(e, t) {
  return t || (t = e.slice(0)), Object.freeze(Object.defineProperties(e, {
    raw: {
      value: Object.freeze(t)
    }
  }));
}
const ew = Math.min, tw = Math.max, cl = Math.round, ho = Math.floor, ul = (e) => ({
  x: e,
  y: e
});
function nw(e) {
  const {
    x: t,
    y: n,
    width: r,
    height: i
  } = e;
  return {
    width: r,
    height: i,
    top: n,
    left: t,
    right: t + r,
    bottom: n + i,
    x: t,
    y: n
  };
}
function $l() {
  return typeof window < "u";
}
function nb(e) {
  return ib(e) ? (e.nodeName || "").toLowerCase() : "#document";
}
function Fr(e) {
  var t;
  return (e == null || (t = e.ownerDocument) == null ? void 0 : t.defaultView) || window;
}
function rb(e) {
  var t;
  return (t = (ib(e) ? e.ownerDocument : e.document) || window.document) == null ? void 0 : t.documentElement;
}
function ib(e) {
  return $l() ? e instanceof Node || e instanceof Fr(e).Node : !1;
}
function rw(e) {
  return $l() ? e instanceof Element || e instanceof Fr(e).Element : !1;
}
function Xd(e) {
  return $l() ? e instanceof HTMLElement || e instanceof Fr(e).HTMLElement : !1;
}
function Up(e) {
  return !$l() || typeof ShadowRoot > "u" ? !1 : e instanceof ShadowRoot || e instanceof Fr(e).ShadowRoot;
}
function ab(e) {
  const {
    overflow: t,
    overflowX: n,
    overflowY: r,
    display: i
  } = Yd(e);
  return /auto|scroll|overlay|hidden|clip/.test(t + r + n) && !["inline", "contents"].includes(i);
}
function iw() {
  return typeof CSS > "u" || !CSS.supports ? !1 : CSS.supports("-webkit-backdrop-filter", "none");
}
function aw(e) {
  return ["html", "body", "#document"].includes(nb(e));
}
function Yd(e) {
  return Fr(e).getComputedStyle(e);
}
function sw(e) {
  if (nb(e) === "html")
    return e;
  const t = (
    // Step into the shadow DOM of the parent of a slotted node.
    e.assignedSlot || // DOM Element detected.
    e.parentNode || // ShadowRoot detected.
    Up(e) && e.host || // Fallback.
    rb(e)
  );
  return Up(t) ? t.host : t;
}
function sb(e) {
  const t = sw(e);
  return aw(t) ? e.ownerDocument ? e.ownerDocument.body : e.body : Xd(t) && ab(t) ? t : sb(t);
}
function dl(e, t, n) {
  var r;
  t === void 0 && (t = []), n === void 0 && (n = !0);
  const i = sb(e), a = i === ((r = e.ownerDocument) == null ? void 0 : r.body), s = Fr(i);
  if (a) {
    const o = Gu(s);
    return t.concat(s, s.visualViewport || [], ab(i) ? i : [], o && n ? dl(o) : []);
  }
  return t.concat(i, dl(i, [], n));
}
function Gu(e) {
  return e.parent && Object.getPrototypeOf(e.parent) ? e.frameElement : null;
}
function ow(e) {
  const t = Yd(e);
  let n = parseFloat(t.width) || 0, r = parseFloat(t.height) || 0;
  const i = Xd(e), a = i ? e.offsetWidth : n, s = i ? e.offsetHeight : r, o = cl(n) !== a || cl(r) !== s;
  return o && (n = a, r = s), {
    width: n,
    height: r,
    $: o
  };
}
function Jd(e) {
  return rw(e) ? e : e.contextElement;
}
function Hp(e) {
  const t = Jd(e);
  if (!Xd(t))
    return ul(1);
  const n = t.getBoundingClientRect(), {
    width: r,
    height: i,
    $: a
  } = ow(t);
  let s = (a ? cl(n.width) : n.width) / r, o = (a ? cl(n.height) : n.height) / i;
  return (!s || !Number.isFinite(s)) && (s = 1), (!o || !Number.isFinite(o)) && (o = 1), {
    x: s,
    y: o
  };
}
const lw = /* @__PURE__ */ ul(0);
function cw(e) {
  const t = Fr(e);
  return !iw() || !t.visualViewport ? lw : {
    x: t.visualViewport.offsetLeft,
    y: t.visualViewport.offsetTop
  };
}
function uw(e, t, n) {
  return !1;
}
function Wp(e, t, n, r) {
  t === void 0 && (t = !1);
  const i = e.getBoundingClientRect(), a = Jd(e);
  let s = ul(1);
  t && (s = Hp(e));
  const o = uw() ? cw(a) : ul(0);
  let l = (i.left + o.x) / s.x, c = (i.top + o.y) / s.y, u = i.width / s.x, d = i.height / s.y;
  if (a) {
    const f = Fr(a), p = r;
    let h = f, g = Gu(h);
    for (; g && r && p !== h; ) {
      const m = Hp(g), b = g.getBoundingClientRect(), y = Yd(g), v = b.left + (g.clientLeft + parseFloat(y.paddingLeft)) * m.x, E = b.top + (g.clientTop + parseFloat(y.paddingTop)) * m.y;
      l *= m.x, c *= m.y, u *= m.x, d *= m.y, l += v, c += E, h = Fr(g), g = Gu(h);
    }
  }
  return nw({
    width: u,
    height: d,
    x: l,
    y: c
  });
}
function ob(e, t) {
  return e.x === t.x && e.y === t.y && e.width === t.width && e.height === t.height;
}
function dw(e, t) {
  let n = null, r;
  const i = rb(e);
  function a() {
    var o;
    clearTimeout(r), (o = n) == null || o.disconnect(), n = null;
  }
  function s(o, l) {
    o === void 0 && (o = !1), l === void 0 && (l = 1), a();
    const c = e.getBoundingClientRect(), {
      left: u,
      top: d,
      width: f,
      height: p
    } = c;
    if (o || t(), !f || !p)
      return;
    const h = ho(d), g = ho(i.clientWidth - (u + f)), m = ho(i.clientHeight - (d + p)), b = ho(u), v = {
      rootMargin: -h + "px " + -g + "px " + -m + "px " + -b + "px",
      threshold: tw(0, ew(1, l)) || 1
    };
    let E = !0;
    function _(x) {
      const I = x[0].intersectionRatio;
      if (I !== l) {
        if (!E)
          return s();
        I ? s(!1, I) : r = setTimeout(() => {
          s(!1, 1e-7);
        }, 1e3);
      }
      I === 1 && !ob(c, e.getBoundingClientRect()) && s(), E = !1;
    }
    try {
      n = new IntersectionObserver(_, {
        ...v,
        // Handle <iframe>s
        root: i.ownerDocument
      });
    } catch {
      n = new IntersectionObserver(_, v);
    }
    n.observe(e);
  }
  return s(!0), a;
}
function fw(e, t, n, r) {
  r === void 0 && (r = {});
  const {
    ancestorScroll: i = !0,
    ancestorResize: a = !0,
    elementResize: s = typeof ResizeObserver == "function",
    layoutShift: o = typeof IntersectionObserver == "function",
    animationFrame: l = !1
  } = r, c = Jd(e), u = i || a ? [...c ? dl(c) : [], ...dl(t)] : [];
  u.forEach((b) => {
    i && b.addEventListener("scroll", n, {
      passive: !0
    }), a && b.addEventListener("resize", n);
  });
  const d = c && o ? dw(c, n) : null;
  let f = -1, p = null;
  s && (p = new ResizeObserver((b) => {
    let [y] = b;
    y && y.target === c && p && (p.unobserve(t), cancelAnimationFrame(f), f = requestAnimationFrame(() => {
      var v;
      (v = p) == null || v.observe(t);
    })), n();
  }), c && !l && p.observe(c), p.observe(t));
  let h, g = l ? Wp(e) : null;
  l && m();
  function m() {
    const b = Wp(e);
    g && !ob(g, b) && n(), g = b, h = requestAnimationFrame(m);
  }
  return n(), () => {
    var b;
    u.forEach((y) => {
      i && y.removeEventListener("scroll", n), a && y.removeEventListener("resize", n);
    }), d == null || d(), (b = p) == null || b.disconnect(), p = null, l && cancelAnimationFrame(h);
  };
}
var ju = Uv, pw = ["className", "clearValue", "cx", "getStyles", "getClassNames", "getValue", "hasValue", "isMulti", "isRtl", "options", "selectOption", "selectProps", "setValue", "theme"], fl = function() {
};
function hw(e, t) {
  return t ? t[0] === "-" ? e + t : e + "__" + t : e;
}
function gw(e, t) {
  for (var n = arguments.length, r = new Array(n > 2 ? n - 2 : 0), i = 2; i < n; i++)
    r[i - 2] = arguments[i];
  var a = [].concat(r);
  if (t && e)
    for (var s in t)
      t.hasOwnProperty(s) && t[s] && a.push("".concat(hw(e, s)));
  return a.filter(function(o) {
    return o;
  }).map(function(o) {
    return String(o).trim();
  }).join(" ");
}
var pl = function(t) {
  return Iw(t) ? t.filter(Boolean) : Ti(t) === "object" && t !== null ? [t] : [];
}, lb = function(t) {
  t.className, t.clearValue, t.cx, t.getStyles, t.getClassNames, t.getValue, t.hasValue, t.isMulti, t.isRtl, t.options, t.selectOption, t.selectProps, t.setValue, t.theme;
  var n = tr(t, pw);
  return pe({}, n);
}, gt = function(t, n, r) {
  var i = t.cx, a = t.getStyles, s = t.getClassNames, o = t.className;
  return {
    css: a(n, t),
    className: i(r ?? {}, s(n, t), o)
  };
};
function mw(e, t, n) {
  if (n) {
    var r = n(e, t);
    if (typeof r == "string") return r;
  }
  return e;
}
function Xl(e) {
  return [document.documentElement, document.body, window].indexOf(e) > -1;
}
function bw(e) {
  return Xl(e) ? window.innerHeight : e.clientHeight;
}
function cb(e) {
  return Xl(e) ? window.pageYOffset : e.scrollTop;
}
function hl(e, t) {
  if (Xl(e)) {
    window.scrollTo(0, t);
    return;
  }
  e.scrollTop = t;
}
function yw(e) {
  var t = getComputedStyle(e), n = t.position === "absolute", r = /(auto|scroll)/;
  if (t.position === "fixed") return document.documentElement;
  for (var i = e; i = i.parentElement; )
    if (t = getComputedStyle(i), !(n && t.position === "static") && r.test(t.overflow + t.overflowY + t.overflowX))
      return i;
  return document.documentElement;
}
function _w(e, t, n, r) {
  return n * ((e = e / r - 1) * e * e + 1) + t;
}
function go(e, t) {
  var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 200, r = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : fl, i = cb(e), a = t - i, s = 10, o = 0;
  function l() {
    o += s;
    var c = _w(o, i, a, n);
    hl(e, c), o < n ? window.requestAnimationFrame(l) : r(e);
  }
  l();
}
function Zp(e, t) {
  var n = e.getBoundingClientRect(), r = t.getBoundingClientRect(), i = t.offsetHeight / 3;
  r.bottom + i > n.bottom ? hl(e, Math.min(t.offsetTop + t.clientHeight - e.offsetHeight + i, e.scrollHeight)) : r.top - i < n.top && hl(e, Math.max(t.offsetTop - i, 0));
}
function vw(e) {
  var t = e.getBoundingClientRect();
  return {
    bottom: t.bottom,
    height: t.height,
    left: t.left,
    right: t.right,
    top: t.top,
    width: t.width
  };
}
function $p() {
  try {
    return document.createEvent("TouchEvent"), !0;
  } catch {
    return !1;
  }
}
function xw() {
  try {
    return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
  } catch {
    return !1;
  }
}
var ub = !1, Ew = {
  get passive() {
    return ub = !0;
  }
}, mo = typeof window < "u" ? window : {};
mo.addEventListener && mo.removeEventListener && (mo.addEventListener("p", fl, Ew), mo.removeEventListener("p", fl, !1));
var ww = ub;
function Cw(e) {
  return e != null;
}
function Iw(e) {
  return Array.isArray(e);
}
function ns(e, t, n) {
  return e ? t : n;
}
var Sw = function(t) {
  for (var n = arguments.length, r = new Array(n > 1 ? n - 1 : 0), i = 1; i < n; i++)
    r[i - 1] = arguments[i];
  var a = Object.entries(t).filter(function(s) {
    var o = Pt(s, 1), l = o[0];
    return !r.includes(l);
  });
  return a.reduce(function(s, o) {
    var l = Pt(o, 2), c = l[0], u = l[1];
    return s[c] = u, s;
  }, {});
}, Aw = ["children", "innerProps"], kw = ["children", "innerProps"];
function Tw(e) {
  var t = e.maxHeight, n = e.menuEl, r = e.minHeight, i = e.placement, a = e.shouldScroll, s = e.isFixedPosition, o = e.controlHeight, l = yw(n), c = {
    placement: "bottom",
    maxHeight: t
  };
  if (!n || !n.offsetParent) return c;
  var u = l.getBoundingClientRect(), d = u.height, f = n.getBoundingClientRect(), p = f.bottom, h = f.height, g = f.top, m = n.offsetParent.getBoundingClientRect(), b = m.top, y = s ? window.innerHeight : bw(l), v = cb(l), E = parseInt(getComputedStyle(n).marginBottom, 10), _ = parseInt(getComputedStyle(n).marginTop, 10), x = b - _, I = y - g, T = x + v, O = d - v - g, k = p - y + v + E, W = v + g - _, M = 160;
  switch (i) {
    case "auto":
    case "bottom":
      if (I >= h)
        return {
          placement: "bottom",
          maxHeight: t
        };
      if (O >= h && !s)
        return a && go(l, k, M), {
          placement: "bottom",
          maxHeight: t
        };
      if (!s && O >= r || s && I >= r) {
        a && go(l, k, M);
        var L = s ? I - E : O - E;
        return {
          placement: "bottom",
          maxHeight: L
        };
      }
      if (i === "auto" || s) {
        var z = t, U = s ? x : T;
        return U >= r && (z = Math.min(U - E - o, t)), {
          placement: "top",
          maxHeight: z
        };
      }
      if (i === "bottom")
        return a && hl(l, k), {
          placement: "bottom",
          maxHeight: t
        };
      break;
    case "top":
      if (x >= h)
        return {
          placement: "top",
          maxHeight: t
        };
      if (T >= h && !s)
        return a && go(l, W, M), {
          placement: "top",
          maxHeight: t
        };
      if (!s && T >= r || s && x >= r) {
        var $ = t;
        return (!s && T >= r || s && x >= r) && ($ = s ? x - _ : T - _), a && go(l, W, M), {
          placement: "top",
          maxHeight: $
        };
      }
      return {
        placement: "bottom",
        maxHeight: t
      };
    default:
      throw new Error('Invalid placement provided "'.concat(i, '".'));
  }
  return c;
}
function Rw(e) {
  var t = {
    bottom: "top",
    top: "bottom"
  };
  return e ? t[e] : "bottom";
}
var db = function(t) {
  return t === "auto" ? "bottom" : t;
}, Nw = function(t, n) {
  var r, i = t.placement, a = t.theme, s = a.borderRadius, o = a.spacing, l = a.colors;
  return pe((r = {
    label: "menu"
  }, ea(r, Rw(i), "100%"), ea(r, "position", "absolute"), ea(r, "width", "100%"), ea(r, "zIndex", 1), r), n ? {} : {
    backgroundColor: l.neutral0,
    borderRadius: s,
    boxShadow: "0 0 0 1px hsla(0, 0%, 0%, 0.1), 0 4px 11px hsla(0, 0%, 0%, 0.1)",
    marginBottom: o.menuGutter,
    marginTop: o.menuGutter
  });
}, fb = /* @__PURE__ */ Bl(null), Ow = function(t) {
  var n = t.children, r = t.minMenuHeight, i = t.maxMenuHeight, a = t.menuPlacement, s = t.menuPosition, o = t.menuShouldScrollIntoView, l = t.theme, c = Fl(fb) || {}, u = c.setPortalPlacement, d = gn(null), f = _t(i), p = Pt(f, 2), h = p[0], g = p[1], m = _t(null), b = Pt(m, 2), y = b[0], v = b[1], E = l.spacing.controlHeight;
  return ju(function() {
    var _ = d.current;
    if (_) {
      var x = s === "fixed", I = o && !x, T = Tw({
        maxHeight: i,
        menuEl: _,
        minHeight: r,
        placement: a,
        shouldScroll: I,
        isFixedPosition: x,
        controlHeight: E
      });
      g(T.maxHeight), v(T.placement), u == null || u(T.placement);
    }
  }, [i, a, s, o, r, u, E]), n({
    ref: d,
    placerProps: pe(pe({}, t), {}, {
      placement: y || db(a),
      maxHeight: h
    })
  });
}, Mw = function(t) {
  var n = t.children, r = t.innerRef, i = t.innerProps;
  return ge("div", ye({}, gt(t, "menu", {
    menu: !0
  }), {
    ref: r
  }, i), n);
}, Pw = Mw, Dw = function(t, n) {
  var r = t.maxHeight, i = t.theme.spacing.baseUnit;
  return pe({
    maxHeight: r,
    overflowY: "auto",
    position: "relative",
    // required for offset[Height, Top] > keyboard scroll
    WebkitOverflowScrolling: "touch"
  }, n ? {} : {
    paddingBottom: i,
    paddingTop: i
  });
}, Lw = function(t) {
  var n = t.children, r = t.innerProps, i = t.innerRef, a = t.isMulti;
  return ge("div", ye({}, gt(t, "menuList", {
    "menu-list": !0,
    "menu-list--is-multi": a
  }), {
    ref: i
  }, r), n);
}, pb = function(t, n) {
  var r = t.theme, i = r.spacing.baseUnit, a = r.colors;
  return pe({
    textAlign: "center"
  }, n ? {} : {
    color: a.neutral40,
    padding: "".concat(i * 2, "px ").concat(i * 3, "px")
  });
}, Fw = pb, Bw = pb, zw = function(t) {
  var n = t.children, r = n === void 0 ? "No options" : n, i = t.innerProps, a = tr(t, Aw);
  return ge("div", ye({}, gt(pe(pe({}, a), {}, {
    children: r,
    innerProps: i
  }), "noOptionsMessage", {
    "menu-notice": !0,
    "menu-notice--no-options": !0
  }), i), r);
}, Vw = function(t) {
  var n = t.children, r = n === void 0 ? "Loading..." : n, i = t.innerProps, a = tr(t, kw);
  return ge("div", ye({}, gt(pe(pe({}, a), {}, {
    children: r,
    innerProps: i
  }), "loadingMessage", {
    "menu-notice": !0,
    "menu-notice--loading": !0
  }), i), r);
}, Gw = function(t) {
  var n = t.rect, r = t.offset, i = t.position;
  return {
    left: n.left,
    position: i,
    top: r,
    width: n.width,
    zIndex: 1
  };
}, jw = function(t) {
  var n = t.appendTo, r = t.children, i = t.controlElement, a = t.innerProps, s = t.menuPlacement, o = t.menuPosition, l = gn(null), c = gn(null), u = _t(db(s)), d = Pt(u, 2), f = d[0], p = d[1], h = Nr(function() {
    return {
      setPortalPlacement: p
    };
  }, []), g = _t(null), m = Pt(g, 2), b = m[0], y = m[1], v = Dt(function() {
    if (i) {
      var I = vw(i), T = o === "fixed" ? 0 : window.pageYOffset, O = I[f] + T;
      (O !== (b == null ? void 0 : b.offset) || I.left !== (b == null ? void 0 : b.rect.left) || I.width !== (b == null ? void 0 : b.rect.width)) && y({
        offset: O,
        rect: I
      });
    }
  }, [i, o, f, b == null ? void 0 : b.offset, b == null ? void 0 : b.rect.left, b == null ? void 0 : b.rect.width]);
  ju(function() {
    v();
  }, [v]);
  var E = Dt(function() {
    typeof c.current == "function" && (c.current(), c.current = null), i && l.current && (c.current = fw(i, l.current, v, {
      elementResize: "ResizeObserver" in window
    }));
  }, [i, v]);
  ju(function() {
    E();
  }, [E]);
  var _ = Dt(function(I) {
    l.current = I, E();
  }, [E]);
  if (!n && o !== "fixed" || !b) return null;
  var x = ge("div", ye({
    ref: _
  }, gt(pe(pe({}, t), {}, {
    offset: b.offset,
    position: o,
    rect: b.rect
  }), "menuPortal", {
    "menu-portal": !0
  }), a), r);
  return ge(fb.Provider, {
    value: h
  }, n ? /* @__PURE__ */ rx(x, n) : x);
}, Uw = function(t) {
  var n = t.isDisabled, r = t.isRtl;
  return {
    label: "container",
    direction: r ? "rtl" : void 0,
    pointerEvents: n ? "none" : void 0,
    // cancel mouse events when disabled
    position: "relative"
  };
}, Hw = function(t) {
  var n = t.children, r = t.innerProps, i = t.isDisabled, a = t.isRtl;
  return ge("div", ye({}, gt(t, "container", {
    "--is-disabled": i,
    "--is-rtl": a
  }), r), n);
}, Ww = function(t, n) {
  var r = t.theme.spacing, i = t.isMulti, a = t.hasValue, s = t.selectProps.controlShouldRenderValue;
  return pe({
    alignItems: "center",
    display: i && a && s ? "flex" : "grid",
    flex: 1,
    flexWrap: "wrap",
    WebkitOverflowScrolling: "touch",
    position: "relative",
    overflow: "hidden"
  }, n ? {} : {
    padding: "".concat(r.baseUnit / 2, "px ").concat(r.baseUnit * 2, "px")
  });
}, Zw = function(t) {
  var n = t.children, r = t.innerProps, i = t.isMulti, a = t.hasValue;
  return ge("div", ye({}, gt(t, "valueContainer", {
    "value-container": !0,
    "value-container--is-multi": i,
    "value-container--has-value": a
  }), r), n);
}, $w = function() {
  return {
    alignItems: "center",
    alignSelf: "stretch",
    display: "flex",
    flexShrink: 0
  };
}, Xw = function(t) {
  var n = t.children, r = t.innerProps;
  return ge("div", ye({}, gt(t, "indicatorsContainer", {
    indicators: !0
  }), r), n);
}, Xp, Yw = ["size"], Jw = ["innerProps", "isRtl", "size"];
function qw() {
  return "You have tried to stringify object returned from `css` function. It isn't supposed to be used directly (e.g. as value of the `className` prop), but rather handed to emotion so it can handle it (e.g. as value of `css` prop).";
}
var Kw = process.env.NODE_ENV === "production" ? {
  name: "8mmkcg",
  styles: "display:inline-block;fill:currentColor;line-height:1;stroke:currentColor;stroke-width:0"
} : {
  name: "tj5bde-Svg",
  styles: "display:inline-block;fill:currentColor;line-height:1;stroke:currentColor;stroke-width:0;label:Svg;",
  map: "/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImluZGljYXRvcnMudHN4Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQXlCSSIsImZpbGUiOiJpbmRpY2F0b3JzLnRzeCIsInNvdXJjZXNDb250ZW50IjpbIi8qKiBAanN4IGpzeCAqL1xuaW1wb3J0IHsgSlNYLCBSZWFjdE5vZGUgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBqc3gsIGtleWZyYW1lcyB9IGZyb20gJ0BlbW90aW9uL3JlYWN0JztcblxuaW1wb3J0IHtcbiAgQ29tbW9uUHJvcHNBbmRDbGFzc05hbWUsXG4gIENTU09iamVjdFdpdGhMYWJlbCxcbiAgR3JvdXBCYXNlLFxufSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQgeyBnZXRTdHlsZVByb3BzIH0gZnJvbSAnLi4vdXRpbHMnO1xuXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vIERyb3Bkb3duICYgQ2xlYXIgSWNvbnNcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG5jb25zdCBTdmcgPSAoe1xuICBzaXplLFxuICAuLi5wcm9wc1xufTogSlNYLkludHJpbnNpY0VsZW1lbnRzWydzdmcnXSAmIHsgc2l6ZTogbnVtYmVyIH0pID0+IChcbiAgPHN2Z1xuICAgIGhlaWdodD17c2l6ZX1cbiAgICB3aWR0aD17c2l6ZX1cbiAgICB2aWV3Qm94PVwiMCAwIDIwIDIwXCJcbiAgICBhcmlhLWhpZGRlbj1cInRydWVcIlxuICAgIGZvY3VzYWJsZT1cImZhbHNlXCJcbiAgICBjc3M9e3tcbiAgICAgIGRpc3BsYXk6ICdpbmxpbmUtYmxvY2snLFxuICAgICAgZmlsbDogJ2N1cnJlbnRDb2xvcicsXG4gICAgICBsaW5lSGVpZ2h0OiAxLFxuICAgICAgc3Ryb2tlOiAnY3VycmVudENvbG9yJyxcbiAgICAgIHN0cm9rZVdpZHRoOiAwLFxuICAgIH19XG4gICAgey4uLnByb3BzfVxuICAvPlxuKTtcblxuZXhwb3J0IHR5cGUgQ3Jvc3NJY29uUHJvcHMgPSBKU1guSW50cmluc2ljRWxlbWVudHNbJ3N2ZyddICYgeyBzaXplPzogbnVtYmVyIH07XG5leHBvcnQgY29uc3QgQ3Jvc3NJY29uID0gKHByb3BzOiBDcm9zc0ljb25Qcm9wcykgPT4gKFxuICA8U3ZnIHNpemU9ezIwfSB7Li4ucHJvcHN9PlxuICAgIDxwYXRoIGQ9XCJNMTQuMzQ4IDE0Ljg0OWMtMC40NjkgMC40NjktMS4yMjkgMC40NjktMS42OTcgMGwtMi42NTEtMy4wMzAtMi42NTEgMy4wMjljLTAuNDY5IDAuNDY5LTEuMjI5IDAuNDY5LTEuNjk3IDAtMC40NjktMC40NjktMC40NjktMS4yMjkgMC0xLjY5N2wyLjc1OC0zLjE1LTIuNzU5LTMuMTUyYy0wLjQ2OS0wLjQ2OS0wLjQ2OS0xLjIyOCAwLTEuNjk3czEuMjI4LTAuNDY5IDEuNjk3IDBsMi42NTIgMy4wMzEgMi42NTEtMy4wMzFjMC40NjktMC40NjkgMS4yMjgtMC40NjkgMS42OTcgMHMwLjQ2OSAxLjIyOSAwIDEuNjk3bC0yLjc1OCAzLjE1MiAyLjc1OCAzLjE1YzAuNDY5IDAuNDY5IDAuNDY5IDEuMjI5IDAgMS42OTh6XCIgLz5cbiAgPC9Tdmc+XG4pO1xuZXhwb3J0IHR5cGUgRG93bkNoZXZyb25Qcm9wcyA9IEpTWC5JbnRyaW5zaWNFbGVtZW50c1snc3ZnJ10gJiB7IHNpemU/OiBudW1iZXIgfTtcbmV4cG9ydCBjb25zdCBEb3duQ2hldnJvbiA9IChwcm9wczogRG93bkNoZXZyb25Qcm9wcykgPT4gKFxuICA8U3ZnIHNpemU9ezIwfSB7Li4ucHJvcHN9PlxuICAgIDxwYXRoIGQ9XCJNNC41MTYgNy41NDhjMC40MzYtMC40NDYgMS4wNDMtMC40ODEgMS41NzYgMGwzLjkwOCAzLjc0NyAzLjkwOC0zLjc0N2MwLjUzMy0wLjQ4MSAxLjE0MS0wLjQ0NiAxLjU3NCAwIDAuNDM2IDAuNDQ1IDAuNDA4IDEuMTk3IDAgMS42MTUtMC40MDYgMC40MTgtNC42OTUgNC41MDItNC42OTUgNC41MDItMC4yMTcgMC4yMjMtMC41MDIgMC4zMzUtMC43ODcgMC4zMzVzLTAuNTctMC4xMTItMC43ODktMC4zMzVjMCAwLTQuMjg3LTQuMDg0LTQuNjk1LTQuNTAycy0wLjQzNi0xLjE3IDAtMS42MTV6XCIgLz5cbiAgPC9Tdmc+XG4pO1xuXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vIERyb3Bkb3duICYgQ2xlYXIgQnV0dG9uc1xuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbmV4cG9ydCBpbnRlcmZhY2UgRHJvcGRvd25JbmRpY2F0b3JQcm9wczxcbiAgT3B0aW9uID0gdW5rbm93bixcbiAgSXNNdWx0aSBleHRlbmRzIGJvb2xlYW4gPSBib29sZWFuLFxuICBHcm91cCBleHRlbmRzIEdyb3VwQmFzZTxPcHRpb24+ID0gR3JvdXBCYXNlPE9wdGlvbj5cbj4gZXh0ZW5kcyBDb21tb25Qcm9wc0FuZENsYXNzTmFtZTxPcHRpb24sIElzTXVsdGksIEdyb3VwPiB7XG4gIC8qKiBUaGUgY2hpbGRyZW4gdG8gYmUgcmVuZGVyZWQgaW5zaWRlIHRoZSBpbmRpY2F0b3IuICovXG4gIGNoaWxkcmVuPzogUmVhY3ROb2RlO1xuICAvKiogUHJvcHMgdGhhdCB3aWxsIGJlIHBhc3NlZCBvbiB0byB0aGUgY2hpbGRyZW4uICovXG4gIGlubmVyUHJvcHM6IEpTWC5JbnRyaW5zaWNFbGVtZW50c1snZGl2J107XG4gIC8qKiBUaGUgZm9jdXNlZCBzdGF0ZSBvZiB0aGUgc2VsZWN0LiAqL1xuICBpc0ZvY3VzZWQ6IGJvb2xlYW47XG4gIGlzRGlzYWJsZWQ6IGJvb2xlYW47XG59XG5cbmNvbnN0IGJhc2VDU1MgPSA8XG4gIE9wdGlvbixcbiAgSXNNdWx0aSBleHRlbmRzIGJvb2xlYW4sXG4gIEdyb3VwIGV4dGVuZHMgR3JvdXBCYXNlPE9wdGlvbj5cbj4oXG4gIHtcbiAgICBpc0ZvY3VzZWQsXG4gICAgdGhlbWU6IHtcbiAgICAgIHNwYWNpbmc6IHsgYmFzZVVuaXQgfSxcbiAgICAgIGNvbG9ycyxcbiAgICB9LFxuICB9OlxuICAgIHwgRHJvcGRvd25JbmRpY2F0b3JQcm9wczxPcHRpb24sIElzTXVsdGksIEdyb3VwPlxuICAgIHwgQ2xlYXJJbmRpY2F0b3JQcm9wczxPcHRpb24sIElzTXVsdGksIEdyb3VwPixcbiAgdW5zdHlsZWQ6IGJvb2xlYW5cbik6IENTU09iamVjdFdpdGhMYWJlbCA9PiAoe1xuICBsYWJlbDogJ2luZGljYXRvckNvbnRhaW5lcicsXG4gIGRpc3BsYXk6ICdmbGV4JyxcbiAgdHJhbnNpdGlvbjogJ2NvbG9yIDE1MG1zJyxcbiAgLi4uKHVuc3R5bGVkXG4gICAgPyB7fVxuICAgIDoge1xuICAgICAgICBjb2xvcjogaXNGb2N1c2VkID8gY29sb3JzLm5ldXRyYWw2MCA6IGNvbG9ycy5uZXV0cmFsMjAsXG4gICAgICAgIHBhZGRpbmc6IGJhc2VVbml0ICogMixcbiAgICAgICAgJzpob3Zlcic6IHtcbiAgICAgICAgICBjb2xvcjogaXNGb2N1c2VkID8gY29sb3JzLm5ldXRyYWw4MCA6IGNvbG9ycy5uZXV0cmFsNDAsXG4gICAgICAgIH0sXG4gICAgICB9KSxcbn0pO1xuXG5leHBvcnQgY29uc3QgZHJvcGRvd25JbmRpY2F0b3JDU1MgPSBiYXNlQ1NTO1xuZXhwb3J0IGNvbnN0IERyb3Bkb3duSW5kaWNhdG9yID0gPFxuICBPcHRpb24sXG4gIElzTXVsdGkgZXh0ZW5kcyBib29sZWFuLFxuICBHcm91cCBleHRlbmRzIEdyb3VwQmFzZTxPcHRpb24+XG4+KFxuICBwcm9wczogRHJvcGRvd25JbmRpY2F0b3JQcm9wczxPcHRpb24sIElzTXVsdGksIEdyb3VwPlxuKSA9PiB7XG4gIGNvbnN0IHsgY2hpbGRyZW4sIGlubmVyUHJvcHMgfSA9IHByb3BzO1xuICByZXR1cm4gKFxuICAgIDxkaXZcbiAgICAgIHsuLi5nZXRTdHlsZVByb3BzKHByb3BzLCAnZHJvcGRvd25JbmRpY2F0b3InLCB7XG4gICAgICAgIGluZGljYXRvcjogdHJ1ZSxcbiAgICAgICAgJ2Ryb3Bkb3duLWluZGljYXRvcic6IHRydWUsXG4gICAgICB9KX1cbiAgICAgIHsuLi5pbm5lclByb3BzfVxuICAgID5cbiAgICAgIHtjaGlsZHJlbiB8fCA8RG93bkNoZXZyb24gLz59XG4gICAgPC9kaXY+XG4gICk7XG59O1xuXG5leHBvcnQgaW50ZXJmYWNlIENsZWFySW5kaWNhdG9yUHJvcHM8XG4gIE9wdGlvbiA9IHVua25vd24sXG4gIElzTXVsdGkgZXh0ZW5kcyBib29sZWFuID0gYm9vbGVhbixcbiAgR3JvdXAgZXh0ZW5kcyBHcm91cEJhc2U8T3B0aW9uPiA9IEdyb3VwQmFzZTxPcHRpb24+XG4+IGV4dGVuZHMgQ29tbW9uUHJvcHNBbmRDbGFzc05hbWU8T3B0aW9uLCBJc011bHRpLCBHcm91cD4ge1xuICAvKiogVGhlIGNoaWxkcmVuIHRvIGJlIHJlbmRlcmVkIGluc2lkZSB0aGUgaW5kaWNhdG9yLiAqL1xuICBjaGlsZHJlbj86IFJlYWN0Tm9kZTtcbiAgLyoqIFByb3BzIHRoYXQgd2lsbCBiZSBwYXNzZWQgb24gdG8gdGhlIGNoaWxkcmVuLiAqL1xuICBpbm5lclByb3BzOiBKU1guSW50cmluc2ljRWxlbWVudHNbJ2RpdiddO1xuICAvKiogVGhlIGZvY3VzZWQgc3RhdGUgb2YgdGhlIHNlbGVjdC4gKi9cbiAgaXNGb2N1c2VkOiBib29sZWFuO1xufVxuXG5leHBvcnQgY29uc3QgY2xlYXJJbmRpY2F0b3JDU1MgPSBiYXNlQ1NTO1xuZXhwb3J0IGNvbnN0IENsZWFySW5kaWNhdG9yID0gPFxuICBPcHRpb24sXG4gIElzTXVsdGkgZXh0ZW5kcyBib29sZWFuLFxuICBHcm91cCBleHRlbmRzIEdyb3VwQmFzZTxPcHRpb24+XG4+KFxuICBwcm9wczogQ2xlYXJJbmRpY2F0b3JQcm9wczxPcHRpb24sIElzTXVsdGksIEdyb3VwPlxuKSA9PiB7XG4gIGNvbnN0IHsgY2hpbGRyZW4sIGlubmVyUHJvcHMgfSA9IHByb3BzO1xuICByZXR1cm4gKFxuICAgIDxkaXZcbiAgICAgIHsuLi5nZXRTdHlsZVByb3BzKHByb3BzLCAnY2xlYXJJbmRpY2F0b3InLCB7XG4gICAgICAgIGluZGljYXRvcjogdHJ1ZSxcbiAgICAgICAgJ2NsZWFyLWluZGljYXRvcic6IHRydWUsXG4gICAgICB9KX1cbiAgICAgIHsuLi5pbm5lclByb3BzfVxuICAgID5cbiAgICAgIHtjaGlsZHJlbiB8fCA8Q3Jvc3NJY29uIC8+fVxuICAgIDwvZGl2PlxuICApO1xufTtcblxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyBTZXBhcmF0b3Jcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG5leHBvcnQgaW50ZXJmYWNlIEluZGljYXRvclNlcGFyYXRvclByb3BzPFxuICBPcHRpb24gPSB1bmtub3duLFxuICBJc011bHRpIGV4dGVuZHMgYm9vbGVhbiA9IGJvb2xlYW4sXG4gIEdyb3VwIGV4dGVuZHMgR3JvdXBCYXNlPE9wdGlvbj4gPSBHcm91cEJhc2U8T3B0aW9uPlxuPiBleHRlbmRzIENvbW1vblByb3BzQW5kQ2xhc3NOYW1lPE9wdGlvbiwgSXNNdWx0aSwgR3JvdXA+IHtcbiAgaXNEaXNhYmxlZDogYm9vbGVhbjtcbiAgaXNGb2N1c2VkOiBib29sZWFuO1xuICBpbm5lclByb3BzPzogSlNYLkludHJpbnNpY0VsZW1lbnRzWydzcGFuJ107XG59XG5cbmV4cG9ydCBjb25zdCBpbmRpY2F0b3JTZXBhcmF0b3JDU1MgPSA8XG4gIE9wdGlvbixcbiAgSXNNdWx0aSBleHRlbmRzIGJvb2xlYW4sXG4gIEdyb3VwIGV4dGVuZHMgR3JvdXBCYXNlPE9wdGlvbj5cbj4oXG4gIHtcbiAgICBpc0Rpc2FibGVkLFxuICAgIHRoZW1lOiB7XG4gICAgICBzcGFjaW5nOiB7IGJhc2VVbml0IH0sXG4gICAgICBjb2xvcnMsXG4gICAgfSxcbiAgfTogSW5kaWNhdG9yU2VwYXJhdG9yUHJvcHM8T3B0aW9uLCBJc011bHRpLCBHcm91cD4sXG4gIHVuc3R5bGVkOiBib29sZWFuXG4pOiBDU1NPYmplY3RXaXRoTGFiZWwgPT4gKHtcbiAgbGFiZWw6ICdpbmRpY2F0b3JTZXBhcmF0b3InLFxuICBhbGlnblNlbGY6ICdzdHJldGNoJyxcbiAgd2lkdGg6IDEsXG4gIC4uLih1bnN0eWxlZFxuICAgID8ge31cbiAgICA6IHtcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiBpc0Rpc2FibGVkID8gY29sb3JzLm5ldXRyYWwxMCA6IGNvbG9ycy5uZXV0cmFsMjAsXG4gICAgICAgIG1hcmdpbkJvdHRvbTogYmFzZVVuaXQgKiAyLFxuICAgICAgICBtYXJnaW5Ub3A6IGJhc2VVbml0ICogMixcbiAgICAgIH0pLFxufSk7XG5cbmV4cG9ydCBjb25zdCBJbmRpY2F0b3JTZXBhcmF0b3IgPSA8XG4gIE9wdGlvbixcbiAgSXNNdWx0aSBleHRlbmRzIGJvb2xlYW4sXG4gIEdyb3VwIGV4dGVuZHMgR3JvdXBCYXNlPE9wdGlvbj5cbj4oXG4gIHByb3BzOiBJbmRpY2F0b3JTZXBhcmF0b3JQcm9wczxPcHRpb24sIElzTXVsdGksIEdyb3VwPlxuKSA9PiB7XG4gIGNvbnN0IHsgaW5uZXJQcm9wcyB9ID0gcHJvcHM7XG4gIHJldHVybiAoXG4gICAgPHNwYW5cbiAgICAgIHsuLi5pbm5lclByb3BzfVxuICAgICAgey4uLmdldFN0eWxlUHJvcHMocHJvcHMsICdpbmRpY2F0b3JTZXBhcmF0b3InLCB7XG4gICAgICAgICdpbmRpY2F0b3Itc2VwYXJhdG9yJzogdHJ1ZSxcbiAgICAgIH0pfVxuICAgIC8+XG4gICk7XG59O1xuXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vIExvYWRpbmdcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG5jb25zdCBsb2FkaW5nRG90QW5pbWF0aW9ucyA9IGtleWZyYW1lc2BcbiAgMCUsIDgwJSwgMTAwJSB7IG9wYWNpdHk6IDA7IH1cbiAgNDAlIHsgb3BhY2l0eTogMTsgfVxuYDtcblxuZXhwb3J0IGNvbnN0IGxvYWRpbmdJbmRpY2F0b3JDU1MgPSA8XG4gIE9wdGlvbixcbiAgSXNNdWx0aSBleHRlbmRzIGJvb2xlYW4sXG4gIEdyb3VwIGV4dGVuZHMgR3JvdXBCYXNlPE9wdGlvbj5cbj4oXG4gIHtcbiAgICBpc0ZvY3VzZWQsXG4gICAgc2l6ZSxcbiAgICB0aGVtZToge1xuICAgICAgY29sb3JzLFxuICAgICAgc3BhY2luZzogeyBiYXNlVW5pdCB9LFxuICAgIH0sXG4gIH06IExvYWRpbmdJbmRpY2F0b3JQcm9wczxPcHRpb24sIElzTXVsdGksIEdyb3VwPixcbiAgdW5zdHlsZWQ6IGJvb2xlYW5cbik6IENTU09iamVjdFdpdGhMYWJlbCA9PiAoe1xuICBsYWJlbDogJ2xvYWRpbmdJbmRpY2F0b3InLFxuICBkaXNwbGF5OiAnZmxleCcsXG4gIHRyYW5zaXRpb246ICdjb2xvciAxNTBtcycsXG4gIGFsaWduU2VsZjogJ2NlbnRlcicsXG4gIGZvbnRTaXplOiBzaXplLFxuICBsaW5lSGVpZ2h0OiAxLFxuICBtYXJnaW5SaWdodDogc2l6ZSxcbiAgdGV4dEFsaWduOiAnY2VudGVyJyxcbiAgdmVydGljYWxBbGlnbjogJ21pZGRsZScsXG4gIC4uLih1bnN0eWxlZFxuICAgID8ge31cbiAgICA6IHtcbiAgICAgICAgY29sb3I6IGlzRm9jdXNlZCA/IGNvbG9ycy5uZXV0cmFsNjAgOiBjb2xvcnMubmV1dHJhbDIwLFxuICAgICAgICBwYWRkaW5nOiBiYXNlVW5pdCAqIDIsXG4gICAgICB9KSxcbn0pO1xuXG5pbnRlcmZhY2UgTG9hZGluZ0RvdFByb3BzIHtcbiAgZGVsYXk6IG51bWJlcjtcbiAgb2Zmc2V0OiBib29sZWFuO1xufVxuY29uc3QgTG9hZGluZ0RvdCA9ICh7IGRlbGF5LCBvZmZzZXQgfTogTG9hZGluZ0RvdFByb3BzKSA9PiAoXG4gIDxzcGFuXG4gICAgY3NzPXt7XG4gICAgICBhbmltYXRpb246IGAke2xvYWRpbmdEb3RBbmltYXRpb25zfSAxcyBlYXNlLWluLW91dCAke2RlbGF5fW1zIGluZmluaXRlO2AsXG4gICAgICBiYWNrZ3JvdW5kQ29sb3I6ICdjdXJyZW50Q29sb3InLFxuICAgICAgYm9yZGVyUmFkaXVzOiAnMWVtJyxcbiAgICAgIGRpc3BsYXk6ICdpbmxpbmUtYmxvY2snLFxuICAgICAgbWFyZ2luTGVmdDogb2Zmc2V0ID8gJzFlbScgOiB1bmRlZmluZWQsXG4gICAgICBoZWlnaHQ6ICcxZW0nLFxuICAgICAgdmVydGljYWxBbGlnbjogJ3RvcCcsXG4gICAgICB3aWR0aDogJzFlbScsXG4gICAgfX1cbiAgLz5cbik7XG5cbmV4cG9ydCBpbnRlcmZhY2UgTG9hZGluZ0luZGljYXRvclByb3BzPFxuICBPcHRpb24gPSB1bmtub3duLFxuICBJc011bHRpIGV4dGVuZHMgYm9vbGVhbiA9IGJvb2xlYW4sXG4gIEdyb3VwIGV4dGVuZHMgR3JvdXBCYXNlPE9wdGlvbj4gPSBHcm91cEJhc2U8T3B0aW9uPlxuPiBleHRlbmRzIENvbW1vblByb3BzQW5kQ2xhc3NOYW1lPE9wdGlvbiwgSXNNdWx0aSwgR3JvdXA+IHtcbiAgLyoqIFByb3BzIHRoYXQgd2lsbCBiZSBwYXNzZWQgb24gdG8gdGhlIGNoaWxkcmVuLiAqL1xuICBpbm5lclByb3BzOiBKU1guSW50cmluc2ljRWxlbWVudHNbJ2RpdiddO1xuICAvKiogVGhlIGZvY3VzZWQgc3RhdGUgb2YgdGhlIHNlbGVjdC4gKi9cbiAgaXNGb2N1c2VkOiBib29sZWFuO1xuICBpc0Rpc2FibGVkOiBib29sZWFuO1xuICAvKiogU2V0IHNpemUgb2YgdGhlIGNvbnRhaW5lci4gKi9cbiAgc2l6ZTogbnVtYmVyO1xufVxuZXhwb3J0IGNvbnN0IExvYWRpbmdJbmRpY2F0b3IgPSA8XG4gIE9wdGlvbixcbiAgSXNNdWx0aSBleHRlbmRzIGJvb2xlYW4sXG4gIEdyb3VwIGV4dGVuZHMgR3JvdXBCYXNlPE9wdGlvbj5cbj4oe1xuICBpbm5lclByb3BzLFxuICBpc1J0bCxcbiAgc2l6ZSA9IDQsXG4gIC4uLnJlc3RQcm9wc1xufTogTG9hZGluZ0luZGljYXRvclByb3BzPE9wdGlvbiwgSXNNdWx0aSwgR3JvdXA+KSA9PiB7XG4gIHJldHVybiAoXG4gICAgPGRpdlxuICAgICAgey4uLmdldFN0eWxlUHJvcHMoXG4gICAgICAgIHsgLi4ucmVzdFByb3BzLCBpbm5lclByb3BzLCBpc1J0bCwgc2l6ZSB9LFxuICAgICAgICAnbG9hZGluZ0luZGljYXRvcicsXG4gICAgICAgIHtcbiAgICAgICAgICBpbmRpY2F0b3I6IHRydWUsXG4gICAgICAgICAgJ2xvYWRpbmctaW5kaWNhdG9yJzogdHJ1ZSxcbiAgICAgICAgfVxuICAgICAgKX1cbiAgICAgIHsuLi5pbm5lclByb3BzfVxuICAgID5cbiAgICAgIDxMb2FkaW5nRG90IGRlbGF5PXswfSBvZmZzZXQ9e2lzUnRsfSAvPlxuICAgICAgPExvYWRpbmdEb3QgZGVsYXk9ezE2MH0gb2Zmc2V0IC8+XG4gICAgICA8TG9hZGluZ0RvdCBkZWxheT17MzIwfSBvZmZzZXQ9eyFpc1J0bH0gLz5cbiAgICA8L2Rpdj5cbiAgKTtcbn07XG4iXX0= */",
  toString: qw
}, hb = function(t) {
  var n = t.size, r = tr(t, Yw);
  return ge("svg", ye({
    height: n,
    width: n,
    viewBox: "0 0 20 20",
    "aria-hidden": "true",
    focusable: "false",
    css: Kw
  }, r));
}, qd = function(t) {
  return ge(hb, ye({
    size: 20
  }, t), ge("path", {
    d: "M14.348 14.849c-0.469 0.469-1.229 0.469-1.697 0l-2.651-3.030-2.651 3.029c-0.469 0.469-1.229 0.469-1.697 0-0.469-0.469-0.469-1.229 0-1.697l2.758-3.15-2.759-3.152c-0.469-0.469-0.469-1.228 0-1.697s1.228-0.469 1.697 0l2.652 3.031 2.651-3.031c0.469-0.469 1.228-0.469 1.697 0s0.469 1.229 0 1.697l-2.758 3.152 2.758 3.15c0.469 0.469 0.469 1.229 0 1.698z"
  }));
}, gb = function(t) {
  return ge(hb, ye({
    size: 20
  }, t), ge("path", {
    d: "M4.516 7.548c0.436-0.446 1.043-0.481 1.576 0l3.908 3.747 3.908-3.747c0.533-0.481 1.141-0.446 1.574 0 0.436 0.445 0.408 1.197 0 1.615-0.406 0.418-4.695 4.502-4.695 4.502-0.217 0.223-0.502 0.335-0.787 0.335s-0.57-0.112-0.789-0.335c0 0-4.287-4.084-4.695-4.502s-0.436-1.17 0-1.615z"
  }));
}, mb = function(t, n) {
  var r = t.isFocused, i = t.theme, a = i.spacing.baseUnit, s = i.colors;
  return pe({
    label: "indicatorContainer",
    display: "flex",
    transition: "color 150ms"
  }, n ? {} : {
    color: r ? s.neutral60 : s.neutral20,
    padding: a * 2,
    ":hover": {
      color: r ? s.neutral80 : s.neutral40
    }
  });
}, Qw = mb, eC = function(t) {
  var n = t.children, r = t.innerProps;
  return ge("div", ye({}, gt(t, "dropdownIndicator", {
    indicator: !0,
    "dropdown-indicator": !0
  }), r), n || ge(gb, null));
}, tC = mb, nC = function(t) {
  var n = t.children, r = t.innerProps;
  return ge("div", ye({}, gt(t, "clearIndicator", {
    indicator: !0,
    "clear-indicator": !0
  }), r), n || ge(qd, null));
}, rC = function(t, n) {
  var r = t.isDisabled, i = t.theme, a = i.spacing.baseUnit, s = i.colors;
  return pe({
    label: "indicatorSeparator",
    alignSelf: "stretch",
    width: 1
  }, n ? {} : {
    backgroundColor: r ? s.neutral10 : s.neutral20,
    marginBottom: a * 2,
    marginTop: a * 2
  });
}, iC = function(t) {
  var n = t.innerProps;
  return ge("span", ye({}, n, gt(t, "indicatorSeparator", {
    "indicator-separator": !0
  })));
}, aC = K1(Xp || (Xp = Q1([`
  0%, 80%, 100% { opacity: 0; }
  40% { opacity: 1; }
`]))), sC = function(t, n) {
  var r = t.isFocused, i = t.size, a = t.theme, s = a.colors, o = a.spacing.baseUnit;
  return pe({
    label: "loadingIndicator",
    display: "flex",
    transition: "color 150ms",
    alignSelf: "center",
    fontSize: i,
    lineHeight: 1,
    marginRight: i,
    textAlign: "center",
    verticalAlign: "middle"
  }, n ? {} : {
    color: r ? s.neutral60 : s.neutral20,
    padding: o * 2
  });
}, Pc = function(t) {
  var n = t.delay, r = t.offset;
  return ge("span", {
    css: /* @__PURE__ */ $d({
      animation: "".concat(aC, " 1s ease-in-out ").concat(n, "ms infinite;"),
      backgroundColor: "currentColor",
      borderRadius: "1em",
      display: "inline-block",
      marginLeft: r ? "1em" : void 0,
      height: "1em",
      verticalAlign: "top",
      width: "1em"
    }, process.env.NODE_ENV === "production" ? "" : ";label:LoadingDot;", process.env.NODE_ENV === "production" ? "" : "/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImluZGljYXRvcnMudHN4Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQW1RSSIsImZpbGUiOiJpbmRpY2F0b3JzLnRzeCIsInNvdXJjZXNDb250ZW50IjpbIi8qKiBAanN4IGpzeCAqL1xuaW1wb3J0IHsgSlNYLCBSZWFjdE5vZGUgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBqc3gsIGtleWZyYW1lcyB9IGZyb20gJ0BlbW90aW9uL3JlYWN0JztcblxuaW1wb3J0IHtcbiAgQ29tbW9uUHJvcHNBbmRDbGFzc05hbWUsXG4gIENTU09iamVjdFdpdGhMYWJlbCxcbiAgR3JvdXBCYXNlLFxufSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQgeyBnZXRTdHlsZVByb3BzIH0gZnJvbSAnLi4vdXRpbHMnO1xuXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vIERyb3Bkb3duICYgQ2xlYXIgSWNvbnNcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG5jb25zdCBTdmcgPSAoe1xuICBzaXplLFxuICAuLi5wcm9wc1xufTogSlNYLkludHJpbnNpY0VsZW1lbnRzWydzdmcnXSAmIHsgc2l6ZTogbnVtYmVyIH0pID0+IChcbiAgPHN2Z1xuICAgIGhlaWdodD17c2l6ZX1cbiAgICB3aWR0aD17c2l6ZX1cbiAgICB2aWV3Qm94PVwiMCAwIDIwIDIwXCJcbiAgICBhcmlhLWhpZGRlbj1cInRydWVcIlxuICAgIGZvY3VzYWJsZT1cImZhbHNlXCJcbiAgICBjc3M9e3tcbiAgICAgIGRpc3BsYXk6ICdpbmxpbmUtYmxvY2snLFxuICAgICAgZmlsbDogJ2N1cnJlbnRDb2xvcicsXG4gICAgICBsaW5lSGVpZ2h0OiAxLFxuICAgICAgc3Ryb2tlOiAnY3VycmVudENvbG9yJyxcbiAgICAgIHN0cm9rZVdpZHRoOiAwLFxuICAgIH19XG4gICAgey4uLnByb3BzfVxuICAvPlxuKTtcblxuZXhwb3J0IHR5cGUgQ3Jvc3NJY29uUHJvcHMgPSBKU1guSW50cmluc2ljRWxlbWVudHNbJ3N2ZyddICYgeyBzaXplPzogbnVtYmVyIH07XG5leHBvcnQgY29uc3QgQ3Jvc3NJY29uID0gKHByb3BzOiBDcm9zc0ljb25Qcm9wcykgPT4gKFxuICA8U3ZnIHNpemU9ezIwfSB7Li4ucHJvcHN9PlxuICAgIDxwYXRoIGQ9XCJNMTQuMzQ4IDE0Ljg0OWMtMC40NjkgMC40NjktMS4yMjkgMC40NjktMS42OTcgMGwtMi42NTEtMy4wMzAtMi42NTEgMy4wMjljLTAuNDY5IDAuNDY5LTEuMjI5IDAuNDY5LTEuNjk3IDAtMC40NjktMC40NjktMC40NjktMS4yMjkgMC0xLjY5N2wyLjc1OC0zLjE1LTIuNzU5LTMuMTUyYy0wLjQ2OS0wLjQ2OS0wLjQ2OS0xLjIyOCAwLTEuNjk3czEuMjI4LTAuNDY5IDEuNjk3IDBsMi42NTIgMy4wMzEgMi42NTEtMy4wMzFjMC40NjktMC40NjkgMS4yMjgtMC40NjkgMS42OTcgMHMwLjQ2OSAxLjIyOSAwIDEuNjk3bC0yLjc1OCAzLjE1MiAyLjc1OCAzLjE1YzAuNDY5IDAuNDY5IDAuNDY5IDEuMjI5IDAgMS42OTh6XCIgLz5cbiAgPC9Tdmc+XG4pO1xuZXhwb3J0IHR5cGUgRG93bkNoZXZyb25Qcm9wcyA9IEpTWC5JbnRyaW5zaWNFbGVtZW50c1snc3ZnJ10gJiB7IHNpemU/OiBudW1iZXIgfTtcbmV4cG9ydCBjb25zdCBEb3duQ2hldnJvbiA9IChwcm9wczogRG93bkNoZXZyb25Qcm9wcykgPT4gKFxuICA8U3ZnIHNpemU9ezIwfSB7Li4ucHJvcHN9PlxuICAgIDxwYXRoIGQ9XCJNNC41MTYgNy41NDhjMC40MzYtMC40NDYgMS4wNDMtMC40ODEgMS41NzYgMGwzLjkwOCAzLjc0NyAzLjkwOC0zLjc0N2MwLjUzMy0wLjQ4MSAxLjE0MS0wLjQ0NiAxLjU3NCAwIDAuNDM2IDAuNDQ1IDAuNDA4IDEuMTk3IDAgMS42MTUtMC40MDYgMC40MTgtNC42OTUgNC41MDItNC42OTUgNC41MDItMC4yMTcgMC4yMjMtMC41MDIgMC4zMzUtMC43ODcgMC4zMzVzLTAuNTctMC4xMTItMC43ODktMC4zMzVjMCAwLTQuMjg3LTQuMDg0LTQuNjk1LTQuNTAycy0wLjQzNi0xLjE3IDAtMS42MTV6XCIgLz5cbiAgPC9Tdmc+XG4pO1xuXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vIERyb3Bkb3duICYgQ2xlYXIgQnV0dG9uc1xuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbmV4cG9ydCBpbnRlcmZhY2UgRHJvcGRvd25JbmRpY2F0b3JQcm9wczxcbiAgT3B0aW9uID0gdW5rbm93bixcbiAgSXNNdWx0aSBleHRlbmRzIGJvb2xlYW4gPSBib29sZWFuLFxuICBHcm91cCBleHRlbmRzIEdyb3VwQmFzZTxPcHRpb24+ID0gR3JvdXBCYXNlPE9wdGlvbj5cbj4gZXh0ZW5kcyBDb21tb25Qcm9wc0FuZENsYXNzTmFtZTxPcHRpb24sIElzTXVsdGksIEdyb3VwPiB7XG4gIC8qKiBUaGUgY2hpbGRyZW4gdG8gYmUgcmVuZGVyZWQgaW5zaWRlIHRoZSBpbmRpY2F0b3IuICovXG4gIGNoaWxkcmVuPzogUmVhY3ROb2RlO1xuICAvKiogUHJvcHMgdGhhdCB3aWxsIGJlIHBhc3NlZCBvbiB0byB0aGUgY2hpbGRyZW4uICovXG4gIGlubmVyUHJvcHM6IEpTWC5JbnRyaW5zaWNFbGVtZW50c1snZGl2J107XG4gIC8qKiBUaGUgZm9jdXNlZCBzdGF0ZSBvZiB0aGUgc2VsZWN0LiAqL1xuICBpc0ZvY3VzZWQ6IGJvb2xlYW47XG4gIGlzRGlzYWJsZWQ6IGJvb2xlYW47XG59XG5cbmNvbnN0IGJhc2VDU1MgPSA8XG4gIE9wdGlvbixcbiAgSXNNdWx0aSBleHRlbmRzIGJvb2xlYW4sXG4gIEdyb3VwIGV4dGVuZHMgR3JvdXBCYXNlPE9wdGlvbj5cbj4oXG4gIHtcbiAgICBpc0ZvY3VzZWQsXG4gICAgdGhlbWU6IHtcbiAgICAgIHNwYWNpbmc6IHsgYmFzZVVuaXQgfSxcbiAgICAgIGNvbG9ycyxcbiAgICB9LFxuICB9OlxuICAgIHwgRHJvcGRvd25JbmRpY2F0b3JQcm9wczxPcHRpb24sIElzTXVsdGksIEdyb3VwPlxuICAgIHwgQ2xlYXJJbmRpY2F0b3JQcm9wczxPcHRpb24sIElzTXVsdGksIEdyb3VwPixcbiAgdW5zdHlsZWQ6IGJvb2xlYW5cbik6IENTU09iamVjdFdpdGhMYWJlbCA9PiAoe1xuICBsYWJlbDogJ2luZGljYXRvckNvbnRhaW5lcicsXG4gIGRpc3BsYXk6ICdmbGV4JyxcbiAgdHJhbnNpdGlvbjogJ2NvbG9yIDE1MG1zJyxcbiAgLi4uKHVuc3R5bGVkXG4gICAgPyB7fVxuICAgIDoge1xuICAgICAgICBjb2xvcjogaXNGb2N1c2VkID8gY29sb3JzLm5ldXRyYWw2MCA6IGNvbG9ycy5uZXV0cmFsMjAsXG4gICAgICAgIHBhZGRpbmc6IGJhc2VVbml0ICogMixcbiAgICAgICAgJzpob3Zlcic6IHtcbiAgICAgICAgICBjb2xvcjogaXNGb2N1c2VkID8gY29sb3JzLm5ldXRyYWw4MCA6IGNvbG9ycy5uZXV0cmFsNDAsXG4gICAgICAgIH0sXG4gICAgICB9KSxcbn0pO1xuXG5leHBvcnQgY29uc3QgZHJvcGRvd25JbmRpY2F0b3JDU1MgPSBiYXNlQ1NTO1xuZXhwb3J0IGNvbnN0IERyb3Bkb3duSW5kaWNhdG9yID0gPFxuICBPcHRpb24sXG4gIElzTXVsdGkgZXh0ZW5kcyBib29sZWFuLFxuICBHcm91cCBleHRlbmRzIEdyb3VwQmFzZTxPcHRpb24+XG4+KFxuICBwcm9wczogRHJvcGRvd25JbmRpY2F0b3JQcm9wczxPcHRpb24sIElzTXVsdGksIEdyb3VwPlxuKSA9PiB7XG4gIGNvbnN0IHsgY2hpbGRyZW4sIGlubmVyUHJvcHMgfSA9IHByb3BzO1xuICByZXR1cm4gKFxuICAgIDxkaXZcbiAgICAgIHsuLi5nZXRTdHlsZVByb3BzKHByb3BzLCAnZHJvcGRvd25JbmRpY2F0b3InLCB7XG4gICAgICAgIGluZGljYXRvcjogdHJ1ZSxcbiAgICAgICAgJ2Ryb3Bkb3duLWluZGljYXRvcic6IHRydWUsXG4gICAgICB9KX1cbiAgICAgIHsuLi5pbm5lclByb3BzfVxuICAgID5cbiAgICAgIHtjaGlsZHJlbiB8fCA8RG93bkNoZXZyb24gLz59XG4gICAgPC9kaXY+XG4gICk7XG59O1xuXG5leHBvcnQgaW50ZXJmYWNlIENsZWFySW5kaWNhdG9yUHJvcHM8XG4gIE9wdGlvbiA9IHVua25vd24sXG4gIElzTXVsdGkgZXh0ZW5kcyBib29sZWFuID0gYm9vbGVhbixcbiAgR3JvdXAgZXh0ZW5kcyBHcm91cEJhc2U8T3B0aW9uPiA9IEdyb3VwQmFzZTxPcHRpb24+XG4+IGV4dGVuZHMgQ29tbW9uUHJvcHNBbmRDbGFzc05hbWU8T3B0aW9uLCBJc011bHRpLCBHcm91cD4ge1xuICAvKiogVGhlIGNoaWxkcmVuIHRvIGJlIHJlbmRlcmVkIGluc2lkZSB0aGUgaW5kaWNhdG9yLiAqL1xuICBjaGlsZHJlbj86IFJlYWN0Tm9kZTtcbiAgLyoqIFByb3BzIHRoYXQgd2lsbCBiZSBwYXNzZWQgb24gdG8gdGhlIGNoaWxkcmVuLiAqL1xuICBpbm5lclByb3BzOiBKU1guSW50cmluc2ljRWxlbWVudHNbJ2RpdiddO1xuICAvKiogVGhlIGZvY3VzZWQgc3RhdGUgb2YgdGhlIHNlbGVjdC4gKi9cbiAgaXNGb2N1c2VkOiBib29sZWFuO1xufVxuXG5leHBvcnQgY29uc3QgY2xlYXJJbmRpY2F0b3JDU1MgPSBiYXNlQ1NTO1xuZXhwb3J0IGNvbnN0IENsZWFySW5kaWNhdG9yID0gPFxuICBPcHRpb24sXG4gIElzTXVsdGkgZXh0ZW5kcyBib29sZWFuLFxuICBHcm91cCBleHRlbmRzIEdyb3VwQmFzZTxPcHRpb24+XG4+KFxuICBwcm9wczogQ2xlYXJJbmRpY2F0b3JQcm9wczxPcHRpb24sIElzTXVsdGksIEdyb3VwPlxuKSA9PiB7XG4gIGNvbnN0IHsgY2hpbGRyZW4sIGlubmVyUHJvcHMgfSA9IHByb3BzO1xuICByZXR1cm4gKFxuICAgIDxkaXZcbiAgICAgIHsuLi5nZXRTdHlsZVByb3BzKHByb3BzLCAnY2xlYXJJbmRpY2F0b3InLCB7XG4gICAgICAgIGluZGljYXRvcjogdHJ1ZSxcbiAgICAgICAgJ2NsZWFyLWluZGljYXRvcic6IHRydWUsXG4gICAgICB9KX1cbiAgICAgIHsuLi5pbm5lclByb3BzfVxuICAgID5cbiAgICAgIHtjaGlsZHJlbiB8fCA8Q3Jvc3NJY29uIC8+fVxuICAgIDwvZGl2PlxuICApO1xufTtcblxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyBTZXBhcmF0b3Jcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG5leHBvcnQgaW50ZXJmYWNlIEluZGljYXRvclNlcGFyYXRvclByb3BzPFxuICBPcHRpb24gPSB1bmtub3duLFxuICBJc011bHRpIGV4dGVuZHMgYm9vbGVhbiA9IGJvb2xlYW4sXG4gIEdyb3VwIGV4dGVuZHMgR3JvdXBCYXNlPE9wdGlvbj4gPSBHcm91cEJhc2U8T3B0aW9uPlxuPiBleHRlbmRzIENvbW1vblByb3BzQW5kQ2xhc3NOYW1lPE9wdGlvbiwgSXNNdWx0aSwgR3JvdXA+IHtcbiAgaXNEaXNhYmxlZDogYm9vbGVhbjtcbiAgaXNGb2N1c2VkOiBib29sZWFuO1xuICBpbm5lclByb3BzPzogSlNYLkludHJpbnNpY0VsZW1lbnRzWydzcGFuJ107XG59XG5cbmV4cG9ydCBjb25zdCBpbmRpY2F0b3JTZXBhcmF0b3JDU1MgPSA8XG4gIE9wdGlvbixcbiAgSXNNdWx0aSBleHRlbmRzIGJvb2xlYW4sXG4gIEdyb3VwIGV4dGVuZHMgR3JvdXBCYXNlPE9wdGlvbj5cbj4oXG4gIHtcbiAgICBpc0Rpc2FibGVkLFxuICAgIHRoZW1lOiB7XG4gICAgICBzcGFjaW5nOiB7IGJhc2VVbml0IH0sXG4gICAgICBjb2xvcnMsXG4gICAgfSxcbiAgfTogSW5kaWNhdG9yU2VwYXJhdG9yUHJvcHM8T3B0aW9uLCBJc011bHRpLCBHcm91cD4sXG4gIHVuc3R5bGVkOiBib29sZWFuXG4pOiBDU1NPYmplY3RXaXRoTGFiZWwgPT4gKHtcbiAgbGFiZWw6ICdpbmRpY2F0b3JTZXBhcmF0b3InLFxuICBhbGlnblNlbGY6ICdzdHJldGNoJyxcbiAgd2lkdGg6IDEsXG4gIC4uLih1bnN0eWxlZFxuICAgID8ge31cbiAgICA6IHtcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiBpc0Rpc2FibGVkID8gY29sb3JzLm5ldXRyYWwxMCA6IGNvbG9ycy5uZXV0cmFsMjAsXG4gICAgICAgIG1hcmdpbkJvdHRvbTogYmFzZVVuaXQgKiAyLFxuICAgICAgICBtYXJnaW5Ub3A6IGJhc2VVbml0ICogMixcbiAgICAgIH0pLFxufSk7XG5cbmV4cG9ydCBjb25zdCBJbmRpY2F0b3JTZXBhcmF0b3IgPSA8XG4gIE9wdGlvbixcbiAgSXNNdWx0aSBleHRlbmRzIGJvb2xlYW4sXG4gIEdyb3VwIGV4dGVuZHMgR3JvdXBCYXNlPE9wdGlvbj5cbj4oXG4gIHByb3BzOiBJbmRpY2F0b3JTZXBhcmF0b3JQcm9wczxPcHRpb24sIElzTXVsdGksIEdyb3VwPlxuKSA9PiB7XG4gIGNvbnN0IHsgaW5uZXJQcm9wcyB9ID0gcHJvcHM7XG4gIHJldHVybiAoXG4gICAgPHNwYW5cbiAgICAgIHsuLi5pbm5lclByb3BzfVxuICAgICAgey4uLmdldFN0eWxlUHJvcHMocHJvcHMsICdpbmRpY2F0b3JTZXBhcmF0b3InLCB7XG4gICAgICAgICdpbmRpY2F0b3Itc2VwYXJhdG9yJzogdHJ1ZSxcbiAgICAgIH0pfVxuICAgIC8+XG4gICk7XG59O1xuXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vIExvYWRpbmdcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG5jb25zdCBsb2FkaW5nRG90QW5pbWF0aW9ucyA9IGtleWZyYW1lc2BcbiAgMCUsIDgwJSwgMTAwJSB7IG9wYWNpdHk6IDA7IH1cbiAgNDAlIHsgb3BhY2l0eTogMTsgfVxuYDtcblxuZXhwb3J0IGNvbnN0IGxvYWRpbmdJbmRpY2F0b3JDU1MgPSA8XG4gIE9wdGlvbixcbiAgSXNNdWx0aSBleHRlbmRzIGJvb2xlYW4sXG4gIEdyb3VwIGV4dGVuZHMgR3JvdXBCYXNlPE9wdGlvbj5cbj4oXG4gIHtcbiAgICBpc0ZvY3VzZWQsXG4gICAgc2l6ZSxcbiAgICB0aGVtZToge1xuICAgICAgY29sb3JzLFxuICAgICAgc3BhY2luZzogeyBiYXNlVW5pdCB9LFxuICAgIH0sXG4gIH06IExvYWRpbmdJbmRpY2F0b3JQcm9wczxPcHRpb24sIElzTXVsdGksIEdyb3VwPixcbiAgdW5zdHlsZWQ6IGJvb2xlYW5cbik6IENTU09iamVjdFdpdGhMYWJlbCA9PiAoe1xuICBsYWJlbDogJ2xvYWRpbmdJbmRpY2F0b3InLFxuICBkaXNwbGF5OiAnZmxleCcsXG4gIHRyYW5zaXRpb246ICdjb2xvciAxNTBtcycsXG4gIGFsaWduU2VsZjogJ2NlbnRlcicsXG4gIGZvbnRTaXplOiBzaXplLFxuICBsaW5lSGVpZ2h0OiAxLFxuICBtYXJnaW5SaWdodDogc2l6ZSxcbiAgdGV4dEFsaWduOiAnY2VudGVyJyxcbiAgdmVydGljYWxBbGlnbjogJ21pZGRsZScsXG4gIC4uLih1bnN0eWxlZFxuICAgID8ge31cbiAgICA6IHtcbiAgICAgICAgY29sb3I6IGlzRm9jdXNlZCA/IGNvbG9ycy5uZXV0cmFsNjAgOiBjb2xvcnMubmV1dHJhbDIwLFxuICAgICAgICBwYWRkaW5nOiBiYXNlVW5pdCAqIDIsXG4gICAgICB9KSxcbn0pO1xuXG5pbnRlcmZhY2UgTG9hZGluZ0RvdFByb3BzIHtcbiAgZGVsYXk6IG51bWJlcjtcbiAgb2Zmc2V0OiBib29sZWFuO1xufVxuY29uc3QgTG9hZGluZ0RvdCA9ICh7IGRlbGF5LCBvZmZzZXQgfTogTG9hZGluZ0RvdFByb3BzKSA9PiAoXG4gIDxzcGFuXG4gICAgY3NzPXt7XG4gICAgICBhbmltYXRpb246IGAke2xvYWRpbmdEb3RBbmltYXRpb25zfSAxcyBlYXNlLWluLW91dCAke2RlbGF5fW1zIGluZmluaXRlO2AsXG4gICAgICBiYWNrZ3JvdW5kQ29sb3I6ICdjdXJyZW50Q29sb3InLFxuICAgICAgYm9yZGVyUmFkaXVzOiAnMWVtJyxcbiAgICAgIGRpc3BsYXk6ICdpbmxpbmUtYmxvY2snLFxuICAgICAgbWFyZ2luTGVmdDogb2Zmc2V0ID8gJzFlbScgOiB1bmRlZmluZWQsXG4gICAgICBoZWlnaHQ6ICcxZW0nLFxuICAgICAgdmVydGljYWxBbGlnbjogJ3RvcCcsXG4gICAgICB3aWR0aDogJzFlbScsXG4gICAgfX1cbiAgLz5cbik7XG5cbmV4cG9ydCBpbnRlcmZhY2UgTG9hZGluZ0luZGljYXRvclByb3BzPFxuICBPcHRpb24gPSB1bmtub3duLFxuICBJc011bHRpIGV4dGVuZHMgYm9vbGVhbiA9IGJvb2xlYW4sXG4gIEdyb3VwIGV4dGVuZHMgR3JvdXBCYXNlPE9wdGlvbj4gPSBHcm91cEJhc2U8T3B0aW9uPlxuPiBleHRlbmRzIENvbW1vblByb3BzQW5kQ2xhc3NOYW1lPE9wdGlvbiwgSXNNdWx0aSwgR3JvdXA+IHtcbiAgLyoqIFByb3BzIHRoYXQgd2lsbCBiZSBwYXNzZWQgb24gdG8gdGhlIGNoaWxkcmVuLiAqL1xuICBpbm5lclByb3BzOiBKU1guSW50cmluc2ljRWxlbWVudHNbJ2RpdiddO1xuICAvKiogVGhlIGZvY3VzZWQgc3RhdGUgb2YgdGhlIHNlbGVjdC4gKi9cbiAgaXNGb2N1c2VkOiBib29sZWFuO1xuICBpc0Rpc2FibGVkOiBib29sZWFuO1xuICAvKiogU2V0IHNpemUgb2YgdGhlIGNvbnRhaW5lci4gKi9cbiAgc2l6ZTogbnVtYmVyO1xufVxuZXhwb3J0IGNvbnN0IExvYWRpbmdJbmRpY2F0b3IgPSA8XG4gIE9wdGlvbixcbiAgSXNNdWx0aSBleHRlbmRzIGJvb2xlYW4sXG4gIEdyb3VwIGV4dGVuZHMgR3JvdXBCYXNlPE9wdGlvbj5cbj4oe1xuICBpbm5lclByb3BzLFxuICBpc1J0bCxcbiAgc2l6ZSA9IDQsXG4gIC4uLnJlc3RQcm9wc1xufTogTG9hZGluZ0luZGljYXRvclByb3BzPE9wdGlvbiwgSXNNdWx0aSwgR3JvdXA+KSA9PiB7XG4gIHJldHVybiAoXG4gICAgPGRpdlxuICAgICAgey4uLmdldFN0eWxlUHJvcHMoXG4gICAgICAgIHsgLi4ucmVzdFByb3BzLCBpbm5lclByb3BzLCBpc1J0bCwgc2l6ZSB9LFxuICAgICAgICAnbG9hZGluZ0luZGljYXRvcicsXG4gICAgICAgIHtcbiAgICAgICAgICBpbmRpY2F0b3I6IHRydWUsXG4gICAgICAgICAgJ2xvYWRpbmctaW5kaWNhdG9yJzogdHJ1ZSxcbiAgICAgICAgfVxuICAgICAgKX1cbiAgICAgIHsuLi5pbm5lclByb3BzfVxuICAgID5cbiAgICAgIDxMb2FkaW5nRG90IGRlbGF5PXswfSBvZmZzZXQ9e2lzUnRsfSAvPlxuICAgICAgPExvYWRpbmdEb3QgZGVsYXk9ezE2MH0gb2Zmc2V0IC8+XG4gICAgICA8TG9hZGluZ0RvdCBkZWxheT17MzIwfSBvZmZzZXQ9eyFpc1J0bH0gLz5cbiAgICA8L2Rpdj5cbiAgKTtcbn07XG4iXX0= */")
  });
}, oC = function(t) {
  var n = t.innerProps, r = t.isRtl, i = t.size, a = i === void 0 ? 4 : i, s = tr(t, Jw);
  return ge("div", ye({}, gt(pe(pe({}, s), {}, {
    innerProps: n,
    isRtl: r,
    size: a
  }), "loadingIndicator", {
    indicator: !0,
    "loading-indicator": !0
  }), n), ge(Pc, {
    delay: 0,
    offset: r
  }), ge(Pc, {
    delay: 160,
    offset: !0
  }), ge(Pc, {
    delay: 320,
    offset: !r
  }));
}, lC = function(t, n) {
  var r = t.isDisabled, i = t.isFocused, a = t.theme, s = a.colors, o = a.borderRadius, l = a.spacing;
  return pe({
    label: "control",
    alignItems: "center",
    cursor: "default",
    display: "flex",
    flexWrap: "wrap",
    justifyContent: "space-between",
    minHeight: l.controlHeight,
    outline: "0 !important",
    position: "relative",
    transition: "all 100ms"
  }, n ? {} : {
    backgroundColor: r ? s.neutral5 : s.neutral0,
    borderColor: r ? s.neutral10 : i ? s.primary : s.neutral20,
    borderRadius: o,
    borderStyle: "solid",
    borderWidth: 1,
    boxShadow: i ? "0 0 0 1px ".concat(s.primary) : void 0,
    "&:hover": {
      borderColor: i ? s.primary : s.neutral30
    }
  });
}, cC = function(t) {
  var n = t.children, r = t.isDisabled, i = t.isFocused, a = t.innerRef, s = t.innerProps, o = t.menuIsOpen;
  return ge("div", ye({
    ref: a
  }, gt(t, "control", {
    control: !0,
    "control--is-disabled": r,
    "control--is-focused": i,
    "control--menu-is-open": o
  }), s, {
    "aria-disabled": r || void 0
  }), n);
}, uC = cC, dC = ["data"], fC = function(t, n) {
  var r = t.theme.spacing;
  return n ? {} : {
    paddingBottom: r.baseUnit * 2,
    paddingTop: r.baseUnit * 2
  };
}, pC = function(t) {
  var n = t.children, r = t.cx, i = t.getStyles, a = t.getClassNames, s = t.Heading, o = t.headingProps, l = t.innerProps, c = t.label, u = t.theme, d = t.selectProps;
  return ge("div", ye({}, gt(t, "group", {
    group: !0
  }), l), ge(s, ye({}, o, {
    selectProps: d,
    theme: u,
    getStyles: i,
    getClassNames: a,
    cx: r
  }), c), ge("div", null, n));
}, hC = function(t, n) {
  var r = t.theme, i = r.colors, a = r.spacing;
  return pe({
    label: "group",
    cursor: "default",
    display: "block"
  }, n ? {} : {
    color: i.neutral40,
    fontSize: "75%",
    fontWeight: 500,
    marginBottom: "0.25em",
    paddingLeft: a.baseUnit * 3,
    paddingRight: a.baseUnit * 3,
    textTransform: "uppercase"
  });
}, gC = function(t) {
  var n = lb(t);
  n.data;
  var r = tr(n, dC);
  return ge("div", ye({}, gt(t, "groupHeading", {
    "group-heading": !0
  }), r));
}, mC = pC, bC = ["innerRef", "isDisabled", "isHidden", "inputClassName"], yC = function(t, n) {
  var r = t.isDisabled, i = t.value, a = t.theme, s = a.spacing, o = a.colors;
  return pe(pe({
    visibility: r ? "hidden" : "visible",
    // force css to recompute when value change due to @emotion bug.
    // We can remove it whenever the bug is fixed.
    transform: i ? "translateZ(0)" : ""
  }, _C), n ? {} : {
    margin: s.baseUnit / 2,
    paddingBottom: s.baseUnit / 2,
    paddingTop: s.baseUnit / 2,
    color: o.neutral80
  });
}, bb = {
  gridArea: "1 / 2",
  font: "inherit",
  minWidth: "2px",
  border: 0,
  margin: 0,
  outline: 0,
  padding: 0
}, _C = {
  flex: "1 1 auto",
  display: "inline-grid",
  gridArea: "1 / 1 / 2 / 3",
  gridTemplateColumns: "0 min-content",
  "&:after": pe({
    content: 'attr(data-value) " "',
    visibility: "hidden",
    whiteSpace: "pre"
  }, bb)
}, vC = function(t) {
  return pe({
    label: "input",
    color: "inherit",
    background: 0,
    opacity: t ? 0 : 1,
    width: "100%"
  }, bb);
}, xC = function(t) {
  var n = t.cx, r = t.value, i = lb(t), a = i.innerRef, s = i.isDisabled, o = i.isHidden, l = i.inputClassName, c = tr(i, bC);
  return ge("div", ye({}, gt(t, "input", {
    "input-container": !0
  }), {
    "data-value": r || ""
  }), ge("input", ye({
    className: n({
      input: !0
    }, l),
    ref: a,
    style: vC(o),
    disabled: s
  }, c)));
}, EC = xC, wC = function(t, n) {
  var r = t.theme, i = r.spacing, a = r.borderRadius, s = r.colors;
  return pe({
    label: "multiValue",
    display: "flex",
    minWidth: 0
  }, n ? {} : {
    backgroundColor: s.neutral10,
    borderRadius: a / 2,
    margin: i.baseUnit / 2
  });
}, CC = function(t, n) {
  var r = t.theme, i = r.borderRadius, a = r.colors, s = t.cropWithEllipsis;
  return pe({
    overflow: "hidden",
    textOverflow: s || s === void 0 ? "ellipsis" : void 0,
    whiteSpace: "nowrap"
  }, n ? {} : {
    borderRadius: i / 2,
    color: a.neutral80,
    fontSize: "85%",
    padding: 3,
    paddingLeft: 6
  });
}, IC = function(t, n) {
  var r = t.theme, i = r.spacing, a = r.borderRadius, s = r.colors, o = t.isFocused;
  return pe({
    alignItems: "center",
    display: "flex"
  }, n ? {} : {
    borderRadius: a / 2,
    backgroundColor: o ? s.dangerLight : void 0,
    paddingLeft: i.baseUnit,
    paddingRight: i.baseUnit,
    ":hover": {
      backgroundColor: s.dangerLight,
      color: s.danger
    }
  });
}, yb = function(t) {
  var n = t.children, r = t.innerProps;
  return ge("div", r, n);
}, SC = yb, AC = yb;
function kC(e) {
  var t = e.children, n = e.innerProps;
  return ge("div", ye({
    role: "button"
  }, n), t || ge(qd, {
    size: 14
  }));
}
var TC = function(t) {
  var n = t.children, r = t.components, i = t.data, a = t.innerProps, s = t.isDisabled, o = t.removeProps, l = t.selectProps, c = r.Container, u = r.Label, d = r.Remove;
  return ge(c, {
    data: i,
    innerProps: pe(pe({}, gt(t, "multiValue", {
      "multi-value": !0,
      "multi-value--is-disabled": s
    })), a),
    selectProps: l
  }, ge(u, {
    data: i,
    innerProps: pe({}, gt(t, "multiValueLabel", {
      "multi-value__label": !0
    })),
    selectProps: l
  }, n), ge(d, {
    data: i,
    innerProps: pe(pe({}, gt(t, "multiValueRemove", {
      "multi-value__remove": !0
    })), {}, {
      "aria-label": "Remove ".concat(n || "option")
    }, o),
    selectProps: l
  }));
}, RC = TC, NC = function(t, n) {
  var r = t.isDisabled, i = t.isFocused, a = t.isSelected, s = t.theme, o = s.spacing, l = s.colors;
  return pe({
    label: "option",
    cursor: "default",
    display: "block",
    fontSize: "inherit",
    width: "100%",
    userSelect: "none",
    WebkitTapHighlightColor: "rgba(0, 0, 0, 0)"
  }, n ? {} : {
    backgroundColor: a ? l.primary : i ? l.primary25 : "transparent",
    color: r ? l.neutral20 : a ? l.neutral0 : "inherit",
    padding: "".concat(o.baseUnit * 2, "px ").concat(o.baseUnit * 3, "px"),
    // provide some affordance on touch devices
    ":active": {
      backgroundColor: r ? void 0 : a ? l.primary : l.primary50
    }
  });
}, OC = function(t) {
  var n = t.children, r = t.isDisabled, i = t.isFocused, a = t.isSelected, s = t.innerRef, o = t.innerProps;
  return ge("div", ye({}, gt(t, "option", {
    option: !0,
    "option--is-disabled": r,
    "option--is-focused": i,
    "option--is-selected": a
  }), {
    ref: s,
    "aria-disabled": r
  }, o), n);
}, MC = OC, PC = function(t, n) {
  var r = t.theme, i = r.spacing, a = r.colors;
  return pe({
    label: "placeholder",
    gridArea: "1 / 1 / 2 / 3"
  }, n ? {} : {
    color: a.neutral50,
    marginLeft: i.baseUnit / 2,
    marginRight: i.baseUnit / 2
  });
}, DC = function(t) {
  var n = t.children, r = t.innerProps;
  return ge("div", ye({}, gt(t, "placeholder", {
    placeholder: !0
  }), r), n);
}, LC = DC, FC = function(t, n) {
  var r = t.isDisabled, i = t.theme, a = i.spacing, s = i.colors;
  return pe({
    label: "singleValue",
    gridArea: "1 / 1 / 2 / 3",
    maxWidth: "100%",
    overflow: "hidden",
    textOverflow: "ellipsis",
    whiteSpace: "nowrap"
  }, n ? {} : {
    color: r ? s.neutral40 : s.neutral80,
    marginLeft: a.baseUnit / 2,
    marginRight: a.baseUnit / 2
  });
}, BC = function(t) {
  var n = t.children, r = t.isDisabled, i = t.innerProps;
  return ge("div", ye({}, gt(t, "singleValue", {
    "single-value": !0,
    "single-value--is-disabled": r
  }), i), n);
}, zC = BC, VC = {
  ClearIndicator: nC,
  Control: uC,
  DropdownIndicator: eC,
  DownChevron: gb,
  CrossIcon: qd,
  Group: mC,
  GroupHeading: gC,
  IndicatorsContainer: Xw,
  IndicatorSeparator: iC,
  Input: EC,
  LoadingIndicator: oC,
  Menu: Pw,
  MenuList: Lw,
  MenuPortal: jw,
  LoadingMessage: Vw,
  NoOptionsMessage: zw,
  MultiValue: RC,
  MultiValueContainer: SC,
  MultiValueLabel: AC,
  MultiValueRemove: kC,
  Option: MC,
  Placeholder: LC,
  SelectContainer: Hw,
  SingleValue: zC,
  ValueContainer: Zw
}, GC = function(t) {
  return pe(pe({}, VC), t.components);
}, Yp = Number.isNaN || function(t) {
  return typeof t == "number" && t !== t;
};
function jC(e, t) {
  return !!(e === t || Yp(e) && Yp(t));
}
function UC(e, t) {
  if (e.length !== t.length)
    return !1;
  for (var n = 0; n < e.length; n++)
    if (!jC(e[n], t[n]))
      return !1;
  return !0;
}
function HC(e, t) {
  t === void 0 && (t = UC);
  var n = null;
  function r() {
    for (var i = [], a = 0; a < arguments.length; a++)
      i[a] = arguments[a];
    if (n && n.lastThis === this && t(i, n.lastArgs))
      return n.lastResult;
    var s = e.apply(this, i);
    return n = {
      lastResult: s,
      lastArgs: i,
      lastThis: this
    }, s;
  }
  return r.clear = function() {
    n = null;
  }, r;
}
function WC() {
  return "You have tried to stringify object returned from `css` function. It isn't supposed to be used directly (e.g. as value of the `className` prop), but rather handed to emotion so it can handle it (e.g. as value of `css` prop).";
}
var ZC = process.env.NODE_ENV === "production" ? {
  name: "7pg0cj-a11yText",
  styles: "label:a11yText;z-index:9999;border:0;clip:rect(1px, 1px, 1px, 1px);height:1px;width:1px;position:absolute;overflow:hidden;padding:0;white-space:nowrap"
} : {
  name: "1f43avz-a11yText-A11yText",
  styles: "label:a11yText;z-index:9999;border:0;clip:rect(1px, 1px, 1px, 1px);height:1px;width:1px;position:absolute;overflow:hidden;padding:0;white-space:nowrap;label:A11yText;",
  map: "/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkExMXlUZXh0LnRzeCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFPSSIsImZpbGUiOiJBMTF5VGV4dC50c3giLCJzb3VyY2VzQ29udGVudCI6WyIvKiogQGpzeCBqc3ggKi9cbmltcG9ydCB7IEpTWCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IGpzeCB9IGZyb20gJ0BlbW90aW9uL3JlYWN0JztcblxuLy8gQXNzaXN0aXZlIHRleHQgdG8gZGVzY3JpYmUgdmlzdWFsIGVsZW1lbnRzLiBIaWRkZW4gZm9yIHNpZ2h0ZWQgdXNlcnMuXG5jb25zdCBBMTF5VGV4dCA9IChwcm9wczogSlNYLkludHJpbnNpY0VsZW1lbnRzWydzcGFuJ10pID0+IChcbiAgPHNwYW5cbiAgICBjc3M9e3tcbiAgICAgIGxhYmVsOiAnYTExeVRleHQnLFxuICAgICAgekluZGV4OiA5OTk5LFxuICAgICAgYm9yZGVyOiAwLFxuICAgICAgY2xpcDogJ3JlY3QoMXB4LCAxcHgsIDFweCwgMXB4KScsXG4gICAgICBoZWlnaHQ6IDEsXG4gICAgICB3aWR0aDogMSxcbiAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgb3ZlcmZsb3c6ICdoaWRkZW4nLFxuICAgICAgcGFkZGluZzogMCxcbiAgICAgIHdoaXRlU3BhY2U6ICdub3dyYXAnLFxuICAgIH19XG4gICAgey4uLnByb3BzfVxuICAvPlxuKTtcblxuZXhwb3J0IGRlZmF1bHQgQTExeVRleHQ7XG4iXX0= */",
  toString: WC
}, $C = function(t) {
  return ge("span", ye({
    css: ZC
  }, t));
}, Jp = $C, XC = {
  guidance: function(t) {
    var n = t.isSearchable, r = t.isMulti, i = t.tabSelectsValue, a = t.context, s = t.isInitialFocus;
    switch (a) {
      case "menu":
        return "Use Up and Down to choose options, press Enter to select the currently focused option, press Escape to exit the menu".concat(i ? ", press Tab to select the option and exit the menu" : "", ".");
      case "input":
        return s ? "".concat(t["aria-label"] || "Select", " is focused ").concat(n ? ",type to refine list" : "", ", press Down to open the menu, ").concat(r ? " press left to focus selected values" : "") : "";
      case "value":
        return "Use left and right to toggle between focused values, press Backspace to remove the currently focused value";
      default:
        return "";
    }
  },
  onChange: function(t) {
    var n = t.action, r = t.label, i = r === void 0 ? "" : r, a = t.labels, s = t.isDisabled;
    switch (n) {
      case "deselect-option":
      case "pop-value":
      case "remove-value":
        return "option ".concat(i, ", deselected.");
      case "clear":
        return "All selected options have been cleared.";
      case "initial-input-focus":
        return "option".concat(a.length > 1 ? "s" : "", " ").concat(a.join(","), ", selected.");
      case "select-option":
        return s ? "option ".concat(i, " is disabled. Select another option.") : "option ".concat(i, ", selected.");
      default:
        return "";
    }
  },
  onFocus: function(t) {
    var n = t.context, r = t.focused, i = t.options, a = t.label, s = a === void 0 ? "" : a, o = t.selectValue, l = t.isDisabled, c = t.isSelected, u = t.isAppleDevice, d = function(g, m) {
      return g && g.length ? "".concat(g.indexOf(m) + 1, " of ").concat(g.length) : "";
    };
    if (n === "value" && o)
      return "value ".concat(s, " focused, ").concat(d(o, r), ".");
    if (n === "menu" && u) {
      var f = l ? " disabled" : "", p = "".concat(c ? " selected" : "").concat(f);
      return "".concat(s).concat(p, ", ").concat(d(i, r), ".");
    }
    return "";
  },
  onFilter: function(t) {
    var n = t.inputValue, r = t.resultsMessage;
    return "".concat(r).concat(n ? " for search term " + n : "", ".");
  }
}, YC = function(t) {
  var n = t.ariaSelection, r = t.focusedOption, i = t.focusedValue, a = t.focusableOptions, s = t.isFocused, o = t.selectValue, l = t.selectProps, c = t.id, u = t.isAppleDevice, d = l.ariaLiveMessages, f = l.getOptionLabel, p = l.inputValue, h = l.isMulti, g = l.isOptionDisabled, m = l.isSearchable, b = l.menuIsOpen, y = l.options, v = l.screenReaderStatus, E = l.tabSelectsValue, _ = l.isLoading, x = l["aria-label"], I = l["aria-live"], T = Nr(function() {
    return pe(pe({}, XC), d || {});
  }, [d]), O = Nr(function() {
    var U = "";
    if (n && T.onChange) {
      var $ = n.option, Q = n.options, K = n.removedValue, fe = n.removedValues, S = n.value, me = function(Be) {
        return Array.isArray(Be) ? null : Be;
      }, se = K || $ || me(S), A = se ? f(se) : "", ve = Q || fe || void 0, Te = ve ? ve.map(f) : [], Ce = pe({
        // multiSelected items are usually items that have already been selected
        // or set by the user as a default value so we assume they are not disabled
        isDisabled: se && g(se, o),
        label: A,
        labels: Te
      }, n);
      U = T.onChange(Ce);
    }
    return U;
  }, [n, T, g, o, f]), k = Nr(function() {
    var U = "", $ = r || i, Q = !!(r && o && o.includes(r));
    if ($ && T.onFocus) {
      var K = {
        focused: $,
        label: f($),
        isDisabled: g($, o),
        isSelected: Q,
        options: a,
        context: $ === r ? "menu" : "value",
        selectValue: o,
        isAppleDevice: u
      };
      U = T.onFocus(K);
    }
    return U;
  }, [r, i, f, g, T, a, o, u]), W = Nr(function() {
    var U = "";
    if (b && y.length && !_ && T.onFilter) {
      var $ = v({
        count: a.length
      });
      U = T.onFilter({
        inputValue: p,
        resultsMessage: $
      });
    }
    return U;
  }, [a, p, b, T, y, v, _]), M = (n == null ? void 0 : n.action) === "initial-input-focus", L = Nr(function() {
    var U = "";
    if (T.guidance) {
      var $ = i ? "value" : b ? "menu" : "input";
      U = T.guidance({
        "aria-label": x,
        context: $,
        isDisabled: r && g(r, o),
        isMulti: h,
        isSearchable: m,
        tabSelectsValue: E,
        isInitialFocus: M
      });
    }
    return U;
  }, [x, r, i, h, g, m, b, T, o, E, M]), z = ge(Tu, null, ge("span", {
    id: "aria-selection"
  }, O), ge("span", {
    id: "aria-focused"
  }, k), ge("span", {
    id: "aria-results"
  }, W), ge("span", {
    id: "aria-guidance"
  }, L));
  return ge(Tu, null, ge(Jp, {
    id: c
  }, M && z), ge(Jp, {
    "aria-live": I,
    "aria-atomic": "false",
    "aria-relevant": "additions text",
    role: "log"
  }, s && !M && z));
}, JC = YC, Uu = [{
  base: "A",
  letters: "A"
}, {
  base: "AA",
  letters: ""
}, {
  base: "AE",
  letters: ""
}, {
  base: "AO",
  letters: ""
}, {
  base: "AU",
  letters: ""
}, {
  base: "AV",
  letters: ""
}, {
  base: "AY",
  letters: ""
}, {
  base: "B",
  letters: "B"
}, {
  base: "C",
  letters: "C"
}, {
  base: "D",
  letters: "D"
}, {
  base: "DZ",
  letters: ""
}, {
  base: "Dz",
  letters: ""
}, {
  base: "E",
  letters: "E"
}, {
  base: "F",
  letters: "F"
}, {
  base: "G",
  letters: "G"
}, {
  base: "H",
  letters: "H"
}, {
  base: "I",
  letters: "I"
}, {
  base: "J",
  letters: "J"
}, {
  base: "K",
  letters: "K"
}, {
  base: "L",
  letters: "L"
}, {
  base: "LJ",
  letters: ""
}, {
  base: "Lj",
  letters: ""
}, {
  base: "M",
  letters: "M"
}, {
  base: "N",
  letters: "N"
}, {
  base: "NJ",
  letters: ""
}, {
  base: "Nj",
  letters: ""
}, {
  base: "O",
  letters: "O"
}, {
  base: "OI",
  letters: ""
}, {
  base: "OO",
  letters: ""
}, {
  base: "OU",
  letters: ""
}, {
  base: "P",
  letters: "P"
}, {
  base: "Q",
  letters: "Q"
}, {
  base: "R",
  letters: "R"
}, {
  base: "S",
  letters: "S"
}, {
  base: "T",
  letters: "T"
}, {
  base: "TZ",
  letters: ""
}, {
  base: "U",
  letters: "U"
}, {
  base: "V",
  letters: "V"
}, {
  base: "VY",
  letters: ""
}, {
  base: "W",
  letters: "W"
}, {
  base: "X",
  letters: "X"
}, {
  base: "Y",
  letters: "Y"
}, {
  base: "Z",
  letters: "Z"
}, {
  base: "a",
  letters: "a"
}, {
  base: "aa",
  letters: ""
}, {
  base: "ae",
  letters: ""
}, {
  base: "ao",
  letters: ""
}, {
  base: "au",
  letters: ""
}, {
  base: "av",
  letters: ""
}, {
  base: "ay",
  letters: ""
}, {
  base: "b",
  letters: "b"
}, {
  base: "c",
  letters: "c"
}, {
  base: "d",
  letters: "d"
}, {
  base: "dz",
  letters: ""
}, {
  base: "e",
  letters: "e"
}, {
  base: "f",
  letters: "f"
}, {
  base: "g",
  letters: "g"
}, {
  base: "h",
  letters: "h"
}, {
  base: "hv",
  letters: ""
}, {
  base: "i",
  letters: "i"
}, {
  base: "j",
  letters: "j"
}, {
  base: "k",
  letters: "k"
}, {
  base: "l",
  letters: "l"
}, {
  base: "lj",
  letters: ""
}, {
  base: "m",
  letters: "m"
}, {
  base: "n",
  letters: "n"
}, {
  base: "nj",
  letters: ""
}, {
  base: "o",
  letters: "o"
}, {
  base: "oi",
  letters: ""
}, {
  base: "ou",
  letters: ""
}, {
  base: "oo",
  letters: ""
}, {
  base: "p",
  letters: "p"
}, {
  base: "q",
  letters: "q"
}, {
  base: "r",
  letters: "r"
}, {
  base: "s",
  letters: "s"
}, {
  base: "t",
  letters: "t"
}, {
  base: "tz",
  letters: ""
}, {
  base: "u",
  letters: "u"
}, {
  base: "v",
  letters: "v"
}, {
  base: "vy",
  letters: ""
}, {
  base: "w",
  letters: "w"
}, {
  base: "x",
  letters: "x"
}, {
  base: "y",
  letters: "y"
}, {
  base: "z",
  letters: "z"
}], qC = new RegExp("[" + Uu.map(function(e) {
  return e.letters;
}).join("") + "]", "g"), _b = {};
for (var Dc = 0; Dc < Uu.length; Dc++)
  for (var Lc = Uu[Dc], Fc = 0; Fc < Lc.letters.length; Fc++)
    _b[Lc.letters[Fc]] = Lc.base;
var vb = function(t) {
  return t.replace(qC, function(n) {
    return _b[n];
  });
}, KC = HC(vb), qp = function(t) {
  return t.replace(/^\s+|\s+$/g, "");
}, QC = function(t) {
  return "".concat(t.label, " ").concat(t.value);
}, eI = function(t) {
  return function(n, r) {
    if (n.data.__isNew__) return !0;
    var i = pe({
      ignoreCase: !0,
      ignoreAccents: !0,
      stringify: QC,
      trim: !0,
      matchFrom: "any"
    }, t), a = i.ignoreCase, s = i.ignoreAccents, o = i.stringify, l = i.trim, c = i.matchFrom, u = l ? qp(r) : r, d = l ? qp(o(n)) : o(n);
    return a && (u = u.toLowerCase(), d = d.toLowerCase()), s && (u = KC(u), d = vb(d)), c === "start" ? d.substr(0, u.length) === u : d.indexOf(u) > -1;
  };
}, tI = ["innerRef"];
function nI(e) {
  var t = e.innerRef, n = tr(e, tI), r = Sw(n, "onExited", "in", "enter", "exit", "appear");
  return ge("input", ye({
    ref: t
  }, r, {
    css: /* @__PURE__ */ $d({
      label: "dummyInput",
      // get rid of any default styles
      background: 0,
      border: 0,
      // important! this hides the flashing cursor
      caretColor: "transparent",
      fontSize: "inherit",
      gridArea: "1 / 1 / 2 / 3",
      outline: 0,
      padding: 0,
      // important! without `width` browsers won't allow focus
      width: 1,
      // remove cursor on desktop
      color: "transparent",
      // remove cursor on mobile whilst maintaining "scroll into view" behaviour
      left: -100,
      opacity: 0,
      position: "relative",
      transform: "scale(.01)"
    }, process.env.NODE_ENV === "production" ? "" : ";label:DummyInput;", process.env.NODE_ENV === "production" ? "" : "/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkR1bW15SW5wdXQudHN4Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQXlCTSIsImZpbGUiOiJEdW1teUlucHV0LnRzeCIsInNvdXJjZXNDb250ZW50IjpbIi8qKiBAanN4IGpzeCAqL1xuaW1wb3J0IHsgSlNYLCBSZWYgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBqc3ggfSBmcm9tICdAZW1vdGlvbi9yZWFjdCc7XG5pbXBvcnQgeyByZW1vdmVQcm9wcyB9IGZyb20gJy4uL3V0aWxzJztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gRHVtbXlJbnB1dCh7XG4gIGlubmVyUmVmLFxuICAuLi5wcm9wc1xufTogSlNYLkludHJpbnNpY0VsZW1lbnRzWydpbnB1dCddICYge1xuICByZWFkb25seSBpbm5lclJlZjogUmVmPEhUTUxJbnB1dEVsZW1lbnQ+O1xufSkge1xuICAvLyBSZW1vdmUgYW5pbWF0aW9uIHByb3BzIG5vdCBtZWFudCBmb3IgSFRNTCBlbGVtZW50c1xuICBjb25zdCBmaWx0ZXJlZFByb3BzID0gcmVtb3ZlUHJvcHMoXG4gICAgcHJvcHMsXG4gICAgJ29uRXhpdGVkJyxcbiAgICAnaW4nLFxuICAgICdlbnRlcicsXG4gICAgJ2V4aXQnLFxuICAgICdhcHBlYXInXG4gICk7XG5cbiAgcmV0dXJuIChcbiAgICA8aW5wdXRcbiAgICAgIHJlZj17aW5uZXJSZWZ9XG4gICAgICB7Li4uZmlsdGVyZWRQcm9wc31cbiAgICAgIGNzcz17e1xuICAgICAgICBsYWJlbDogJ2R1bW15SW5wdXQnLFxuICAgICAgICAvLyBnZXQgcmlkIG9mIGFueSBkZWZhdWx0IHN0eWxlc1xuICAgICAgICBiYWNrZ3JvdW5kOiAwLFxuICAgICAgICBib3JkZXI6IDAsXG4gICAgICAgIC8vIGltcG9ydGFudCEgdGhpcyBoaWRlcyB0aGUgZmxhc2hpbmcgY3Vyc29yXG4gICAgICAgIGNhcmV0Q29sb3I6ICd0cmFuc3BhcmVudCcsXG4gICAgICAgIGZvbnRTaXplOiAnaW5oZXJpdCcsXG4gICAgICAgIGdyaWRBcmVhOiAnMSAvIDEgLyAyIC8gMycsXG4gICAgICAgIG91dGxpbmU6IDAsXG4gICAgICAgIHBhZGRpbmc6IDAsXG4gICAgICAgIC8vIGltcG9ydGFudCEgd2l0aG91dCBgd2lkdGhgIGJyb3dzZXJzIHdvbid0IGFsbG93IGZvY3VzXG4gICAgICAgIHdpZHRoOiAxLFxuXG4gICAgICAgIC8vIHJlbW92ZSBjdXJzb3Igb24gZGVza3RvcFxuICAgICAgICBjb2xvcjogJ3RyYW5zcGFyZW50JyxcblxuICAgICAgICAvLyByZW1vdmUgY3Vyc29yIG9uIG1vYmlsZSB3aGlsc3QgbWFpbnRhaW5pbmcgXCJzY3JvbGwgaW50byB2aWV3XCIgYmVoYXZpb3VyXG4gICAgICAgIGxlZnQ6IC0xMDAsXG4gICAgICAgIG9wYWNpdHk6IDAsXG4gICAgICAgIHBvc2l0aW9uOiAncmVsYXRpdmUnLFxuICAgICAgICB0cmFuc2Zvcm06ICdzY2FsZSguMDEpJyxcbiAgICAgIH19XG4gICAgLz5cbiAgKTtcbn1cbiJdfQ== */")
  }));
}
var rI = function(t) {
  t.cancelable && t.preventDefault(), t.stopPropagation();
};
function iI(e) {
  var t = e.isEnabled, n = e.onBottomArrive, r = e.onBottomLeave, i = e.onTopArrive, a = e.onTopLeave, s = gn(!1), o = gn(!1), l = gn(0), c = gn(null), u = Dt(function(m, b) {
    if (c.current !== null) {
      var y = c.current, v = y.scrollTop, E = y.scrollHeight, _ = y.clientHeight, x = c.current, I = b > 0, T = E - _ - v, O = !1;
      T > b && s.current && (r && r(m), s.current = !1), I && o.current && (a && a(m), o.current = !1), I && b > T ? (n && !s.current && n(m), x.scrollTop = E, O = !0, s.current = !0) : !I && -b > v && (i && !o.current && i(m), x.scrollTop = 0, O = !0, o.current = !0), O && rI(m);
    }
  }, [n, r, i, a]), d = Dt(function(m) {
    u(m, m.deltaY);
  }, [u]), f = Dt(function(m) {
    l.current = m.changedTouches[0].clientY;
  }, []), p = Dt(function(m) {
    var b = l.current - m.changedTouches[0].clientY;
    u(m, b);
  }, [u]), h = Dt(function(m) {
    if (m) {
      var b = ww ? {
        passive: !1
      } : !1;
      m.addEventListener("wheel", d, b), m.addEventListener("touchstart", f, b), m.addEventListener("touchmove", p, b);
    }
  }, [p, f, d]), g = Dt(function(m) {
    m && (m.removeEventListener("wheel", d, !1), m.removeEventListener("touchstart", f, !1), m.removeEventListener("touchmove", p, !1));
  }, [p, f, d]);
  return er(function() {
    if (t) {
      var m = c.current;
      return h(m), function() {
        g(m);
      };
    }
  }, [t, h, g]), function(m) {
    c.current = m;
  };
}
var Kp = ["boxSizing", "height", "overflow", "paddingRight", "position"], Qp = {
  boxSizing: "border-box",
  // account for possible declaration `width: 100%;` on body
  overflow: "hidden",
  position: "relative",
  height: "100%"
};
function eh(e) {
  e.cancelable && e.preventDefault();
}
function th(e) {
  e.stopPropagation();
}
function nh() {
  var e = this.scrollTop, t = this.scrollHeight, n = e + this.offsetHeight;
  e === 0 ? this.scrollTop = 1 : n === t && (this.scrollTop = e - 1);
}
function rh() {
  return "ontouchstart" in window || navigator.maxTouchPoints;
}
var ih = !!(typeof window < "u" && window.document && window.document.createElement), Za = 0, Wi = {
  capture: !1,
  passive: !1
};
function aI(e) {
  var t = e.isEnabled, n = e.accountForScrollbars, r = n === void 0 ? !0 : n, i = gn({}), a = gn(null), s = Dt(function(l) {
    if (ih) {
      var c = document.body, u = c && c.style;
      if (r && Kp.forEach(function(h) {
        var g = u && u[h];
        i.current[h] = g;
      }), r && Za < 1) {
        var d = parseInt(i.current.paddingRight, 10) || 0, f = document.body ? document.body.clientWidth : 0, p = window.innerWidth - f + d || 0;
        Object.keys(Qp).forEach(function(h) {
          var g = Qp[h];
          u && (u[h] = g);
        }), u && (u.paddingRight = "".concat(p, "px"));
      }
      c && rh() && (c.addEventListener("touchmove", eh, Wi), l && (l.addEventListener("touchstart", nh, Wi), l.addEventListener("touchmove", th, Wi))), Za += 1;
    }
  }, [r]), o = Dt(function(l) {
    if (ih) {
      var c = document.body, u = c && c.style;
      Za = Math.max(Za - 1, 0), r && Za < 1 && Kp.forEach(function(d) {
        var f = i.current[d];
        u && (u[d] = f);
      }), c && rh() && (c.removeEventListener("touchmove", eh, Wi), l && (l.removeEventListener("touchstart", nh, Wi), l.removeEventListener("touchmove", th, Wi)));
    }
  }, [r]);
  return er(function() {
    if (t) {
      var l = a.current;
      return s(l), function() {
        o(l);
      };
    }
  }, [t, s, o]), function(l) {
    a.current = l;
  };
}
function sI() {
  return "You have tried to stringify object returned from `css` function. It isn't supposed to be used directly (e.g. as value of the `className` prop), but rather handed to emotion so it can handle it (e.g. as value of `css` prop).";
}
var oI = function(t) {
  var n = t.target;
  return n.ownerDocument.activeElement && n.ownerDocument.activeElement.blur();
}, lI = process.env.NODE_ENV === "production" ? {
  name: "1kfdb0e",
  styles: "position:fixed;left:0;bottom:0;right:0;top:0"
} : {
  name: "bp8cua-ScrollManager",
  styles: "position:fixed;left:0;bottom:0;right:0;top:0;label:ScrollManager;",
  map: "/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIlNjcm9sbE1hbmFnZXIudHN4Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQW9EVSIsImZpbGUiOiJTY3JvbGxNYW5hZ2VyLnRzeCIsInNvdXJjZXNDb250ZW50IjpbIi8qKiBAanN4IGpzeCAqL1xuaW1wb3J0IHsganN4IH0gZnJvbSAnQGVtb3Rpb24vcmVhY3QnO1xuaW1wb3J0IHsgRnJhZ21lbnQsIFJlYWN0RWxlbWVudCwgUmVmQ2FsbGJhY2ssIE1vdXNlRXZlbnQgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgdXNlU2Nyb2xsQ2FwdHVyZSBmcm9tICcuL3VzZVNjcm9sbENhcHR1cmUnO1xuaW1wb3J0IHVzZVNjcm9sbExvY2sgZnJvbSAnLi91c2VTY3JvbGxMb2NrJztcblxuaW50ZXJmYWNlIFByb3BzIHtcbiAgcmVhZG9ubHkgY2hpbGRyZW46IChyZWY6IFJlZkNhbGxiYWNrPEhUTUxFbGVtZW50PikgPT4gUmVhY3RFbGVtZW50O1xuICByZWFkb25seSBsb2NrRW5hYmxlZDogYm9vbGVhbjtcbiAgcmVhZG9ubHkgY2FwdHVyZUVuYWJsZWQ6IGJvb2xlYW47XG4gIHJlYWRvbmx5IG9uQm90dG9tQXJyaXZlPzogKGV2ZW50OiBXaGVlbEV2ZW50IHwgVG91Y2hFdmVudCkgPT4gdm9pZDtcbiAgcmVhZG9ubHkgb25Cb3R0b21MZWF2ZT86IChldmVudDogV2hlZWxFdmVudCB8IFRvdWNoRXZlbnQpID0+IHZvaWQ7XG4gIHJlYWRvbmx5IG9uVG9wQXJyaXZlPzogKGV2ZW50OiBXaGVlbEV2ZW50IHwgVG91Y2hFdmVudCkgPT4gdm9pZDtcbiAgcmVhZG9ubHkgb25Ub3BMZWF2ZT86IChldmVudDogV2hlZWxFdmVudCB8IFRvdWNoRXZlbnQpID0+IHZvaWQ7XG59XG5cbmNvbnN0IGJsdXJTZWxlY3RJbnB1dCA9IChldmVudDogTW91c2VFdmVudDxIVE1MRGl2RWxlbWVudD4pID0+IHtcbiAgY29uc3QgZWxlbWVudCA9IGV2ZW50LnRhcmdldCBhcyBIVE1MRGl2RWxlbWVudDtcbiAgcmV0dXJuIChcbiAgICBlbGVtZW50Lm93bmVyRG9jdW1lbnQuYWN0aXZlRWxlbWVudCAmJlxuICAgIChlbGVtZW50Lm93bmVyRG9jdW1lbnQuYWN0aXZlRWxlbWVudCBhcyBIVE1MRWxlbWVudCkuYmx1cigpXG4gICk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBTY3JvbGxNYW5hZ2VyKHtcbiAgY2hpbGRyZW4sXG4gIGxvY2tFbmFibGVkLFxuICBjYXB0dXJlRW5hYmxlZCA9IHRydWUsXG4gIG9uQm90dG9tQXJyaXZlLFxuICBvbkJvdHRvbUxlYXZlLFxuICBvblRvcEFycml2ZSxcbiAgb25Ub3BMZWF2ZSxcbn06IFByb3BzKSB7XG4gIGNvbnN0IHNldFNjcm9sbENhcHR1cmVUYXJnZXQgPSB1c2VTY3JvbGxDYXB0dXJlKHtcbiAgICBpc0VuYWJsZWQ6IGNhcHR1cmVFbmFibGVkLFxuICAgIG9uQm90dG9tQXJyaXZlLFxuICAgIG9uQm90dG9tTGVhdmUsXG4gICAgb25Ub3BBcnJpdmUsXG4gICAgb25Ub3BMZWF2ZSxcbiAgfSk7XG4gIGNvbnN0IHNldFNjcm9sbExvY2tUYXJnZXQgPSB1c2VTY3JvbGxMb2NrKHsgaXNFbmFibGVkOiBsb2NrRW5hYmxlZCB9KTtcblxuICBjb25zdCB0YXJnZXRSZWY6IFJlZkNhbGxiYWNrPEhUTUxFbGVtZW50PiA9IChlbGVtZW50KSA9PiB7XG4gICAgc2V0U2Nyb2xsQ2FwdHVyZVRhcmdldChlbGVtZW50KTtcbiAgICBzZXRTY3JvbGxMb2NrVGFyZ2V0KGVsZW1lbnQpO1xuICB9O1xuXG4gIHJldHVybiAoXG4gICAgPEZyYWdtZW50PlxuICAgICAge2xvY2tFbmFibGVkICYmIChcbiAgICAgICAgPGRpdlxuICAgICAgICAgIG9uQ2xpY2s9e2JsdXJTZWxlY3RJbnB1dH1cbiAgICAgICAgICBjc3M9e3sgcG9zaXRpb246ICdmaXhlZCcsIGxlZnQ6IDAsIGJvdHRvbTogMCwgcmlnaHQ6IDAsIHRvcDogMCB9fVxuICAgICAgICAvPlxuICAgICAgKX1cbiAgICAgIHtjaGlsZHJlbih0YXJnZXRSZWYpfVxuICAgIDwvRnJhZ21lbnQ+XG4gICk7XG59XG4iXX0= */",
  toString: sI
};
function cI(e) {
  var t = e.children, n = e.lockEnabled, r = e.captureEnabled, i = r === void 0 ? !0 : r, a = e.onBottomArrive, s = e.onBottomLeave, o = e.onTopArrive, l = e.onTopLeave, c = iI({
    isEnabled: i,
    onBottomArrive: a,
    onBottomLeave: s,
    onTopArrive: o,
    onTopLeave: l
  }), u = aI({
    isEnabled: n
  }), d = function(p) {
    c(p), u(p);
  };
  return ge(Tu, null, n && ge("div", {
    onClick: oI,
    css: lI
  }), t(d));
}
function uI() {
  return "You have tried to stringify object returned from `css` function. It isn't supposed to be used directly (e.g. as value of the `className` prop), but rather handed to emotion so it can handle it (e.g. as value of `css` prop).";
}
var dI = process.env.NODE_ENV === "production" ? {
  name: "1a0ro4n-requiredInput",
  styles: "label:requiredInput;opacity:0;pointer-events:none;position:absolute;bottom:0;left:0;right:0;width:100%"
} : {
  name: "5kkxb2-requiredInput-RequiredInput",
  styles: "label:requiredInput;opacity:0;pointer-events:none;position:absolute;bottom:0;left:0;right:0;width:100%;label:RequiredInput;",
  map: "/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIlJlcXVpcmVkSW5wdXQudHN4Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQWNJIiwiZmlsZSI6IlJlcXVpcmVkSW5wdXQudHN4Iiwic291cmNlc0NvbnRlbnQiOlsiLyoqIEBqc3gganN4ICovXG5pbXBvcnQgeyBGb2N1c0V2ZW50SGFuZGxlciwgRnVuY3Rpb25Db21wb25lbnQgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBqc3ggfSBmcm9tICdAZW1vdGlvbi9yZWFjdCc7XG5cbmNvbnN0IFJlcXVpcmVkSW5wdXQ6IEZ1bmN0aW9uQ29tcG9uZW50PHtcbiAgcmVhZG9ubHkgbmFtZT86IHN0cmluZztcbiAgcmVhZG9ubHkgb25Gb2N1czogRm9jdXNFdmVudEhhbmRsZXI8SFRNTElucHV0RWxlbWVudD47XG59PiA9ICh7IG5hbWUsIG9uRm9jdXMgfSkgPT4gKFxuICA8aW5wdXRcbiAgICByZXF1aXJlZFxuICAgIG5hbWU9e25hbWV9XG4gICAgdGFiSW5kZXg9ey0xfVxuICAgIGFyaWEtaGlkZGVuPVwidHJ1ZVwiXG4gICAgb25Gb2N1cz17b25Gb2N1c31cbiAgICBjc3M9e3tcbiAgICAgIGxhYmVsOiAncmVxdWlyZWRJbnB1dCcsXG4gICAgICBvcGFjaXR5OiAwLFxuICAgICAgcG9pbnRlckV2ZW50czogJ25vbmUnLFxuICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgICBib3R0b206IDAsXG4gICAgICBsZWZ0OiAwLFxuICAgICAgcmlnaHQ6IDAsXG4gICAgICB3aWR0aDogJzEwMCUnLFxuICAgIH19XG4gICAgLy8gUHJldmVudCBgU3dpdGNoaW5nIGZyb20gdW5jb250cm9sbGVkIHRvIGNvbnRyb2xsZWRgIGVycm9yXG4gICAgdmFsdWU9XCJcIlxuICAgIG9uQ2hhbmdlPXsoKSA9PiB7fX1cbiAgLz5cbik7XG5cbmV4cG9ydCBkZWZhdWx0IFJlcXVpcmVkSW5wdXQ7XG4iXX0= */",
  toString: uI
}, fI = function(t) {
  var n = t.name, r = t.onFocus;
  return ge("input", {
    required: !0,
    name: n,
    tabIndex: -1,
    "aria-hidden": "true",
    onFocus: r,
    css: dI,
    value: "",
    onChange: function() {
    }
  });
}, pI = fI;
function Kd(e) {
  var t;
  return typeof window < "u" && window.navigator != null ? e.test(((t = window.navigator.userAgentData) === null || t === void 0 ? void 0 : t.platform) || window.navigator.platform) : !1;
}
function hI() {
  return Kd(/^iPhone/i);
}
function xb() {
  return Kd(/^Mac/i);
}
function gI() {
  return Kd(/^iPad/i) || // iPadOS 13 lies and says it's a Mac, but we can distinguish by detecting touch support.
  xb() && navigator.maxTouchPoints > 1;
}
function mI() {
  return hI() || gI();
}
function bI() {
  return xb() || mI();
}
var yI = function(t) {
  return t.label;
}, Eb = function(t) {
  return t.label;
}, wb = function(t) {
  return t.value;
}, _I = function(t) {
  return !!t.isDisabled;
}, vI = {
  clearIndicator: tC,
  container: Uw,
  control: lC,
  dropdownIndicator: Qw,
  group: fC,
  groupHeading: hC,
  indicatorsContainer: $w,
  indicatorSeparator: rC,
  input: yC,
  loadingIndicator: sC,
  loadingMessage: Bw,
  menu: Nw,
  menuList: Dw,
  menuPortal: Gw,
  multiValue: wC,
  multiValueLabel: CC,
  multiValueRemove: IC,
  noOptionsMessage: Fw,
  option: NC,
  placeholder: PC,
  singleValue: FC,
  valueContainer: Ww
}, xI = {
  primary: "#2684FF",
  primary75: "#4C9AFF",
  primary50: "#B2D4FF",
  primary25: "#DEEBFF",
  danger: "#DE350B",
  dangerLight: "#FFBDAD",
  neutral0: "hsl(0, 0%, 100%)",
  neutral5: "hsl(0, 0%, 95%)",
  neutral10: "hsl(0, 0%, 90%)",
  neutral20: "hsl(0, 0%, 80%)",
  neutral30: "hsl(0, 0%, 70%)",
  neutral40: "hsl(0, 0%, 60%)",
  neutral50: "hsl(0, 0%, 50%)",
  neutral60: "hsl(0, 0%, 40%)",
  neutral70: "hsl(0, 0%, 30%)",
  neutral80: "hsl(0, 0%, 20%)",
  neutral90: "hsl(0, 0%, 10%)"
}, EI = 4, Cb = 4, wI = 38, CI = Cb * 2, II = {
  baseUnit: Cb,
  controlHeight: wI,
  menuGutter: CI
}, Bc = {
  borderRadius: EI,
  colors: xI,
  spacing: II
}, SI = {
  "aria-live": "polite",
  backspaceRemovesValue: !0,
  blurInputOnSelect: $p(),
  captureMenuScroll: !$p(),
  classNames: {},
  closeMenuOnSelect: !0,
  closeMenuOnScroll: !1,
  components: {},
  controlShouldRenderValue: !0,
  escapeClearsValue: !1,
  filterOption: eI(),
  formatGroupLabel: yI,
  getOptionLabel: Eb,
  getOptionValue: wb,
  isDisabled: !1,
  isLoading: !1,
  isMulti: !1,
  isRtl: !1,
  isSearchable: !0,
  isOptionDisabled: _I,
  loadingMessage: function() {
    return "Loading...";
  },
  maxMenuHeight: 300,
  minMenuHeight: 140,
  menuIsOpen: !1,
  menuPlacement: "bottom",
  menuPosition: "absolute",
  menuShouldBlockScroll: !1,
  menuShouldScrollIntoView: !xw(),
  noOptionsMessage: function() {
    return "No options";
  },
  openMenuOnFocus: !1,
  openMenuOnClick: !0,
  options: [],
  pageSize: 5,
  placeholder: "Select...",
  screenReaderStatus: function(t) {
    var n = t.count;
    return "".concat(n, " result").concat(n !== 1 ? "s" : "", " available");
  },
  styles: {},
  tabIndex: 0,
  tabSelectsValue: !0,
  unstyled: !1
};
function ah(e, t, n, r) {
  var i = Ab(e, t, n), a = kb(e, t, n), s = Sb(e, t), o = gl(e, t);
  return {
    type: "option",
    data: t,
    isDisabled: i,
    isSelected: a,
    label: s,
    value: o,
    index: r
  };
}
function Do(e, t) {
  return e.options.map(function(n, r) {
    if ("options" in n) {
      var i = n.options.map(function(s, o) {
        return ah(e, s, t, o);
      }).filter(function(s) {
        return oh(e, s);
      });
      return i.length > 0 ? {
        type: "group",
        data: n,
        options: i,
        index: r
      } : void 0;
    }
    var a = ah(e, n, t, r);
    return oh(e, a) ? a : void 0;
  }).filter(Cw);
}
function Ib(e) {
  return e.reduce(function(t, n) {
    return n.type === "group" ? t.push.apply(t, sa(n.options.map(function(r) {
      return r.data;
    }))) : t.push(n.data), t;
  }, []);
}
function sh(e, t) {
  return e.reduce(function(n, r) {
    return r.type === "group" ? n.push.apply(n, sa(r.options.map(function(i) {
      return {
        data: i.data,
        id: "".concat(t, "-").concat(r.index, "-").concat(i.index)
      };
    }))) : n.push({
      data: r.data,
      id: "".concat(t, "-").concat(r.index)
    }), n;
  }, []);
}
function AI(e, t) {
  return Ib(Do(e, t));
}
function oh(e, t) {
  var n = e.inputValue, r = n === void 0 ? "" : n, i = t.data, a = t.isSelected, s = t.label, o = t.value;
  return (!Rb(e) || !a) && Tb(e, {
    label: s,
    value: o,
    data: i
  }, r);
}
function kI(e, t) {
  var n = e.focusedValue, r = e.selectValue, i = r.indexOf(n);
  if (i > -1) {
    var a = t.indexOf(n);
    if (a > -1)
      return n;
    if (i < t.length)
      return t[i];
  }
  return null;
}
function TI(e, t) {
  var n = e.focusedOption;
  return n && t.indexOf(n) > -1 ? n : t[0];
}
var zc = function(t, n) {
  var r, i = (r = t.find(function(a) {
    return a.data === n;
  })) === null || r === void 0 ? void 0 : r.id;
  return i || null;
}, Sb = function(t, n) {
  return t.getOptionLabel(n);
}, gl = function(t, n) {
  return t.getOptionValue(n);
};
function Ab(e, t, n) {
  return typeof e.isOptionDisabled == "function" ? e.isOptionDisabled(t, n) : !1;
}
function kb(e, t, n) {
  if (n.indexOf(t) > -1) return !0;
  if (typeof e.isOptionSelected == "function")
    return e.isOptionSelected(t, n);
  var r = gl(e, t);
  return n.some(function(i) {
    return gl(e, i) === r;
  });
}
function Tb(e, t, n) {
  return e.filterOption ? e.filterOption(t, n) : !0;
}
var Rb = function(t) {
  var n = t.hideSelectedOptions, r = t.isMulti;
  return n === void 0 ? r : n;
}, RI = 1, Js = /* @__PURE__ */ function(e) {
  XE(n, e);
  var t = qE(n);
  function n(r) {
    var i;
    if (ZE(this, n), i = t.call(this, r), i.state = {
      ariaSelection: null,
      focusedOption: null,
      focusedOptionId: null,
      focusableOptionsWithIds: [],
      focusedValue: null,
      inputIsHidden: !1,
      isFocused: !1,
      selectValue: [],
      clearFocusValueOnUpdate: !1,
      prevWasFocused: !1,
      inputIsHiddenAfterUpdate: void 0,
      prevProps: void 0,
      instancePrefix: ""
    }, i.blockOptionHover = !1, i.isComposing = !1, i.commonProps = void 0, i.initialTouchX = 0, i.initialTouchY = 0, i.openAfterFocus = !1, i.scrollToFocusedOptionOnUpdate = !1, i.userIsDragging = void 0, i.isAppleDevice = bI(), i.controlRef = null, i.getControlRef = function(l) {
      i.controlRef = l;
    }, i.focusedOptionRef = null, i.getFocusedOptionRef = function(l) {
      i.focusedOptionRef = l;
    }, i.menuListRef = null, i.getMenuListRef = function(l) {
      i.menuListRef = l;
    }, i.inputRef = null, i.getInputRef = function(l) {
      i.inputRef = l;
    }, i.focus = i.focusInput, i.blur = i.blurInput, i.onChange = function(l, c) {
      var u = i.props, d = u.onChange, f = u.name;
      c.name = f, i.ariaOnChange(l, c), d(l, c);
    }, i.setValue = function(l, c, u) {
      var d = i.props, f = d.closeMenuOnSelect, p = d.isMulti, h = d.inputValue;
      i.onInputChange("", {
        action: "set-value",
        prevInputValue: h
      }), f && (i.setState({
        inputIsHiddenAfterUpdate: !p
      }), i.onMenuClose()), i.setState({
        clearFocusValueOnUpdate: !0
      }), i.onChange(l, {
        action: c,
        option: u
      });
    }, i.selectOption = function(l) {
      var c = i.props, u = c.blurInputOnSelect, d = c.isMulti, f = c.name, p = i.state.selectValue, h = d && i.isOptionSelected(l, p), g = i.isOptionDisabled(l, p);
      if (h) {
        var m = i.getOptionValue(l);
        i.setValue(p.filter(function(b) {
          return i.getOptionValue(b) !== m;
        }), "deselect-option", l);
      } else if (!g)
        d ? i.setValue([].concat(sa(p), [l]), "select-option", l) : i.setValue(l, "select-option");
      else {
        i.ariaOnChange(l, {
          action: "select-option",
          option: l,
          name: f
        });
        return;
      }
      u && i.blurInput();
    }, i.removeValue = function(l) {
      var c = i.props.isMulti, u = i.state.selectValue, d = i.getOptionValue(l), f = u.filter(function(h) {
        return i.getOptionValue(h) !== d;
      }), p = ns(c, f, f[0] || null);
      i.onChange(p, {
        action: "remove-value",
        removedValue: l
      }), i.focusInput();
    }, i.clearValue = function() {
      var l = i.state.selectValue;
      i.onChange(ns(i.props.isMulti, [], null), {
        action: "clear",
        removedValues: l
      });
    }, i.popValue = function() {
      var l = i.props.isMulti, c = i.state.selectValue, u = c[c.length - 1], d = c.slice(0, c.length - 1), f = ns(l, d, d[0] || null);
      u && i.onChange(f, {
        action: "pop-value",
        removedValue: u
      });
    }, i.getFocusedOptionId = function(l) {
      return zc(i.state.focusableOptionsWithIds, l);
    }, i.getFocusableOptionsWithIds = function() {
      return sh(Do(i.props, i.state.selectValue), i.getElementId("option"));
    }, i.getValue = function() {
      return i.state.selectValue;
    }, i.cx = function() {
      for (var l = arguments.length, c = new Array(l), u = 0; u < l; u++)
        c[u] = arguments[u];
      return gw.apply(void 0, [i.props.classNamePrefix].concat(c));
    }, i.getOptionLabel = function(l) {
      return Sb(i.props, l);
    }, i.getOptionValue = function(l) {
      return gl(i.props, l);
    }, i.getStyles = function(l, c) {
      var u = i.props.unstyled, d = vI[l](c, u);
      d.boxSizing = "border-box";
      var f = i.props.styles[l];
      return f ? f(d, c) : d;
    }, i.getClassNames = function(l, c) {
      var u, d;
      return (u = (d = i.props.classNames)[l]) === null || u === void 0 ? void 0 : u.call(d, c);
    }, i.getElementId = function(l) {
      return "".concat(i.state.instancePrefix, "-").concat(l);
    }, i.getComponents = function() {
      return GC(i.props);
    }, i.buildCategorizedOptions = function() {
      return Do(i.props, i.state.selectValue);
    }, i.getCategorizedOptions = function() {
      return i.props.menuIsOpen ? i.buildCategorizedOptions() : [];
    }, i.buildFocusableOptions = function() {
      return Ib(i.buildCategorizedOptions());
    }, i.getFocusableOptions = function() {
      return i.props.menuIsOpen ? i.buildFocusableOptions() : [];
    }, i.ariaOnChange = function(l, c) {
      i.setState({
        ariaSelection: pe({
          value: l
        }, c)
      });
    }, i.onMenuMouseDown = function(l) {
      l.button === 0 && (l.stopPropagation(), l.preventDefault(), i.focusInput());
    }, i.onMenuMouseMove = function(l) {
      i.blockOptionHover = !1;
    }, i.onControlMouseDown = function(l) {
      if (!l.defaultPrevented) {
        var c = i.props.openMenuOnClick;
        i.state.isFocused ? i.props.menuIsOpen ? l.target.tagName !== "INPUT" && l.target.tagName !== "TEXTAREA" && i.onMenuClose() : c && i.openMenu("first") : (c && (i.openAfterFocus = !0), i.focusInput()), l.target.tagName !== "INPUT" && l.target.tagName !== "TEXTAREA" && l.preventDefault();
      }
    }, i.onDropdownIndicatorMouseDown = function(l) {
      if (!(l && l.type === "mousedown" && l.button !== 0) && !i.props.isDisabled) {
        var c = i.props, u = c.isMulti, d = c.menuIsOpen;
        i.focusInput(), d ? (i.setState({
          inputIsHiddenAfterUpdate: !u
        }), i.onMenuClose()) : i.openMenu("first"), l.preventDefault();
      }
    }, i.onClearIndicatorMouseDown = function(l) {
      l && l.type === "mousedown" && l.button !== 0 || (i.clearValue(), l.preventDefault(), i.openAfterFocus = !1, l.type === "touchend" ? i.focusInput() : setTimeout(function() {
        return i.focusInput();
      }));
    }, i.onScroll = function(l) {
      typeof i.props.closeMenuOnScroll == "boolean" ? l.target instanceof HTMLElement && Xl(l.target) && i.props.onMenuClose() : typeof i.props.closeMenuOnScroll == "function" && i.props.closeMenuOnScroll(l) && i.props.onMenuClose();
    }, i.onCompositionStart = function() {
      i.isComposing = !0;
    }, i.onCompositionEnd = function() {
      i.isComposing = !1;
    }, i.onTouchStart = function(l) {
      var c = l.touches, u = c && c.item(0);
      u && (i.initialTouchX = u.clientX, i.initialTouchY = u.clientY, i.userIsDragging = !1);
    }, i.onTouchMove = function(l) {
      var c = l.touches, u = c && c.item(0);
      if (u) {
        var d = Math.abs(u.clientX - i.initialTouchX), f = Math.abs(u.clientY - i.initialTouchY), p = 5;
        i.userIsDragging = d > p || f > p;
      }
    }, i.onTouchEnd = function(l) {
      i.userIsDragging || (i.controlRef && !i.controlRef.contains(l.target) && i.menuListRef && !i.menuListRef.contains(l.target) && i.blurInput(), i.initialTouchX = 0, i.initialTouchY = 0);
    }, i.onControlTouchEnd = function(l) {
      i.userIsDragging || i.onControlMouseDown(l);
    }, i.onClearIndicatorTouchEnd = function(l) {
      i.userIsDragging || i.onClearIndicatorMouseDown(l);
    }, i.onDropdownIndicatorTouchEnd = function(l) {
      i.userIsDragging || i.onDropdownIndicatorMouseDown(l);
    }, i.handleInputChange = function(l) {
      var c = i.props.inputValue, u = l.currentTarget.value;
      i.setState({
        inputIsHiddenAfterUpdate: !1
      }), i.onInputChange(u, {
        action: "input-change",
        prevInputValue: c
      }), i.props.menuIsOpen || i.onMenuOpen();
    }, i.onInputFocus = function(l) {
      i.props.onFocus && i.props.onFocus(l), i.setState({
        inputIsHiddenAfterUpdate: !1,
        isFocused: !0
      }), (i.openAfterFocus || i.props.openMenuOnFocus) && i.openMenu("first"), i.openAfterFocus = !1;
    }, i.onInputBlur = function(l) {
      var c = i.props.inputValue;
      if (i.menuListRef && i.menuListRef.contains(document.activeElement)) {
        i.inputRef.focus();
        return;
      }
      i.props.onBlur && i.props.onBlur(l), i.onInputChange("", {
        action: "input-blur",
        prevInputValue: c
      }), i.onMenuClose(), i.setState({
        focusedValue: null,
        isFocused: !1
      });
    }, i.onOptionHover = function(l) {
      if (!(i.blockOptionHover || i.state.focusedOption === l)) {
        var c = i.getFocusableOptions(), u = c.indexOf(l);
        i.setState({
          focusedOption: l,
          focusedOptionId: u > -1 ? i.getFocusedOptionId(l) : null
        });
      }
    }, i.shouldHideSelectedOptions = function() {
      return Rb(i.props);
    }, i.onValueInputFocus = function(l) {
      l.preventDefault(), l.stopPropagation(), i.focus();
    }, i.onKeyDown = function(l) {
      var c = i.props, u = c.isMulti, d = c.backspaceRemovesValue, f = c.escapeClearsValue, p = c.inputValue, h = c.isClearable, g = c.isDisabled, m = c.menuIsOpen, b = c.onKeyDown, y = c.tabSelectsValue, v = c.openMenuOnFocus, E = i.state, _ = E.focusedOption, x = E.focusedValue, I = E.selectValue;
      if (!g && !(typeof b == "function" && (b(l), l.defaultPrevented))) {
        switch (i.blockOptionHover = !0, l.key) {
          case "ArrowLeft":
            if (!u || p) return;
            i.focusValue("previous");
            break;
          case "ArrowRight":
            if (!u || p) return;
            i.focusValue("next");
            break;
          case "Delete":
          case "Backspace":
            if (p) return;
            if (x)
              i.removeValue(x);
            else {
              if (!d) return;
              u ? i.popValue() : h && i.clearValue();
            }
            break;
          case "Tab":
            if (i.isComposing || l.shiftKey || !m || !y || !_ || // don't capture the event if the menu opens on focus and the focused
            // option is already selected; it breaks the flow of navigation
            v && i.isOptionSelected(_, I))
              return;
            i.selectOption(_);
            break;
          case "Enter":
            if (l.keyCode === 229)
              break;
            if (m) {
              if (!_ || i.isComposing) return;
              i.selectOption(_);
              break;
            }
            return;
          case "Escape":
            m ? (i.setState({
              inputIsHiddenAfterUpdate: !1
            }), i.onInputChange("", {
              action: "menu-close",
              prevInputValue: p
            }), i.onMenuClose()) : h && f && i.clearValue();
            break;
          case " ":
            if (p)
              return;
            if (!m) {
              i.openMenu("first");
              break;
            }
            if (!_) return;
            i.selectOption(_);
            break;
          case "ArrowUp":
            m ? i.focusOption("up") : i.openMenu("last");
            break;
          case "ArrowDown":
            m ? i.focusOption("down") : i.openMenu("first");
            break;
          case "PageUp":
            if (!m) return;
            i.focusOption("pageup");
            break;
          case "PageDown":
            if (!m) return;
            i.focusOption("pagedown");
            break;
          case "Home":
            if (!m) return;
            i.focusOption("first");
            break;
          case "End":
            if (!m) return;
            i.focusOption("last");
            break;
          default:
            return;
        }
        l.preventDefault();
      }
    }, i.state.instancePrefix = "react-select-" + (i.props.instanceId || ++RI), i.state.selectValue = pl(r.value), r.menuIsOpen && i.state.selectValue.length) {
      var a = i.getFocusableOptionsWithIds(), s = i.buildFocusableOptions(), o = s.indexOf(i.state.selectValue[0]);
      i.state.focusableOptionsWithIds = a, i.state.focusedOption = s[o], i.state.focusedOptionId = zc(a, s[o]);
    }
    return i;
  }
  return $E(n, [{
    key: "componentDidMount",
    value: function() {
      this.startListeningComposition(), this.startListeningToTouch(), this.props.closeMenuOnScroll && document && document.addEventListener && document.addEventListener("scroll", this.onScroll, !0), this.props.autoFocus && this.focusInput(), this.props.menuIsOpen && this.state.focusedOption && this.menuListRef && this.focusedOptionRef && Zp(this.menuListRef, this.focusedOptionRef);
    }
  }, {
    key: "componentDidUpdate",
    value: function(i) {
      var a = this.props, s = a.isDisabled, o = a.menuIsOpen, l = this.state.isFocused;
      // ensure focus is restored correctly when the control becomes enabled
      (l && !s && i.isDisabled || // ensure focus is on the Input when the menu opens
      l && o && !i.menuIsOpen) && this.focusInput(), l && s && !i.isDisabled ? this.setState({
        isFocused: !1
      }, this.onMenuClose) : !l && !s && i.isDisabled && this.inputRef === document.activeElement && this.setState({
        isFocused: !0
      }), this.menuListRef && this.focusedOptionRef && this.scrollToFocusedOptionOnUpdate && (Zp(this.menuListRef, this.focusedOptionRef), this.scrollToFocusedOptionOnUpdate = !1);
    }
  }, {
    key: "componentWillUnmount",
    value: function() {
      this.stopListeningComposition(), this.stopListeningToTouch(), document.removeEventListener("scroll", this.onScroll, !0);
    }
    // ==============================
    // Consumer Handlers
    // ==============================
  }, {
    key: "onMenuOpen",
    value: function() {
      this.props.onMenuOpen();
    }
  }, {
    key: "onMenuClose",
    value: function() {
      this.onInputChange("", {
        action: "menu-close",
        prevInputValue: this.props.inputValue
      }), this.props.onMenuClose();
    }
  }, {
    key: "onInputChange",
    value: function(i, a) {
      this.props.onInputChange(i, a);
    }
    // ==============================
    // Methods
    // ==============================
  }, {
    key: "focusInput",
    value: function() {
      this.inputRef && this.inputRef.focus();
    }
  }, {
    key: "blurInput",
    value: function() {
      this.inputRef && this.inputRef.blur();
    }
    // aliased for consumers
  }, {
    key: "openMenu",
    value: function(i) {
      var a = this, s = this.state, o = s.selectValue, l = s.isFocused, c = this.buildFocusableOptions(), u = i === "first" ? 0 : c.length - 1;
      if (!this.props.isMulti) {
        var d = c.indexOf(o[0]);
        d > -1 && (u = d);
      }
      this.scrollToFocusedOptionOnUpdate = !(l && this.menuListRef), this.setState({
        inputIsHiddenAfterUpdate: !1,
        focusedValue: null,
        focusedOption: c[u],
        focusedOptionId: this.getFocusedOptionId(c[u])
      }, function() {
        return a.onMenuOpen();
      });
    }
  }, {
    key: "focusValue",
    value: function(i) {
      var a = this.state, s = a.selectValue, o = a.focusedValue;
      if (this.props.isMulti) {
        this.setState({
          focusedOption: null
        });
        var l = s.indexOf(o);
        o || (l = -1);
        var c = s.length - 1, u = -1;
        if (s.length) {
          switch (i) {
            case "previous":
              l === 0 ? u = 0 : l === -1 ? u = c : u = l - 1;
              break;
            case "next":
              l > -1 && l < c && (u = l + 1);
              break;
          }
          this.setState({
            inputIsHidden: u !== -1,
            focusedValue: s[u]
          });
        }
      }
    }
  }, {
    key: "focusOption",
    value: function() {
      var i = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "first", a = this.props.pageSize, s = this.state.focusedOption, o = this.getFocusableOptions();
      if (o.length) {
        var l = 0, c = o.indexOf(s);
        s || (c = -1), i === "up" ? l = c > 0 ? c - 1 : o.length - 1 : i === "down" ? l = (c + 1) % o.length : i === "pageup" ? (l = c - a, l < 0 && (l = 0)) : i === "pagedown" ? (l = c + a, l > o.length - 1 && (l = o.length - 1)) : i === "last" && (l = o.length - 1), this.scrollToFocusedOptionOnUpdate = !0, this.setState({
          focusedOption: o[l],
          focusedValue: null,
          focusedOptionId: this.getFocusedOptionId(o[l])
        });
      }
    }
  }, {
    key: "getTheme",
    value: (
      // ==============================
      // Getters
      // ==============================
      function() {
        return this.props.theme ? typeof this.props.theme == "function" ? this.props.theme(Bc) : pe(pe({}, Bc), this.props.theme) : Bc;
      }
    )
  }, {
    key: "getCommonProps",
    value: function() {
      var i = this.clearValue, a = this.cx, s = this.getStyles, o = this.getClassNames, l = this.getValue, c = this.selectOption, u = this.setValue, d = this.props, f = d.isMulti, p = d.isRtl, h = d.options, g = this.hasValue();
      return {
        clearValue: i,
        cx: a,
        getStyles: s,
        getClassNames: o,
        getValue: l,
        hasValue: g,
        isMulti: f,
        isRtl: p,
        options: h,
        selectOption: c,
        selectProps: d,
        setValue: u,
        theme: this.getTheme()
      };
    }
  }, {
    key: "hasValue",
    value: function() {
      var i = this.state.selectValue;
      return i.length > 0;
    }
  }, {
    key: "hasOptions",
    value: function() {
      return !!this.getFocusableOptions().length;
    }
  }, {
    key: "isClearable",
    value: function() {
      var i = this.props, a = i.isClearable, s = i.isMulti;
      return a === void 0 ? s : a;
    }
  }, {
    key: "isOptionDisabled",
    value: function(i, a) {
      return Ab(this.props, i, a);
    }
  }, {
    key: "isOptionSelected",
    value: function(i, a) {
      return kb(this.props, i, a);
    }
  }, {
    key: "filterOption",
    value: function(i, a) {
      return Tb(this.props, i, a);
    }
  }, {
    key: "formatOptionLabel",
    value: function(i, a) {
      if (typeof this.props.formatOptionLabel == "function") {
        var s = this.props.inputValue, o = this.state.selectValue;
        return this.props.formatOptionLabel(i, {
          context: a,
          inputValue: s,
          selectValue: o
        });
      } else
        return this.getOptionLabel(i);
    }
  }, {
    key: "formatGroupLabel",
    value: function(i) {
      return this.props.formatGroupLabel(i);
    }
    // ==============================
    // Mouse Handlers
    // ==============================
  }, {
    key: "startListeningComposition",
    value: (
      // ==============================
      // Composition Handlers
      // ==============================
      function() {
        document && document.addEventListener && (document.addEventListener("compositionstart", this.onCompositionStart, !1), document.addEventListener("compositionend", this.onCompositionEnd, !1));
      }
    )
  }, {
    key: "stopListeningComposition",
    value: function() {
      document && document.removeEventListener && (document.removeEventListener("compositionstart", this.onCompositionStart), document.removeEventListener("compositionend", this.onCompositionEnd));
    }
  }, {
    key: "startListeningToTouch",
    value: (
      // ==============================
      // Touch Handlers
      // ==============================
      function() {
        document && document.addEventListener && (document.addEventListener("touchstart", this.onTouchStart, !1), document.addEventListener("touchmove", this.onTouchMove, !1), document.addEventListener("touchend", this.onTouchEnd, !1));
      }
    )
  }, {
    key: "stopListeningToTouch",
    value: function() {
      document && document.removeEventListener && (document.removeEventListener("touchstart", this.onTouchStart), document.removeEventListener("touchmove", this.onTouchMove), document.removeEventListener("touchend", this.onTouchEnd));
    }
  }, {
    key: "renderInput",
    value: (
      // ==============================
      // Renderers
      // ==============================
      function() {
        var i = this.props, a = i.isDisabled, s = i.isSearchable, o = i.inputId, l = i.inputValue, c = i.tabIndex, u = i.form, d = i.menuIsOpen, f = i.required, p = this.getComponents(), h = p.Input, g = this.state, m = g.inputIsHidden, b = g.ariaSelection, y = this.commonProps, v = o || this.getElementId("input"), E = pe(pe(pe({
          "aria-autocomplete": "list",
          "aria-expanded": d,
          "aria-haspopup": !0,
          "aria-errormessage": this.props["aria-errormessage"],
          "aria-invalid": this.props["aria-invalid"],
          "aria-label": this.props["aria-label"],
          "aria-labelledby": this.props["aria-labelledby"],
          "aria-required": f,
          role: "combobox",
          "aria-activedescendant": this.isAppleDevice ? void 0 : this.state.focusedOptionId || ""
        }, d && {
          "aria-controls": this.getElementId("listbox")
        }), !s && {
          "aria-readonly": !0
        }), this.hasValue() ? (b == null ? void 0 : b.action) === "initial-input-focus" && {
          "aria-describedby": this.getElementId("live-region")
        } : {
          "aria-describedby": this.getElementId("placeholder")
        });
        return s ? /* @__PURE__ */ F.createElement(h, ye({}, y, {
          autoCapitalize: "none",
          autoComplete: "off",
          autoCorrect: "off",
          id: v,
          innerRef: this.getInputRef,
          isDisabled: a,
          isHidden: m,
          onBlur: this.onInputBlur,
          onChange: this.handleInputChange,
          onFocus: this.onInputFocus,
          spellCheck: "false",
          tabIndex: c,
          form: u,
          type: "text",
          value: l
        }, E)) : /* @__PURE__ */ F.createElement(nI, ye({
          id: v,
          innerRef: this.getInputRef,
          onBlur: this.onInputBlur,
          onChange: fl,
          onFocus: this.onInputFocus,
          disabled: a,
          tabIndex: c,
          inputMode: "none",
          form: u,
          value: ""
        }, E));
      }
    )
  }, {
    key: "renderPlaceholderOrValue",
    value: function() {
      var i = this, a = this.getComponents(), s = a.MultiValue, o = a.MultiValueContainer, l = a.MultiValueLabel, c = a.MultiValueRemove, u = a.SingleValue, d = a.Placeholder, f = this.commonProps, p = this.props, h = p.controlShouldRenderValue, g = p.isDisabled, m = p.isMulti, b = p.inputValue, y = p.placeholder, v = this.state, E = v.selectValue, _ = v.focusedValue, x = v.isFocused;
      if (!this.hasValue() || !h)
        return b ? null : /* @__PURE__ */ F.createElement(d, ye({}, f, {
          key: "placeholder",
          isDisabled: g,
          isFocused: x,
          innerProps: {
            id: this.getElementId("placeholder")
          }
        }), y);
      if (m)
        return E.map(function(T, O) {
          var k = T === _, W = "".concat(i.getOptionLabel(T), "-").concat(i.getOptionValue(T));
          return /* @__PURE__ */ F.createElement(s, ye({}, f, {
            components: {
              Container: o,
              Label: l,
              Remove: c
            },
            isFocused: k,
            isDisabled: g,
            key: W,
            index: O,
            removeProps: {
              onClick: function() {
                return i.removeValue(T);
              },
              onTouchEnd: function() {
                return i.removeValue(T);
              },
              onMouseDown: function(L) {
                L.preventDefault();
              }
            },
            data: T
          }), i.formatOptionLabel(T, "value"));
        });
      if (b)
        return null;
      var I = E[0];
      return /* @__PURE__ */ F.createElement(u, ye({}, f, {
        data: I,
        isDisabled: g
      }), this.formatOptionLabel(I, "value"));
    }
  }, {
    key: "renderClearIndicator",
    value: function() {
      var i = this.getComponents(), a = i.ClearIndicator, s = this.commonProps, o = this.props, l = o.isDisabled, c = o.isLoading, u = this.state.isFocused;
      if (!this.isClearable() || !a || l || !this.hasValue() || c)
        return null;
      var d = {
        onMouseDown: this.onClearIndicatorMouseDown,
        onTouchEnd: this.onClearIndicatorTouchEnd,
        "aria-hidden": "true"
      };
      return /* @__PURE__ */ F.createElement(a, ye({}, s, {
        innerProps: d,
        isFocused: u
      }));
    }
  }, {
    key: "renderLoadingIndicator",
    value: function() {
      var i = this.getComponents(), a = i.LoadingIndicator, s = this.commonProps, o = this.props, l = o.isDisabled, c = o.isLoading, u = this.state.isFocused;
      if (!a || !c) return null;
      var d = {
        "aria-hidden": "true"
      };
      return /* @__PURE__ */ F.createElement(a, ye({}, s, {
        innerProps: d,
        isDisabled: l,
        isFocused: u
      }));
    }
  }, {
    key: "renderIndicatorSeparator",
    value: function() {
      var i = this.getComponents(), a = i.DropdownIndicator, s = i.IndicatorSeparator;
      if (!a || !s) return null;
      var o = this.commonProps, l = this.props.isDisabled, c = this.state.isFocused;
      return /* @__PURE__ */ F.createElement(s, ye({}, o, {
        isDisabled: l,
        isFocused: c
      }));
    }
  }, {
    key: "renderDropdownIndicator",
    value: function() {
      var i = this.getComponents(), a = i.DropdownIndicator;
      if (!a) return null;
      var s = this.commonProps, o = this.props.isDisabled, l = this.state.isFocused, c = {
        onMouseDown: this.onDropdownIndicatorMouseDown,
        onTouchEnd: this.onDropdownIndicatorTouchEnd,
        "aria-hidden": "true"
      };
      return /* @__PURE__ */ F.createElement(a, ye({}, s, {
        innerProps: c,
        isDisabled: o,
        isFocused: l
      }));
    }
  }, {
    key: "renderMenu",
    value: function() {
      var i = this, a = this.getComponents(), s = a.Group, o = a.GroupHeading, l = a.Menu, c = a.MenuList, u = a.MenuPortal, d = a.LoadingMessage, f = a.NoOptionsMessage, p = a.Option, h = this.commonProps, g = this.state.focusedOption, m = this.props, b = m.captureMenuScroll, y = m.inputValue, v = m.isLoading, E = m.loadingMessage, _ = m.minMenuHeight, x = m.maxMenuHeight, I = m.menuIsOpen, T = m.menuPlacement, O = m.menuPosition, k = m.menuPortalTarget, W = m.menuShouldBlockScroll, M = m.menuShouldScrollIntoView, L = m.noOptionsMessage, z = m.onMenuScrollToTop, U = m.onMenuScrollToBottom;
      if (!I) return null;
      var $ = function(A, ve) {
        var Te = A.type, Ce = A.data, Je = A.isDisabled, Be = A.isSelected, it = A.label, at = A.value, mt = g === Ce, ie = Je ? void 0 : function() {
          return i.onOptionHover(Ce);
        }, Rt = Je ? void 0 : function() {
          return i.selectOption(Ce);
        }, ft = "".concat(i.getElementId("option"), "-").concat(ve), wt = {
          id: ft,
          onClick: Rt,
          onMouseMove: ie,
          onMouseOver: ie,
          tabIndex: -1,
          role: "option",
          "aria-selected": i.isAppleDevice ? void 0 : Be
          // is not supported on Apple devices
        };
        return /* @__PURE__ */ F.createElement(p, ye({}, h, {
          innerProps: wt,
          data: Ce,
          isDisabled: Je,
          isSelected: Be,
          key: ft,
          label: it,
          type: Te,
          value: at,
          isFocused: mt,
          innerRef: mt ? i.getFocusedOptionRef : void 0
        }), i.formatOptionLabel(A.data, "menu"));
      }, Q;
      if (this.hasOptions())
        Q = this.getCategorizedOptions().map(function(se) {
          if (se.type === "group") {
            var A = se.data, ve = se.options, Te = se.index, Ce = "".concat(i.getElementId("group"), "-").concat(Te), Je = "".concat(Ce, "-heading");
            return /* @__PURE__ */ F.createElement(s, ye({}, h, {
              key: Ce,
              data: A,
              options: ve,
              Heading: o,
              headingProps: {
                id: Je,
                data: se.data
              },
              label: i.formatGroupLabel(se.data)
            }), se.options.map(function(Be) {
              return $(Be, "".concat(Te, "-").concat(Be.index));
            }));
          } else if (se.type === "option")
            return $(se, "".concat(se.index));
        });
      else if (v) {
        var K = E({
          inputValue: y
        });
        if (K === null) return null;
        Q = /* @__PURE__ */ F.createElement(d, h, K);
      } else {
        var fe = L({
          inputValue: y
        });
        if (fe === null) return null;
        Q = /* @__PURE__ */ F.createElement(f, h, fe);
      }
      var S = {
        minMenuHeight: _,
        maxMenuHeight: x,
        menuPlacement: T,
        menuPosition: O,
        menuShouldScrollIntoView: M
      }, me = /* @__PURE__ */ F.createElement(Ow, ye({}, h, S), function(se) {
        var A = se.ref, ve = se.placerProps, Te = ve.placement, Ce = ve.maxHeight;
        return /* @__PURE__ */ F.createElement(l, ye({}, h, S, {
          innerRef: A,
          innerProps: {
            onMouseDown: i.onMenuMouseDown,
            onMouseMove: i.onMenuMouseMove
          },
          isLoading: v,
          placement: Te
        }), /* @__PURE__ */ F.createElement(cI, {
          captureEnabled: b,
          onTopArrive: z,
          onBottomArrive: U,
          lockEnabled: W
        }, function(Je) {
          return /* @__PURE__ */ F.createElement(c, ye({}, h, {
            innerRef: function(it) {
              i.getMenuListRef(it), Je(it);
            },
            innerProps: {
              role: "listbox",
              "aria-multiselectable": h.isMulti,
              id: i.getElementId("listbox")
            },
            isLoading: v,
            maxHeight: Ce,
            focusedOption: g
          }), Q);
        }));
      });
      return k || O === "fixed" ? /* @__PURE__ */ F.createElement(u, ye({}, h, {
        appendTo: k,
        controlElement: this.controlRef,
        menuPlacement: T,
        menuPosition: O
      }), me) : me;
    }
  }, {
    key: "renderFormField",
    value: function() {
      var i = this, a = this.props, s = a.delimiter, o = a.isDisabled, l = a.isMulti, c = a.name, u = a.required, d = this.state.selectValue;
      if (u && !this.hasValue() && !o)
        return /* @__PURE__ */ F.createElement(pI, {
          name: c,
          onFocus: this.onValueInputFocus
        });
      if (!(!c || o))
        if (l)
          if (s) {
            var f = d.map(function(g) {
              return i.getOptionValue(g);
            }).join(s);
            return /* @__PURE__ */ F.createElement("input", {
              name: c,
              type: "hidden",
              value: f
            });
          } else {
            var p = d.length > 0 ? d.map(function(g, m) {
              return /* @__PURE__ */ F.createElement("input", {
                key: "i-".concat(m),
                name: c,
                type: "hidden",
                value: i.getOptionValue(g)
              });
            }) : /* @__PURE__ */ F.createElement("input", {
              name: c,
              type: "hidden",
              value: ""
            });
            return /* @__PURE__ */ F.createElement("div", null, p);
          }
        else {
          var h = d[0] ? this.getOptionValue(d[0]) : "";
          return /* @__PURE__ */ F.createElement("input", {
            name: c,
            type: "hidden",
            value: h
          });
        }
    }
  }, {
    key: "renderLiveRegion",
    value: function() {
      var i = this.commonProps, a = this.state, s = a.ariaSelection, o = a.focusedOption, l = a.focusedValue, c = a.isFocused, u = a.selectValue, d = this.getFocusableOptions();
      return /* @__PURE__ */ F.createElement(JC, ye({}, i, {
        id: this.getElementId("live-region"),
        ariaSelection: s,
        focusedOption: o,
        focusedValue: l,
        isFocused: c,
        selectValue: u,
        focusableOptions: d,
        isAppleDevice: this.isAppleDevice
      }));
    }
  }, {
    key: "render",
    value: function() {
      var i = this.getComponents(), a = i.Control, s = i.IndicatorsContainer, o = i.SelectContainer, l = i.ValueContainer, c = this.props, u = c.className, d = c.id, f = c.isDisabled, p = c.menuIsOpen, h = this.state.isFocused, g = this.commonProps = this.getCommonProps();
      return /* @__PURE__ */ F.createElement(o, ye({}, g, {
        className: u,
        innerProps: {
          id: d,
          onKeyDown: this.onKeyDown
        },
        isDisabled: f,
        isFocused: h
      }), this.renderLiveRegion(), /* @__PURE__ */ F.createElement(a, ye({}, g, {
        innerRef: this.getControlRef,
        innerProps: {
          onMouseDown: this.onControlMouseDown,
          onTouchEnd: this.onControlTouchEnd
        },
        isDisabled: f,
        isFocused: h,
        menuIsOpen: p
      }), /* @__PURE__ */ F.createElement(l, ye({}, g, {
        isDisabled: f
      }), this.renderPlaceholderOrValue(), this.renderInput()), /* @__PURE__ */ F.createElement(s, ye({}, g, {
        isDisabled: f
      }), this.renderClearIndicator(), this.renderLoadingIndicator(), this.renderIndicatorSeparator(), this.renderDropdownIndicator())), this.renderMenu(), this.renderFormField());
    }
  }], [{
    key: "getDerivedStateFromProps",
    value: function(i, a) {
      var s = a.prevProps, o = a.clearFocusValueOnUpdate, l = a.inputIsHiddenAfterUpdate, c = a.ariaSelection, u = a.isFocused, d = a.prevWasFocused, f = a.instancePrefix, p = i.options, h = i.value, g = i.menuIsOpen, m = i.inputValue, b = i.isMulti, y = pl(h), v = {};
      if (s && (h !== s.value || p !== s.options || g !== s.menuIsOpen || m !== s.inputValue)) {
        var E = g ? AI(i, y) : [], _ = g ? sh(Do(i, y), "".concat(f, "-option")) : [], x = o ? kI(a, y) : null, I = TI(a, E), T = zc(_, I);
        v = {
          selectValue: y,
          focusedOption: I,
          focusedOptionId: T,
          focusableOptionsWithIds: _,
          focusedValue: x,
          clearFocusValueOnUpdate: !1
        };
      }
      var O = l != null && i !== s ? {
        inputIsHidden: l,
        inputIsHiddenAfterUpdate: void 0
      } : {}, k = c, W = u && d;
      return u && !W && (k = {
        value: ns(b, y, y[0] || null),
        options: y,
        action: "initial-input-focus"
      }, W = !d), (c == null ? void 0 : c.action) === "initial-input-focus" && (k = null), pe(pe(pe({}, v), O), {}, {
        prevProps: i,
        ariaSelection: k,
        prevWasFocused: W
      });
    }
  }]), n;
}(Hv);
Js.defaultProps = SI;
var NI = /* @__PURE__ */ Ue(function(e, t) {
  var n = Ul(e);
  return /* @__PURE__ */ F.createElement(Js, ye({
    ref: t
  }, n));
}), OI = NI, MI = (e, t, n, r, i, a, s, o) => {
  let l = document.documentElement, c = ["light", "dark"];
  function u(p) {
    (Array.isArray(e) ? e : [e]).forEach((h) => {
      let g = h === "class", m = g && a ? i.map((b) => a[b] || b) : i;
      g ? (l.classList.remove(...m), l.classList.add(p)) : l.setAttribute(h, p);
    }), d(p);
  }
  function d(p) {
    o && c.includes(p) && (l.style.colorScheme = p);
  }
  function f() {
    return window.matchMedia("(prefers-color-scheme: dark)").matches ? "dark" : "light";
  }
  if (r) u(r);
  else try {
    let p = localStorage.getItem(t) || n, h = s && p === "system" ? f() : p;
    u(h);
  } catch {
  }
}, PI = F.createContext(void 0), DI = { setTheme: (e) => {
}, themes: [] }, Nb = () => {
  var e;
  return (e = F.useContext(PI)) != null ? e : DI;
};
F.memo(({ forcedTheme: e, storageKey: t, attribute: n, enableSystem: r, enableColorScheme: i, defaultTheme: a, value: s, themes: o, nonce: l, scriptProps: c }) => {
  let u = JSON.stringify([n, t, a, e, o, s, r, i]).slice(1, -1);
  return F.createElement("script", { ...c, suppressHydrationWarning: !0, nonce: typeof window > "u" ? l : "", dangerouslySetInnerHTML: { __html: `(${MI.toString()})(${u})` } });
});
var LI = ["allowCreateWhileLoading", "createOptionPosition", "formatCreateLabel", "isValidNewOption", "getNewOptionData", "onCreateOption", "options", "onChange"], lh = function() {
  var t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "", n = arguments.length > 1 ? arguments[1] : void 0, r = arguments.length > 2 ? arguments[2] : void 0, i = String(t).toLowerCase(), a = String(r.getOptionValue(n)).toLowerCase(), s = String(r.getOptionLabel(n)).toLowerCase();
  return a === i || s === i;
}, Vc = {
  formatCreateLabel: function(t) {
    return 'Create "'.concat(t, '"');
  },
  isValidNewOption: function(t, n, r, i) {
    return !(!t || n.some(function(a) {
      return lh(t, a, i);
    }) || r.some(function(a) {
      return lh(t, a, i);
    }));
  },
  getNewOptionData: function(t, n) {
    return {
      label: n,
      value: t,
      __isNew__: !0
    };
  }
};
function Ob(e) {
  var t = e.allowCreateWhileLoading, n = t === void 0 ? !1 : t, r = e.createOptionPosition, i = r === void 0 ? "last" : r, a = e.formatCreateLabel, s = a === void 0 ? Vc.formatCreateLabel : a, o = e.isValidNewOption, l = o === void 0 ? Vc.isValidNewOption : o, c = e.getNewOptionData, u = c === void 0 ? Vc.getNewOptionData : c, d = e.onCreateOption, f = e.options, p = f === void 0 ? [] : f, h = e.onChange, g = tr(e, LI), m = g.getOptionValue, b = m === void 0 ? wb : m, y = g.getOptionLabel, v = y === void 0 ? Eb : y, E = g.inputValue, _ = g.isLoading, x = g.isMulti, I = g.value, T = g.name, O = Nr(function() {
    return l(E, pl(I), p, {
      getOptionValue: b,
      getOptionLabel: v
    }) ? u(E, s(E)) : void 0;
  }, [s, u, v, b, E, l, p, I]), k = Nr(function() {
    return (n || !_) && O ? i === "first" ? [O].concat(sa(p)) : [].concat(sa(p), [O]) : p;
  }, [n, i, _, O, p]), W = Dt(function(M, L) {
    if (L.action !== "select-option")
      return h(M, L);
    var z = Array.isArray(M) ? M : [M];
    if (z[z.length - 1] === O) {
      if (d) d(E);
      else {
        var U = u(E, E), $ = {
          action: "create-option",
          name: T,
          option: U
        };
        h(ns(x, [].concat(sa(pl(I)), [U]), U), $);
      }
      return;
    }
    h(M, L);
  }, [u, E, x, T, O, d, h, I]);
  return pe(pe({}, g), {}, {
    options: k,
    onChange: W
  });
}
var FI = /* @__PURE__ */ Ue(function(e, t) {
  var n = Ul(e), r = Ob(n);
  return /* @__PURE__ */ F.createElement(Js, ye({
    ref: t
  }, r));
}), BI = FI, zI = ["defaultOptions", "cacheOptions", "loadOptions", "options", "isLoading", "onInputChange", "filterOption"];
function Mb(e) {
  var t = e.defaultOptions, n = t === void 0 ? !1 : t, r = e.cacheOptions, i = r === void 0 ? !1 : r, a = e.loadOptions;
  e.options;
  var s = e.isLoading, o = s === void 0 ? !1 : s, l = e.onInputChange, c = e.filterOption, u = c === void 0 ? null : c, d = tr(e, zI), f = d.inputValue, p = gn(void 0), h = gn(!1), g = _t(Array.isArray(n) ? n : void 0), m = Pt(g, 2), b = m[0], y = m[1], v = _t(typeof f < "u" ? f : ""), E = Pt(v, 2), _ = E[0], x = E[1], I = _t(n === !0), T = Pt(I, 2), O = T[0], k = T[1], W = _t(void 0), M = Pt(W, 2), L = M[0], z = M[1], U = _t([]), $ = Pt(U, 2), Q = $[0], K = $[1], fe = _t(!1), S = Pt(fe, 2), me = S[0], se = S[1], A = _t({}), ve = Pt(A, 2), Te = ve[0], Ce = ve[1], Je = _t(void 0), Be = Pt(Je, 2), it = Be[0], at = Be[1], mt = _t(void 0), ie = Pt(mt, 2), Rt = ie[0], ft = ie[1];
  i !== Rt && (Ce({}), ft(i)), n !== it && (y(Array.isArray(n) ? n : void 0), at(n)), er(function() {
    return h.current = !0, function() {
      h.current = !1;
    };
  }, []);
  var wt = Dt(function(R, D) {
    if (!a) return D();
    var V = a(R, D);
    V && typeof V.then == "function" && V.then(D, function() {
      return D();
    });
  }, [a]);
  er(function() {
    n === !0 && wt(_, function(R) {
      h.current && (y(R || []), k(!!p.current));
    });
  }, []);
  var Fe = Dt(function(R, D) {
    var V = mw(R, D, l);
    if (!V) {
      p.current = void 0, x(""), z(""), K([]), k(!1), se(!1);
      return;
    }
    if (i && Te[V])
      x(V), z(V), K(Te[V]), k(!1), se(!1);
    else {
      var C = p.current = {};
      x(V), k(!0), se(!L), wt(V, function(G) {
        h && C === p.current && (p.current = void 0, k(!1), z(V), K(G || []), se(!1), Ce(G ? pe(pe({}, Te), {}, ea({}, V, G)) : Te));
      });
    }
  }, [i, wt, L, Te, l]), en = me ? [] : _ && L ? Q : b || [];
  return pe(pe({}, d), {}, {
    options: en,
    isLoading: O || o,
    onInputChange: Fe,
    filterOption: u
  });
}
var VI = /* @__PURE__ */ Ue(function(e, t) {
  var n = Mb(e), r = Ul(n);
  return /* @__PURE__ */ F.createElement(Js, ye({
    ref: t
  }, r));
}), GI = VI, jI = /* @__PURE__ */ Ue(function(e, t) {
  var n = Mb(e), r = Ul(n), i = Ob(r);
  return /* @__PURE__ */ F.createElement(Js, ye({
    ref: t
  }, i));
}), UI = jI, HI = (e) => {
  const {
    children: t,
    className: n,
    cx: r,
    innerProps: i,
    isDisabled: a,
    isRtl: s,
    hasValue: o,
    selectProps: { chakraStyles: l, size: c, variant: u }
  } = e, f = {
    ...jr({ key: "select" })({
      size: c,
      variant: u
    }).root,
    gap: 0,
    position: "relative",
    direction: s ? "rtl" : void 0,
    ...a ? { cursor: "not-allowed" } : {}
  }, p = l != null && l.container ? l.container(f, e) : f;
  return /* @__PURE__ */ w.jsx(
    jt,
    {
      ...i,
      className: r(
        {
          "--is-disabled": a,
          "--is-rtl": s,
          "--has-value": o
        },
        n
      ),
      css: p,
      children: t
    }
  );
}, WI = (e) => {
  const {
    children: t,
    className: n,
    cx: r,
    isMulti: i,
    hasValue: a,
    innerProps: s,
    selectProps: { chakraStyles: o, controlShouldRenderValue: l }
  } = e, c = {
    display: i && a && l ? "flex" : "grid",
    alignItems: "center",
    flex: 1,
    paddingY: "2px",
    flexWrap: "wrap",
    position: "relative",
    overflow: "hidden"
  }, u = o != null && o.valueContainer ? o.valueContainer(c, e) : c;
  return /* @__PURE__ */ w.jsx(
    jt,
    {
      ...s,
      className: r(
        {
          "value-container": !0,
          "value-container--is-multi": i,
          "value-container--has-value": a
        },
        n
      ),
      css: u,
      children: t
    }
  );
}, ZI = (e) => {
  const {
    children: t,
    className: n,
    cx: r,
    innerProps: i,
    selectProps: { chakraStyles: a, size: s, variant: o }
  } = e, c = {
    ...jr({ key: "select" })({
      size: s,
      variant: o
    }).indicatorGroup,
    // TODO: Figure out if this should be allowed to be position: "absolute"
    // That's the built-in default, but it's causing the tags to overlap the indicators
    position: "static",
    // This needs to be overridden otherwise, because the padding is already on the control
    paddingRight: 0
  }, u = a != null && a.indicatorsContainer ? a.indicatorsContainer(c, e) : c;
  return /* @__PURE__ */ w.jsx(
    jt,
    {
      ...i,
      className: r(
        {
          indicators: !0
        },
        n
      ),
      css: u,
      children: t
    }
  );
}, Qd = Xo("svg"), Pb = (e) => /* @__PURE__ */ w.jsx(
  Qd,
  {
    viewBox: "0 0 24 24",
    fill: "none",
    stroke: "currentColor",
    strokeWidth: "2",
    strokeLinecap: "round",
    strokeLinejoin: "round",
    ...e,
    children: /* @__PURE__ */ w.jsx("path", { d: "M20 6 9 17l-5-5" })
  }
), $I = (e) => /* @__PURE__ */ w.jsx(
  Qd,
  {
    viewBox: "0 0 24 24",
    fill: "none",
    stroke: "currentColor",
    strokeWidth: "2",
    strokeLinecap: "round",
    strokeLinejoin: "round",
    ...e,
    children: /* @__PURE__ */ w.jsx("path", { d: "m6 9 6 6 6-6" })
  }
), Db = (e) => /* @__PURE__ */ w.jsx(Qd, { viewBox: "0 0 24 24", fill: "currentColor", ...e, children: /* @__PURE__ */ w.jsx(
  "path",
  {
    fillRule: "evenodd",
    clipRule: "evenodd",
    d: "M18.7071 6.70711C19.0976 6.31658 19.0976 5.68342 18.7071 5.29289C18.3166 4.90237 17.6834 4.90237 17.2929 5.29289L12 10.5858L6.70711 5.29289C6.31658 4.90237 5.68342 4.90237 5.29289 5.29289C4.90237 5.68342 4.90237 6.31658 5.29289 6.70711L10.5858 12L5.29289 17.2929C4.90237 17.6834 4.90237 18.3166 5.29289 18.7071C5.68342 19.0976 6.31658 19.0976 6.70711 18.7071L12 13.4142L17.2929 18.7071C17.6834 19.0976 18.3166 19.0976 18.7071 18.7071C19.0976 18.3166 19.0976 17.6834 18.7071 17.2929L13.4142 12L18.7071 6.70711Z"
  }
) }), XI = (e) => {
  const {
    className: t,
    cx: n,
    children: r,
    innerRef: i,
    innerProps: a,
    isDisabled: s,
    isFocused: o,
    menuIsOpen: l,
    selectProps: {
      chakraStyles: c,
      size: u,
      variant: d,
      invalid: f,
      readOnly: p,
      focusRingColor: h
    }
  } = e, b = {
    ...$v({ key: "input" })({
      size: u,
      variant: d
    }),
    display: "flex",
    height: "auto",
    minHeight: "var(--select-trigger-height)",
    ...s ? { pointerEvents: "none" } : {}
  }, y = c != null && c.control ? c.control(b, e) : b;
  return /* @__PURE__ */ w.jsx(
    jt,
    {
      ref: i,
      className: n(
        {
          control: !0,
          "control--is-disabled": s,
          "control--is-focused": o,
          "control--menu-is-open": l
        },
        t
      ),
      css: y,
      ...a,
      focusRingColor: h,
      "data-focus": o ? !0 : void 0,
      "data-focus-visible": o ? !0 : void 0,
      "data-invalid": f ? !0 : void 0,
      "data-disabled": s ? !0 : void 0,
      "data-readonly": p ? !0 : void 0,
      children: r
    }
  );
}, YI = (e) => {
  const {
    className: t,
    cx: n,
    selectProps: { chakraStyles: r }
  } = e, i = {
    // To match the default styles of the Chakra select, we don't want to show the separator
    display: "none"
  }, a = r != null && r.indicatorSeparator ? r.indicatorSeparator(i, e) : i;
  return /* @__PURE__ */ w.jsx(
    Zv,
    {
      className: n({ "indicator-separator": !0 }, t),
      css: a,
      orientation: "vertical"
    }
  );
}, JI = (e) => {
  const {
    children: t,
    className: n,
    cx: r,
    innerProps: i,
    selectProps: { chakraStyles: a, size: s, variant: o }
  } = e, c = {
    ...jr({ key: "select" })({
      size: s,
      variant: o
    }).indicator
  }, u = a != null && a.dropdownIndicator ? a.dropdownIndicator(c, e) : c, d = {}, f = a != null && a.downChevron ? a.downChevron(d, e) : d;
  return /* @__PURE__ */ w.jsx(
    jt,
    {
      ...i,
      className: r(
        {
          indicator: !0,
          "dropdown-indicator": !0
        },
        n
      ),
      css: u,
      children: t || /* @__PURE__ */ w.jsx($I, { css: f })
    }
  );
}, qI = (e) => {
  const {
    children: t,
    className: n,
    cx: r,
    innerProps: i,
    selectProps: { chakraStyles: a, size: s, variant: o }
  } = e, c = {
    ...jr({ key: "select" })({
      size: s,
      variant: o
    }).clearTrigger
  }, u = a != null && a.clearIndicator ? a.clearIndicator(c, e) : c, d = {}, f = a != null && a.crossIcon ? a.crossIcon(d, e) : d;
  return /* @__PURE__ */ w.jsx(
    jt,
    {
      className: r(
        {
          indicator: !0,
          "clear-indicator": !0
        },
        n
      ),
      css: u,
      "aria-label": "Clear selected options",
      asChild: !0,
      ...i,
      children: /* @__PURE__ */ w.jsx(
        Li,
        {
          size: "sm",
          boxSize: 8,
          minWidth: "unset",
          variant: "plain",
          pointerEvents: "auto",
          tabIndex: -1,
          children: t || /* @__PURE__ */ w.jsx(Db, { css: f })
        }
      )
    }
  );
}, KI = (e) => {
  const {
    className: t,
    cx: n,
    innerProps: r,
    selectProps: { chakraStyles: i },
    color: a,
    colorPalette: s,
    trackColor: o,
    animationDuration: l,
    borderWidth: c,
    spinnerSize: u
  } = e, d = {
    marginRight: 3,
    ...o ? { "--spinner-track-color": o } : {}
  }, f = i != null && i.loadingIndicator ? i.loadingIndicator(d, e) : d;
  return /* @__PURE__ */ w.jsx(
    Yo,
    {
      className: n(
        {
          indicator: !0,
          "loading-indicator": !0
        },
        t
      ),
      css: f,
      ...r,
      size: u,
      colorPalette: s,
      color: a,
      animationDuration: l,
      borderWidth: c
    }
  );
}, Lb = (e) => {
  const {
    className: t,
    // not listed in commonProps documentation, needs to be removed to allow Emotion to generate classNames
    clearValue: n,
    cx: r,
    getStyles: i,
    getClassNames: a,
    getValue: s,
    hasValue: o,
    isMulti: l,
    isRtl: c,
    options: u,
    // not listed in commonProps documentation
    selectOption: d,
    selectProps: f,
    setValue: p,
    theme: h,
    // not listed in commonProps documentation
    ...g
  } = e;
  return { ...g };
}, QI = (e) => typeof e == "string" && ["sm", "md", "lg"].includes(e), eS = (e) => QI(e) ? e : e === "xs" ? "sm" : e === "xl" ? "lg" : "md", Fb = (e) => {
  var t, n, r, i;
  const a = pm(), s = eS(
    (n = (t = a.getSlotRecipe("select")) == null ? void 0 : t.defaultVariants) == null ? void 0 : n.size
  ), o = (r = typeof e == "string" ? [e] : e) != null ? r : [
    s
  ];
  return (i = Xv(o)) != null ? i : s;
};
function tS() {
  const { resolvedTheme: e, setTheme: t } = Nb();
  return {
    colorMode: e,
    setColorMode: t,
    toggleColorMode: () => {
      t(e === "light" ? "dark" : "light");
    }
  };
}
function ch(e, t) {
  const { colorMode: n } = tS();
  return n === "light" ? e : t;
}
var nS = Xo("input"), rS = (e) => {
  const {
    className: t,
    cx: n,
    value: r,
    selectProps: { chakraStyles: i, readOnly: a }
  } = e, { innerRef: s, isDisabled: o, isHidden: l, inputClassName: c, ...u } = Lb(e), d = {
    gridArea: "1 / 2",
    minW: "2px",
    border: 0,
    margin: 0,
    outline: 0,
    padding: 0
  }, f = {
    flex: "1 1 auto",
    display: "inline-grid",
    gridArea: "1 / 1 / 2 / 3",
    gridTemplateColumns: "0 min-content",
    color: "inherit",
    marginX: "0.125rem",
    paddingY: "0.125rem",
    visibility: o ? "hidden" : "visible",
    // Force css to recompute when value change due to @emotion bug.
    // We can remove it whenever the bug is fixed.
    transform: r ? "translateZ(0)" : "",
    _after: {
      content: 'attr(data-value) " "',
      visibility: "hidden",
      whiteSpace: "pre",
      padding: 0,
      ...d
    }
  }, p = i != null && i.inputContainer ? i.inputContainer(f, e) : f, h = {
    background: 0,
    opacity: l ? 0 : 1,
    width: "100%",
    ...d
  }, g = i != null && i.input ? i.input(h, e) : h;
  return /* @__PURE__ */ w.jsx(
    jt,
    {
      className: n({ "input-container": !0 }, t),
      "data-value": r || "",
      css: p,
      children: /* @__PURE__ */ w.jsx(
        nS,
        {
          className: n({ input: !0 }, c),
          ref: s,
          css: g,
          disabled: o,
          readOnly: a ? !0 : void 0,
          ...u
        }
      )
    }
  );
}, iS = (e) => {
  const {
    className: t,
    cx: n,
    children: r,
    innerProps: i,
    innerRef: a,
    placement: s,
    selectProps: { chakraStyles: o }
  } = e, l = {
    position: "absolute",
    ...s === "top" ? { bottom: "100%" } : { top: "100%" },
    marginY: "8px",
    width: "100%",
    zIndex: 1
  }, c = o != null && o.menu ? o.menu(l, e) : l;
  return /* @__PURE__ */ w.jsx(
    jt,
    {
      ...i,
      ref: a,
      className: n({ menu: !0 }, t),
      css: c,
      children: r
    }
  );
}, aS = (e) => {
  const {
    className: t,
    cx: n,
    innerRef: r,
    children: i,
    maxHeight: a,
    isMulti: s,
    innerProps: o,
    selectProps: { chakraStyles: l, size: c, variant: u }
  } = e, f = {
    ...jr({ key: "select" })({ size: c, variant: u }).content,
    maxHeight: `${a}px`,
    position: "relative"
    // required for offset[Height, Top] > keyboard scroll
  }, p = l != null && l.menuList ? l.menuList(f, e) : f;
  return /* @__PURE__ */ w.jsx(
    jt,
    {
      ...o,
      className: n(
        {
          "menu-list": !0,
          "menu-list--is-multi": s
        },
        t
      ),
      css: p,
      ref: r,
      children: i
    }
  );
}, Bb = {
  sm: 1.5,
  md: 2,
  lg: 2.5
}, sS = (e) => {
  const {
    children: t,
    className: n,
    cx: r,
    innerProps: i,
    selectProps: { chakraStyles: a, size: s }
  } = e, o = Fb(s), l = {
    color: "fg.muted",
    textAlign: "center",
    paddingY: Bb[o]
  }, c = a != null && a.loadingMessage ? a.loadingMessage(l, e) : l;
  return /* @__PURE__ */ w.jsx(
    jt,
    {
      ...i,
      className: r(
        {
          "menu-notice": !0,
          "menu-notice--loading": !0
        },
        n
      ),
      css: c,
      children: t
    }
  );
}, oS = (e) => {
  const {
    children: t,
    className: n,
    cx: r,
    innerProps: i,
    selectProps: { chakraStyles: a, size: s }
  } = e, o = Fb(s), l = {
    color: "fg.muted",
    textAlign: "center",
    paddingY: Bb[o]
  }, c = a != null && a.noOptionsMessage ? a.noOptionsMessage(l, e) : l;
  return /* @__PURE__ */ w.jsx(
    jt,
    {
      ...i,
      className: r(
        {
          "menu-notice": !0,
          "menu-notice--no-options": !0
        },
        n
      ),
      css: c,
      children: t
    }
  );
}, lS = (e) => {
  const {
    children: t,
    className: n,
    cx: r,
    theme: i,
    getStyles: a,
    Heading: s,
    headingProps: o,
    label: l,
    selectProps: c,
    innerProps: u,
    getClassNames: d
  } = e, { chakraStyles: f, size: p, variant: h } = c, m = {
    ...jr({ key: "select" })({ size: p, variant: h }).itemGroup
  }, b = f != null && f.group ? f.group(m, e) : m;
  return /* @__PURE__ */ w.jsxs(jt, { ...u, className: r({ group: !0 }, n), css: b, children: [
    /* @__PURE__ */ w.jsx(
      s,
      {
        ...o,
        selectProps: c,
        cx: r,
        theme: i,
        getStyles: a,
        getClassNames: d,
        children: l
      }
    ),
    /* @__PURE__ */ w.jsx(jt, { children: t })
  ] });
}, cS = (e) => {
  const {
    cx: t,
    className: n,
    selectProps: { chakraStyles: r, size: i, variant: a }
  } = e, { data: s, ...o } = Lb(e), c = {
    ...jr({ key: "select" })({ size: i, variant: a }).itemGroupLabel
  }, u = r != null && r.groupHeading ? r.groupHeading(c, e) : c;
  return /* @__PURE__ */ w.jsx(
    jt,
    {
      ...o,
      className: t({ "group-heading": !0 }, n),
      css: u
    }
  );
}, uS = (e) => /* @__PURE__ */ w.jsx(pa, { ...e, children: /* @__PURE__ */ w.jsx(Pb, {}) }), dS = (e) => {
  const {
    className: t,
    cx: n,
    innerRef: r,
    innerProps: i,
    children: a,
    isFocused: s,
    isDisabled: o,
    isSelected: l,
    selectProps: {
      chakraStyles: c,
      isMulti: u,
      hideSelectedOptions: d,
      selectedOptionStyle: f,
      selectedOptionColorPalette: p,
      size: h,
      variant: g
    }
  } = e, m = jr({ key: "select" })({ size: h, variant: g }), b = ch(
    `${p}.500`,
    `${p}.300`
  ), y = ch("white", "black"), v = f === "check" && (!u || d === !1), E = f === "color" && l, _ = {
    ...m.item,
    ...E ? {
      bg: b,
      color: y,
      _active: { bg: b }
    } : {}
  }, x = c != null && c.option ? c.option(_, e) : _;
  return /* @__PURE__ */ w.jsxs(
    jt,
    {
      ...i,
      className: n(
        {
          option: !0,
          "option--is-disabled": o,
          "option--is-focused": s,
          "option--is-selected": l
        },
        t
      ),
      css: x,
      ref: r,
      "data-highlighted": s ? !0 : void 0,
      "aria-disabled": o ? !0 : void 0,
      "aria-selected": l,
      children: [
        a,
        v && /* @__PURE__ */ w.jsx(uS, { css: { ...m.itemIndicator }, hidden: !l, children: /* @__PURE__ */ w.jsx(Pb, {}) })
      ]
    }
  );
}, fS = (e) => typeof e == "object" && e !== null && "colorPalette" in e && typeof e.colorPalette == "string", pS = (e) => typeof e == "object" && e !== null && "variant" in e && typeof e.variant == "string", hS = (e) => {
  var t;
  const {
    children: n,
    className: r,
    components: i,
    cx: a,
    data: s,
    innerProps: o,
    isDisabled: l,
    isFocused: c,
    removeProps: u,
    selectProps: d,
    cropWithEllipsis: f
  } = e, { Container: p, Label: h, Remove: g } = i, { chakraStyles: m, tagColorPalette: b, tagVariant: y, size: v } = d, E = pm(), { colorPalette: _, variant: x } = (t = E.getSlotRecipe("tag").defaultVariants) != null ? t : {};
  let I = _;
  fS(s) ? I = s.colorPalette : b && (I = b);
  let T = x;
  pS(s) ? T = s.variant : y && (T = y);
  const O = jr({ key: "tag" })({
    size: v,
    variant: T
  }), k = {
    ...O.root,
    colorPalette: I,
    minWidth: 0,
    // resolves flex/text-overflow bug
    margin: "0.125rem"
  }, W = m != null && m.multiValue ? m.multiValue(k, e) : k, M = {
    ...O.label,
    overflow: "hidden",
    textOverflow: f || f === void 0 ? "ellipsis" : void 0,
    whiteSpace: "nowrap"
  }, L = m != null && m.multiValueLabel ? m.multiValueLabel(M, e) : M, z = {
    ...O.endElement
  }, U = m != null && m.multiValueEndElement ? m.multiValueEndElement(z, e) : z, $ = {
    ...O.closeTrigger,
    cursor: "pointer"
  }, Q = m != null && m.multiValueRemove ? m.multiValueRemove($, e) : $;
  return /* @__PURE__ */ w.jsxs(
    p,
    {
      data: s,
      innerProps: {
        className: a(
          {
            "multi-value": !0,
            "multi-value--is-disabled": l
          },
          r
        ),
        ...o
      },
      css: W,
      selectProps: d,
      children: [
        /* @__PURE__ */ w.jsx(
          h,
          {
            data: s,
            innerProps: {
              className: a(
                {
                  "multi-value__label": !0
                },
                r
              )
            },
            css: L,
            selectProps: d,
            children: n
          }
        ),
        /* @__PURE__ */ w.jsx(
          g,
          {
            data: s,
            innerProps: {
              className: a(
                {
                  "multi-value__remove": !0
                },
                r
              ),
              "aria-label": `Remove ${n || "option"}`,
              ...u
            },
            endElementCss: U,
            css: Q,
            selectProps: d,
            isFocused: c
          }
        )
      ]
    }
  );
}, gS = (e) => {
  const { children: t, innerProps: n, css: r } = e;
  return /* @__PURE__ */ w.jsx(pa, { ...n, css: r, children: t });
}, mS = (e) => {
  const { children: t, innerProps: n, css: r } = e;
  return /* @__PURE__ */ w.jsx(pa, { ...n, css: r, children: t });
}, bS = (e) => {
  const { children: t, innerProps: n, isFocused: r, endElementCss: i, css: a } = e;
  return /* @__PURE__ */ w.jsx(pa, { css: i, ...n, children: /* @__PURE__ */ w.jsx(
    pa,
    {
      role: "button",
      css: a,
      "data-focus-visible": r ? !0 : void 0,
      children: t || /* @__PURE__ */ w.jsx(Db, {})
    }
  ) });
}, yS = (e) => {
  const {
    children: t,
    className: n,
    cx: r,
    innerProps: i,
    selectProps: { chakraStyles: a }
  } = e, s = {
    gridArea: "1 / 1 / 2 / 3",
    // Matches the color for the default placeholder styles from the Chakra theme
    // https://github.com/chakra-ui/chakra-ui/blob/080fb8a/packages/react/src/theme/global-css.ts#L49-L51
    color: "fg.muted/80",
    mx: "0.125rem",
    userSelect: "none"
  }, o = a != null && a.placeholder ? a.placeholder(s, e) : s;
  return /* @__PURE__ */ w.jsx(
    jt,
    {
      ...i,
      className: r(
        {
          placeholder: !0
        },
        n
      ),
      css: o,
      children: t
    }
  );
}, _S = (e) => {
  const {
    children: t,
    className: n,
    cx: r,
    isDisabled: i,
    innerProps: a,
    selectProps: { chakraStyles: s }
  } = e, o = {
    gridArea: "1 / 1 / 2 / 3",
    mx: "0.125rem",
    maxWidth: "100%",
    overflow: "hidden",
    textOverflow: "ellipsis",
    whiteSpace: "nowrap"
  }, l = s != null && s.singleValue ? s.singleValue(o, e) : o;
  return /* @__PURE__ */ w.jsx(
    jt,
    {
      className: r(
        {
          "single-value": !0,
          "single-value--is-disabled": i
        },
        n
      ),
      css: l,
      ...a,
      children: t
    }
  );
}, vS = {
  ClearIndicator: qI,
  Control: XI,
  DropdownIndicator: JI,
  Group: lS,
  GroupHeading: cS,
  IndicatorSeparator: YI,
  IndicatorsContainer: ZI,
  Input: rS,
  LoadingIndicator: KI,
  LoadingMessage: sS,
  Menu: iS,
  MenuList: aS,
  MultiValue: hS,
  MultiValueContainer: gS,
  MultiValueLabel: mS,
  MultiValueRemove: bS,
  NoOptionsMessage: oS,
  Option: dS,
  Placeholder: yS,
  SelectContainer: HI,
  SingleValue: _S,
  ValueContainer: WI
}, xS = vS, ES = ({
  components: e = {},
  disabled: t,
  isDisabled: n,
  invalid: r,
  readOnly: i,
  required: a,
  inputId: s,
  selectedOptionStyle: o = "color",
  selectedOptionColorPalette: l = "blue",
  menuIsOpen: c,
  menuPlacement: u = "auto",
  // eslint-disable-next-line @typescript-eslint/no-deprecated
  theme: d,
  ...f
}) => {
  var p, h, g;
  const m = Wv(), b = i ?? (m == null ? void 0 : m.readOnly), y = c ?? (b ? !1 : void 0);
  let v = o;
  ["color", "check"].includes(o) || (v = "color");
  let _ = l || "blue";
  return typeof _ != "string" && (_ = "blue"), {
    // Allow overriding of custom components
    components: {
      ...xS,
      ...e
    },
    // Custom select props
    selectedOptionStyle: v,
    selectedOptionColorPalette: _,
    // Extract custom props from form control
    isDisabled: (p = t ?? n) != null ? p : m == null ? void 0 : m.disabled,
    invalid: r ?? (m == null ? void 0 : m.invalid),
    inputId: s ?? (m == null ? void 0 : m.ids.control),
    readOnly: b,
    required: (h = (a != null, a)) != null ? h : m == null ? void 0 : m.required,
    menuIsOpen: y,
    menuPlacement: u,
    unstyled: !0,
    ...f,
    // aria-invalid can be passed to react-select, so we allow that to
    // override the `isInvalid` prop
    "aria-invalid": (g = f["aria-invalid"]) != null ? g : m == null ? void 0 : m.invalid
  };
}, Yl = ES, wS = Ue(
  (e, t) => {
    const n = Yl(e);
    return /* @__PURE__ */ w.jsx(OI, { ref: t, ...n });
  }
), CS = wS;
Ue(
  (e, t) => {
    const n = Yl(e);
    return /* @__PURE__ */ w.jsx(BI, { ref: t, ...n });
  }
);
Ue(
  (e, t) => {
    const n = Yl(e);
    return /* @__PURE__ */ w.jsx(GI, { ref: t, ...n });
  }
);
Ue(
  (e, t) => {
    const n = Yl(e);
    return /* @__PURE__ */ w.jsx(UI, { ref: t, ...n });
  }
);
const Gc = Ue(
  function(t, n) {
    const { label: r, children: i, helperText: a, errorText: s, optionalText: o, ...l } = t;
    return /* @__PURE__ */ w.jsxs(za.Root, { ref: n, ...l, children: [
      r && /* @__PURE__ */ w.jsxs(za.Label, { children: [
        r,
        /* @__PURE__ */ w.jsx(za.RequiredIndicator, { fallback: o })
      ] }),
      i,
      a && /* @__PURE__ */ w.jsx(za.HelperText, { children: a }),
      s && /* @__PURE__ */ w.jsx(za.ErrorText, { children: s })
    ] });
  }
), ef = Ue(
  function(t, n) {
    const { icon: r, children: i, inputProps: a, rootRef: s, ...o } = t;
    return /* @__PURE__ */ w.jsxs(Va.Root, { ref: s, ...o, children: [
      /* @__PURE__ */ w.jsx(Va.HiddenInput, { ref: n, ...a }),
      /* @__PURE__ */ w.jsx(Va.Control, { children: r || /* @__PURE__ */ w.jsx(Va.Indicator, {}) }),
      i != null && /* @__PURE__ */ w.jsx(Va.Label, { children: i })
    ] });
  }
);
function uh({ methods: e, name: t, meta: n, fieldSchema: r }) {
  const i = zE(r);
  function a(o) {
    return i instanceof pt.ZodString && o.toLowerCase().includes("password") ? "password" : i instanceof pt.ZodString && o.toLowerCase().includes("email") ? "email" : i instanceof pt.ZodDate ? "date" : "text";
  }
  function s(o) {
    var l, c;
    if (i instanceof pt.ZodString || i instanceof pt.ZodDate)
      return /* @__PURE__ */ w.jsx(qn, { ...n != null && n.style ? { ...n == null ? void 0 : n.style } : { width: "100%" }, alignItems: "left", children: /* @__PURE__ */ w.jsx(
        Gc,
        {
          label: (n == null ? void 0 : n.label) && n.label,
          invalid: e.formState.errors[t] !== void 0,
          errorText: (l = e.formState.errors[t]) == null ? void 0 : l.message,
          children: /* @__PURE__ */ w.jsx(
            Yv,
            {
              disabled: o.disabled,
              type: a(t),
              ref: o.ref,
              id: t,
              name: t,
              autoComplete: (n == null ? void 0 : n.autocomplete) ?? "",
              onBlur: o.onBlur,
              onChange: o.onChange,
              value: o.value ?? ""
            }
          )
        }
      ) });
    if (i instanceof Dr) {
      const d = i.options.map((f, p) => {
        var h;
        return {
          label: ((h = n == null ? void 0 : n.labels) == null ? void 0 : h[p]) ?? "",
          value: f ?? null
        };
      });
      return /* @__PURE__ */ w.jsx(
        Gc,
        {
          label: (n == null ? void 0 : n.label) && n.label,
          children: /* @__PURE__ */ w.jsx(
            CS,
            {
              ...o,
              options: d,
              value: d.find((f) => f.value === o.value) || null,
              onChange: (f) => o.onChange(f ? f.value : null),
              placeholder: n != null && n.label ? `Select ${n == null ? void 0 : n.label}` : void 0,
              defaultValue: null
            }
          )
        }
      );
    } else if (i instanceof pt.ZodBoolean)
      return /* @__PURE__ */ w.jsx(
        Gc,
        {
          invalid: e.formState.errors[t] !== void 0,
          errorText: (c = e.formState.errors[t]) == null ? void 0 : c.message,
          children: /* @__PURE__ */ w.jsx(
            ef,
            {
              ...o,
              variant: "solid",
              disabled: o.disabled,
              id: t,
              name: t,
              checked: o.value ?? !1,
              onCheckedChange: ({ checked: u }) => o.onChange(u),
              children: n == null ? void 0 : n.label
            }
          )
        }
      );
    return /* @__PURE__ */ w.jsx(w.Fragment, {});
  }
  return /* @__PURE__ */ w.jsx(
    px,
    {
      name: t,
      control: e.control,
      render: ({ field: o }) => s(o)
    },
    crypto.randomUUID()
  );
}
function Vn(e, t) {
  const n = e;
  return t && (n.meta = t || {}), n;
}
function Jl({
  width: e,
  schema: t,
  defaultValues: n,
  step: r = 0,
  onNext: i,
  onBack: a,
  render: s
}) {
  const { fields: o, methods: l } = Rx(t, n), c = o.length !== 0 ? Object.entries(o[r] ?? {}).flatMap(([p, h]) => h.map(([g]) => g)) : [], u = o.length !== 0 ? Object.entries(o[r] ?? {}).map(([p, h]) => {
    switch (p) {
      case "__NO_ROW__":
        return h.map(([g, m]) => /* @__PURE__ */ w.jsx(
          uh,
          {
            methods: l,
            name: g,
            meta: m.meta ?? void 0,
            fieldSchema: m
          },
          crypto.randomUUID()
        ));
      default:
        return /* @__PURE__ */ w.jsx(
          pn,
          {
            width: "100%",
            direction: "row",
            gap: "0.8rem",
            justifyContent: "start",
            children: h.map(([g, m]) => /* @__PURE__ */ w.jsx(
              uh,
              {
                methods: l,
                name: g,
                meta: m.meta ?? void 0,
                fieldSchema: m
              },
              crypto.randomUUID()
            ))
          },
          crypto.randomUUID()
        );
    }
  }) : [];
  async function d() {
    if (await l.trigger(c)) {
      const h = Rp(t.innerType()), g = r + 1;
      g <= h && g === h ? i(g, !0) : i(g, !1);
    }
  }
  async function f() {
    const p = Rp(t.innerType()) + 1, h = r - 1;
    h <= p && h >= 0, a(h, !1);
  }
  return /* @__PURE__ */ w.jsx(pn, { flexDirection: "column", width: e, children: /* @__PURE__ */ w.jsx(cx, { ...l, children: s ? s(u, l.handleSubmit, d, f) : /* @__PURE__ */ w.jsxs(w.Fragment, { children: [
    u,
    /* @__PURE__ */ w.jsx("button", { type: "submit", children: "Invia" })
  ] }) }) });
}
const vi = Ue(
  function(t, n) {
    const { loading: r, disabled: i, loadingText: a, children: s, ...o } = t;
    return /* @__PURE__ */ w.jsx(Nd, { disabled: r || i, ref: n, ...o, children: r && !a ? /* @__PURE__ */ w.jsxs(w.Fragment, { children: [
      /* @__PURE__ */ w.jsx(Jv, { display: "inline-flex", children: /* @__PURE__ */ w.jsx(Yo, { size: "inherit", color: "inherit" }) }),
      /* @__PURE__ */ w.jsx(pa, { opacity: 0, children: s })
    ] }) : r && a ? /* @__PURE__ */ w.jsxs(w.Fragment, { children: [
      /* @__PURE__ */ w.jsx(Yo, { size: "inherit", color: "inherit" }),
      a
    ] }) : s });
  }
);
function IS({ schema: e }) {
  return /* @__PURE__ */ w.jsx(
    Jl,
    {
      schema: e,
      width: "100%",
      render: (t) => /* @__PURE__ */ w.jsxs(
        qn,
        {
          gap: "1rem",
          padding: "1.5rem",
          borderRadius: "10px",
          backgroundColor: "gray.100",
          _dark: { backgroundColor: "gray.950" },
          children: [
            /* @__PURE__ */ w.jsx(ha, { gap: "4", width: "100%", children: t }),
            /* @__PURE__ */ w.jsx(qn, { gap: "4", width: "100%", alignItems: "flex-end", children: /* @__PURE__ */ w.jsx(vi, { variant: "outline", type: "submit", colorPalette: "teal", children: "Crea Account" }) })
          ]
        }
      )
    }
  );
}
function SS(e) {
  if (!e) return "";
  let t = e.replace(/([A-Z])/g, " $1");
  return t = t.trim(), t.charAt(0).toUpperCase() + t.slice(1);
}
function AS(e, t = []) {
  if (!e || e.length === 0)
    return { columns: [], rows: [] };
  const n = /* @__PURE__ */ new Set();
  e.forEach((a) => {
    Object.keys(a).forEach((s) => n.add(s));
  });
  const r = Array.from(n).map((a) => {
    const s = t.includes(a);
    return { field: a, label: SS(a), visible: !s, isNumeric: !1 };
  }), i = e.map((a, s) => ({
    id: a.id ?? String(s),
    data: a
  }));
  return { columns: r, rows: i };
}
const zb = Bl(void 0), kS = (e) => (n) => {
  const { columns: r, rows: i } = AS(n.items, n.hiddenFields), [a, s] = _t([]);
  return /* @__PURE__ */ w.jsx(
    zb.Provider,
    {
      value: {
        columns: r,
        rows: i,
        pagination: n.pagination,
        select: { selection: a, setSelection: s }
      },
      children: /* @__PURE__ */ w.jsx(e, { ...n })
    }
  );
}, ql = () => {
  const e = Fl(zb);
  if (!e)
    throw new Error("useTableContext must be used within LiquidTable");
  return e;
}, TS = () => {
  const { columns: e, rows: t, select: n } = ql(), i = n.selection.length > 0 && n.selection.length < t.length;
  return /* @__PURE__ */ w.jsx(hr.Header, { children: /* @__PURE__ */ w.jsxs(hr.Row, { bg: "bg.subtle", children: [
    /* @__PURE__ */ w.jsx(hr.ColumnHeader, { w: "6", children: /* @__PURE__ */ w.jsx(
      ef,
      {
        top: "1",
        "aria-label": "Select all rows",
        checked: i ? "indeterminate" : n.selection.length > 0,
        onCheckedChange: (a) => a.checked ? n.setSelection(t.map((s) => s.id)) : n.setSelection([])
      }
    ) }),
    e.filter((a) => a.visible).map(
      (a) => /* @__PURE__ */ w.jsx(
        hr.ColumnHeader,
        {
          textAlign: a.isNumeric ? "end" : "start",
          children: a.label
        },
        crypto.randomUUID()
      )
    )
  ] }) });
}, RS = () => {
  const { columns: e, rows: t, select: n } = ql();
  return /* @__PURE__ */ w.jsx(hr.Body, { children: t.map((r) => /* @__PURE__ */ w.jsxs(hr.Row, { children: [
    /* @__PURE__ */ w.jsx(hr.Cell, { children: /* @__PURE__ */ w.jsx(
      ef,
      {
        top: "1",
        "aria-label": "Select row",
        checked: n.selection.includes(r.id),
        onCheckedChange: (i) => n.setSelection((a) => i.checked ? [...a, r.id] : a.filter((s) => s !== r.id))
      }
    ) }),
    e.filter((i) => i.visible).map(
      (i) => /* @__PURE__ */ w.jsx(
        hr.Cell,
        {
          textAlign: i.isNumeric ? "end" : "start",
          children: r.data[i.field] == null ? "/" : r.data[i.field]
        },
        crypto.randomUUID()
      )
    )
  ] }, crypto.randomUUID())) });
};
var Vb = {
  color: void 0,
  size: void 0,
  className: void 0,
  style: void 0,
  attr: void 0
}, dh = De.createContext && /* @__PURE__ */ De.createContext(Vb), NS = ["attr", "size", "title"];
function OS(e, t) {
  if (e == null) return {};
  var n = MS(e, t), r, i;
  if (Object.getOwnPropertySymbols) {
    var a = Object.getOwnPropertySymbols(e);
    for (i = 0; i < a.length; i++)
      r = a[i], !(t.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(e, r) && (n[r] = e[r]);
  }
  return n;
}
function MS(e, t) {
  if (e == null) return {};
  var n = {};
  for (var r in e)
    if (Object.prototype.hasOwnProperty.call(e, r)) {
      if (t.indexOf(r) >= 0) continue;
      n[r] = e[r];
    }
  return n;
}
function ml() {
  return ml = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n)
        Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, ml.apply(this, arguments);
}
function fh(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(i) {
      return Object.getOwnPropertyDescriptor(e, i).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function bl(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? fh(Object(n), !0).forEach(function(r) {
      PS(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : fh(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function PS(e, t, n) {
  return t = DS(t), t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
function DS(e) {
  var t = LS(e, "string");
  return typeof t == "symbol" ? t : t + "";
}
function LS(e, t) {
  if (typeof e != "object" || !e) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t);
    if (typeof r != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function Gb(e) {
  return e && e.map((t, n) => /* @__PURE__ */ De.createElement(t.tag, bl({
    key: n
  }, t.attr), Gb(t.child)));
}
function Bn(e) {
  return (t) => /* @__PURE__ */ De.createElement(FS, ml({
    attr: bl({}, e.attr)
  }, t), Gb(e.child));
}
function FS(e) {
  var t = (n) => {
    var {
      attr: r,
      size: i,
      title: a
    } = e, s = OS(e, NS), o = i || n.size || "1em", l;
    return n.className && (l = n.className), e.className && (l = (l ? l + " " : "") + e.className), /* @__PURE__ */ De.createElement("svg", ml({
      stroke: "currentColor",
      fill: "currentColor",
      strokeWidth: "0"
    }, n.attr, r, s, {
      className: l,
      style: bl(bl({
        color: e.color || n.color
      }, n.style), e.style),
      height: o,
      width: o,
      xmlns: "http://www.w3.org/2000/svg"
    }), a && /* @__PURE__ */ De.createElement("title", null, a), e.children);
  };
  return dh !== void 0 ? /* @__PURE__ */ De.createElement(dh.Consumer, null, (n) => t(n)) : t(Vb);
}
function ph(e) {
  return Bn({ attr: { viewBox: "0 0 24 24", fill: "currentColor", "aria-hidden": "true" }, child: [{ tag: "path", attr: { fillRule: "evenodd", d: "M7.72 12.53a.75.75 0 0 1 0-1.06l7.5-7.5a.75.75 0 1 1 1.06 1.06L9.31 12l6.97 6.97a.75.75 0 1 1-1.06 1.06l-7.5-7.5Z", clipRule: "evenodd" }, child: [] }] })(e);
}
function hh(e) {
  return Bn({ attr: { viewBox: "0 0 24 24", fill: "currentColor", "aria-hidden": "true" }, child: [{ tag: "path", attr: { fillRule: "evenodd", d: "M16.28 11.47a.75.75 0 0 1 0 1.06l-7.5 7.5a.75.75 0 0 1-1.06-1.06L14.69 12 7.72 5.03a.75.75 0 0 1 1.06-1.06l7.5 7.5Z", clipRule: "evenodd" }, child: [] }] })(e);
}
function BS(e) {
  return Bn({ attr: { viewBox: "0 0 24 24", fill: "currentColor", "aria-hidden": "true" }, child: [{ tag: "path", attr: { fillRule: "evenodd", d: "M9.528 1.718a.75.75 0 0 1 .162.819A8.97 8.97 0 0 0 9 6a9 9 0 0 0 9 9 8.97 8.97 0 0 0 3.463-.69.75.75 0 0 1 .981.98 10.503 10.503 0 0 1-9.694 6.46c-5.799 0-10.5-4.7-10.5-10.5 0-4.368 2.667-8.112 6.46-9.694a.75.75 0 0 1 .818.162Z", clipRule: "evenodd" }, child: [] }] })(e);
}
function zS(e) {
  return Bn({ attr: { viewBox: "0 0 24 24", fill: "currentColor", "aria-hidden": "true" }, child: [{ tag: "path", attr: { d: "M12 2.25a.75.75 0 0 1 .75.75v2.25a.75.75 0 0 1-1.5 0V3a.75.75 0 0 1 .75-.75ZM7.5 12a4.5 4.5 0 1 1 9 0 4.5 4.5 0 0 1-9 0ZM18.894 6.166a.75.75 0 0 0-1.06-1.06l-1.591 1.59a.75.75 0 1 0 1.06 1.061l1.591-1.59ZM21.75 12a.75.75 0 0 1-.75.75h-2.25a.75.75 0 0 1 0-1.5H21a.75.75 0 0 1 .75.75ZM17.834 18.894a.75.75 0 0 0 1.06-1.06l-1.59-1.591a.75.75 0 1 0-1.061 1.06l1.59 1.591ZM12 18a.75.75 0 0 1 .75.75V21a.75.75 0 0 1-1.5 0v-2.25A.75.75 0 0 1 12 18ZM7.758 17.303a.75.75 0 0 0-1.061-1.06l-1.591 1.59a.75.75 0 0 0 1.06 1.061l1.591-1.59ZM6 12a.75.75 0 0 1-.75.75H3a.75.75 0 0 1 0-1.5h2.25A.75.75 0 0 1 6 12ZM6.697 7.757a.75.75 0 0 0 1.06-1.06l-1.59-1.591a.75.75 0 0 0-1.061 1.06l1.59 1.591Z" }, child: [] }] })(e);
}
function VS(e) {
  return Bn({ attr: { viewBox: "0 0 20 20", fill: "currentColor", "aria-hidden": "true" }, child: [{ tag: "path", attr: { d: "M3 10a1.5 1.5 0 1 1 3 0 1.5 1.5 0 0 1-3 0ZM8.5 10a1.5 1.5 0 1 1 3 0 1.5 1.5 0 0 1-3 0ZM15.5 8.5a1.5 1.5 0 1 0 0 3 1.5 1.5 0 0 0 0-3Z" }, child: [] }] })(e);
}
const { withContext: GS } = qv({ key: "button" }), tf = GS("a"), [jS, Kl] = Kv({
  name: "RootPropsProvider"
}), US = {
  outline: { default: "ghost", ellipsis: "plain", current: "outline" },
  solid: { default: "outline", ellipsis: "outline", current: "solid" },
  subtle: { default: "ghost", ellipsis: "plain", current: "subtle" }
}, HS = Ue(
  function(t, n) {
    const { size: r = "sm", variant: i = "outline", getHref: a, ...s } = t;
    return /* @__PURE__ */ w.jsx(
      jS,
      {
        value: { size: r, variantMap: US[i], getHref: a },
        children: /* @__PURE__ */ w.jsx(
          Ta.Root,
          {
            ref: n,
            type: a ? "link" : "button",
            ...s
          }
        )
      }
    );
  }
), WS = Ue(function(t, n) {
  const { size: r, variantMap: i } = Kl();
  return /* @__PURE__ */ w.jsx(Ta.Ellipsis, { ref: n, ...t, asChild: !0, children: /* @__PURE__ */ w.jsx(Nd, { as: "span", variant: i.ellipsis, size: r, children: /* @__PURE__ */ w.jsx(VS, {}) }) });
}), ZS = Ue(function(t, n) {
  const { page: r } = zl(), { size: i, variantMap: a, getHref: s } = Kl(), l = r === t.value ? a.current : a.default;
  return s ? /* @__PURE__ */ w.jsx(tf, { href: s(t.value), variant: l, size: i, children: t.value }) : /* @__PURE__ */ w.jsx(Ta.Item, { ref: n, ...t, asChild: !0, children: /* @__PURE__ */ w.jsx(Nd, { variant: l, size: i, children: t.value }) });
}), $S = Ue(function(t, n) {
  const { size: r, variantMap: i, getHref: a } = Kl(), { previousPage: s } = zl();
  return a ? /* @__PURE__ */ w.jsx(
    tf,
    {
      href: s != null ? a(s) : void 0,
      variant: i.default,
      size: r,
      children: /* @__PURE__ */ w.jsx(ph, {})
    }
  ) : /* @__PURE__ */ w.jsx(Ta.PrevTrigger, { ref: n, asChild: !0, ...t, children: /* @__PURE__ */ w.jsx(Li, { variant: i.default, size: r, children: /* @__PURE__ */ w.jsx(ph, {}) }) });
}), XS = Ue(function(t, n) {
  const { size: r, variantMap: i, getHref: a } = Kl(), { nextPage: s } = zl();
  return a ? /* @__PURE__ */ w.jsx(
    tf,
    {
      href: s != null ? a(s) : void 0,
      variant: i.default,
      size: r,
      children: /* @__PURE__ */ w.jsx(hh, {})
    }
  ) : /* @__PURE__ */ w.jsx(Ta.NextTrigger, { ref: n, asChild: !0, ...t, children: /* @__PURE__ */ w.jsx(Li, { variant: i.default, size: r, children: /* @__PURE__ */ w.jsx(hh, {}) }) });
}), YS = (e) => /* @__PURE__ */ w.jsx(Ta.Context, { children: ({ pages: t }) => t.map((n, r) => n.type === "ellipsis" ? /* @__PURE__ */ w.jsx(WS, { index: r, ...e }, r) : /* @__PURE__ */ w.jsx(
  ZS,
  {
    type: "page",
    value: n.value,
    ...e
  },
  r
)) });
Ue(function(t, n) {
  const { format: r = "compact", ...i } = t, { page: a, pages: s, pageRange: o, count: l } = zl(), c = Nr(() => r === "short" ? `${a} / ${s.length}` : r === "compact" ? `${a} of ${s.length}` : `${o.start + 1} - ${o.end} of ${l}`, [r, a, s.length, o, l]);
  return /* @__PURE__ */ w.jsx(ra, { fontWeight: "medium", ref: n, ...i, children: c });
});
const JS = () => {
  const { pagination: e } = ql();
  return e && /* @__PURE__ */ w.jsx(
    HS,
    {
      padding: "0.3rem",
      count: e.totalPages,
      width: "fit-content",
      pageSize: e.size,
      page: e.offset,
      borderRadius: "10px",
      backgroundColor: "gray.100",
      _dark: { backgroundColor: "gray.950" },
      children: /* @__PURE__ */ w.jsxs(ha, { wrap: "wrap", children: [
        /* @__PURE__ */ w.jsx($S, {}),
        /* @__PURE__ */ w.jsx(YS, {}),
        /* @__PURE__ */ w.jsx(XS, {})
      ] })
    }
  );
};
function qS(e) {
  return Bn({ attr: { viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", strokeLinecap: "round", strokeLinejoin: "round" }, child: [{ tag: "path", attr: { d: "M12 3a6 6 0 0 0 9 9 9 9 0 1 1-9-9Z" }, child: [] }] })(e);
}
function KS(e) {
  return Bn({ attr: { viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", strokeLinecap: "round", strokeLinejoin: "round" }, child: [{ tag: "circle", attr: { cx: "12", cy: "12", r: "4" }, child: [] }, { tag: "path", attr: { d: "M12 2v2" }, child: [] }, { tag: "path", attr: { d: "M12 20v2" }, child: [] }, { tag: "path", attr: { d: "m4.93 4.93 1.41 1.41" }, child: [] }, { tag: "path", attr: { d: "m17.66 17.66 1.41 1.41" }, child: [] }, { tag: "path", attr: { d: "M2 12h2" }, child: [] }, { tag: "path", attr: { d: "M20 12h2" }, child: [] }, { tag: "path", attr: { d: "m6.34 17.66-1.41 1.41" }, child: [] }, { tag: "path", attr: { d: "m19.07 4.93-1.41 1.41" }, child: [] }] })(e);
}
function QS(e) {
  return Bn({ attr: { viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", strokeLinecap: "round", strokeLinejoin: "round" }, child: [{ tag: "path", attr: { d: "M18 6 6 18" }, child: [] }, { tag: "path", attr: { d: "m6 6 12 12" }, child: [] }] })(e);
}
const jb = Ue(
  function(t, n) {
    return /* @__PURE__ */ w.jsx(Li, { variant: "ghost", "aria-label": "Close", ref: n, ...t, children: t.children ?? /* @__PURE__ */ w.jsx(QS, {}) });
  }
), eA = Ue(function(t, n) {
  const { children: r, portalled: i = !0, portalRef: a, ...s } = t;
  return /* @__PURE__ */ w.jsx(Vl, { disabled: !i, container: a, children: /* @__PURE__ */ w.jsx(ga.Positioner, { children: /* @__PURE__ */ w.jsx(ga.Content, { ref: n, ...s, asChild: !1, children: r }) }) });
});
Ue(function(t, n) {
  return /* @__PURE__ */ w.jsx(ga.CloseTrigger, { ...t, asChild: !0, ref: n, children: /* @__PURE__ */ w.jsx(jb, { size: "sm" }) });
});
const tA = ga.Root, nA = ga.SelectionTrigger, rA = ga.Separator, iA = () => {
  const { select: e } = ql(), t = e.selection.length > 0;
  return er(() => {
    const n = document.getElementsByClassName("chakra-action-bar__positioner");
    for (let r = 0; r < n.length; r++)
      n[r].style.zIndex = "9999";
  }, []), /* @__PURE__ */ w.jsx(tA, { open: t, children: /* @__PURE__ */ w.jsxs(eA, { children: [
    /* @__PURE__ */ w.jsxs(nA, { children: [
      e.selection.length,
      " selected"
    ] }),
    /* @__PURE__ */ w.jsx(rA, {}),
    /* @__PURE__ */ w.jsxs(vi, { variant: "outline", size: "sm", children: [
      "Delete ",
      /* @__PURE__ */ w.jsx(pp, { children: "" })
    ] }),
    /* @__PURE__ */ w.jsxs(vi, { variant: "outline", size: "sm", children: [
      "Share ",
      /* @__PURE__ */ w.jsx(pp, { children: "T" })
    ] })
  ] }) });
}, aA = () => /* @__PURE__ */ w.jsxs(Ws, { width: "full", gap: "3", alignItems: "flex-end", children: [
  /* @__PURE__ */ w.jsx(JS, {}),
  /* @__PURE__ */ w.jsx(hr.ScrollArea, { borderWidth: "1px", rounded: "md", width: "100%", height: "100%", children: /* @__PURE__ */ w.jsxs(hr.Root, { size: "lg", stickyHeader: !0, interactive: !0, children: [
    /* @__PURE__ */ w.jsx(TS, {}),
    /* @__PURE__ */ w.jsx(RS, {})
  ] }) }),
  /* @__PURE__ */ w.jsx(iA, {})
] }), sA = kS(aA), Ub = pt.object({
  id: Vn(
    pt.string().trim(),
    { label: "Email/Username", autocomplete: "username" }
  ),
  password: Vn(
    pt.string().min(6, { message: "La password deve contenere almeno 6 caratteri" }),
    { label: "Password", autocomplete: "password" }
  ),
  stay_logged: Vn(
    pt.boolean().default(!1),
    { label: "Stay logged" }
  )
}).superRefine((e, t) => {
});
Ub.innerType();
const oA = ({ header: e, submit: t, children: n, root: r }) => /* @__PURE__ */ w.jsx(ia.Root, { borderRadius: "10px", ...r, children: /* @__PURE__ */ w.jsxs(ha, { gap: "1rem", padding: "2rem", justifyContent: "center", children: [
  /* @__PURE__ */ w.jsx(
    Od,
    {
      borderRadius: "10px",
      display: { base: "none", lg: "block" },
      objectFit: "cover",
      height: "15rem",
      src: "undefined/assets/background_card_login.png",
      alt: ""
    }
  ),
  /* @__PURE__ */ w.jsxs(qn, { children: [
    /* @__PURE__ */ w.jsxs(qn, { children: [
      /* @__PURE__ */ w.jsx(Md, { textStyle: "4xl", children: "Login" }),
      e
    ] }),
    /* @__PURE__ */ w.jsx(
      Jl,
      {
        schema: Ub,
        render: (i, a) => /* @__PURE__ */ w.jsxs(w.Fragment, { children: [
          /* @__PURE__ */ w.jsx(ia.Body, { children: /* @__PURE__ */ w.jsx(Ws, { gap: "4", width: { md: "fit-content" }, children: i }) }),
          /* @__PURE__ */ w.jsx(ia.Footer, { justifyContent: "center", paddingY: "1rem", children: /* @__PURE__ */ w.jsx(vi, { onClick: a(t), variant: "solid", width: "100%", children: "Accedi" }) }),
          n
        ] })
      }
    )
  ] })
] }) }), Hb = pt.object({
  /**
   * STEP: 0
   */
  first_name: Vn(
    pt.string().trim().min(2, {
      message: "Il nome deve contenere almeno 2 caratteri"
    }).max(50, {
      message: "Il nome non pu superare i 50 caratteri"
    }),
    { label: "Nome", autocomplete: "first-name", row: "row-1", step: 0 }
  ),
  last_name: Vn(
    pt.string().trim().min(2, {
      message: "Il cognome deve contenere almeno 2 caratteri"
    }).max(50, {
      message: "Il cognome non pu superare i 50 caratteri"
    }),
    { label: "Cognome", autocomplete: "last-name", row: "row-1", step: 0 }
  ),
  bday: Vn(
    pt.coerce.date({
      required_error: "La data di nascita  obbligatoria",
      invalid_type_error: "Formato data non valido"
    }).max(/* @__PURE__ */ new Date(), {
      message: "La data non pu essere nel futuro"
    }).transform((e) => e.getTime()),
    // Converti in timestamp epoch
    { label: "Data di Nascita", autocomplete: "bday", row: "row-2", step: 0 }
  ),
  /**
   * STEP: 1
   */
  username: Vn(
    pt.string().trim(),
    { label: "Nickname", autocomplete: "username", step: 1, style: { width: { sm: "20rem" } } }
  ),
  gender: Vn(
    pt.enum(["male", "female"]).nullable().default(null),
    { label: "Gender", labels: ["Male", "Female"], autocomplete: "gender", step: 1, style: { width: { sm: "20rem" } } }
  ),
  /**
   * STEP: 2
   */
  email: Vn(
    pt.string().trim().toLowerCase().email({ message: "Inserisci unemail valida" }),
    { label: "Email", autocomplete: "email", row: "row-3", step: 2 }
  ),
  confirm_email: Vn(
    pt.string().trim().toLowerCase().email({ message: "Inserisci unemail valida" }),
    { label: "Ripeti Email", autocomplete: "confirm-email", row: "row-3", step: 2 }
  ),
  password: Vn(
    pt.string().trim().min(6, { message: "La password deve contenere almeno 6 caratteri" }).max(100, { message: "La password non pu superare i 100 caratteri" }).regex(/[A-Z]/, { message: "La password deve contenere almeno una lettera maiuscola" }).regex(/\d/, { message: "La password deve contenere almeno un numero" }),
    { label: "Password", autocomplete: "password", row: "row-4", step: 2 }
  ),
  confirm_password: Vn(
    pt.string().trim().min(6, { message: "La password deve contenere almeno 6 caratteri" }).max(100, { message: "La password non pu superare i 100 caratteri" }),
    { label: "Ripeti Password", autocomplete: "confirm-password", row: "row-4", step: 2 }
  )
}).superRefine((e, t) => {
  e.email !== e.confirm_email && t.addIssue({
    code: pt.ZodIssueCode.custom,
    message: "Le email non coincidono.",
    path: ["confirm_email"]
  }), e.password !== e.confirm_password && t.addIssue({
    code: pt.ZodIssueCode.custom,
    message: "Le password non coincidono.",
    path: ["confirm_password"]
  });
});
Hb.innerType();
const lA = ({ rootStyle: e, children: t, submit: n }) => {
  const [r, i] = _t(0), [a, s] = _t(!1);
  async function o(c, u) {
    i(c), s(u);
  }
  async function l(c, u) {
    i(c), s(u);
  }
  return /* @__PURE__ */ w.jsx(ia.Root, { flexDirection: "row", borderRadius: "10px", ...e, children: /* @__PURE__ */ w.jsxs(ha, { gap: "1rem", padding: "2rem", justifyContent: "center", children: [
    /* @__PURE__ */ w.jsx(
      Od,
      {
        borderRadius: "10px",
        display: { base: "none", lg: "block" },
        objectFit: "cover",
        height: "15rem",
        src: "undefined/assets/background_card_register.png",
        alt: ""
      }
    ),
    /* @__PURE__ */ w.jsxs(qn, { children: [
      /* @__PURE__ */ w.jsxs(qn, { children: [
        /* @__PURE__ */ w.jsx(Md, { textStyle: "4xl", children: "Registrazione" }),
        t
      ] }),
      /* @__PURE__ */ w.jsx(
        Jl,
        {
          schema: Hb,
          step: r,
          onNext: o,
          onBack: l,
          render: (c, u, d, f) => /* @__PURE__ */ w.jsxs(w.Fragment, { children: [
            /* @__PURE__ */ w.jsx(ia.Body, { children: /* @__PURE__ */ w.jsx(Ws, { gap: "4", width: { md: "fit-content" }, children: c }) }),
            /* @__PURE__ */ w.jsxs(ia.Footer, { justifyContent: "flex-end", paddingY: "1rem", flexWrap: "wrap", children: [
              r !== 0 && /* @__PURE__ */ w.jsx(vi, { onClick: () => f(), variant: "outline", colorPalette: "cyan", width: "40%", children: "Indietro" }),
              a ? /* @__PURE__ */ w.jsx(vi, { onClick: u(n), variant: "solid", colorPalette: "cyan", width: "40%", children: "Crea Account" }) : /* @__PURE__ */ w.jsx(vi, { onClick: () => d(), variant: "subtle", colorPalette: "cyan", width: "40%", children: "Avanti" })
            ] })
          ] })
        }
      )
    ] })
  ] }) });
};
function cA(e) {
  return Bn({ attr: { viewBox: "0 0 24 24" }, child: [{ tag: "g", attr: { id: "Folder_Off" }, child: [{ tag: "g", attr: {}, child: [{ tag: "path", attr: { d: "M4.013,3.3a.5.5,0,0,0-.711.71l.25.25A2.438,2.438,0,0,0,2.062,6.5v11a2.453,2.453,0,0,0,2.451,2.44h14.72l.759.76c.461.46,1.171-.25.711-.7Zm.5,15.64A1.45,1.45,0,0,1,3.062,17.5V6.5a1.444,1.444,0,0,1,1.31-1.43C5.893,6.6,7.432,8.14,8.963,9.66q4.485,4.485,8.96,8.97l.31.31Z" }, child: [] }, { tag: "path", attr: { d: "M21.438,17.693a.5.5,0,0,1-.5-.5V9.175a1.445,1.445,0,0,0-1.445-1.444H12.827a1.5,1.5,0,0,1-1.474-1.225l-.05-.267a1.445,1.445,0,0,0-1.42-1.178H8.8a.5.5,0,0,1,0-1H9.883a2.446,2.446,0,0,1,2.4,1.994l.05.268a.5.5,0,0,0,.491.408h6.666a2.448,2.448,0,0,1,2.445,2.444v8.018A.5.5,0,0,1,21.438,17.693Z" }, child: [] }] }] }] })(e);
}
function uA(e) {
  return Bn({ attr: { viewBox: "0 0 24 24" }, child: [{ tag: "g", attr: { id: "Globe" }, child: [{ tag: "path", attr: { d: "M14.645,2.428a8.1,8.1,0,0,0-1.61-.3,9.332,9.332,0,0,0-3.6.28l-.07.02a9.928,9.928,0,0,0,.01,19.15,9.091,9.091,0,0,0,2.36.34,1.274,1.274,0,0,0,.27.02,9.65,9.65,0,0,0,2.63-.36,9.931,9.931,0,0,0,.01-19.15Zm-.27.96a8.943,8.943,0,0,1,5.84,5.11h-4.26a13.778,13.778,0,0,0-2.74-5.35A8.254,8.254,0,0,1,14.375,3.388Zm-2.37-.09a12.78,12.78,0,0,1,2.91,5.2H9.075A12.545,12.545,0,0,1,12.005,3.3Zm3.16,6.2a13.193,13.193,0,0,1,0,5.01H8.845a12.185,12.185,0,0,1-.25-2.5,12.353,12.353,0,0,1,.25-2.51Zm-5.6-6.09.07-.02a9.152,9.152,0,0,1,1.16-.23A13.618,13.618,0,0,0,8.045,8.5H3.8A9,9,0,0,1,9.565,3.408Zm-6.5,8.6a8.71,8.71,0,0,1,.37-2.51h4.39a13.95,13.95,0,0,0-.23,2.51,13.757,13.757,0,0,0,.23,2.5H3.435A8.591,8.591,0,0,1,3.065,12.008Zm6.57,8.61a8.9,8.9,0,0,1-5.84-5.11h4.24a13.632,13.632,0,0,0,2.77,5.35A8.1,8.1,0,0,1,9.635,20.618Zm-.56-5.11h5.84a12.638,12.638,0,0,1-2.91,5.21A12.872,12.872,0,0,1,9.075,15.508Zm5.3,5.11a11.551,11.551,0,0,1-1.17.24,13.8,13.8,0,0,0,2.75-5.35h4.26A8.924,8.924,0,0,1,14.375,20.618Zm1.8-6.11a13.611,13.611,0,0,0,0-5.01h4.39a8.379,8.379,0,0,1,.37,2.51,8.687,8.687,0,0,1-.36,2.5Z" }, child: [] }] }] })(e);
}
const nf = Ue(
  function(t, n) {
    const { title: r, description: i, icon: a, children: s, ...o } = t;
    return /* @__PURE__ */ w.jsx(Gi.Root, { ref: n, ...o, children: /* @__PURE__ */ w.jsxs(Gi.Content, { children: [
      a && /* @__PURE__ */ w.jsx(Gi.Indicator, { children: a }),
      i ? /* @__PURE__ */ w.jsxs(qn, { textAlign: "center", children: [
        /* @__PURE__ */ w.jsx(Gi.Title, { children: r }),
        /* @__PURE__ */ w.jsx(Gi.Description, { children: i })
      ] }) : /* @__PURE__ */ w.jsx(Gi.Title, { children: r }),
      s
    ] }) });
  }
), dA = (e) => {
  const { size: t, ...n } = e;
  return /* @__PURE__ */ w.jsx(Qv, { size: t, asChild: !0, children: /* @__PURE__ */ w.jsx(Zs, { ...n }) });
}, fA = Ue(
  function(t, n) {
    const { noOfLines: r = 3, gap: i, ...a } = t;
    return /* @__PURE__ */ w.jsx(Ws, { gap: i, width: "full", ref: n, children: Array.from({ length: r }).map((s, o) => /* @__PURE__ */ w.jsx(
      Zs,
      {
        height: "4",
        ...t,
        _last: { maxW: "80%" },
        ...a
      },
      o
    )) });
  }
), pA = Zs, hA = Ue(
  function(t, n) {
    const { name: r, src: i, srcSet: a, loading: s, icon: o, fallback: l, children: c, ...u } = t;
    return /* @__PURE__ */ w.jsxs(hs.Root, { ref: n, ...u, children: [
      /* @__PURE__ */ w.jsx(gA, { name: r, icon: o, children: l }),
      /* @__PURE__ */ w.jsx(hs.Image, { src: i, srcSet: a, loading: s }),
      c
    ] });
  }
), gA = Ue(
  function(t, n) {
    const { name: r, icon: i, children: a, ...s } = t;
    return /* @__PURE__ */ w.jsxs(hs.Fallback, { ref: n, ...s, children: [
      a,
      r != null && a == null && /* @__PURE__ */ w.jsx(w.Fragment, { children: mA(r) }),
      r == null && a == null && /* @__PURE__ */ w.jsx(hs.Icon, { asChild: !!i, children: i })
    ] });
  }
);
function mA(e) {
  const t = e.trim().split(" "), n = t[0] != null ? t[0] : "", r = t.length > 1 ? t[t.length - 1] : "";
  return n && r ? `${n.charAt(0)}${r.charAt(0)}` : n.charAt(0);
}
Ue(
  function(t, n) {
    const { size: r, variant: i, borderless: a, ...s } = t;
    return /* @__PURE__ */ w.jsx(hs.PropsProvider, { value: { size: r, variant: i, borderless: a }, children: /* @__PURE__ */ w.jsx(ex, { gap: "0", spaceX: "-3", ref: n, ...s }) });
  }
);
const bA = ({
  status: e,
  isEmpty: t = !0,
  header: n,
  subHeader: r,
  body: i,
  empty: a
}) => /* @__PURE__ */ w.jsxs(qn, { gapY: "1rem", children: [
  n && /* @__PURE__ */ w.jsxs(qn, { gapY: "1rem", children: [
    e === 1 && /* @__PURE__ */ w.jsxs(w.Fragment, { children: [
      ((n == null ? void 0 : n.avatar) || r) && /* @__PURE__ */ w.jsxs(ha, { gapY: "2rem", children: [
        (n == null ? void 0 : n.avatar) && /* @__PURE__ */ w.jsx(dA, { size: "20" }),
        r && /* @__PURE__ */ w.jsx(fA, { noOfLines: 2, gap: "4", width: "18rem" })
      ] }),
      /* @__PURE__ */ w.jsx(qn, { gapY: "2rem", children: /* @__PURE__ */ w.jsx(pA, { width: "25rem", height: "20rem" }) })
    ] }),
    t !== !0 && e !== 1 && e === 2 && /* @__PURE__ */ w.jsxs(ha, { gapX: "1rem", children: [
      (n == null ? void 0 : n.avatar) && /* @__PURE__ */ w.jsx(hA, { size: "2xl", variant: "subtle", name: n.avatar }),
      (n == null ? void 0 : n.title) && /* @__PURE__ */ w.jsx(Md, { size: "4xl", children: n.title })
    ] }),
    t !== !0 && e !== 1 && e === 2 && (r == null ? void 0 : r.content)
  ] }),
  t !== !0 && e !== 1 && e === 2 && /* @__PURE__ */ w.jsx(
    pn,
    {
      direction: "column",
      ...!i.disableStyle && {
        borderRadius: "10px",
        borderWidth: "1px",
        backgroundColor: "gray.100",
        _dark: { backgroundColor: "gray.950" },
        height: "fit-content",
        padding: "2rem",
        gapY: "1rem",
        justifyContent: "start"
      },
      ...i.style,
      children: i.content
    }
  ),
  t && e !== 1 && (e === 2 || e === 3) && a && /* @__PURE__ */ w.jsx(
    nf,
    {
      icon: a.icon ? /* @__PURE__ */ w.jsx(Pd, { as: cA }) : void 0,
      title: a.title ?? "No results found",
      description: a.description ?? void 0
    }
  )
] }), yA = ({ field: e, value: t }) => e ? /* @__PURE__ */ w.jsxs(pn, { wrap: "wrap", gapX: "5rem", justifyContent: "space-between", children: [
  /* @__PURE__ */ w.jsx(
    ra,
    {
      textStyle: "lg",
      style: { wordWrap: "break-word", overflowWrap: "break-word", whiteSpace: "normal" },
      children: e
    }
  ),
  /* @__PURE__ */ w.jsx(Ru, {}),
  /* @__PURE__ */ w.jsx(
    ra,
    {
      textStyle: "lg",
      style: { wordWrap: "break-word", overflowWrap: "break-word", whiteSpace: "normal" },
      children: t
    }
  )
] }) : /* @__PURE__ */ w.jsx(
  ra,
  {
    textStyle: "lg",
    style: { wordWrap: "break-word", overflowWrap: "break-word", whiteSpace: "normal" },
    children: t
  }
);
function _A(e, t) {
  const n = {};
  return (e[e.length - 1] === "" ? [...e, ""] : e).join(
    (n.padRight ? " " : "") + "," + (n.padLeft === !1 ? "" : " ")
  ).trim();
}
const vA = /^[$_\p{ID_Start}][$_\u{200C}\u{200D}\p{ID_Continue}]*$/u, xA = /^[$_\p{ID_Start}][-$_\u{200C}\u{200D}\p{ID_Continue}]*$/u, EA = {};
function gh(e, t) {
  return (EA.jsx ? xA : vA).test(e);
}
const wA = /[ \t\n\f\r]/g;
function CA(e) {
  return typeof e == "object" ? e.type === "text" ? mh(e.value) : !1 : mh(e);
}
function mh(e) {
  return e.replace(wA, "") === "";
}
class qs {
  /**
   * @constructor
   * @param {Properties} property
   * @param {Normal} normal
   * @param {string} [space]
   */
  constructor(t, n, r) {
    this.property = t, this.normal = n, r && (this.space = r);
  }
}
qs.prototype.property = {};
qs.prototype.normal = {};
qs.prototype.space = null;
function Wb(e, t) {
  const n = {}, r = {};
  let i = -1;
  for (; ++i < e.length; )
    Object.assign(n, e[i].property), Object.assign(r, e[i].normal);
  return new qs(n, r, t);
}
function Hu(e) {
  return e.toLowerCase();
}
class $n {
  /**
   * @constructor
   * @param {string} property
   * @param {string} attribute
   */
  constructor(t, n) {
    this.property = t, this.attribute = n;
  }
}
$n.prototype.space = null;
$n.prototype.boolean = !1;
$n.prototype.booleanish = !1;
$n.prototype.overloadedBoolean = !1;
$n.prototype.number = !1;
$n.prototype.commaSeparated = !1;
$n.prototype.spaceSeparated = !1;
$n.prototype.commaOrSpaceSeparated = !1;
$n.prototype.mustUseProperty = !1;
$n.prototype.defined = !1;
let IA = 0;
const Re = Fi(), St = Fi(), Zb = Fi(), J = Fi(), nt = Fi(), la = Fi(), In = Fi();
function Fi() {
  return 2 ** ++IA;
}
const Wu = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  boolean: Re,
  booleanish: St,
  commaOrSpaceSeparated: In,
  commaSeparated: la,
  number: J,
  overloadedBoolean: Zb,
  spaceSeparated: nt
}, Symbol.toStringTag, { value: "Module" })), jc = Object.keys(Wu);
class rf extends $n {
  /**
   * @constructor
   * @param {string} property
   * @param {string} attribute
   * @param {number|null} [mask]
   * @param {string} [space]
   */
  constructor(t, n, r, i) {
    let a = -1;
    if (super(t, n), bh(this, "space", i), typeof r == "number")
      for (; ++a < jc.length; ) {
        const s = jc[a];
        bh(this, jc[a], (r & Wu[s]) === Wu[s]);
      }
  }
}
rf.prototype.defined = !0;
function bh(e, t, n) {
  n && (e[t] = n);
}
const SA = {}.hasOwnProperty;
function Na(e) {
  const t = {}, n = {};
  let r;
  for (r in e.properties)
    if (SA.call(e.properties, r)) {
      const i = e.properties[r], a = new rf(
        r,
        e.transform(e.attributes || {}, r),
        i,
        e.space
      );
      e.mustUseProperty && e.mustUseProperty.includes(r) && (a.mustUseProperty = !0), t[r] = a, n[Hu(r)] = r, n[Hu(a.attribute)] = r;
    }
  return new qs(t, n, e.space);
}
const $b = Na({
  space: "xlink",
  transform(e, t) {
    return "xlink:" + t.slice(5).toLowerCase();
  },
  properties: {
    xLinkActuate: null,
    xLinkArcRole: null,
    xLinkHref: null,
    xLinkRole: null,
    xLinkShow: null,
    xLinkTitle: null,
    xLinkType: null
  }
}), Xb = Na({
  space: "xml",
  transform(e, t) {
    return "xml:" + t.slice(3).toLowerCase();
  },
  properties: { xmlLang: null, xmlBase: null, xmlSpace: null }
});
function Yb(e, t) {
  return t in e ? e[t] : t;
}
function Jb(e, t) {
  return Yb(e, t.toLowerCase());
}
const qb = Na({
  space: "xmlns",
  attributes: { xmlnsxlink: "xmlns:xlink" },
  transform: Jb,
  properties: { xmlns: null, xmlnsXLink: null }
}), Kb = Na({
  transform(e, t) {
    return t === "role" ? t : "aria-" + t.slice(4).toLowerCase();
  },
  properties: {
    ariaActiveDescendant: null,
    ariaAtomic: St,
    ariaAutoComplete: null,
    ariaBusy: St,
    ariaChecked: St,
    ariaColCount: J,
    ariaColIndex: J,
    ariaColSpan: J,
    ariaControls: nt,
    ariaCurrent: null,
    ariaDescribedBy: nt,
    ariaDetails: null,
    ariaDisabled: St,
    ariaDropEffect: nt,
    ariaErrorMessage: null,
    ariaExpanded: St,
    ariaFlowTo: nt,
    ariaGrabbed: St,
    ariaHasPopup: null,
    ariaHidden: St,
    ariaInvalid: null,
    ariaKeyShortcuts: null,
    ariaLabel: null,
    ariaLabelledBy: nt,
    ariaLevel: J,
    ariaLive: null,
    ariaModal: St,
    ariaMultiLine: St,
    ariaMultiSelectable: St,
    ariaOrientation: null,
    ariaOwns: nt,
    ariaPlaceholder: null,
    ariaPosInSet: J,
    ariaPressed: St,
    ariaReadOnly: St,
    ariaRelevant: null,
    ariaRequired: St,
    ariaRoleDescription: nt,
    ariaRowCount: J,
    ariaRowIndex: J,
    ariaRowSpan: J,
    ariaSelected: St,
    ariaSetSize: J,
    ariaSort: null,
    ariaValueMax: J,
    ariaValueMin: J,
    ariaValueNow: J,
    ariaValueText: null,
    role: null
  }
}), AA = Na({
  space: "html",
  attributes: {
    acceptcharset: "accept-charset",
    classname: "class",
    htmlfor: "for",
    httpequiv: "http-equiv"
  },
  transform: Jb,
  mustUseProperty: ["checked", "multiple", "muted", "selected"],
  properties: {
    // Standard Properties.
    abbr: null,
    accept: la,
    acceptCharset: nt,
    accessKey: nt,
    action: null,
    allow: null,
    allowFullScreen: Re,
    allowPaymentRequest: Re,
    allowUserMedia: Re,
    alt: null,
    as: null,
    async: Re,
    autoCapitalize: null,
    autoComplete: nt,
    autoFocus: Re,
    autoPlay: Re,
    blocking: nt,
    capture: null,
    charSet: null,
    checked: Re,
    cite: null,
    className: nt,
    cols: J,
    colSpan: null,
    content: null,
    contentEditable: St,
    controls: Re,
    controlsList: nt,
    coords: J | la,
    crossOrigin: null,
    data: null,
    dateTime: null,
    decoding: null,
    default: Re,
    defer: Re,
    dir: null,
    dirName: null,
    disabled: Re,
    download: Zb,
    draggable: St,
    encType: null,
    enterKeyHint: null,
    fetchPriority: null,
    form: null,
    formAction: null,
    formEncType: null,
    formMethod: null,
    formNoValidate: Re,
    formTarget: null,
    headers: nt,
    height: J,
    hidden: Re,
    high: J,
    href: null,
    hrefLang: null,
    htmlFor: nt,
    httpEquiv: nt,
    id: null,
    imageSizes: null,
    imageSrcSet: null,
    inert: Re,
    inputMode: null,
    integrity: null,
    is: null,
    isMap: Re,
    itemId: null,
    itemProp: nt,
    itemRef: nt,
    itemScope: Re,
    itemType: nt,
    kind: null,
    label: null,
    lang: null,
    language: null,
    list: null,
    loading: null,
    loop: Re,
    low: J,
    manifest: null,
    max: null,
    maxLength: J,
    media: null,
    method: null,
    min: null,
    minLength: J,
    multiple: Re,
    muted: Re,
    name: null,
    nonce: null,
    noModule: Re,
    noValidate: Re,
    onAbort: null,
    onAfterPrint: null,
    onAuxClick: null,
    onBeforeMatch: null,
    onBeforePrint: null,
    onBeforeToggle: null,
    onBeforeUnload: null,
    onBlur: null,
    onCancel: null,
    onCanPlay: null,
    onCanPlayThrough: null,
    onChange: null,
    onClick: null,
    onClose: null,
    onContextLost: null,
    onContextMenu: null,
    onContextRestored: null,
    onCopy: null,
    onCueChange: null,
    onCut: null,
    onDblClick: null,
    onDrag: null,
    onDragEnd: null,
    onDragEnter: null,
    onDragExit: null,
    onDragLeave: null,
    onDragOver: null,
    onDragStart: null,
    onDrop: null,
    onDurationChange: null,
    onEmptied: null,
    onEnded: null,
    onError: null,
    onFocus: null,
    onFormData: null,
    onHashChange: null,
    onInput: null,
    onInvalid: null,
    onKeyDown: null,
    onKeyPress: null,
    onKeyUp: null,
    onLanguageChange: null,
    onLoad: null,
    onLoadedData: null,
    onLoadedMetadata: null,
    onLoadEnd: null,
    onLoadStart: null,
    onMessage: null,
    onMessageError: null,
    onMouseDown: null,
    onMouseEnter: null,
    onMouseLeave: null,
    onMouseMove: null,
    onMouseOut: null,
    onMouseOver: null,
    onMouseUp: null,
    onOffline: null,
    onOnline: null,
    onPageHide: null,
    onPageShow: null,
    onPaste: null,
    onPause: null,
    onPlay: null,
    onPlaying: null,
    onPopState: null,
    onProgress: null,
    onRateChange: null,
    onRejectionHandled: null,
    onReset: null,
    onResize: null,
    onScroll: null,
    onScrollEnd: null,
    onSecurityPolicyViolation: null,
    onSeeked: null,
    onSeeking: null,
    onSelect: null,
    onSlotChange: null,
    onStalled: null,
    onStorage: null,
    onSubmit: null,
    onSuspend: null,
    onTimeUpdate: null,
    onToggle: null,
    onUnhandledRejection: null,
    onUnload: null,
    onVolumeChange: null,
    onWaiting: null,
    onWheel: null,
    open: Re,
    optimum: J,
    pattern: null,
    ping: nt,
    placeholder: null,
    playsInline: Re,
    popover: null,
    popoverTarget: null,
    popoverTargetAction: null,
    poster: null,
    preload: null,
    readOnly: Re,
    referrerPolicy: null,
    rel: nt,
    required: Re,
    reversed: Re,
    rows: J,
    rowSpan: J,
    sandbox: nt,
    scope: null,
    scoped: Re,
    seamless: Re,
    selected: Re,
    shadowRootClonable: Re,
    shadowRootDelegatesFocus: Re,
    shadowRootMode: null,
    shape: null,
    size: J,
    sizes: null,
    slot: null,
    span: J,
    spellCheck: St,
    src: null,
    srcDoc: null,
    srcLang: null,
    srcSet: null,
    start: J,
    step: null,
    style: null,
    tabIndex: J,
    target: null,
    title: null,
    translate: null,
    type: null,
    typeMustMatch: Re,
    useMap: null,
    value: St,
    width: J,
    wrap: null,
    writingSuggestions: null,
    // Legacy.
    // See: https://html.spec.whatwg.org/#other-elements,-attributes-and-apis
    align: null,
    // Several. Use CSS `text-align` instead,
    aLink: null,
    // `<body>`. Use CSS `a:active {color}` instead
    archive: nt,
    // `<object>`. List of URIs to archives
    axis: null,
    // `<td>` and `<th>`. Use `scope` on `<th>`
    background: null,
    // `<body>`. Use CSS `background-image` instead
    bgColor: null,
    // `<body>` and table elements. Use CSS `background-color` instead
    border: J,
    // `<table>`. Use CSS `border-width` instead,
    borderColor: null,
    // `<table>`. Use CSS `border-color` instead,
    bottomMargin: J,
    // `<body>`
    cellPadding: null,
    // `<table>`
    cellSpacing: null,
    // `<table>`
    char: null,
    // Several table elements. When `align=char`, sets the character to align on
    charOff: null,
    // Several table elements. When `char`, offsets the alignment
    classId: null,
    // `<object>`
    clear: null,
    // `<br>`. Use CSS `clear` instead
    code: null,
    // `<object>`
    codeBase: null,
    // `<object>`
    codeType: null,
    // `<object>`
    color: null,
    // `<font>` and `<hr>`. Use CSS instead
    compact: Re,
    // Lists. Use CSS to reduce space between items instead
    declare: Re,
    // `<object>`
    event: null,
    // `<script>`
    face: null,
    // `<font>`. Use CSS instead
    frame: null,
    // `<table>`
    frameBorder: null,
    // `<iframe>`. Use CSS `border` instead
    hSpace: J,
    // `<img>` and `<object>`
    leftMargin: J,
    // `<body>`
    link: null,
    // `<body>`. Use CSS `a:link {color: *}` instead
    longDesc: null,
    // `<frame>`, `<iframe>`, and `<img>`. Use an `<a>`
    lowSrc: null,
    // `<img>`. Use a `<picture>`
    marginHeight: J,
    // `<body>`
    marginWidth: J,
    // `<body>`
    noResize: Re,
    // `<frame>`
    noHref: Re,
    // `<area>`. Use no href instead of an explicit `nohref`
    noShade: Re,
    // `<hr>`. Use background-color and height instead of borders
    noWrap: Re,
    // `<td>` and `<th>`
    object: null,
    // `<applet>`
    profile: null,
    // `<head>`
    prompt: null,
    // `<isindex>`
    rev: null,
    // `<link>`
    rightMargin: J,
    // `<body>`
    rules: null,
    // `<table>`
    scheme: null,
    // `<meta>`
    scrolling: St,
    // `<frame>`. Use overflow in the child context
    standby: null,
    // `<object>`
    summary: null,
    // `<table>`
    text: null,
    // `<body>`. Use CSS `color` instead
    topMargin: J,
    // `<body>`
    valueType: null,
    // `<param>`
    version: null,
    // `<html>`. Use a doctype.
    vAlign: null,
    // Several. Use CSS `vertical-align` instead
    vLink: null,
    // `<body>`. Use CSS `a:visited {color}` instead
    vSpace: J,
    // `<img>` and `<object>`
    // Non-standard Properties.
    allowTransparency: null,
    autoCorrect: null,
    autoSave: null,
    disablePictureInPicture: Re,
    disableRemotePlayback: Re,
    prefix: null,
    property: null,
    results: J,
    security: null,
    unselectable: null
  }
}), kA = Na({
  space: "svg",
  attributes: {
    accentHeight: "accent-height",
    alignmentBaseline: "alignment-baseline",
    arabicForm: "arabic-form",
    baselineShift: "baseline-shift",
    capHeight: "cap-height",
    className: "class",
    clipPath: "clip-path",
    clipRule: "clip-rule",
    colorInterpolation: "color-interpolation",
    colorInterpolationFilters: "color-interpolation-filters",
    colorProfile: "color-profile",
    colorRendering: "color-rendering",
    crossOrigin: "crossorigin",
    dataType: "datatype",
    dominantBaseline: "dominant-baseline",
    enableBackground: "enable-background",
    fillOpacity: "fill-opacity",
    fillRule: "fill-rule",
    floodColor: "flood-color",
    floodOpacity: "flood-opacity",
    fontFamily: "font-family",
    fontSize: "font-size",
    fontSizeAdjust: "font-size-adjust",
    fontStretch: "font-stretch",
    fontStyle: "font-style",
    fontVariant: "font-variant",
    fontWeight: "font-weight",
    glyphName: "glyph-name",
    glyphOrientationHorizontal: "glyph-orientation-horizontal",
    glyphOrientationVertical: "glyph-orientation-vertical",
    hrefLang: "hreflang",
    horizAdvX: "horiz-adv-x",
    horizOriginX: "horiz-origin-x",
    horizOriginY: "horiz-origin-y",
    imageRendering: "image-rendering",
    letterSpacing: "letter-spacing",
    lightingColor: "lighting-color",
    markerEnd: "marker-end",
    markerMid: "marker-mid",
    markerStart: "marker-start",
    navDown: "nav-down",
    navDownLeft: "nav-down-left",
    navDownRight: "nav-down-right",
    navLeft: "nav-left",
    navNext: "nav-next",
    navPrev: "nav-prev",
    navRight: "nav-right",
    navUp: "nav-up",
    navUpLeft: "nav-up-left",
    navUpRight: "nav-up-right",
    onAbort: "onabort",
    onActivate: "onactivate",
    onAfterPrint: "onafterprint",
    onBeforePrint: "onbeforeprint",
    onBegin: "onbegin",
    onCancel: "oncancel",
    onCanPlay: "oncanplay",
    onCanPlayThrough: "oncanplaythrough",
    onChange: "onchange",
    onClick: "onclick",
    onClose: "onclose",
    onCopy: "oncopy",
    onCueChange: "oncuechange",
    onCut: "oncut",
    onDblClick: "ondblclick",
    onDrag: "ondrag",
    onDragEnd: "ondragend",
    onDragEnter: "ondragenter",
    onDragExit: "ondragexit",
    onDragLeave: "ondragleave",
    onDragOver: "ondragover",
    onDragStart: "ondragstart",
    onDrop: "ondrop",
    onDurationChange: "ondurationchange",
    onEmptied: "onemptied",
    onEnd: "onend",
    onEnded: "onended",
    onError: "onerror",
    onFocus: "onfocus",
    onFocusIn: "onfocusin",
    onFocusOut: "onfocusout",
    onHashChange: "onhashchange",
    onInput: "oninput",
    onInvalid: "oninvalid",
    onKeyDown: "onkeydown",
    onKeyPress: "onkeypress",
    onKeyUp: "onkeyup",
    onLoad: "onload",
    onLoadedData: "onloadeddata",
    onLoadedMetadata: "onloadedmetadata",
    onLoadStart: "onloadstart",
    onMessage: "onmessage",
    onMouseDown: "onmousedown",
    onMouseEnter: "onmouseenter",
    onMouseLeave: "onmouseleave",
    onMouseMove: "onmousemove",
    onMouseOut: "onmouseout",
    onMouseOver: "onmouseover",
    onMouseUp: "onmouseup",
    onMouseWheel: "onmousewheel",
    onOffline: "onoffline",
    onOnline: "ononline",
    onPageHide: "onpagehide",
    onPageShow: "onpageshow",
    onPaste: "onpaste",
    onPause: "onpause",
    onPlay: "onplay",
    onPlaying: "onplaying",
    onPopState: "onpopstate",
    onProgress: "onprogress",
    onRateChange: "onratechange",
    onRepeat: "onrepeat",
    onReset: "onreset",
    onResize: "onresize",
    onScroll: "onscroll",
    onSeeked: "onseeked",
    onSeeking: "onseeking",
    onSelect: "onselect",
    onShow: "onshow",
    onStalled: "onstalled",
    onStorage: "onstorage",
    onSubmit: "onsubmit",
    onSuspend: "onsuspend",
    onTimeUpdate: "ontimeupdate",
    onToggle: "ontoggle",
    onUnload: "onunload",
    onVolumeChange: "onvolumechange",
    onWaiting: "onwaiting",
    onZoom: "onzoom",
    overlinePosition: "overline-position",
    overlineThickness: "overline-thickness",
    paintOrder: "paint-order",
    panose1: "panose-1",
    pointerEvents: "pointer-events",
    referrerPolicy: "referrerpolicy",
    renderingIntent: "rendering-intent",
    shapeRendering: "shape-rendering",
    stopColor: "stop-color",
    stopOpacity: "stop-opacity",
    strikethroughPosition: "strikethrough-position",
    strikethroughThickness: "strikethrough-thickness",
    strokeDashArray: "stroke-dasharray",
    strokeDashOffset: "stroke-dashoffset",
    strokeLineCap: "stroke-linecap",
    strokeLineJoin: "stroke-linejoin",
    strokeMiterLimit: "stroke-miterlimit",
    strokeOpacity: "stroke-opacity",
    strokeWidth: "stroke-width",
    tabIndex: "tabindex",
    textAnchor: "text-anchor",
    textDecoration: "text-decoration",
    textRendering: "text-rendering",
    transformOrigin: "transform-origin",
    typeOf: "typeof",
    underlinePosition: "underline-position",
    underlineThickness: "underline-thickness",
    unicodeBidi: "unicode-bidi",
    unicodeRange: "unicode-range",
    unitsPerEm: "units-per-em",
    vAlphabetic: "v-alphabetic",
    vHanging: "v-hanging",
    vIdeographic: "v-ideographic",
    vMathematical: "v-mathematical",
    vectorEffect: "vector-effect",
    vertAdvY: "vert-adv-y",
    vertOriginX: "vert-origin-x",
    vertOriginY: "vert-origin-y",
    wordSpacing: "word-spacing",
    writingMode: "writing-mode",
    xHeight: "x-height",
    // These were camelcased in Tiny. Now lowercased in SVG 2
    playbackOrder: "playbackorder",
    timelineBegin: "timelinebegin"
  },
  transform: Yb,
  properties: {
    about: In,
    accentHeight: J,
    accumulate: null,
    additive: null,
    alignmentBaseline: null,
    alphabetic: J,
    amplitude: J,
    arabicForm: null,
    ascent: J,
    attributeName: null,
    attributeType: null,
    azimuth: J,
    bandwidth: null,
    baselineShift: null,
    baseFrequency: null,
    baseProfile: null,
    bbox: null,
    begin: null,
    bias: J,
    by: null,
    calcMode: null,
    capHeight: J,
    className: nt,
    clip: null,
    clipPath: null,
    clipPathUnits: null,
    clipRule: null,
    color: null,
    colorInterpolation: null,
    colorInterpolationFilters: null,
    colorProfile: null,
    colorRendering: null,
    content: null,
    contentScriptType: null,
    contentStyleType: null,
    crossOrigin: null,
    cursor: null,
    cx: null,
    cy: null,
    d: null,
    dataType: null,
    defaultAction: null,
    descent: J,
    diffuseConstant: J,
    direction: null,
    display: null,
    dur: null,
    divisor: J,
    dominantBaseline: null,
    download: Re,
    dx: null,
    dy: null,
    edgeMode: null,
    editable: null,
    elevation: J,
    enableBackground: null,
    end: null,
    event: null,
    exponent: J,
    externalResourcesRequired: null,
    fill: null,
    fillOpacity: J,
    fillRule: null,
    filter: null,
    filterRes: null,
    filterUnits: null,
    floodColor: null,
    floodOpacity: null,
    focusable: null,
    focusHighlight: null,
    fontFamily: null,
    fontSize: null,
    fontSizeAdjust: null,
    fontStretch: null,
    fontStyle: null,
    fontVariant: null,
    fontWeight: null,
    format: null,
    fr: null,
    from: null,
    fx: null,
    fy: null,
    g1: la,
    g2: la,
    glyphName: la,
    glyphOrientationHorizontal: null,
    glyphOrientationVertical: null,
    glyphRef: null,
    gradientTransform: null,
    gradientUnits: null,
    handler: null,
    hanging: J,
    hatchContentUnits: null,
    hatchUnits: null,
    height: null,
    href: null,
    hrefLang: null,
    horizAdvX: J,
    horizOriginX: J,
    horizOriginY: J,
    id: null,
    ideographic: J,
    imageRendering: null,
    initialVisibility: null,
    in: null,
    in2: null,
    intercept: J,
    k: J,
    k1: J,
    k2: J,
    k3: J,
    k4: J,
    kernelMatrix: In,
    kernelUnitLength: null,
    keyPoints: null,
    // SEMI_COLON_SEPARATED
    keySplines: null,
    // SEMI_COLON_SEPARATED
    keyTimes: null,
    // SEMI_COLON_SEPARATED
    kerning: null,
    lang: null,
    lengthAdjust: null,
    letterSpacing: null,
    lightingColor: null,
    limitingConeAngle: J,
    local: null,
    markerEnd: null,
    markerMid: null,
    markerStart: null,
    markerHeight: null,
    markerUnits: null,
    markerWidth: null,
    mask: null,
    maskContentUnits: null,
    maskUnits: null,
    mathematical: null,
    max: null,
    media: null,
    mediaCharacterEncoding: null,
    mediaContentEncodings: null,
    mediaSize: J,
    mediaTime: null,
    method: null,
    min: null,
    mode: null,
    name: null,
    navDown: null,
    navDownLeft: null,
    navDownRight: null,
    navLeft: null,
    navNext: null,
    navPrev: null,
    navRight: null,
    navUp: null,
    navUpLeft: null,
    navUpRight: null,
    numOctaves: null,
    observer: null,
    offset: null,
    onAbort: null,
    onActivate: null,
    onAfterPrint: null,
    onBeforePrint: null,
    onBegin: null,
    onCancel: null,
    onCanPlay: null,
    onCanPlayThrough: null,
    onChange: null,
    onClick: null,
    onClose: null,
    onCopy: null,
    onCueChange: null,
    onCut: null,
    onDblClick: null,
    onDrag: null,
    onDragEnd: null,
    onDragEnter: null,
    onDragExit: null,
    onDragLeave: null,
    onDragOver: null,
    onDragStart: null,
    onDrop: null,
    onDurationChange: null,
    onEmptied: null,
    onEnd: null,
    onEnded: null,
    onError: null,
    onFocus: null,
    onFocusIn: null,
    onFocusOut: null,
    onHashChange: null,
    onInput: null,
    onInvalid: null,
    onKeyDown: null,
    onKeyPress: null,
    onKeyUp: null,
    onLoad: null,
    onLoadedData: null,
    onLoadedMetadata: null,
    onLoadStart: null,
    onMessage: null,
    onMouseDown: null,
    onMouseEnter: null,
    onMouseLeave: null,
    onMouseMove: null,
    onMouseOut: null,
    onMouseOver: null,
    onMouseUp: null,
    onMouseWheel: null,
    onOffline: null,
    onOnline: null,
    onPageHide: null,
    onPageShow: null,
    onPaste: null,
    onPause: null,
    onPlay: null,
    onPlaying: null,
    onPopState: null,
    onProgress: null,
    onRateChange: null,
    onRepeat: null,
    onReset: null,
    onResize: null,
    onScroll: null,
    onSeeked: null,
    onSeeking: null,
    onSelect: null,
    onShow: null,
    onStalled: null,
    onStorage: null,
    onSubmit: null,
    onSuspend: null,
    onTimeUpdate: null,
    onToggle: null,
    onUnload: null,
    onVolumeChange: null,
    onWaiting: null,
    onZoom: null,
    opacity: null,
    operator: null,
    order: null,
    orient: null,
    orientation: null,
    origin: null,
    overflow: null,
    overlay: null,
    overlinePosition: J,
    overlineThickness: J,
    paintOrder: null,
    panose1: null,
    path: null,
    pathLength: J,
    patternContentUnits: null,
    patternTransform: null,
    patternUnits: null,
    phase: null,
    ping: nt,
    pitch: null,
    playbackOrder: null,
    pointerEvents: null,
    points: null,
    pointsAtX: J,
    pointsAtY: J,
    pointsAtZ: J,
    preserveAlpha: null,
    preserveAspectRatio: null,
    primitiveUnits: null,
    propagate: null,
    property: In,
    r: null,
    radius: null,
    referrerPolicy: null,
    refX: null,
    refY: null,
    rel: In,
    rev: In,
    renderingIntent: null,
    repeatCount: null,
    repeatDur: null,
    requiredExtensions: In,
    requiredFeatures: In,
    requiredFonts: In,
    requiredFormats: In,
    resource: null,
    restart: null,
    result: null,
    rotate: null,
    rx: null,
    ry: null,
    scale: null,
    seed: null,
    shapeRendering: null,
    side: null,
    slope: null,
    snapshotTime: null,
    specularConstant: J,
    specularExponent: J,
    spreadMethod: null,
    spacing: null,
    startOffset: null,
    stdDeviation: null,
    stemh: null,
    stemv: null,
    stitchTiles: null,
    stopColor: null,
    stopOpacity: null,
    strikethroughPosition: J,
    strikethroughThickness: J,
    string: null,
    stroke: null,
    strokeDashArray: In,
    strokeDashOffset: null,
    strokeLineCap: null,
    strokeLineJoin: null,
    strokeMiterLimit: J,
    strokeOpacity: J,
    strokeWidth: null,
    style: null,
    surfaceScale: J,
    syncBehavior: null,
    syncBehaviorDefault: null,
    syncMaster: null,
    syncTolerance: null,
    syncToleranceDefault: null,
    systemLanguage: In,
    tabIndex: J,
    tableValues: null,
    target: null,
    targetX: J,
    targetY: J,
    textAnchor: null,
    textDecoration: null,
    textRendering: null,
    textLength: null,
    timelineBegin: null,
    title: null,
    transformBehavior: null,
    type: null,
    typeOf: In,
    to: null,
    transform: null,
    transformOrigin: null,
    u1: null,
    u2: null,
    underlinePosition: J,
    underlineThickness: J,
    unicode: null,
    unicodeBidi: null,
    unicodeRange: null,
    unitsPerEm: J,
    values: null,
    vAlphabetic: J,
    vMathematical: J,
    vectorEffect: null,
    vHanging: J,
    vIdeographic: J,
    version: null,
    vertAdvY: J,
    vertOriginX: J,
    vertOriginY: J,
    viewBox: null,
    viewTarget: null,
    visibility: null,
    width: null,
    widths: null,
    wordSpacing: null,
    writingMode: null,
    x: null,
    x1: null,
    x2: null,
    xChannelSelector: null,
    xHeight: J,
    y: null,
    y1: null,
    y2: null,
    yChannelSelector: null,
    z: null,
    zoomAndPan: null
  }
}), TA = /^data[-\w.:]+$/i, yh = /-[a-z]/g, RA = /[A-Z]/g;
function NA(e, t) {
  const n = Hu(t);
  let r = t, i = $n;
  if (n in e.normal)
    return e.property[e.normal[n]];
  if (n.length > 4 && n.slice(0, 4) === "data" && TA.test(t)) {
    if (t.charAt(4) === "-") {
      const a = t.slice(5).replace(yh, MA);
      r = "data" + a.charAt(0).toUpperCase() + a.slice(1);
    } else {
      const a = t.slice(4);
      if (!yh.test(a)) {
        let s = a.replace(RA, OA);
        s.charAt(0) !== "-" && (s = "-" + s), t = "data" + s;
      }
    }
    i = rf;
  }
  return new i(r, t);
}
function OA(e) {
  return "-" + e.toLowerCase();
}
function MA(e) {
  return e.charAt(1).toUpperCase();
}
const PA = {
  classId: "classID",
  dataType: "datatype",
  itemId: "itemID",
  strokeDashArray: "strokeDasharray",
  strokeDashOffset: "strokeDashoffset",
  strokeLineCap: "strokeLinecap",
  strokeLineJoin: "strokeLinejoin",
  strokeMiterLimit: "strokeMiterlimit",
  typeOf: "typeof",
  xLinkActuate: "xlinkActuate",
  xLinkArcRole: "xlinkArcrole",
  xLinkHref: "xlinkHref",
  xLinkRole: "xlinkRole",
  xLinkShow: "xlinkShow",
  xLinkTitle: "xlinkTitle",
  xLinkType: "xlinkType",
  xmlnsXLink: "xmlnsXlink"
}, DA = Wb([Xb, $b, qb, Kb, AA], "html"), af = Wb([Xb, $b, qb, Kb, kA], "svg");
function LA(e) {
  return e.join(" ").trim();
}
var Zi = {}, Uc, _h;
function FA() {
  if (_h) return Uc;
  _h = 1;
  var e = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g, t = /\n/g, n = /^\s*/, r = /^(\*?[-#/*\\\w]+(\[[0-9a-z_-]+\])?)\s*/, i = /^:\s*/, a = /^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};])+)/, s = /^[;\s]*/, o = /^\s+|\s+$/g, l = `
`, c = "/", u = "*", d = "", f = "comment", p = "declaration";
  Uc = function(g, m) {
    if (typeof g != "string")
      throw new TypeError("First argument must be a string");
    if (!g) return [];
    m = m || {};
    var b = 1, y = 1;
    function v(L) {
      var z = L.match(t);
      z && (b += z.length);
      var U = L.lastIndexOf(l);
      y = ~U ? L.length - U : y + L.length;
    }
    function E() {
      var L = { line: b, column: y };
      return function(z) {
        return z.position = new _(L), T(), z;
      };
    }
    function _(L) {
      this.start = L, this.end = { line: b, column: y }, this.source = m.source;
    }
    _.prototype.content = g;
    function x(L) {
      var z = new Error(
        m.source + ":" + b + ":" + y + ": " + L
      );
      if (z.reason = L, z.filename = m.source, z.line = b, z.column = y, z.source = g, !m.silent) throw z;
    }
    function I(L) {
      var z = L.exec(g);
      if (z) {
        var U = z[0];
        return v(U), g = g.slice(U.length), z;
      }
    }
    function T() {
      I(n);
    }
    function O(L) {
      var z;
      for (L = L || []; z = k(); )
        z !== !1 && L.push(z);
      return L;
    }
    function k() {
      var L = E();
      if (!(c != g.charAt(0) || u != g.charAt(1))) {
        for (var z = 2; d != g.charAt(z) && (u != g.charAt(z) || c != g.charAt(z + 1)); )
          ++z;
        if (z += 2, d === g.charAt(z - 1))
          return x("End of comment missing");
        var U = g.slice(2, z - 2);
        return y += 2, v(U), g = g.slice(z), y += 2, L({
          type: f,
          comment: U
        });
      }
    }
    function W() {
      var L = E(), z = I(r);
      if (z) {
        if (k(), !I(i)) return x("property missing ':'");
        var U = I(a), $ = L({
          type: p,
          property: h(z[0].replace(e, d)),
          value: U ? h(U[0].replace(e, d)) : d
        });
        return I(s), $;
      }
    }
    function M() {
      var L = [];
      O(L);
      for (var z; z = W(); )
        z !== !1 && (L.push(z), O(L));
      return L;
    }
    return T(), M();
  };
  function h(g) {
    return g ? g.replace(o, d) : d;
  }
  return Uc;
}
var vh;
function BA() {
  if (vh) return Zi;
  vh = 1;
  var e = Zi && Zi.__importDefault || function(r) {
    return r && r.__esModule ? r : { default: r };
  };
  Object.defineProperty(Zi, "__esModule", { value: !0 }), Zi.default = n;
  var t = e(FA());
  function n(r, i) {
    var a = null;
    if (!r || typeof r != "string")
      return a;
    var s = (0, t.default)(r), o = typeof i == "function";
    return s.forEach(function(l) {
      if (l.type === "declaration") {
        var c = l.property, u = l.value;
        o ? i(c, u, l) : u && (a = a || {}, a[c] = u);
      }
    }), a;
  }
  return Zi;
}
var zA = BA();
const xh = /* @__PURE__ */ Dd(zA), VA = xh.default || xh, Qb = ey("end"), sf = ey("start");
function ey(e) {
  return t;
  function t(n) {
    const r = n && n.position && n.position[e] || {};
    if (typeof r.line == "number" && r.line > 0 && typeof r.column == "number" && r.column > 0)
      return {
        line: r.line,
        column: r.column,
        offset: typeof r.offset == "number" && r.offset > -1 ? r.offset : void 0
      };
  }
}
function GA(e) {
  const t = sf(e), n = Qb(e);
  if (t && n)
    return { start: t, end: n };
}
function os(e) {
  return !e || typeof e != "object" ? "" : "position" in e || "type" in e ? Eh(e.position) : "start" in e || "end" in e ? Eh(e) : "line" in e || "column" in e ? Zu(e) : "";
}
function Zu(e) {
  return wh(e && e.line) + ":" + wh(e && e.column);
}
function Eh(e) {
  return Zu(e && e.start) + "-" + Zu(e && e.end);
}
function wh(e) {
  return e && typeof e == "number" ? e : 1;
}
class Qt extends Error {
  /**
   * Create a message for `reason`.
   *
   * >  **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {Options | null | undefined} [options]
   * @returns
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | Options | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns
   *   Instance of `VFileMessage`.
   */
  // eslint-disable-next-line complexity
  constructor(t, n, r) {
    super(), typeof n == "string" && (r = n, n = void 0);
    let i = "", a = {}, s = !1;
    if (n && ("line" in n && "column" in n ? a = { place: n } : "start" in n && "end" in n ? a = { place: n } : "type" in n ? a = {
      ancestors: [n],
      place: n.position
    } : a = { ...n }), typeof t == "string" ? i = t : !a.cause && t && (s = !0, i = t.message, a.cause = t), !a.ruleId && !a.source && typeof r == "string") {
      const l = r.indexOf(":");
      l === -1 ? a.ruleId = r : (a.source = r.slice(0, l), a.ruleId = r.slice(l + 1));
    }
    if (!a.place && a.ancestors && a.ancestors) {
      const l = a.ancestors[a.ancestors.length - 1];
      l && (a.place = l.position);
    }
    const o = a.place && "start" in a.place ? a.place.start : a.place;
    this.ancestors = a.ancestors || void 0, this.cause = a.cause || void 0, this.column = o ? o.column : void 0, this.fatal = void 0, this.file, this.message = i, this.line = o ? o.line : void 0, this.name = os(a.place) || "1:1", this.place = a.place || void 0, this.reason = this.message, this.ruleId = a.ruleId || void 0, this.source = a.source || void 0, this.stack = s && a.cause && typeof a.cause.stack == "string" ? a.cause.stack : "", this.actual, this.expected, this.note, this.url;
  }
}
Qt.prototype.file = "";
Qt.prototype.name = "";
Qt.prototype.reason = "";
Qt.prototype.message = "";
Qt.prototype.stack = "";
Qt.prototype.column = void 0;
Qt.prototype.line = void 0;
Qt.prototype.ancestors = void 0;
Qt.prototype.cause = void 0;
Qt.prototype.fatal = void 0;
Qt.prototype.place = void 0;
Qt.prototype.ruleId = void 0;
Qt.prototype.source = void 0;
const of = {}.hasOwnProperty, jA = /* @__PURE__ */ new Map(), UA = /[A-Z]/g, HA = /-([a-z])/g, WA = /* @__PURE__ */ new Set(["table", "tbody", "thead", "tfoot", "tr"]), ZA = /* @__PURE__ */ new Set(["td", "th"]), ty = "https://github.com/syntax-tree/hast-util-to-jsx-runtime";
function $A(e, t) {
  if (!t || t.Fragment === void 0)
    throw new TypeError("Expected `Fragment` in options");
  const n = t.filePath || void 0;
  let r;
  if (t.development) {
    if (typeof t.jsxDEV != "function")
      throw new TypeError(
        "Expected `jsxDEV` in options when `development: true`"
      );
    r = tk(n, t.jsxDEV);
  } else {
    if (typeof t.jsx != "function")
      throw new TypeError("Expected `jsx` in production options");
    if (typeof t.jsxs != "function")
      throw new TypeError("Expected `jsxs` in production options");
    r = ek(n, t.jsx, t.jsxs);
  }
  const i = {
    Fragment: t.Fragment,
    ancestors: [],
    components: t.components || {},
    create: r,
    elementAttributeNameCase: t.elementAttributeNameCase || "react",
    evaluater: t.createEvaluater ? t.createEvaluater() : void 0,
    filePath: n,
    ignoreInvalidStyle: t.ignoreInvalidStyle || !1,
    passKeys: t.passKeys !== !1,
    passNode: t.passNode || !1,
    schema: t.space === "svg" ? af : DA,
    stylePropertyNameCase: t.stylePropertyNameCase || "dom",
    tableCellAlignToStyle: t.tableCellAlignToStyle !== !1
  }, a = ny(i, e, void 0);
  return a && typeof a != "string" ? a : i.create(
    e,
    i.Fragment,
    { children: a || void 0 },
    void 0
  );
}
function ny(e, t, n) {
  if (t.type === "element")
    return XA(e, t, n);
  if (t.type === "mdxFlowExpression" || t.type === "mdxTextExpression")
    return YA(e, t);
  if (t.type === "mdxJsxFlowElement" || t.type === "mdxJsxTextElement")
    return qA(e, t, n);
  if (t.type === "mdxjsEsm")
    return JA(e, t);
  if (t.type === "root")
    return KA(e, t, n);
  if (t.type === "text")
    return QA(e, t);
}
function XA(e, t, n) {
  const r = e.schema;
  let i = r;
  t.tagName.toLowerCase() === "svg" && r.space === "html" && (i = af, e.schema = i), e.ancestors.push(t);
  const a = iy(e, t.tagName, !1), s = nk(e, t);
  let o = cf(e, t);
  return WA.has(t.tagName) && (o = o.filter(function(l) {
    return typeof l == "string" ? !CA(l) : !0;
  })), ry(e, s, a, t), lf(s, o), e.ancestors.pop(), e.schema = r, e.create(t, a, s, n);
}
function YA(e, t) {
  if (t.data && t.data.estree && e.evaluater) {
    const r = t.data.estree.body[0];
    return r.type, /** @type {Child | undefined} */
    e.evaluater.evaluateExpression(r.expression);
  }
  Ns(e, t.position);
}
function JA(e, t) {
  if (t.data && t.data.estree && e.evaluater)
    return (
      /** @type {Child | undefined} */
      e.evaluater.evaluateProgram(t.data.estree)
    );
  Ns(e, t.position);
}
function qA(e, t, n) {
  const r = e.schema;
  let i = r;
  t.name === "svg" && r.space === "html" && (i = af, e.schema = i), e.ancestors.push(t);
  const a = t.name === null ? e.Fragment : iy(e, t.name, !0), s = rk(e, t), o = cf(e, t);
  return ry(e, s, a, t), lf(s, o), e.ancestors.pop(), e.schema = r, e.create(t, a, s, n);
}
function KA(e, t, n) {
  const r = {};
  return lf(r, cf(e, t)), e.create(t, e.Fragment, r, n);
}
function QA(e, t) {
  return t.value;
}
function ry(e, t, n, r) {
  typeof n != "string" && n !== e.Fragment && e.passNode && (t.node = r);
}
function lf(e, t) {
  if (t.length > 0) {
    const n = t.length > 1 ? t : t[0];
    n && (e.children = n);
  }
}
function ek(e, t, n) {
  return r;
  function r(i, a, s, o) {
    const c = Array.isArray(s.children) ? n : t;
    return o ? c(a, s, o) : c(a, s);
  }
}
function tk(e, t) {
  return n;
  function n(r, i, a, s) {
    const o = Array.isArray(a.children), l = sf(r);
    return t(
      i,
      a,
      s,
      o,
      {
        columnNumber: l ? l.column - 1 : void 0,
        fileName: e,
        lineNumber: l ? l.line : void 0
      },
      void 0
    );
  }
}
function nk(e, t) {
  const n = {};
  let r, i;
  for (i in t.properties)
    if (i !== "children" && of.call(t.properties, i)) {
      const a = ik(e, i, t.properties[i]);
      if (a) {
        const [s, o] = a;
        e.tableCellAlignToStyle && s === "align" && typeof o == "string" && ZA.has(t.tagName) ? r = o : n[s] = o;
      }
    }
  if (r) {
    const a = (
      /** @type {Style} */
      n.style || (n.style = {})
    );
    a[e.stylePropertyNameCase === "css" ? "text-align" : "textAlign"] = r;
  }
  return n;
}
function rk(e, t) {
  const n = {};
  for (const r of t.attributes)
    if (r.type === "mdxJsxExpressionAttribute")
      if (r.data && r.data.estree && e.evaluater) {
        const a = r.data.estree.body[0];
        a.type;
        const s = a.expression;
        s.type;
        const o = s.properties[0];
        o.type, Object.assign(
          n,
          e.evaluater.evaluateExpression(o.argument)
        );
      } else
        Ns(e, t.position);
    else {
      const i = r.name;
      let a;
      if (r.value && typeof r.value == "object")
        if (r.value.data && r.value.data.estree && e.evaluater) {
          const o = r.value.data.estree.body[0];
          o.type, a = e.evaluater.evaluateExpression(o.expression);
        } else
          Ns(e, t.position);
      else
        a = r.value === null ? !0 : r.value;
      n[i] = /** @type {Props[keyof Props]} */
      a;
    }
  return n;
}
function cf(e, t) {
  const n = [];
  let r = -1;
  const i = e.passKeys ? /* @__PURE__ */ new Map() : jA;
  for (; ++r < t.children.length; ) {
    const a = t.children[r];
    let s;
    if (e.passKeys) {
      const l = a.type === "element" ? a.tagName : a.type === "mdxJsxFlowElement" || a.type === "mdxJsxTextElement" ? a.name : void 0;
      if (l) {
        const c = i.get(l) || 0;
        s = l + "-" + c, i.set(l, c + 1);
      }
    }
    const o = ny(e, a, s);
    o !== void 0 && n.push(o);
  }
  return n;
}
function ik(e, t, n) {
  const r = NA(e.schema, t);
  if (!(n == null || typeof n == "number" && Number.isNaN(n))) {
    if (Array.isArray(n) && (n = r.commaSeparated ? _A(n) : LA(n)), r.property === "style") {
      let i = typeof n == "object" ? n : ak(e, String(n));
      return e.stylePropertyNameCase === "css" && (i = sk(i)), ["style", i];
    }
    return [
      e.elementAttributeNameCase === "react" && r.space ? PA[r.property] || r.property : r.attribute,
      n
    ];
  }
}
function ak(e, t) {
  const n = {};
  try {
    VA(t, r);
  } catch (i) {
    if (!e.ignoreInvalidStyle) {
      const a = (
        /** @type {Error} */
        i
      ), s = new Qt("Cannot parse `style` attribute", {
        ancestors: e.ancestors,
        cause: a,
        ruleId: "style",
        source: "hast-util-to-jsx-runtime"
      });
      throw s.file = e.filePath || void 0, s.url = ty + "#cannot-parse-style-attribute", s;
    }
  }
  return n;
  function r(i, a) {
    let s = i;
    s.slice(0, 2) !== "--" && (s.slice(0, 4) === "-ms-" && (s = "ms-" + s.slice(4)), s = s.replace(HA, lk)), n[s] = a;
  }
}
function iy(e, t, n) {
  let r;
  if (!n)
    r = { type: "Literal", value: t };
  else if (t.includes(".")) {
    const i = t.split(".");
    let a = -1, s;
    for (; ++a < i.length; ) {
      const o = gh(i[a]) ? { type: "Identifier", name: i[a] } : { type: "Literal", value: i[a] };
      s = s ? {
        type: "MemberExpression",
        object: s,
        property: o,
        computed: !!(a && o.type === "Literal"),
        optional: !1
      } : o;
    }
    r = s;
  } else
    r = gh(t) && !/^[a-z]/.test(t) ? { type: "Identifier", name: t } : { type: "Literal", value: t };
  if (r.type === "Literal") {
    const i = (
      /** @type {keyof JSX.IntrinsicElements} */
      r.value
    );
    return of.call(e.components, i) ? e.components[i] : i;
  }
  if (e.evaluater)
    return e.evaluater.evaluateExpression(r);
  Ns(e);
}
function Ns(e, t) {
  const n = new Qt(
    "Cannot handle MDX estrees without `createEvaluater`",
    {
      ancestors: e.ancestors,
      place: t,
      ruleId: "mdx-estree",
      source: "hast-util-to-jsx-runtime"
    }
  );
  throw n.file = e.filePath || void 0, n.url = ty + "#cannot-handle-mdx-estrees-without-createevaluater", n;
}
function sk(e) {
  const t = {};
  let n;
  for (n in e)
    of.call(e, n) && (t[ok(n)] = e[n]);
  return t;
}
function ok(e) {
  let t = e.replace(UA, ck);
  return t.slice(0, 3) === "ms-" && (t = "-" + t), t;
}
function lk(e, t) {
  return t.toUpperCase();
}
function ck(e) {
  return "-" + e.toLowerCase();
}
const Hc = {
  action: ["form"],
  cite: ["blockquote", "del", "ins", "q"],
  data: ["object"],
  formAction: ["button", "input"],
  href: ["a", "area", "base", "link"],
  icon: ["menuitem"],
  itemId: null,
  manifest: ["html"],
  ping: ["a", "area"],
  poster: ["video"],
  src: [
    "audio",
    "embed",
    "iframe",
    "img",
    "input",
    "script",
    "source",
    "track",
    "video"
  ]
}, uk = {};
function uf(e, t) {
  const n = uk, r = typeof n.includeImageAlt == "boolean" ? n.includeImageAlt : !0, i = typeof n.includeHtml == "boolean" ? n.includeHtml : !0;
  return ay(e, r, i);
}
function ay(e, t, n) {
  if (dk(e)) {
    if ("value" in e)
      return e.type === "html" && !n ? "" : e.value;
    if (t && "alt" in e && e.alt)
      return e.alt;
    if ("children" in e)
      return Ch(e.children, t, n);
  }
  return Array.isArray(e) ? Ch(e, t, n) : "";
}
function Ch(e, t, n) {
  const r = [];
  let i = -1;
  for (; ++i < e.length; )
    r[i] = ay(e[i], t, n);
  return r.join("");
}
function dk(e) {
  return !!(e && typeof e == "object");
}
const Ih = document.createElement("i");
function df(e) {
  const t = "&" + e + ";";
  Ih.innerHTML = t;
  const n = Ih.textContent;
  return n.charCodeAt(n.length - 1) === 59 && e !== "semi" || n === t ? !1 : n;
}
function Nn(e, t, n, r) {
  const i = e.length;
  let a = 0, s;
  if (t < 0 ? t = -t > i ? 0 : i + t : t = t > i ? i : t, n = n > 0 ? n : 0, r.length < 1e4)
    s = Array.from(r), s.unshift(t, n), e.splice(...s);
  else
    for (n && e.splice(t, n); a < r.length; )
      s = r.slice(a, a + 1e4), s.unshift(t, 0), e.splice(...s), a += 1e4, t += 1e4;
}
function jn(e, t) {
  return e.length > 0 ? (Nn(e, e.length, 0, t), e) : t;
}
const Sh = {}.hasOwnProperty;
function sy(e) {
  const t = {};
  let n = -1;
  for (; ++n < e.length; )
    fk(t, e[n]);
  return t;
}
function fk(e, t) {
  let n;
  for (n in t) {
    const i = (Sh.call(e, n) ? e[n] : void 0) || (e[n] = {}), a = t[n];
    let s;
    if (a)
      for (s in a) {
        Sh.call(i, s) || (i[s] = []);
        const o = a[s];
        pk(
          // @ts-expect-error Looks like a list.
          i[s],
          Array.isArray(o) ? o : o ? [o] : []
        );
      }
  }
}
function pk(e, t) {
  let n = -1;
  const r = [];
  for (; ++n < t.length; )
    (t[n].add === "after" ? e : r).push(t[n]);
  Nn(e, 0, 0, r);
}
function oy(e, t) {
  const n = Number.parseInt(e, t);
  return (
    // C0 except for HT, LF, FF, CR, space.
    n < 9 || n === 11 || n > 13 && n < 32 || // Control character (DEL) of C0, and C1 controls.
    n > 126 && n < 160 || // Lone high surrogates and low surrogates.
    n > 55295 && n < 57344 || // Noncharacters.
    n > 64975 && n < 65008 || /* eslint-disable no-bitwise */
    (n & 65535) === 65535 || (n & 65535) === 65534 || /* eslint-enable no-bitwise */
    // Out of range
    n > 1114111 ? "" : String.fromCodePoint(n)
  );
}
function Qn(e) {
  return e.replace(/[\t\n\r ]+/g, " ").replace(/^ | $/g, "").toLowerCase().toUpperCase();
}
const on = oi(/[A-Za-z]/), Yt = oi(/[\dA-Za-z]/), hk = oi(/[#-'*+\--9=?A-Z^-~]/);
function yl(e) {
  return (
    // Special whitespace codes (which have negative values), C0 and Control
    // character DEL
    e !== null && (e < 32 || e === 127)
  );
}
const $u = oi(/\d/), gk = oi(/[\dA-Fa-f]/), mk = oi(/[!-/:-@[-`{-~]/);
function _e(e) {
  return e !== null && e < -2;
}
function Qe(e) {
  return e !== null && (e < 0 || e === 32);
}
function Le(e) {
  return e === -2 || e === -1 || e === 32;
}
const Ql = oi(new RegExp("\\p{P}|\\p{S}", "u")), Ri = oi(/\s/);
function oi(e) {
  return t;
  function t(n) {
    return n !== null && n > -1 && e.test(String.fromCharCode(n));
  }
}
function Oa(e) {
  const t = [];
  let n = -1, r = 0, i = 0;
  for (; ++n < e.length; ) {
    const a = e.charCodeAt(n);
    let s = "";
    if (a === 37 && Yt(e.charCodeAt(n + 1)) && Yt(e.charCodeAt(n + 2)))
      i = 2;
    else if (a < 128)
      /[!#$&-;=?-Z_a-z~]/.test(String.fromCharCode(a)) || (s = String.fromCharCode(a));
    else if (a > 55295 && a < 57344) {
      const o = e.charCodeAt(n + 1);
      a < 56320 && o > 56319 && o < 57344 ? (s = String.fromCharCode(a, o), i = 1) : s = "";
    } else
      s = String.fromCharCode(a);
    s && (t.push(e.slice(r, n), encodeURIComponent(s)), r = n + i + 1, s = ""), i && (n += i, i = 0);
  }
  return t.join("") + e.slice(r);
}
function je(e, t, n, r) {
  const i = r ? r - 1 : Number.POSITIVE_INFINITY;
  let a = 0;
  return s;
  function s(l) {
    return Le(l) ? (e.enter(n), o(l)) : t(l);
  }
  function o(l) {
    return Le(l) && a++ < i ? (e.consume(l), o) : (e.exit(n), t(l));
  }
}
const bk = {
  tokenize: yk
};
function yk(e) {
  const t = e.attempt(this.parser.constructs.contentInitial, r, i);
  let n;
  return t;
  function r(o) {
    if (o === null) {
      e.consume(o);
      return;
    }
    return e.enter("lineEnding"), e.consume(o), e.exit("lineEnding"), je(e, t, "linePrefix");
  }
  function i(o) {
    return e.enter("paragraph"), a(o);
  }
  function a(o) {
    const l = e.enter("chunkText", {
      contentType: "text",
      previous: n
    });
    return n && (n.next = l), n = l, s(o);
  }
  function s(o) {
    if (o === null) {
      e.exit("chunkText"), e.exit("paragraph"), e.consume(o);
      return;
    }
    return _e(o) ? (e.consume(o), e.exit("chunkText"), a) : (e.consume(o), s);
  }
}
const _k = {
  tokenize: vk
}, Ah = {
  tokenize: xk
};
function vk(e) {
  const t = this, n = [];
  let r = 0, i, a, s;
  return o;
  function o(v) {
    if (r < n.length) {
      const E = n[r];
      return t.containerState = E[1], e.attempt(E[0].continuation, l, c)(v);
    }
    return c(v);
  }
  function l(v) {
    if (r++, t.containerState._closeFlow) {
      t.containerState._closeFlow = void 0, i && y();
      const E = t.events.length;
      let _ = E, x;
      for (; _--; )
        if (t.events[_][0] === "exit" && t.events[_][1].type === "chunkFlow") {
          x = t.events[_][1].end;
          break;
        }
      b(r);
      let I = E;
      for (; I < t.events.length; )
        t.events[I][1].end = {
          ...x
        }, I++;
      return Nn(t.events, _ + 1, 0, t.events.slice(E)), t.events.length = I, c(v);
    }
    return o(v);
  }
  function c(v) {
    if (r === n.length) {
      if (!i)
        return f(v);
      if (i.currentConstruct && i.currentConstruct.concrete)
        return h(v);
      t.interrupt = !!(i.currentConstruct && !i._gfmTableDynamicInterruptHack);
    }
    return t.containerState = {}, e.check(Ah, u, d)(v);
  }
  function u(v) {
    return i && y(), b(r), f(v);
  }
  function d(v) {
    return t.parser.lazy[t.now().line] = r !== n.length, s = t.now().offset, h(v);
  }
  function f(v) {
    return t.containerState = {}, e.attempt(Ah, p, h)(v);
  }
  function p(v) {
    return r++, n.push([t.currentConstruct, t.containerState]), f(v);
  }
  function h(v) {
    if (v === null) {
      i && y(), b(0), e.consume(v);
      return;
    }
    return i = i || t.parser.flow(t.now()), e.enter("chunkFlow", {
      _tokenizer: i,
      contentType: "flow",
      previous: a
    }), g(v);
  }
  function g(v) {
    if (v === null) {
      m(e.exit("chunkFlow"), !0), b(0), e.consume(v);
      return;
    }
    return _e(v) ? (e.consume(v), m(e.exit("chunkFlow")), r = 0, t.interrupt = void 0, o) : (e.consume(v), g);
  }
  function m(v, E) {
    const _ = t.sliceStream(v);
    if (E && _.push(null), v.previous = a, a && (a.next = v), a = v, i.defineSkip(v.start), i.write(_), t.parser.lazy[v.start.line]) {
      let x = i.events.length;
      for (; x--; )
        if (
          // The token starts before the line ending
          i.events[x][1].start.offset < s && // and either is not ended yet
          (!i.events[x][1].end || // or ends after it.
          i.events[x][1].end.offset > s)
        )
          return;
      const I = t.events.length;
      let T = I, O, k;
      for (; T--; )
        if (t.events[T][0] === "exit" && t.events[T][1].type === "chunkFlow") {
          if (O) {
            k = t.events[T][1].end;
            break;
          }
          O = !0;
        }
      for (b(r), x = I; x < t.events.length; )
        t.events[x][1].end = {
          ...k
        }, x++;
      Nn(t.events, T + 1, 0, t.events.slice(I)), t.events.length = x;
    }
  }
  function b(v) {
    let E = n.length;
    for (; E-- > v; ) {
      const _ = n[E];
      t.containerState = _[1], _[0].exit.call(t, e);
    }
    n.length = v;
  }
  function y() {
    i.write([null]), a = void 0, i = void 0, t.containerState._closeFlow = void 0;
  }
}
function xk(e, t, n) {
  return je(e, e.attempt(this.parser.constructs.document, t, n), "linePrefix", this.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4);
}
function xa(e) {
  if (e === null || Qe(e) || Ri(e))
    return 1;
  if (Ql(e))
    return 2;
}
function ec(e, t, n) {
  const r = [];
  let i = -1;
  for (; ++i < e.length; ) {
    const a = e[i].resolveAll;
    a && !r.includes(a) && (t = a(t, n), r.push(a));
  }
  return t;
}
const Xu = {
  name: "attention",
  resolveAll: Ek,
  tokenize: wk
};
function Ek(e, t) {
  let n = -1, r, i, a, s, o, l, c, u;
  for (; ++n < e.length; )
    if (e[n][0] === "enter" && e[n][1].type === "attentionSequence" && e[n][1]._close) {
      for (r = n; r--; )
        if (e[r][0] === "exit" && e[r][1].type === "attentionSequence" && e[r][1]._open && // If the markers are the same:
        t.sliceSerialize(e[r][1]).charCodeAt(0) === t.sliceSerialize(e[n][1]).charCodeAt(0)) {
          if ((e[r][1]._close || e[n][1]._open) && (e[n][1].end.offset - e[n][1].start.offset) % 3 && !((e[r][1].end.offset - e[r][1].start.offset + e[n][1].end.offset - e[n][1].start.offset) % 3))
            continue;
          l = e[r][1].end.offset - e[r][1].start.offset > 1 && e[n][1].end.offset - e[n][1].start.offset > 1 ? 2 : 1;
          const d = {
            ...e[r][1].end
          }, f = {
            ...e[n][1].start
          };
          kh(d, -l), kh(f, l), s = {
            type: l > 1 ? "strongSequence" : "emphasisSequence",
            start: d,
            end: {
              ...e[r][1].end
            }
          }, o = {
            type: l > 1 ? "strongSequence" : "emphasisSequence",
            start: {
              ...e[n][1].start
            },
            end: f
          }, a = {
            type: l > 1 ? "strongText" : "emphasisText",
            start: {
              ...e[r][1].end
            },
            end: {
              ...e[n][1].start
            }
          }, i = {
            type: l > 1 ? "strong" : "emphasis",
            start: {
              ...s.start
            },
            end: {
              ...o.end
            }
          }, e[r][1].end = {
            ...s.start
          }, e[n][1].start = {
            ...o.end
          }, c = [], e[r][1].end.offset - e[r][1].start.offset && (c = jn(c, [["enter", e[r][1], t], ["exit", e[r][1], t]])), c = jn(c, [["enter", i, t], ["enter", s, t], ["exit", s, t], ["enter", a, t]]), c = jn(c, ec(t.parser.constructs.insideSpan.null, e.slice(r + 1, n), t)), c = jn(c, [["exit", a, t], ["enter", o, t], ["exit", o, t], ["exit", i, t]]), e[n][1].end.offset - e[n][1].start.offset ? (u = 2, c = jn(c, [["enter", e[n][1], t], ["exit", e[n][1], t]])) : u = 0, Nn(e, r - 1, n - r + 3, c), n = r + c.length - u - 2;
          break;
        }
    }
  for (n = -1; ++n < e.length; )
    e[n][1].type === "attentionSequence" && (e[n][1].type = "data");
  return e;
}
function wk(e, t) {
  const n = this.parser.constructs.attentionMarkers.null, r = this.previous, i = xa(r);
  let a;
  return s;
  function s(l) {
    return a = l, e.enter("attentionSequence"), o(l);
  }
  function o(l) {
    if (l === a)
      return e.consume(l), o;
    const c = e.exit("attentionSequence"), u = xa(l), d = !u || u === 2 && i || n.includes(l), f = !i || i === 2 && u || n.includes(r);
    return c._open = !!(a === 42 ? d : d && (i || !f)), c._close = !!(a === 42 ? f : f && (u || !d)), t(l);
  }
}
function kh(e, t) {
  e.column += t, e.offset += t, e._bufferIndex += t;
}
const Ck = {
  name: "autolink",
  tokenize: Ik
};
function Ik(e, t, n) {
  let r = 0;
  return i;
  function i(p) {
    return e.enter("autolink"), e.enter("autolinkMarker"), e.consume(p), e.exit("autolinkMarker"), e.enter("autolinkProtocol"), a;
  }
  function a(p) {
    return on(p) ? (e.consume(p), s) : p === 64 ? n(p) : c(p);
  }
  function s(p) {
    return p === 43 || p === 45 || p === 46 || Yt(p) ? (r = 1, o(p)) : c(p);
  }
  function o(p) {
    return p === 58 ? (e.consume(p), r = 0, l) : (p === 43 || p === 45 || p === 46 || Yt(p)) && r++ < 32 ? (e.consume(p), o) : (r = 0, c(p));
  }
  function l(p) {
    return p === 62 ? (e.exit("autolinkProtocol"), e.enter("autolinkMarker"), e.consume(p), e.exit("autolinkMarker"), e.exit("autolink"), t) : p === null || p === 32 || p === 60 || yl(p) ? n(p) : (e.consume(p), l);
  }
  function c(p) {
    return p === 64 ? (e.consume(p), u) : hk(p) ? (e.consume(p), c) : n(p);
  }
  function u(p) {
    return Yt(p) ? d(p) : n(p);
  }
  function d(p) {
    return p === 46 ? (e.consume(p), r = 0, u) : p === 62 ? (e.exit("autolinkProtocol").type = "autolinkEmail", e.enter("autolinkMarker"), e.consume(p), e.exit("autolinkMarker"), e.exit("autolink"), t) : f(p);
  }
  function f(p) {
    if ((p === 45 || Yt(p)) && r++ < 63) {
      const h = p === 45 ? f : d;
      return e.consume(p), h;
    }
    return n(p);
  }
}
const Ks = {
  partial: !0,
  tokenize: Sk
};
function Sk(e, t, n) {
  return r;
  function r(a) {
    return Le(a) ? je(e, i, "linePrefix")(a) : i(a);
  }
  function i(a) {
    return a === null || _e(a) ? t(a) : n(a);
  }
}
const ly = {
  continuation: {
    tokenize: kk
  },
  exit: Tk,
  name: "blockQuote",
  tokenize: Ak
};
function Ak(e, t, n) {
  const r = this;
  return i;
  function i(s) {
    if (s === 62) {
      const o = r.containerState;
      return o.open || (e.enter("blockQuote", {
        _container: !0
      }), o.open = !0), e.enter("blockQuotePrefix"), e.enter("blockQuoteMarker"), e.consume(s), e.exit("blockQuoteMarker"), a;
    }
    return n(s);
  }
  function a(s) {
    return Le(s) ? (e.enter("blockQuotePrefixWhitespace"), e.consume(s), e.exit("blockQuotePrefixWhitespace"), e.exit("blockQuotePrefix"), t) : (e.exit("blockQuotePrefix"), t(s));
  }
}
function kk(e, t, n) {
  const r = this;
  return i;
  function i(s) {
    return Le(s) ? je(e, a, "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(s) : a(s);
  }
  function a(s) {
    return e.attempt(ly, t, n)(s);
  }
}
function Tk(e) {
  e.exit("blockQuote");
}
const cy = {
  name: "characterEscape",
  tokenize: Rk
};
function Rk(e, t, n) {
  return r;
  function r(a) {
    return e.enter("characterEscape"), e.enter("escapeMarker"), e.consume(a), e.exit("escapeMarker"), i;
  }
  function i(a) {
    return mk(a) ? (e.enter("characterEscapeValue"), e.consume(a), e.exit("characterEscapeValue"), e.exit("characterEscape"), t) : n(a);
  }
}
const uy = {
  name: "characterReference",
  tokenize: Nk
};
function Nk(e, t, n) {
  const r = this;
  let i = 0, a, s;
  return o;
  function o(d) {
    return e.enter("characterReference"), e.enter("characterReferenceMarker"), e.consume(d), e.exit("characterReferenceMarker"), l;
  }
  function l(d) {
    return d === 35 ? (e.enter("characterReferenceMarkerNumeric"), e.consume(d), e.exit("characterReferenceMarkerNumeric"), c) : (e.enter("characterReferenceValue"), a = 31, s = Yt, u(d));
  }
  function c(d) {
    return d === 88 || d === 120 ? (e.enter("characterReferenceMarkerHexadecimal"), e.consume(d), e.exit("characterReferenceMarkerHexadecimal"), e.enter("characterReferenceValue"), a = 6, s = gk, u) : (e.enter("characterReferenceValue"), a = 7, s = $u, u(d));
  }
  function u(d) {
    if (d === 59 && i) {
      const f = e.exit("characterReferenceValue");
      return s === Yt && !df(r.sliceSerialize(f)) ? n(d) : (e.enter("characterReferenceMarker"), e.consume(d), e.exit("characterReferenceMarker"), e.exit("characterReference"), t);
    }
    return s(d) && i++ < a ? (e.consume(d), u) : n(d);
  }
}
const Th = {
  partial: !0,
  tokenize: Mk
}, Rh = {
  concrete: !0,
  name: "codeFenced",
  tokenize: Ok
};
function Ok(e, t, n) {
  const r = this, i = {
    partial: !0,
    tokenize: _
  };
  let a = 0, s = 0, o;
  return l;
  function l(x) {
    return c(x);
  }
  function c(x) {
    const I = r.events[r.events.length - 1];
    return a = I && I[1].type === "linePrefix" ? I[2].sliceSerialize(I[1], !0).length : 0, o = x, e.enter("codeFenced"), e.enter("codeFencedFence"), e.enter("codeFencedFenceSequence"), u(x);
  }
  function u(x) {
    return x === o ? (s++, e.consume(x), u) : s < 3 ? n(x) : (e.exit("codeFencedFenceSequence"), Le(x) ? je(e, d, "whitespace")(x) : d(x));
  }
  function d(x) {
    return x === null || _e(x) ? (e.exit("codeFencedFence"), r.interrupt ? t(x) : e.check(Th, g, E)(x)) : (e.enter("codeFencedFenceInfo"), e.enter("chunkString", {
      contentType: "string"
    }), f(x));
  }
  function f(x) {
    return x === null || _e(x) ? (e.exit("chunkString"), e.exit("codeFencedFenceInfo"), d(x)) : Le(x) ? (e.exit("chunkString"), e.exit("codeFencedFenceInfo"), je(e, p, "whitespace")(x)) : x === 96 && x === o ? n(x) : (e.consume(x), f);
  }
  function p(x) {
    return x === null || _e(x) ? d(x) : (e.enter("codeFencedFenceMeta"), e.enter("chunkString", {
      contentType: "string"
    }), h(x));
  }
  function h(x) {
    return x === null || _e(x) ? (e.exit("chunkString"), e.exit("codeFencedFenceMeta"), d(x)) : x === 96 && x === o ? n(x) : (e.consume(x), h);
  }
  function g(x) {
    return e.attempt(i, E, m)(x);
  }
  function m(x) {
    return e.enter("lineEnding"), e.consume(x), e.exit("lineEnding"), b;
  }
  function b(x) {
    return a > 0 && Le(x) ? je(e, y, "linePrefix", a + 1)(x) : y(x);
  }
  function y(x) {
    return x === null || _e(x) ? e.check(Th, g, E)(x) : (e.enter("codeFlowValue"), v(x));
  }
  function v(x) {
    return x === null || _e(x) ? (e.exit("codeFlowValue"), y(x)) : (e.consume(x), v);
  }
  function E(x) {
    return e.exit("codeFenced"), t(x);
  }
  function _(x, I, T) {
    let O = 0;
    return k;
    function k(U) {
      return x.enter("lineEnding"), x.consume(U), x.exit("lineEnding"), W;
    }
    function W(U) {
      return x.enter("codeFencedFence"), Le(U) ? je(x, M, "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(U) : M(U);
    }
    function M(U) {
      return U === o ? (x.enter("codeFencedFenceSequence"), L(U)) : T(U);
    }
    function L(U) {
      return U === o ? (O++, x.consume(U), L) : O >= s ? (x.exit("codeFencedFenceSequence"), Le(U) ? je(x, z, "whitespace")(U) : z(U)) : T(U);
    }
    function z(U) {
      return U === null || _e(U) ? (x.exit("codeFencedFence"), I(U)) : T(U);
    }
  }
}
function Mk(e, t, n) {
  const r = this;
  return i;
  function i(s) {
    return s === null ? n(s) : (e.enter("lineEnding"), e.consume(s), e.exit("lineEnding"), a);
  }
  function a(s) {
    return r.parser.lazy[r.now().line] ? n(s) : t(s);
  }
}
const Wc = {
  name: "codeIndented",
  tokenize: Dk
}, Pk = {
  partial: !0,
  tokenize: Lk
};
function Dk(e, t, n) {
  const r = this;
  return i;
  function i(c) {
    return e.enter("codeIndented"), je(e, a, "linePrefix", 5)(c);
  }
  function a(c) {
    const u = r.events[r.events.length - 1];
    return u && u[1].type === "linePrefix" && u[2].sliceSerialize(u[1], !0).length >= 4 ? s(c) : n(c);
  }
  function s(c) {
    return c === null ? l(c) : _e(c) ? e.attempt(Pk, s, l)(c) : (e.enter("codeFlowValue"), o(c));
  }
  function o(c) {
    return c === null || _e(c) ? (e.exit("codeFlowValue"), s(c)) : (e.consume(c), o);
  }
  function l(c) {
    return e.exit("codeIndented"), t(c);
  }
}
function Lk(e, t, n) {
  const r = this;
  return i;
  function i(s) {
    return r.parser.lazy[r.now().line] ? n(s) : _e(s) ? (e.enter("lineEnding"), e.consume(s), e.exit("lineEnding"), i) : je(e, a, "linePrefix", 5)(s);
  }
  function a(s) {
    const o = r.events[r.events.length - 1];
    return o && o[1].type === "linePrefix" && o[2].sliceSerialize(o[1], !0).length >= 4 ? t(s) : _e(s) ? i(s) : n(s);
  }
}
const Fk = {
  name: "codeText",
  previous: zk,
  resolve: Bk,
  tokenize: Vk
};
function Bk(e) {
  let t = e.length - 4, n = 3, r, i;
  if ((e[n][1].type === "lineEnding" || e[n][1].type === "space") && (e[t][1].type === "lineEnding" || e[t][1].type === "space")) {
    for (r = n; ++r < t; )
      if (e[r][1].type === "codeTextData") {
        e[n][1].type = "codeTextPadding", e[t][1].type = "codeTextPadding", n += 2, t -= 2;
        break;
      }
  }
  for (r = n - 1, t++; ++r <= t; )
    i === void 0 ? r !== t && e[r][1].type !== "lineEnding" && (i = r) : (r === t || e[r][1].type === "lineEnding") && (e[i][1].type = "codeTextData", r !== i + 2 && (e[i][1].end = e[r - 1][1].end, e.splice(i + 2, r - i - 2), t -= r - i - 2, r = i + 2), i = void 0);
  return e;
}
function zk(e) {
  return e !== 96 || this.events[this.events.length - 1][1].type === "characterEscape";
}
function Vk(e, t, n) {
  let r = 0, i, a;
  return s;
  function s(d) {
    return e.enter("codeText"), e.enter("codeTextSequence"), o(d);
  }
  function o(d) {
    return d === 96 ? (e.consume(d), r++, o) : (e.exit("codeTextSequence"), l(d));
  }
  function l(d) {
    return d === null ? n(d) : d === 32 ? (e.enter("space"), e.consume(d), e.exit("space"), l) : d === 96 ? (a = e.enter("codeTextSequence"), i = 0, u(d)) : _e(d) ? (e.enter("lineEnding"), e.consume(d), e.exit("lineEnding"), l) : (e.enter("codeTextData"), c(d));
  }
  function c(d) {
    return d === null || d === 32 || d === 96 || _e(d) ? (e.exit("codeTextData"), l(d)) : (e.consume(d), c);
  }
  function u(d) {
    return d === 96 ? (e.consume(d), i++, u) : i === r ? (e.exit("codeTextSequence"), e.exit("codeText"), t(d)) : (a.type = "codeTextData", c(d));
  }
}
class Gk {
  /**
   * @param {ReadonlyArray<T> | null | undefined} [initial]
   *   Initial items (optional).
   * @returns
   *   Splice buffer.
   */
  constructor(t) {
    this.left = t ? [...t] : [], this.right = [];
  }
  /**
   * Array access;
   * does not move the cursor.
   *
   * @param {number} index
   *   Index.
   * @return {T}
   *   Item.
   */
  get(t) {
    if (t < 0 || t >= this.left.length + this.right.length)
      throw new RangeError("Cannot access index `" + t + "` in a splice buffer of size `" + (this.left.length + this.right.length) + "`");
    return t < this.left.length ? this.left[t] : this.right[this.right.length - t + this.left.length - 1];
  }
  /**
   * The length of the splice buffer, one greater than the largest index in the
   * array.
   */
  get length() {
    return this.left.length + this.right.length;
  }
  /**
   * Remove and return `list[0]`;
   * moves the cursor to `0`.
   *
   * @returns {T | undefined}
   *   Item, optional.
   */
  shift() {
    return this.setCursor(0), this.right.pop();
  }
  /**
   * Slice the buffer to get an array;
   * does not move the cursor.
   *
   * @param {number} start
   *   Start.
   * @param {number | null | undefined} [end]
   *   End (optional).
   * @returns {Array<T>}
   *   Array of items.
   */
  slice(t, n) {
    const r = n ?? Number.POSITIVE_INFINITY;
    return r < this.left.length ? this.left.slice(t, r) : t > this.left.length ? this.right.slice(this.right.length - r + this.left.length, this.right.length - t + this.left.length).reverse() : this.left.slice(t).concat(this.right.slice(this.right.length - r + this.left.length).reverse());
  }
  /**
   * Mimics the behavior of Array.prototype.splice() except for the change of
   * interface necessary to avoid segfaults when patching in very large arrays.
   *
   * This operation moves cursor is moved to `start` and results in the cursor
   * placed after any inserted items.
   *
   * @param {number} start
   *   Start;
   *   zero-based index at which to start changing the array;
   *   negative numbers count backwards from the end of the array and values
   *   that are out-of bounds are clamped to the appropriate end of the array.
   * @param {number | null | undefined} [deleteCount=0]
   *   Delete count (default: `0`);
   *   maximum number of elements to delete, starting from start.
   * @param {Array<T> | null | undefined} [items=[]]
   *   Items to include in place of the deleted items (default: `[]`).
   * @return {Array<T>}
   *   Any removed items.
   */
  splice(t, n, r) {
    const i = n || 0;
    this.setCursor(Math.trunc(t));
    const a = this.right.splice(this.right.length - i, Number.POSITIVE_INFINITY);
    return r && $a(this.left, r), a.reverse();
  }
  /**
   * Remove and return the highest-numbered item in the array, so
   * `list[list.length - 1]`;
   * Moves the cursor to `length`.
   *
   * @returns {T | undefined}
   *   Item, optional.
   */
  pop() {
    return this.setCursor(Number.POSITIVE_INFINITY), this.left.pop();
  }
  /**
   * Inserts a single item to the high-numbered side of the array;
   * moves the cursor to `length`.
   *
   * @param {T} item
   *   Item.
   * @returns {undefined}
   *   Nothing.
   */
  push(t) {
    this.setCursor(Number.POSITIVE_INFINITY), this.left.push(t);
  }
  /**
   * Inserts many items to the high-numbered side of the array.
   * Moves the cursor to `length`.
   *
   * @param {Array<T>} items
   *   Items.
   * @returns {undefined}
   *   Nothing.
   */
  pushMany(t) {
    this.setCursor(Number.POSITIVE_INFINITY), $a(this.left, t);
  }
  /**
   * Inserts a single item to the low-numbered side of the array;
   * Moves the cursor to `0`.
   *
   * @param {T} item
   *   Item.
   * @returns {undefined}
   *   Nothing.
   */
  unshift(t) {
    this.setCursor(0), this.right.push(t);
  }
  /**
   * Inserts many items to the low-numbered side of the array;
   * moves the cursor to `0`.
   *
   * @param {Array<T>} items
   *   Items.
   * @returns {undefined}
   *   Nothing.
   */
  unshiftMany(t) {
    this.setCursor(0), $a(this.right, t.reverse());
  }
  /**
   * Move the cursor to a specific position in the array. Requires
   * time proportional to the distance moved.
   *
   * If `n < 0`, the cursor will end up at the beginning.
   * If `n > length`, the cursor will end up at the end.
   *
   * @param {number} n
   *   Position.
   * @return {undefined}
   *   Nothing.
   */
  setCursor(t) {
    if (!(t === this.left.length || t > this.left.length && this.right.length === 0 || t < 0 && this.left.length === 0))
      if (t < this.left.length) {
        const n = this.left.splice(t, Number.POSITIVE_INFINITY);
        $a(this.right, n.reverse());
      } else {
        const n = this.right.splice(this.left.length + this.right.length - t, Number.POSITIVE_INFINITY);
        $a(this.left, n.reverse());
      }
  }
}
function $a(e, t) {
  let n = 0;
  if (t.length < 1e4)
    e.push(...t);
  else
    for (; n < t.length; )
      e.push(...t.slice(n, n + 1e4)), n += 1e4;
}
function dy(e) {
  const t = {};
  let n = -1, r, i, a, s, o, l, c;
  const u = new Gk(e);
  for (; ++n < u.length; ) {
    for (; n in t; )
      n = t[n];
    if (r = u.get(n), n && r[1].type === "chunkFlow" && u.get(n - 1)[1].type === "listItemPrefix" && (l = r[1]._tokenizer.events, a = 0, a < l.length && l[a][1].type === "lineEndingBlank" && (a += 2), a < l.length && l[a][1].type === "content"))
      for (; ++a < l.length && l[a][1].type !== "content"; )
        l[a][1].type === "chunkText" && (l[a][1]._isInFirstContentOfListItem = !0, a++);
    if (r[0] === "enter")
      r[1].contentType && (Object.assign(t, jk(u, n)), n = t[n], c = !0);
    else if (r[1]._container) {
      for (a = n, i = void 0; a--; )
        if (s = u.get(a), s[1].type === "lineEnding" || s[1].type === "lineEndingBlank")
          s[0] === "enter" && (i && (u.get(i)[1].type = "lineEndingBlank"), s[1].type = "lineEnding", i = a);
        else if (s[1].type !== "linePrefix") break;
      i && (r[1].end = {
        ...u.get(i)[1].start
      }, o = u.slice(i, n), o.unshift(r), u.splice(i, n - i + 1, o));
    }
  }
  return Nn(e, 0, Number.POSITIVE_INFINITY, u.slice(0)), !c;
}
function jk(e, t) {
  const n = e.get(t)[1], r = e.get(t)[2];
  let i = t - 1;
  const a = [], s = n._tokenizer || r.parser[n.contentType](n.start), o = s.events, l = [], c = {};
  let u, d, f = -1, p = n, h = 0, g = 0;
  const m = [g];
  for (; p; ) {
    for (; e.get(++i)[1] !== p; )
      ;
    a.push(i), p._tokenizer || (u = r.sliceStream(p), p.next || u.push(null), d && s.defineSkip(p.start), p._isInFirstContentOfListItem && (s._gfmTasklistFirstContentOfListItem = !0), s.write(u), p._isInFirstContentOfListItem && (s._gfmTasklistFirstContentOfListItem = void 0)), d = p, p = p.next;
  }
  for (p = n; ++f < o.length; )
    // Find a void token that includes a break.
    o[f][0] === "exit" && o[f - 1][0] === "enter" && o[f][1].type === o[f - 1][1].type && o[f][1].start.line !== o[f][1].end.line && (g = f + 1, m.push(g), p._tokenizer = void 0, p.previous = void 0, p = p.next);
  for (s.events = [], p ? (p._tokenizer = void 0, p.previous = void 0) : m.pop(), f = m.length; f--; ) {
    const b = o.slice(m[f], m[f + 1]), y = a.pop();
    l.push([y, y + b.length - 1]), e.splice(y, 2, b);
  }
  for (l.reverse(), f = -1; ++f < l.length; )
    c[h + l[f][0]] = h + l[f][1], h += l[f][1] - l[f][0] - 1;
  return c;
}
const Uk = {
  resolve: Wk,
  tokenize: Zk
}, Hk = {
  partial: !0,
  tokenize: $k
};
function Wk(e) {
  return dy(e), e;
}
function Zk(e, t) {
  let n;
  return r;
  function r(o) {
    return e.enter("content"), n = e.enter("chunkContent", {
      contentType: "content"
    }), i(o);
  }
  function i(o) {
    return o === null ? a(o) : _e(o) ? e.check(Hk, s, a)(o) : (e.consume(o), i);
  }
  function a(o) {
    return e.exit("chunkContent"), e.exit("content"), t(o);
  }
  function s(o) {
    return e.consume(o), e.exit("chunkContent"), n.next = e.enter("chunkContent", {
      contentType: "content",
      previous: n
    }), n = n.next, i;
  }
}
function $k(e, t, n) {
  const r = this;
  return i;
  function i(s) {
    return e.exit("chunkContent"), e.enter("lineEnding"), e.consume(s), e.exit("lineEnding"), je(e, a, "linePrefix");
  }
  function a(s) {
    if (s === null || _e(s))
      return n(s);
    const o = r.events[r.events.length - 1];
    return !r.parser.constructs.disable.null.includes("codeIndented") && o && o[1].type === "linePrefix" && o[2].sliceSerialize(o[1], !0).length >= 4 ? t(s) : e.interrupt(r.parser.constructs.flow, n, t)(s);
  }
}
function fy(e, t, n, r, i, a, s, o, l) {
  const c = l || Number.POSITIVE_INFINITY;
  let u = 0;
  return d;
  function d(b) {
    return b === 60 ? (e.enter(r), e.enter(i), e.enter(a), e.consume(b), e.exit(a), f) : b === null || b === 32 || b === 41 || yl(b) ? n(b) : (e.enter(r), e.enter(s), e.enter(o), e.enter("chunkString", {
      contentType: "string"
    }), g(b));
  }
  function f(b) {
    return b === 62 ? (e.enter(a), e.consume(b), e.exit(a), e.exit(i), e.exit(r), t) : (e.enter(o), e.enter("chunkString", {
      contentType: "string"
    }), p(b));
  }
  function p(b) {
    return b === 62 ? (e.exit("chunkString"), e.exit(o), f(b)) : b === null || b === 60 || _e(b) ? n(b) : (e.consume(b), b === 92 ? h : p);
  }
  function h(b) {
    return b === 60 || b === 62 || b === 92 ? (e.consume(b), p) : p(b);
  }
  function g(b) {
    return !u && (b === null || b === 41 || Qe(b)) ? (e.exit("chunkString"), e.exit(o), e.exit(s), e.exit(r), t(b)) : u < c && b === 40 ? (e.consume(b), u++, g) : b === 41 ? (e.consume(b), u--, g) : b === null || b === 32 || b === 40 || yl(b) ? n(b) : (e.consume(b), b === 92 ? m : g);
  }
  function m(b) {
    return b === 40 || b === 41 || b === 92 ? (e.consume(b), g) : g(b);
  }
}
function py(e, t, n, r, i, a) {
  const s = this;
  let o = 0, l;
  return c;
  function c(p) {
    return e.enter(r), e.enter(i), e.consume(p), e.exit(i), e.enter(a), u;
  }
  function u(p) {
    return o > 999 || p === null || p === 91 || p === 93 && !l || // To do: remove in the future once weve switched from
    // `micromark-extension-footnote` to `micromark-extension-gfm-footnote`,
    // which doesnt need this.
    // Hidden footnotes hook.
    /* c8 ignore next 3 */
    p === 94 && !o && "_hiddenFootnoteSupport" in s.parser.constructs ? n(p) : p === 93 ? (e.exit(a), e.enter(i), e.consume(p), e.exit(i), e.exit(r), t) : _e(p) ? (e.enter("lineEnding"), e.consume(p), e.exit("lineEnding"), u) : (e.enter("chunkString", {
      contentType: "string"
    }), d(p));
  }
  function d(p) {
    return p === null || p === 91 || p === 93 || _e(p) || o++ > 999 ? (e.exit("chunkString"), u(p)) : (e.consume(p), l || (l = !Le(p)), p === 92 ? f : d);
  }
  function f(p) {
    return p === 91 || p === 92 || p === 93 ? (e.consume(p), o++, d) : d(p);
  }
}
function hy(e, t, n, r, i, a) {
  let s;
  return o;
  function o(f) {
    return f === 34 || f === 39 || f === 40 ? (e.enter(r), e.enter(i), e.consume(f), e.exit(i), s = f === 40 ? 41 : f, l) : n(f);
  }
  function l(f) {
    return f === s ? (e.enter(i), e.consume(f), e.exit(i), e.exit(r), t) : (e.enter(a), c(f));
  }
  function c(f) {
    return f === s ? (e.exit(a), l(s)) : f === null ? n(f) : _e(f) ? (e.enter("lineEnding"), e.consume(f), e.exit("lineEnding"), je(e, c, "linePrefix")) : (e.enter("chunkString", {
      contentType: "string"
    }), u(f));
  }
  function u(f) {
    return f === s || f === null || _e(f) ? (e.exit("chunkString"), c(f)) : (e.consume(f), f === 92 ? d : u);
  }
  function d(f) {
    return f === s || f === 92 ? (e.consume(f), u) : u(f);
  }
}
function ls(e, t) {
  let n;
  return r;
  function r(i) {
    return _e(i) ? (e.enter("lineEnding"), e.consume(i), e.exit("lineEnding"), n = !0, r) : Le(i) ? je(e, r, n ? "linePrefix" : "lineSuffix")(i) : t(i);
  }
}
const Xk = {
  name: "definition",
  tokenize: Jk
}, Yk = {
  partial: !0,
  tokenize: qk
};
function Jk(e, t, n) {
  const r = this;
  let i;
  return a;
  function a(p) {
    return e.enter("definition"), s(p);
  }
  function s(p) {
    return py.call(
      r,
      e,
      o,
      // Note: we dont need to reset the way `markdown-rs` does.
      n,
      "definitionLabel",
      "definitionLabelMarker",
      "definitionLabelString"
    )(p);
  }
  function o(p) {
    return i = Qn(r.sliceSerialize(r.events[r.events.length - 1][1]).slice(1, -1)), p === 58 ? (e.enter("definitionMarker"), e.consume(p), e.exit("definitionMarker"), l) : n(p);
  }
  function l(p) {
    return Qe(p) ? ls(e, c)(p) : c(p);
  }
  function c(p) {
    return fy(
      e,
      u,
      // Note: we dont need to reset the way `markdown-rs` does.
      n,
      "definitionDestination",
      "definitionDestinationLiteral",
      "definitionDestinationLiteralMarker",
      "definitionDestinationRaw",
      "definitionDestinationString"
    )(p);
  }
  function u(p) {
    return e.attempt(Yk, d, d)(p);
  }
  function d(p) {
    return Le(p) ? je(e, f, "whitespace")(p) : f(p);
  }
  function f(p) {
    return p === null || _e(p) ? (e.exit("definition"), r.parser.defined.push(i), t(p)) : n(p);
  }
}
function qk(e, t, n) {
  return r;
  function r(o) {
    return Qe(o) ? ls(e, i)(o) : n(o);
  }
  function i(o) {
    return hy(e, a, n, "definitionTitle", "definitionTitleMarker", "definitionTitleString")(o);
  }
  function a(o) {
    return Le(o) ? je(e, s, "whitespace")(o) : s(o);
  }
  function s(o) {
    return o === null || _e(o) ? t(o) : n(o);
  }
}
const Kk = {
  name: "hardBreakEscape",
  tokenize: Qk
};
function Qk(e, t, n) {
  return r;
  function r(a) {
    return e.enter("hardBreakEscape"), e.consume(a), i;
  }
  function i(a) {
    return _e(a) ? (e.exit("hardBreakEscape"), t(a)) : n(a);
  }
}
const eT = {
  name: "headingAtx",
  resolve: tT,
  tokenize: nT
};
function tT(e, t) {
  let n = e.length - 2, r = 3, i, a;
  return e[r][1].type === "whitespace" && (r += 2), n - 2 > r && e[n][1].type === "whitespace" && (n -= 2), e[n][1].type === "atxHeadingSequence" && (r === n - 1 || n - 4 > r && e[n - 2][1].type === "whitespace") && (n -= r + 1 === n ? 2 : 4), n > r && (i = {
    type: "atxHeadingText",
    start: e[r][1].start,
    end: e[n][1].end
  }, a = {
    type: "chunkText",
    start: e[r][1].start,
    end: e[n][1].end,
    contentType: "text"
  }, Nn(e, r, n - r + 1, [["enter", i, t], ["enter", a, t], ["exit", a, t], ["exit", i, t]])), e;
}
function nT(e, t, n) {
  let r = 0;
  return i;
  function i(u) {
    return e.enter("atxHeading"), a(u);
  }
  function a(u) {
    return e.enter("atxHeadingSequence"), s(u);
  }
  function s(u) {
    return u === 35 && r++ < 6 ? (e.consume(u), s) : u === null || Qe(u) ? (e.exit("atxHeadingSequence"), o(u)) : n(u);
  }
  function o(u) {
    return u === 35 ? (e.enter("atxHeadingSequence"), l(u)) : u === null || _e(u) ? (e.exit("atxHeading"), t(u)) : Le(u) ? je(e, o, "whitespace")(u) : (e.enter("atxHeadingText"), c(u));
  }
  function l(u) {
    return u === 35 ? (e.consume(u), l) : (e.exit("atxHeadingSequence"), o(u));
  }
  function c(u) {
    return u === null || u === 35 || Qe(u) ? (e.exit("atxHeadingText"), o(u)) : (e.consume(u), c);
  }
}
const rT = [
  "address",
  "article",
  "aside",
  "base",
  "basefont",
  "blockquote",
  "body",
  "caption",
  "center",
  "col",
  "colgroup",
  "dd",
  "details",
  "dialog",
  "dir",
  "div",
  "dl",
  "dt",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "frame",
  "frameset",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hr",
  "html",
  "iframe",
  "legend",
  "li",
  "link",
  "main",
  "menu",
  "menuitem",
  "nav",
  "noframes",
  "ol",
  "optgroup",
  "option",
  "p",
  "param",
  "search",
  "section",
  "summary",
  "table",
  "tbody",
  "td",
  "tfoot",
  "th",
  "thead",
  "title",
  "tr",
  "track",
  "ul"
], Nh = ["pre", "script", "style", "textarea"], iT = {
  concrete: !0,
  name: "htmlFlow",
  resolveTo: oT,
  tokenize: lT
}, aT = {
  partial: !0,
  tokenize: uT
}, sT = {
  partial: !0,
  tokenize: cT
};
function oT(e) {
  let t = e.length;
  for (; t-- && !(e[t][0] === "enter" && e[t][1].type === "htmlFlow"); )
    ;
  return t > 1 && e[t - 2][1].type === "linePrefix" && (e[t][1].start = e[t - 2][1].start, e[t + 1][1].start = e[t - 2][1].start, e.splice(t - 2, 2)), e;
}
function lT(e, t, n) {
  const r = this;
  let i, a, s, o, l;
  return c;
  function c(A) {
    return u(A);
  }
  function u(A) {
    return e.enter("htmlFlow"), e.enter("htmlFlowData"), e.consume(A), d;
  }
  function d(A) {
    return A === 33 ? (e.consume(A), f) : A === 47 ? (e.consume(A), a = !0, g) : A === 63 ? (e.consume(A), i = 3, r.interrupt ? t : S) : on(A) ? (e.consume(A), s = String.fromCharCode(A), m) : n(A);
  }
  function f(A) {
    return A === 45 ? (e.consume(A), i = 2, p) : A === 91 ? (e.consume(A), i = 5, o = 0, h) : on(A) ? (e.consume(A), i = 4, r.interrupt ? t : S) : n(A);
  }
  function p(A) {
    return A === 45 ? (e.consume(A), r.interrupt ? t : S) : n(A);
  }
  function h(A) {
    const ve = "CDATA[";
    return A === ve.charCodeAt(o++) ? (e.consume(A), o === ve.length ? r.interrupt ? t : M : h) : n(A);
  }
  function g(A) {
    return on(A) ? (e.consume(A), s = String.fromCharCode(A), m) : n(A);
  }
  function m(A) {
    if (A === null || A === 47 || A === 62 || Qe(A)) {
      const ve = A === 47, Te = s.toLowerCase();
      return !ve && !a && Nh.includes(Te) ? (i = 1, r.interrupt ? t(A) : M(A)) : rT.includes(s.toLowerCase()) ? (i = 6, ve ? (e.consume(A), b) : r.interrupt ? t(A) : M(A)) : (i = 7, r.interrupt && !r.parser.lazy[r.now().line] ? n(A) : a ? y(A) : v(A));
    }
    return A === 45 || Yt(A) ? (e.consume(A), s += String.fromCharCode(A), m) : n(A);
  }
  function b(A) {
    return A === 62 ? (e.consume(A), r.interrupt ? t : M) : n(A);
  }
  function y(A) {
    return Le(A) ? (e.consume(A), y) : k(A);
  }
  function v(A) {
    return A === 47 ? (e.consume(A), k) : A === 58 || A === 95 || on(A) ? (e.consume(A), E) : Le(A) ? (e.consume(A), v) : k(A);
  }
  function E(A) {
    return A === 45 || A === 46 || A === 58 || A === 95 || Yt(A) ? (e.consume(A), E) : _(A);
  }
  function _(A) {
    return A === 61 ? (e.consume(A), x) : Le(A) ? (e.consume(A), _) : v(A);
  }
  function x(A) {
    return A === null || A === 60 || A === 61 || A === 62 || A === 96 ? n(A) : A === 34 || A === 39 ? (e.consume(A), l = A, I) : Le(A) ? (e.consume(A), x) : T(A);
  }
  function I(A) {
    return A === l ? (e.consume(A), l = null, O) : A === null || _e(A) ? n(A) : (e.consume(A), I);
  }
  function T(A) {
    return A === null || A === 34 || A === 39 || A === 47 || A === 60 || A === 61 || A === 62 || A === 96 || Qe(A) ? _(A) : (e.consume(A), T);
  }
  function O(A) {
    return A === 47 || A === 62 || Le(A) ? v(A) : n(A);
  }
  function k(A) {
    return A === 62 ? (e.consume(A), W) : n(A);
  }
  function W(A) {
    return A === null || _e(A) ? M(A) : Le(A) ? (e.consume(A), W) : n(A);
  }
  function M(A) {
    return A === 45 && i === 2 ? (e.consume(A), $) : A === 60 && i === 1 ? (e.consume(A), Q) : A === 62 && i === 4 ? (e.consume(A), me) : A === 63 && i === 3 ? (e.consume(A), S) : A === 93 && i === 5 ? (e.consume(A), fe) : _e(A) && (i === 6 || i === 7) ? (e.exit("htmlFlowData"), e.check(aT, se, L)(A)) : A === null || _e(A) ? (e.exit("htmlFlowData"), L(A)) : (e.consume(A), M);
  }
  function L(A) {
    return e.check(sT, z, se)(A);
  }
  function z(A) {
    return e.enter("lineEnding"), e.consume(A), e.exit("lineEnding"), U;
  }
  function U(A) {
    return A === null || _e(A) ? L(A) : (e.enter("htmlFlowData"), M(A));
  }
  function $(A) {
    return A === 45 ? (e.consume(A), S) : M(A);
  }
  function Q(A) {
    return A === 47 ? (e.consume(A), s = "", K) : M(A);
  }
  function K(A) {
    if (A === 62) {
      const ve = s.toLowerCase();
      return Nh.includes(ve) ? (e.consume(A), me) : M(A);
    }
    return on(A) && s.length < 8 ? (e.consume(A), s += String.fromCharCode(A), K) : M(A);
  }
  function fe(A) {
    return A === 93 ? (e.consume(A), S) : M(A);
  }
  function S(A) {
    return A === 62 ? (e.consume(A), me) : A === 45 && i === 2 ? (e.consume(A), S) : M(A);
  }
  function me(A) {
    return A === null || _e(A) ? (e.exit("htmlFlowData"), se(A)) : (e.consume(A), me);
  }
  function se(A) {
    return e.exit("htmlFlow"), t(A);
  }
}
function cT(e, t, n) {
  const r = this;
  return i;
  function i(s) {
    return _e(s) ? (e.enter("lineEnding"), e.consume(s), e.exit("lineEnding"), a) : n(s);
  }
  function a(s) {
    return r.parser.lazy[r.now().line] ? n(s) : t(s);
  }
}
function uT(e, t, n) {
  return r;
  function r(i) {
    return e.enter("lineEnding"), e.consume(i), e.exit("lineEnding"), e.attempt(Ks, t, n);
  }
}
const dT = {
  name: "htmlText",
  tokenize: fT
};
function fT(e, t, n) {
  const r = this;
  let i, a, s;
  return o;
  function o(S) {
    return e.enter("htmlText"), e.enter("htmlTextData"), e.consume(S), l;
  }
  function l(S) {
    return S === 33 ? (e.consume(S), c) : S === 47 ? (e.consume(S), _) : S === 63 ? (e.consume(S), v) : on(S) ? (e.consume(S), T) : n(S);
  }
  function c(S) {
    return S === 45 ? (e.consume(S), u) : S === 91 ? (e.consume(S), a = 0, h) : on(S) ? (e.consume(S), y) : n(S);
  }
  function u(S) {
    return S === 45 ? (e.consume(S), p) : n(S);
  }
  function d(S) {
    return S === null ? n(S) : S === 45 ? (e.consume(S), f) : _e(S) ? (s = d, Q(S)) : (e.consume(S), d);
  }
  function f(S) {
    return S === 45 ? (e.consume(S), p) : d(S);
  }
  function p(S) {
    return S === 62 ? $(S) : S === 45 ? f(S) : d(S);
  }
  function h(S) {
    const me = "CDATA[";
    return S === me.charCodeAt(a++) ? (e.consume(S), a === me.length ? g : h) : n(S);
  }
  function g(S) {
    return S === null ? n(S) : S === 93 ? (e.consume(S), m) : _e(S) ? (s = g, Q(S)) : (e.consume(S), g);
  }
  function m(S) {
    return S === 93 ? (e.consume(S), b) : g(S);
  }
  function b(S) {
    return S === 62 ? $(S) : S === 93 ? (e.consume(S), b) : g(S);
  }
  function y(S) {
    return S === null || S === 62 ? $(S) : _e(S) ? (s = y, Q(S)) : (e.consume(S), y);
  }
  function v(S) {
    return S === null ? n(S) : S === 63 ? (e.consume(S), E) : _e(S) ? (s = v, Q(S)) : (e.consume(S), v);
  }
  function E(S) {
    return S === 62 ? $(S) : v(S);
  }
  function _(S) {
    return on(S) ? (e.consume(S), x) : n(S);
  }
  function x(S) {
    return S === 45 || Yt(S) ? (e.consume(S), x) : I(S);
  }
  function I(S) {
    return _e(S) ? (s = I, Q(S)) : Le(S) ? (e.consume(S), I) : $(S);
  }
  function T(S) {
    return S === 45 || Yt(S) ? (e.consume(S), T) : S === 47 || S === 62 || Qe(S) ? O(S) : n(S);
  }
  function O(S) {
    return S === 47 ? (e.consume(S), $) : S === 58 || S === 95 || on(S) ? (e.consume(S), k) : _e(S) ? (s = O, Q(S)) : Le(S) ? (e.consume(S), O) : $(S);
  }
  function k(S) {
    return S === 45 || S === 46 || S === 58 || S === 95 || Yt(S) ? (e.consume(S), k) : W(S);
  }
  function W(S) {
    return S === 61 ? (e.consume(S), M) : _e(S) ? (s = W, Q(S)) : Le(S) ? (e.consume(S), W) : O(S);
  }
  function M(S) {
    return S === null || S === 60 || S === 61 || S === 62 || S === 96 ? n(S) : S === 34 || S === 39 ? (e.consume(S), i = S, L) : _e(S) ? (s = M, Q(S)) : Le(S) ? (e.consume(S), M) : (e.consume(S), z);
  }
  function L(S) {
    return S === i ? (e.consume(S), i = void 0, U) : S === null ? n(S) : _e(S) ? (s = L, Q(S)) : (e.consume(S), L);
  }
  function z(S) {
    return S === null || S === 34 || S === 39 || S === 60 || S === 61 || S === 96 ? n(S) : S === 47 || S === 62 || Qe(S) ? O(S) : (e.consume(S), z);
  }
  function U(S) {
    return S === 47 || S === 62 || Qe(S) ? O(S) : n(S);
  }
  function $(S) {
    return S === 62 ? (e.consume(S), e.exit("htmlTextData"), e.exit("htmlText"), t) : n(S);
  }
  function Q(S) {
    return e.exit("htmlTextData"), e.enter("lineEnding"), e.consume(S), e.exit("lineEnding"), K;
  }
  function K(S) {
    return Le(S) ? je(e, fe, "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(S) : fe(S);
  }
  function fe(S) {
    return e.enter("htmlTextData"), s(S);
  }
}
const ff = {
  name: "labelEnd",
  resolveAll: mT,
  resolveTo: bT,
  tokenize: yT
}, pT = {
  tokenize: _T
}, hT = {
  tokenize: vT
}, gT = {
  tokenize: xT
};
function mT(e) {
  let t = -1;
  const n = [];
  for (; ++t < e.length; ) {
    const r = e[t][1];
    if (n.push(e[t]), r.type === "labelImage" || r.type === "labelLink" || r.type === "labelEnd") {
      const i = r.type === "labelImage" ? 4 : 2;
      r.type = "data", t += i;
    }
  }
  return e.length !== n.length && Nn(e, 0, e.length, n), e;
}
function bT(e, t) {
  let n = e.length, r = 0, i, a, s, o;
  for (; n--; )
    if (i = e[n][1], a) {
      if (i.type === "link" || i.type === "labelLink" && i._inactive)
        break;
      e[n][0] === "enter" && i.type === "labelLink" && (i._inactive = !0);
    } else if (s) {
      if (e[n][0] === "enter" && (i.type === "labelImage" || i.type === "labelLink") && !i._balanced && (a = n, i.type !== "labelLink")) {
        r = 2;
        break;
      }
    } else i.type === "labelEnd" && (s = n);
  const l = {
    type: e[a][1].type === "labelLink" ? "link" : "image",
    start: {
      ...e[a][1].start
    },
    end: {
      ...e[e.length - 1][1].end
    }
  }, c = {
    type: "label",
    start: {
      ...e[a][1].start
    },
    end: {
      ...e[s][1].end
    }
  }, u = {
    type: "labelText",
    start: {
      ...e[a + r + 2][1].end
    },
    end: {
      ...e[s - 2][1].start
    }
  };
  return o = [["enter", l, t], ["enter", c, t]], o = jn(o, e.slice(a + 1, a + r + 3)), o = jn(o, [["enter", u, t]]), o = jn(o, ec(t.parser.constructs.insideSpan.null, e.slice(a + r + 4, s - 3), t)), o = jn(o, [["exit", u, t], e[s - 2], e[s - 1], ["exit", c, t]]), o = jn(o, e.slice(s + 1)), o = jn(o, [["exit", l, t]]), Nn(e, a, e.length, o), e;
}
function yT(e, t, n) {
  const r = this;
  let i = r.events.length, a, s;
  for (; i--; )
    if ((r.events[i][1].type === "labelImage" || r.events[i][1].type === "labelLink") && !r.events[i][1]._balanced) {
      a = r.events[i][1];
      break;
    }
  return o;
  function o(f) {
    return a ? a._inactive ? d(f) : (s = r.parser.defined.includes(Qn(r.sliceSerialize({
      start: a.end,
      end: r.now()
    }))), e.enter("labelEnd"), e.enter("labelMarker"), e.consume(f), e.exit("labelMarker"), e.exit("labelEnd"), l) : n(f);
  }
  function l(f) {
    return f === 40 ? e.attempt(pT, u, s ? u : d)(f) : f === 91 ? e.attempt(hT, u, s ? c : d)(f) : s ? u(f) : d(f);
  }
  function c(f) {
    return e.attempt(gT, u, d)(f);
  }
  function u(f) {
    return t(f);
  }
  function d(f) {
    return a._balanced = !0, n(f);
  }
}
function _T(e, t, n) {
  return r;
  function r(d) {
    return e.enter("resource"), e.enter("resourceMarker"), e.consume(d), e.exit("resourceMarker"), i;
  }
  function i(d) {
    return Qe(d) ? ls(e, a)(d) : a(d);
  }
  function a(d) {
    return d === 41 ? u(d) : fy(e, s, o, "resourceDestination", "resourceDestinationLiteral", "resourceDestinationLiteralMarker", "resourceDestinationRaw", "resourceDestinationString", 32)(d);
  }
  function s(d) {
    return Qe(d) ? ls(e, l)(d) : u(d);
  }
  function o(d) {
    return n(d);
  }
  function l(d) {
    return d === 34 || d === 39 || d === 40 ? hy(e, c, n, "resourceTitle", "resourceTitleMarker", "resourceTitleString")(d) : u(d);
  }
  function c(d) {
    return Qe(d) ? ls(e, u)(d) : u(d);
  }
  function u(d) {
    return d === 41 ? (e.enter("resourceMarker"), e.consume(d), e.exit("resourceMarker"), e.exit("resource"), t) : n(d);
  }
}
function vT(e, t, n) {
  const r = this;
  return i;
  function i(o) {
    return py.call(r, e, a, s, "reference", "referenceMarker", "referenceString")(o);
  }
  function a(o) {
    return r.parser.defined.includes(Qn(r.sliceSerialize(r.events[r.events.length - 1][1]).slice(1, -1))) ? t(o) : n(o);
  }
  function s(o) {
    return n(o);
  }
}
function xT(e, t, n) {
  return r;
  function r(a) {
    return e.enter("reference"), e.enter("referenceMarker"), e.consume(a), e.exit("referenceMarker"), i;
  }
  function i(a) {
    return a === 93 ? (e.enter("referenceMarker"), e.consume(a), e.exit("referenceMarker"), e.exit("reference"), t) : n(a);
  }
}
const ET = {
  name: "labelStartImage",
  resolveAll: ff.resolveAll,
  tokenize: wT
};
function wT(e, t, n) {
  const r = this;
  return i;
  function i(o) {
    return e.enter("labelImage"), e.enter("labelImageMarker"), e.consume(o), e.exit("labelImageMarker"), a;
  }
  function a(o) {
    return o === 91 ? (e.enter("labelMarker"), e.consume(o), e.exit("labelMarker"), e.exit("labelImage"), s) : n(o);
  }
  function s(o) {
    return o === 94 && "_hiddenFootnoteSupport" in r.parser.constructs ? n(o) : t(o);
  }
}
const CT = {
  name: "labelStartLink",
  resolveAll: ff.resolveAll,
  tokenize: IT
};
function IT(e, t, n) {
  const r = this;
  return i;
  function i(s) {
    return e.enter("labelLink"), e.enter("labelMarker"), e.consume(s), e.exit("labelMarker"), e.exit("labelLink"), a;
  }
  function a(s) {
    return s === 94 && "_hiddenFootnoteSupport" in r.parser.constructs ? n(s) : t(s);
  }
}
const Zc = {
  name: "lineEnding",
  tokenize: ST
};
function ST(e, t) {
  return n;
  function n(r) {
    return e.enter("lineEnding"), e.consume(r), e.exit("lineEnding"), je(e, t, "linePrefix");
  }
}
const Lo = {
  name: "thematicBreak",
  tokenize: AT
};
function AT(e, t, n) {
  let r = 0, i;
  return a;
  function a(c) {
    return e.enter("thematicBreak"), s(c);
  }
  function s(c) {
    return i = c, o(c);
  }
  function o(c) {
    return c === i ? (e.enter("thematicBreakSequence"), l(c)) : r >= 3 && (c === null || _e(c)) ? (e.exit("thematicBreak"), t(c)) : n(c);
  }
  function l(c) {
    return c === i ? (e.consume(c), r++, l) : (e.exit("thematicBreakSequence"), Le(c) ? je(e, o, "whitespace")(c) : o(c));
  }
}
const un = {
  continuation: {
    tokenize: NT
  },
  exit: MT,
  name: "list",
  tokenize: RT
}, kT = {
  partial: !0,
  tokenize: PT
}, TT = {
  partial: !0,
  tokenize: OT
};
function RT(e, t, n) {
  const r = this, i = r.events[r.events.length - 1];
  let a = i && i[1].type === "linePrefix" ? i[2].sliceSerialize(i[1], !0).length : 0, s = 0;
  return o;
  function o(p) {
    const h = r.containerState.type || (p === 42 || p === 43 || p === 45 ? "listUnordered" : "listOrdered");
    if (h === "listUnordered" ? !r.containerState.marker || p === r.containerState.marker : $u(p)) {
      if (r.containerState.type || (r.containerState.type = h, e.enter(h, {
        _container: !0
      })), h === "listUnordered")
        return e.enter("listItemPrefix"), p === 42 || p === 45 ? e.check(Lo, n, c)(p) : c(p);
      if (!r.interrupt || p === 49)
        return e.enter("listItemPrefix"), e.enter("listItemValue"), l(p);
    }
    return n(p);
  }
  function l(p) {
    return $u(p) && ++s < 10 ? (e.consume(p), l) : (!r.interrupt || s < 2) && (r.containerState.marker ? p === r.containerState.marker : p === 41 || p === 46) ? (e.exit("listItemValue"), c(p)) : n(p);
  }
  function c(p) {
    return e.enter("listItemMarker"), e.consume(p), e.exit("listItemMarker"), r.containerState.marker = r.containerState.marker || p, e.check(
      Ks,
      // Cant be empty when interrupting.
      r.interrupt ? n : u,
      e.attempt(kT, f, d)
    );
  }
  function u(p) {
    return r.containerState.initialBlankLine = !0, a++, f(p);
  }
  function d(p) {
    return Le(p) ? (e.enter("listItemPrefixWhitespace"), e.consume(p), e.exit("listItemPrefixWhitespace"), f) : n(p);
  }
  function f(p) {
    return r.containerState.size = a + r.sliceSerialize(e.exit("listItemPrefix"), !0).length, t(p);
  }
}
function NT(e, t, n) {
  const r = this;
  return r.containerState._closeFlow = void 0, e.check(Ks, i, a);
  function i(o) {
    return r.containerState.furtherBlankLines = r.containerState.furtherBlankLines || r.containerState.initialBlankLine, je(e, t, "listItemIndent", r.containerState.size + 1)(o);
  }
  function a(o) {
    return r.containerState.furtherBlankLines || !Le(o) ? (r.containerState.furtherBlankLines = void 0, r.containerState.initialBlankLine = void 0, s(o)) : (r.containerState.furtherBlankLines = void 0, r.containerState.initialBlankLine = void 0, e.attempt(TT, t, s)(o));
  }
  function s(o) {
    return r.containerState._closeFlow = !0, r.interrupt = void 0, je(e, e.attempt(un, t, n), "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(o);
  }
}
function OT(e, t, n) {
  const r = this;
  return je(e, i, "listItemIndent", r.containerState.size + 1);
  function i(a) {
    const s = r.events[r.events.length - 1];
    return s && s[1].type === "listItemIndent" && s[2].sliceSerialize(s[1], !0).length === r.containerState.size ? t(a) : n(a);
  }
}
function MT(e) {
  e.exit(this.containerState.type);
}
function PT(e, t, n) {
  const r = this;
  return je(e, i, "listItemPrefixWhitespace", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 5);
  function i(a) {
    const s = r.events[r.events.length - 1];
    return !Le(a) && s && s[1].type === "listItemPrefixWhitespace" ? t(a) : n(a);
  }
}
const Oh = {
  name: "setextUnderline",
  resolveTo: DT,
  tokenize: LT
};
function DT(e, t) {
  let n = e.length, r, i, a;
  for (; n--; )
    if (e[n][0] === "enter") {
      if (e[n][1].type === "content") {
        r = n;
        break;
      }
      e[n][1].type === "paragraph" && (i = n);
    } else
      e[n][1].type === "content" && e.splice(n, 1), !a && e[n][1].type === "definition" && (a = n);
  const s = {
    type: "setextHeading",
    start: {
      ...e[i][1].start
    },
    end: {
      ...e[e.length - 1][1].end
    }
  };
  return e[i][1].type = "setextHeadingText", a ? (e.splice(i, 0, ["enter", s, t]), e.splice(a + 1, 0, ["exit", e[r][1], t]), e[r][1].end = {
    ...e[a][1].end
  }) : e[r][1] = s, e.push(["exit", s, t]), e;
}
function LT(e, t, n) {
  const r = this;
  let i;
  return a;
  function a(c) {
    let u = r.events.length, d;
    for (; u--; )
      if (r.events[u][1].type !== "lineEnding" && r.events[u][1].type !== "linePrefix" && r.events[u][1].type !== "content") {
        d = r.events[u][1].type === "paragraph";
        break;
      }
    return !r.parser.lazy[r.now().line] && (r.interrupt || d) ? (e.enter("setextHeadingLine"), i = c, s(c)) : n(c);
  }
  function s(c) {
    return e.enter("setextHeadingLineSequence"), o(c);
  }
  function o(c) {
    return c === i ? (e.consume(c), o) : (e.exit("setextHeadingLineSequence"), Le(c) ? je(e, l, "lineSuffix")(c) : l(c));
  }
  function l(c) {
    return c === null || _e(c) ? (e.exit("setextHeadingLine"), t(c)) : n(c);
  }
}
const FT = {
  tokenize: BT
};
function BT(e) {
  const t = this, n = e.attempt(
    // Try to parse a blank line.
    Ks,
    r,
    // Try to parse initial flow (essentially, only code).
    e.attempt(this.parser.constructs.flowInitial, i, je(e, e.attempt(this.parser.constructs.flow, i, e.attempt(Uk, i)), "linePrefix"))
  );
  return n;
  function r(a) {
    if (a === null) {
      e.consume(a);
      return;
    }
    return e.enter("lineEndingBlank"), e.consume(a), e.exit("lineEndingBlank"), t.currentConstruct = void 0, n;
  }
  function i(a) {
    if (a === null) {
      e.consume(a);
      return;
    }
    return e.enter("lineEnding"), e.consume(a), e.exit("lineEnding"), t.currentConstruct = void 0, n;
  }
}
const zT = {
  resolveAll: my()
}, VT = gy("string"), GT = gy("text");
function gy(e) {
  return {
    resolveAll: my(e === "text" ? jT : void 0),
    tokenize: t
  };
  function t(n) {
    const r = this, i = this.parser.constructs[e], a = n.attempt(i, s, o);
    return s;
    function s(u) {
      return c(u) ? a(u) : o(u);
    }
    function o(u) {
      if (u === null) {
        n.consume(u);
        return;
      }
      return n.enter("data"), n.consume(u), l;
    }
    function l(u) {
      return c(u) ? (n.exit("data"), a(u)) : (n.consume(u), l);
    }
    function c(u) {
      if (u === null)
        return !0;
      const d = i[u];
      let f = -1;
      if (d)
        for (; ++f < d.length; ) {
          const p = d[f];
          if (!p.previous || p.previous.call(r, r.previous))
            return !0;
        }
      return !1;
    }
  }
}
function my(e) {
  return t;
  function t(n, r) {
    let i = -1, a;
    for (; ++i <= n.length; )
      a === void 0 ? n[i] && n[i][1].type === "data" && (a = i, i++) : (!n[i] || n[i][1].type !== "data") && (i !== a + 2 && (n[a][1].end = n[i - 1][1].end, n.splice(a + 2, i - a - 2), i = a + 2), a = void 0);
    return e ? e(n, r) : n;
  }
}
function jT(e, t) {
  let n = 0;
  for (; ++n <= e.length; )
    if ((n === e.length || e[n][1].type === "lineEnding") && e[n - 1][1].type === "data") {
      const r = e[n - 1][1], i = t.sliceStream(r);
      let a = i.length, s = -1, o = 0, l;
      for (; a--; ) {
        const c = i[a];
        if (typeof c == "string") {
          for (s = c.length; c.charCodeAt(s - 1) === 32; )
            o++, s--;
          if (s) break;
          s = -1;
        } else if (c === -2)
          l = !0, o++;
        else if (c !== -1) {
          a++;
          break;
        }
      }
      if (o) {
        const c = {
          type: n === e.length || l || o < 2 ? "lineSuffix" : "hardBreakTrailing",
          start: {
            _bufferIndex: a ? s : r.start._bufferIndex + s,
            _index: r.start._index + a,
            line: r.end.line,
            column: r.end.column - o,
            offset: r.end.offset - o
          },
          end: {
            ...r.end
          }
        };
        r.end = {
          ...c.start
        }, r.start.offset === r.end.offset ? Object.assign(r, c) : (e.splice(n, 0, ["enter", c, t], ["exit", c, t]), n += 2);
      }
      n++;
    }
  return e;
}
const UT = {
  42: un,
  43: un,
  45: un,
  48: un,
  49: un,
  50: un,
  51: un,
  52: un,
  53: un,
  54: un,
  55: un,
  56: un,
  57: un,
  62: ly
}, HT = {
  91: Xk
}, WT = {
  [-2]: Wc,
  [-1]: Wc,
  32: Wc
}, ZT = {
  35: eT,
  42: Lo,
  45: [Oh, Lo],
  60: iT,
  61: Oh,
  95: Lo,
  96: Rh,
  126: Rh
}, $T = {
  38: uy,
  92: cy
}, XT = {
  [-5]: Zc,
  [-4]: Zc,
  [-3]: Zc,
  33: ET,
  38: uy,
  42: Xu,
  60: [Ck, dT],
  91: CT,
  92: [Kk, cy],
  93: ff,
  95: Xu,
  96: Fk
}, YT = {
  null: [Xu, zT]
}, JT = {
  null: [42, 95]
}, qT = {
  null: []
}, KT = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  attentionMarkers: JT,
  contentInitial: HT,
  disable: qT,
  document: UT,
  flow: ZT,
  flowInitial: WT,
  insideSpan: YT,
  string: $T,
  text: XT
}, Symbol.toStringTag, { value: "Module" }));
function QT(e, t, n) {
  let r = {
    _bufferIndex: -1,
    _index: 0,
    line: n && n.line || 1,
    column: n && n.column || 1,
    offset: n && n.offset || 0
  };
  const i = {}, a = [];
  let s = [], o = [];
  const l = {
    attempt: I(_),
    check: I(x),
    consume: y,
    enter: v,
    exit: E,
    interrupt: I(x, {
      interrupt: !0
    })
  }, c = {
    code: null,
    containerState: {},
    defineSkip: g,
    events: [],
    now: h,
    parser: e,
    previous: null,
    sliceSerialize: f,
    sliceStream: p,
    write: d
  };
  let u = t.tokenize.call(c, l);
  return t.resolveAll && a.push(t), c;
  function d(W) {
    return s = jn(s, W), m(), s[s.length - 1] !== null ? [] : (T(t, 0), c.events = ec(a, c.events, c), c.events);
  }
  function f(W, M) {
    return tR(p(W), M);
  }
  function p(W) {
    return eR(s, W);
  }
  function h() {
    const {
      _bufferIndex: W,
      _index: M,
      line: L,
      column: z,
      offset: U
    } = r;
    return {
      _bufferIndex: W,
      _index: M,
      line: L,
      column: z,
      offset: U
    };
  }
  function g(W) {
    i[W.line] = W.column, k();
  }
  function m() {
    let W;
    for (; r._index < s.length; ) {
      const M = s[r._index];
      if (typeof M == "string")
        for (W = r._index, r._bufferIndex < 0 && (r._bufferIndex = 0); r._index === W && r._bufferIndex < M.length; )
          b(M.charCodeAt(r._bufferIndex));
      else
        b(M);
    }
  }
  function b(W) {
    u = u(W);
  }
  function y(W) {
    _e(W) ? (r.line++, r.column = 1, r.offset += W === -3 ? 2 : 1, k()) : W !== -1 && (r.column++, r.offset++), r._bufferIndex < 0 ? r._index++ : (r._bufferIndex++, r._bufferIndex === // Points w/ non-negative `_bufferIndex` reference
    // strings.
    /** @type {string} */
    s[r._index].length && (r._bufferIndex = -1, r._index++)), c.previous = W;
  }
  function v(W, M) {
    const L = M || {};
    return L.type = W, L.start = h(), c.events.push(["enter", L, c]), o.push(L), L;
  }
  function E(W) {
    const M = o.pop();
    return M.end = h(), c.events.push(["exit", M, c]), M;
  }
  function _(W, M) {
    T(W, M.from);
  }
  function x(W, M) {
    M.restore();
  }
  function I(W, M) {
    return L;
    function L(z, U, $) {
      let Q, K, fe, S;
      return Array.isArray(z) ? (
        /* c8 ignore next 1 */
        se(z)
      ) : "tokenize" in z ? (
        // Looks like a construct.
        se([
          /** @type {Construct} */
          z
        ])
      ) : me(z);
      function me(Ce) {
        return Je;
        function Je(Be) {
          const it = Be !== null && Ce[Be], at = Be !== null && Ce.null, mt = [
            // To do: add more extension tests.
            /* c8 ignore next 2 */
            ...Array.isArray(it) ? it : it ? [it] : [],
            ...Array.isArray(at) ? at : at ? [at] : []
          ];
          return se(mt)(Be);
        }
      }
      function se(Ce) {
        return Q = Ce, K = 0, Ce.length === 0 ? $ : A(Ce[K]);
      }
      function A(Ce) {
        return Je;
        function Je(Be) {
          return S = O(), fe = Ce, Ce.partial || (c.currentConstruct = Ce), Ce.name && c.parser.constructs.disable.null.includes(Ce.name) ? Te() : Ce.tokenize.call(
            // If we do have fields, create an object w/ `context` as its
            // prototype.
            // This allows a live binding, which is needed for `interrupt`.
            M ? Object.assign(Object.create(c), M) : c,
            l,
            ve,
            Te
          )(Be);
        }
      }
      function ve(Ce) {
        return W(fe, S), U;
      }
      function Te(Ce) {
        return S.restore(), ++K < Q.length ? A(Q[K]) : $;
      }
    }
  }
  function T(W, M) {
    W.resolveAll && !a.includes(W) && a.push(W), W.resolve && Nn(c.events, M, c.events.length - M, W.resolve(c.events.slice(M), c)), W.resolveTo && (c.events = W.resolveTo(c.events, c));
  }
  function O() {
    const W = h(), M = c.previous, L = c.currentConstruct, z = c.events.length, U = Array.from(o);
    return {
      from: z,
      restore: $
    };
    function $() {
      r = W, c.previous = M, c.currentConstruct = L, c.events.length = z, o = U, k();
    }
  }
  function k() {
    r.line in i && r.column < 2 && (r.column = i[r.line], r.offset += i[r.line] - 1);
  }
}
function eR(e, t) {
  const n = t.start._index, r = t.start._bufferIndex, i = t.end._index, a = t.end._bufferIndex;
  let s;
  if (n === i)
    s = [e[n].slice(r, a)];
  else {
    if (s = e.slice(n, i), r > -1) {
      const o = s[0];
      typeof o == "string" ? s[0] = o.slice(r) : s.shift();
    }
    a > 0 && s.push(e[i].slice(0, a));
  }
  return s;
}
function tR(e, t) {
  let n = -1;
  const r = [];
  let i;
  for (; ++n < e.length; ) {
    const a = e[n];
    let s;
    if (typeof a == "string")
      s = a;
    else switch (a) {
      case -5: {
        s = "\r";
        break;
      }
      case -4: {
        s = `
`;
        break;
      }
      case -3: {
        s = `\r
`;
        break;
      }
      case -2: {
        s = t ? " " : "	";
        break;
      }
      case -1: {
        if (!t && i) continue;
        s = " ";
        break;
      }
      default:
        s = String.fromCharCode(a);
    }
    i = a === -2, r.push(s);
  }
  return r.join("");
}
function nR(e) {
  const r = {
    constructs: (
      /** @type {FullNormalizedExtension} */
      sy([KT, ...(e || {}).extensions || []])
    ),
    content: i(bk),
    defined: [],
    document: i(_k),
    flow: i(FT),
    lazy: {},
    string: i(VT),
    text: i(GT)
  };
  return r;
  function i(a) {
    return s;
    function s(o) {
      return QT(r, a, o);
    }
  }
}
function rR(e) {
  for (; !dy(e); )
    ;
  return e;
}
const Mh = /[\0\t\n\r]/g;
function iR() {
  let e = 1, t = "", n = !0, r;
  return i;
  function i(a, s, o) {
    const l = [];
    let c, u, d, f, p;
    for (a = t + (typeof a == "string" ? a.toString() : new TextDecoder(s || void 0).decode(a)), d = 0, t = "", n && (a.charCodeAt(0) === 65279 && d++, n = void 0); d < a.length; ) {
      if (Mh.lastIndex = d, c = Mh.exec(a), f = c && c.index !== void 0 ? c.index : a.length, p = a.charCodeAt(f), !c) {
        t = a.slice(d);
        break;
      }
      if (p === 10 && d === f && r)
        l.push(-3), r = void 0;
      else
        switch (r && (l.push(-5), r = void 0), d < f && (l.push(a.slice(d, f)), e += f - d), p) {
          case 0: {
            l.push(65533), e++;
            break;
          }
          case 9: {
            for (u = Math.ceil(e / 4) * 4, l.push(-2); e++ < u; ) l.push(-1);
            break;
          }
          case 10: {
            l.push(-4), e = 1;
            break;
          }
          default:
            r = !0, e = 1;
        }
      d = f + 1;
    }
    return o && (r && l.push(-5), t && l.push(t), l.push(null)), l;
  }
}
const aR = /\\([!-/:-@[-`{-~])|&(#(?:\d{1,7}|x[\da-f]{1,6})|[\da-z]{1,31});/gi;
function sR(e) {
  return e.replace(aR, oR);
}
function oR(e, t, n) {
  if (t)
    return t;
  if (n.charCodeAt(0) === 35) {
    const i = n.charCodeAt(1), a = i === 120 || i === 88;
    return oy(n.slice(a ? 2 : 1), a ? 16 : 10);
  }
  return df(n) || e;
}
const by = {}.hasOwnProperty;
function lR(e, t, n) {
  return typeof t != "string" && (n = t, t = void 0), cR(n)(rR(nR(n).document().write(iR()(e, t, !0))));
}
function cR(e) {
  const t = {
    transforms: [],
    canContainEols: ["emphasis", "fragment", "heading", "paragraph", "strong"],
    enter: {
      autolink: a(D),
      autolinkProtocol: O,
      autolinkEmail: O,
      atxHeading: a(wt),
      blockQuote: a(at),
      characterEscape: O,
      characterReference: O,
      codeFenced: a(mt),
      codeFencedFenceInfo: s,
      codeFencedFenceMeta: s,
      codeIndented: a(mt, s),
      codeText: a(ie, s),
      codeTextData: O,
      data: O,
      codeFlowValue: O,
      definition: a(Rt),
      definitionDestinationString: s,
      definitionLabelString: s,
      definitionTitleString: s,
      emphasis: a(ft),
      hardBreakEscape: a(Fe),
      hardBreakTrailing: a(Fe),
      htmlFlow: a(en, s),
      htmlFlowData: O,
      htmlText: a(en, s),
      htmlTextData: O,
      image: a(R),
      label: s,
      link: a(D),
      listItem: a(C),
      listItemValue: f,
      listOrdered: a(V, d),
      listUnordered: a(V),
      paragraph: a(G),
      reference: A,
      referenceString: s,
      resourceDestinationString: s,
      resourceTitleString: s,
      setextHeading: a(wt),
      strong: a(B),
      thematicBreak: a(ce)
    },
    exit: {
      atxHeading: l(),
      atxHeadingSequence: _,
      autolink: l(),
      autolinkEmail: it,
      autolinkProtocol: Be,
      blockQuote: l(),
      characterEscapeValue: k,
      characterReferenceMarkerHexadecimal: Te,
      characterReferenceMarkerNumeric: Te,
      characterReferenceValue: Ce,
      characterReference: Je,
      codeFenced: l(m),
      codeFencedFence: g,
      codeFencedFenceInfo: p,
      codeFencedFenceMeta: h,
      codeFlowValue: k,
      codeIndented: l(b),
      codeText: l(U),
      codeTextData: k,
      data: k,
      definition: l(),
      definitionDestinationString: E,
      definitionLabelString: y,
      definitionTitleString: v,
      emphasis: l(),
      hardBreakEscape: l(M),
      hardBreakTrailing: l(M),
      htmlFlow: l(L),
      htmlFlowData: k,
      htmlText: l(z),
      htmlTextData: k,
      image: l(Q),
      label: fe,
      labelText: K,
      lineEnding: W,
      link: l($),
      listItem: l(),
      listOrdered: l(),
      listUnordered: l(),
      paragraph: l(),
      referenceString: ve,
      resourceDestinationString: S,
      resourceTitleString: me,
      resource: se,
      setextHeading: l(T),
      setextHeadingLineSequence: I,
      setextHeadingText: x,
      strong: l(),
      thematicBreak: l()
    }
  };
  yy(t, (e || {}).mdastExtensions || []);
  const n = {};
  return r;
  function r(P) {
    let j = {
      type: "root",
      children: []
    };
    const oe = {
      stack: [j],
      tokenStack: [],
      config: t,
      enter: o,
      exit: c,
      buffer: s,
      resume: u,
      data: n
    }, Ie = [];
    let xe = -1;
    for (; ++xe < P.length; )
      if (P[xe][1].type === "listOrdered" || P[xe][1].type === "listUnordered")
        if (P[xe][0] === "enter")
          Ie.push(xe);
        else {
          const rt = Ie.pop();
          xe = i(P, rt, xe);
        }
    for (xe = -1; ++xe < P.length; ) {
      const rt = t[P[xe][0]];
      by.call(rt, P[xe][1].type) && rt[P[xe][1].type].call(Object.assign({
        sliceSerialize: P[xe][2].sliceSerialize
      }, oe), P[xe][1]);
    }
    if (oe.tokenStack.length > 0) {
      const rt = oe.tokenStack[oe.tokenStack.length - 1];
      (rt[1] || Ph).call(oe, void 0, rt[0]);
    }
    for (j.position = {
      start: Yr(P.length > 0 ? P[0][1].start : {
        line: 1,
        column: 1,
        offset: 0
      }),
      end: Yr(P.length > 0 ? P[P.length - 2][1].end : {
        line: 1,
        column: 1,
        offset: 0
      })
    }, xe = -1; ++xe < t.transforms.length; )
      j = t.transforms[xe](j) || j;
    return j;
  }
  function i(P, j, oe) {
    let Ie = j - 1, xe = -1, rt = !1, Ft, ot, tn, Ct;
    for (; ++Ie <= oe; ) {
      const nn = P[Ie];
      switch (nn[1].type) {
        case "listUnordered":
        case "listOrdered":
        case "blockQuote": {
          nn[0] === "enter" ? xe++ : xe--, Ct = void 0;
          break;
        }
        case "lineEndingBlank": {
          nn[0] === "enter" && (Ft && !Ct && !xe && !tn && (tn = Ie), Ct = void 0);
          break;
        }
        case "linePrefix":
        case "listItemValue":
        case "listItemMarker":
        case "listItemPrefix":
        case "listItemPrefixWhitespace":
          break;
        default:
          Ct = void 0;
      }
      if (!xe && nn[0] === "enter" && nn[1].type === "listItemPrefix" || xe === -1 && nn[0] === "exit" && (nn[1].type === "listUnordered" || nn[1].type === "listOrdered")) {
        if (Ft) {
          let Zr = Ie;
          for (ot = void 0; Zr--; ) {
            const wn = P[Zr];
            if (wn[1].type === "lineEnding" || wn[1].type === "lineEndingBlank") {
              if (wn[0] === "exit") continue;
              ot && (P[ot][1].type = "lineEndingBlank", rt = !0), wn[1].type = "lineEnding", ot = Zr;
            } else if (!(wn[1].type === "linePrefix" || wn[1].type === "blockQuotePrefix" || wn[1].type === "blockQuotePrefixWhitespace" || wn[1].type === "blockQuoteMarker" || wn[1].type === "listItemIndent")) break;
          }
          tn && (!ot || tn < ot) && (Ft._spread = !0), Ft.end = Object.assign({}, ot ? P[ot][1].start : nn[1].end), P.splice(ot || Ie, 0, ["exit", Ft, nn[2]]), Ie++, oe++;
        }
        if (nn[1].type === "listItemPrefix") {
          const Zr = {
            type: "listItem",
            _spread: !1,
            start: Object.assign({}, nn[1].start),
            // @ts-expect-error: well add `end` in a second.
            end: void 0
          };
          Ft = Zr, P.splice(Ie, 0, ["enter", Zr, nn[2]]), Ie++, oe++, tn = void 0, Ct = !0;
        }
      }
    }
    return P[j][1]._spread = rt, oe;
  }
  function a(P, j) {
    return oe;
    function oe(Ie) {
      o.call(this, P(Ie), Ie), j && j.call(this, Ie);
    }
  }
  function s() {
    this.stack.push({
      type: "fragment",
      children: []
    });
  }
  function o(P, j, oe) {
    this.stack[this.stack.length - 1].children.push(P), this.stack.push(P), this.tokenStack.push([j, oe || void 0]), P.position = {
      start: Yr(j.start),
      // @ts-expect-error: `end` will be patched later.
      end: void 0
    };
  }
  function l(P) {
    return j;
    function j(oe) {
      P && P.call(this, oe), c.call(this, oe);
    }
  }
  function c(P, j) {
    const oe = this.stack.pop(), Ie = this.tokenStack.pop();
    if (Ie)
      Ie[0].type !== P.type && (j ? j.call(this, P, Ie[0]) : (Ie[1] || Ph).call(this, P, Ie[0]));
    else throw new Error("Cannot close `" + P.type + "` (" + os({
      start: P.start,
      end: P.end
    }) + "): its not open");
    oe.position.end = Yr(P.end);
  }
  function u() {
    return uf(this.stack.pop());
  }
  function d() {
    this.data.expectingFirstListItemValue = !0;
  }
  function f(P) {
    if (this.data.expectingFirstListItemValue) {
      const j = this.stack[this.stack.length - 2];
      j.start = Number.parseInt(this.sliceSerialize(P), 10), this.data.expectingFirstListItemValue = void 0;
    }
  }
  function p() {
    const P = this.resume(), j = this.stack[this.stack.length - 1];
    j.lang = P;
  }
  function h() {
    const P = this.resume(), j = this.stack[this.stack.length - 1];
    j.meta = P;
  }
  function g() {
    this.data.flowCodeInside || (this.buffer(), this.data.flowCodeInside = !0);
  }
  function m() {
    const P = this.resume(), j = this.stack[this.stack.length - 1];
    j.value = P.replace(/^(\r?\n|\r)|(\r?\n|\r)$/g, ""), this.data.flowCodeInside = void 0;
  }
  function b() {
    const P = this.resume(), j = this.stack[this.stack.length - 1];
    j.value = P.replace(/(\r?\n|\r)$/g, "");
  }
  function y(P) {
    const j = this.resume(), oe = this.stack[this.stack.length - 1];
    oe.label = j, oe.identifier = Qn(this.sliceSerialize(P)).toLowerCase();
  }
  function v() {
    const P = this.resume(), j = this.stack[this.stack.length - 1];
    j.title = P;
  }
  function E() {
    const P = this.resume(), j = this.stack[this.stack.length - 1];
    j.url = P;
  }
  function _(P) {
    const j = this.stack[this.stack.length - 1];
    if (!j.depth) {
      const oe = this.sliceSerialize(P).length;
      j.depth = oe;
    }
  }
  function x() {
    this.data.setextHeadingSlurpLineEnding = !0;
  }
  function I(P) {
    const j = this.stack[this.stack.length - 1];
    j.depth = this.sliceSerialize(P).codePointAt(0) === 61 ? 1 : 2;
  }
  function T() {
    this.data.setextHeadingSlurpLineEnding = void 0;
  }
  function O(P) {
    const oe = this.stack[this.stack.length - 1].children;
    let Ie = oe[oe.length - 1];
    (!Ie || Ie.type !== "text") && (Ie = Y(), Ie.position = {
      start: Yr(P.start),
      // @ts-expect-error: well add `end` later.
      end: void 0
    }, oe.push(Ie)), this.stack.push(Ie);
  }
  function k(P) {
    const j = this.stack.pop();
    j.value += this.sliceSerialize(P), j.position.end = Yr(P.end);
  }
  function W(P) {
    const j = this.stack[this.stack.length - 1];
    if (this.data.atHardBreak) {
      const oe = j.children[j.children.length - 1];
      oe.position.end = Yr(P.end), this.data.atHardBreak = void 0;
      return;
    }
    !this.data.setextHeadingSlurpLineEnding && t.canContainEols.includes(j.type) && (O.call(this, P), k.call(this, P));
  }
  function M() {
    this.data.atHardBreak = !0;
  }
  function L() {
    const P = this.resume(), j = this.stack[this.stack.length - 1];
    j.value = P;
  }
  function z() {
    const P = this.resume(), j = this.stack[this.stack.length - 1];
    j.value = P;
  }
  function U() {
    const P = this.resume(), j = this.stack[this.stack.length - 1];
    j.value = P;
  }
  function $() {
    const P = this.stack[this.stack.length - 1];
    if (this.data.inReference) {
      const j = this.data.referenceType || "shortcut";
      P.type += "Reference", P.referenceType = j, delete P.url, delete P.title;
    } else
      delete P.identifier, delete P.label;
    this.data.referenceType = void 0;
  }
  function Q() {
    const P = this.stack[this.stack.length - 1];
    if (this.data.inReference) {
      const j = this.data.referenceType || "shortcut";
      P.type += "Reference", P.referenceType = j, delete P.url, delete P.title;
    } else
      delete P.identifier, delete P.label;
    this.data.referenceType = void 0;
  }
  function K(P) {
    const j = this.sliceSerialize(P), oe = this.stack[this.stack.length - 2];
    oe.label = sR(j), oe.identifier = Qn(j).toLowerCase();
  }
  function fe() {
    const P = this.stack[this.stack.length - 1], j = this.resume(), oe = this.stack[this.stack.length - 1];
    if (this.data.inReference = !0, oe.type === "link") {
      const Ie = P.children;
      oe.children = Ie;
    } else
      oe.alt = j;
  }
  function S() {
    const P = this.resume(), j = this.stack[this.stack.length - 1];
    j.url = P;
  }
  function me() {
    const P = this.resume(), j = this.stack[this.stack.length - 1];
    j.title = P;
  }
  function se() {
    this.data.inReference = void 0;
  }
  function A() {
    this.data.referenceType = "collapsed";
  }
  function ve(P) {
    const j = this.resume(), oe = this.stack[this.stack.length - 1];
    oe.label = j, oe.identifier = Qn(this.sliceSerialize(P)).toLowerCase(), this.data.referenceType = "full";
  }
  function Te(P) {
    this.data.characterReferenceType = P.type;
  }
  function Ce(P) {
    const j = this.sliceSerialize(P), oe = this.data.characterReferenceType;
    let Ie;
    oe ? (Ie = oy(j, oe === "characterReferenceMarkerNumeric" ? 10 : 16), this.data.characterReferenceType = void 0) : Ie = df(j);
    const xe = this.stack[this.stack.length - 1];
    xe.value += Ie;
  }
  function Je(P) {
    const j = this.stack.pop();
    j.position.end = Yr(P.end);
  }
  function Be(P) {
    k.call(this, P);
    const j = this.stack[this.stack.length - 1];
    j.url = this.sliceSerialize(P);
  }
  function it(P) {
    k.call(this, P);
    const j = this.stack[this.stack.length - 1];
    j.url = "mailto:" + this.sliceSerialize(P);
  }
  function at() {
    return {
      type: "blockquote",
      children: []
    };
  }
  function mt() {
    return {
      type: "code",
      lang: null,
      meta: null,
      value: ""
    };
  }
  function ie() {
    return {
      type: "inlineCode",
      value: ""
    };
  }
  function Rt() {
    return {
      type: "definition",
      identifier: "",
      label: null,
      title: null,
      url: ""
    };
  }
  function ft() {
    return {
      type: "emphasis",
      children: []
    };
  }
  function wt() {
    return {
      type: "heading",
      // @ts-expect-error `depth` will be set later.
      depth: 0,
      children: []
    };
  }
  function Fe() {
    return {
      type: "break"
    };
  }
  function en() {
    return {
      type: "html",
      value: ""
    };
  }
  function R() {
    return {
      type: "image",
      title: null,
      url: "",
      alt: null
    };
  }
  function D() {
    return {
      type: "link",
      title: null,
      url: "",
      children: []
    };
  }
  function V(P) {
    return {
      type: "list",
      ordered: P.type === "listOrdered",
      start: null,
      spread: P._spread,
      children: []
    };
  }
  function C(P) {
    return {
      type: "listItem",
      spread: P._spread,
      checked: null,
      children: []
    };
  }
  function G() {
    return {
      type: "paragraph",
      children: []
    };
  }
  function B() {
    return {
      type: "strong",
      children: []
    };
  }
  function Y() {
    return {
      type: "text",
      value: ""
    };
  }
  function ce() {
    return {
      type: "thematicBreak"
    };
  }
}
function Yr(e) {
  return {
    line: e.line,
    column: e.column,
    offset: e.offset
  };
}
function yy(e, t) {
  let n = -1;
  for (; ++n < t.length; ) {
    const r = t[n];
    Array.isArray(r) ? yy(e, r) : uR(e, r);
  }
}
function uR(e, t) {
  let n;
  for (n in t)
    if (by.call(t, n))
      switch (n) {
        case "canContainEols": {
          const r = t[n];
          r && e[n].push(...r);
          break;
        }
        case "transforms": {
          const r = t[n];
          r && e[n].push(...r);
          break;
        }
        case "enter":
        case "exit": {
          const r = t[n];
          r && Object.assign(e[n], r);
          break;
        }
      }
}
function Ph(e, t) {
  throw e ? new Error("Cannot close `" + e.type + "` (" + os({
    start: e.start,
    end: e.end
  }) + "): a different token (`" + t.type + "`, " + os({
    start: t.start,
    end: t.end
  }) + ") is open") : new Error("Cannot close document, a token (`" + t.type + "`, " + os({
    start: t.start,
    end: t.end
  }) + ") is still open");
}
function dR(e) {
  const t = this;
  t.parser = n;
  function n(r) {
    return lR(r, {
      ...t.data("settings"),
      ...e,
      // Note: these options are not in the readme.
      // The goal is for them to be set by plugins on `data` instead of being
      // passed by users.
      extensions: t.data("micromarkExtensions") || [],
      mdastExtensions: t.data("fromMarkdownExtensions") || []
    });
  }
}
function fR(e, t) {
  const n = {
    type: "element",
    tagName: "blockquote",
    properties: {},
    children: e.wrap(e.all(t), !0)
  };
  return e.patch(t, n), e.applyData(t, n);
}
function pR(e, t) {
  const n = { type: "element", tagName: "br", properties: {}, children: [] };
  return e.patch(t, n), [e.applyData(t, n), { type: "text", value: `
` }];
}
function hR(e, t) {
  const n = t.value ? t.value + `
` : "", r = {};
  t.lang && (r.className = ["language-" + t.lang]);
  let i = {
    type: "element",
    tagName: "code",
    properties: r,
    children: [{ type: "text", value: n }]
  };
  return t.meta && (i.data = { meta: t.meta }), e.patch(t, i), i = e.applyData(t, i), i = { type: "element", tagName: "pre", properties: {}, children: [i] }, e.patch(t, i), i;
}
function gR(e, t) {
  const n = {
    type: "element",
    tagName: "del",
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, n), e.applyData(t, n);
}
function mR(e, t) {
  const n = {
    type: "element",
    tagName: "em",
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, n), e.applyData(t, n);
}
function bR(e, t) {
  const n = typeof e.options.clobberPrefix == "string" ? e.options.clobberPrefix : "user-content-", r = String(t.identifier).toUpperCase(), i = Oa(r.toLowerCase()), a = e.footnoteOrder.indexOf(r);
  let s, o = e.footnoteCounts.get(r);
  o === void 0 ? (o = 0, e.footnoteOrder.push(r), s = e.footnoteOrder.length) : s = a + 1, o += 1, e.footnoteCounts.set(r, o);
  const l = {
    type: "element",
    tagName: "a",
    properties: {
      href: "#" + n + "fn-" + i,
      id: n + "fnref-" + i + (o > 1 ? "-" + o : ""),
      dataFootnoteRef: !0,
      ariaDescribedBy: ["footnote-label"]
    },
    children: [{ type: "text", value: String(s) }]
  };
  e.patch(t, l);
  const c = {
    type: "element",
    tagName: "sup",
    properties: {},
    children: [l]
  };
  return e.patch(t, c), e.applyData(t, c);
}
function yR(e, t) {
  const n = {
    type: "element",
    tagName: "h" + t.depth,
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, n), e.applyData(t, n);
}
function _R(e, t) {
  if (e.options.allowDangerousHtml) {
    const n = { type: "raw", value: t.value };
    return e.patch(t, n), e.applyData(t, n);
  }
}
function _y(e, t) {
  const n = t.referenceType;
  let r = "]";
  if (n === "collapsed" ? r += "[]" : n === "full" && (r += "[" + (t.label || t.identifier) + "]"), t.type === "imageReference")
    return [{ type: "text", value: "![" + t.alt + r }];
  const i = e.all(t), a = i[0];
  a && a.type === "text" ? a.value = "[" + a.value : i.unshift({ type: "text", value: "[" });
  const s = i[i.length - 1];
  return s && s.type === "text" ? s.value += r : i.push({ type: "text", value: r }), i;
}
function vR(e, t) {
  const n = String(t.identifier).toUpperCase(), r = e.definitionById.get(n);
  if (!r)
    return _y(e, t);
  const i = { src: Oa(r.url || ""), alt: t.alt };
  r.title !== null && r.title !== void 0 && (i.title = r.title);
  const a = { type: "element", tagName: "img", properties: i, children: [] };
  return e.patch(t, a), e.applyData(t, a);
}
function xR(e, t) {
  const n = { src: Oa(t.url) };
  t.alt !== null && t.alt !== void 0 && (n.alt = t.alt), t.title !== null && t.title !== void 0 && (n.title = t.title);
  const r = { type: "element", tagName: "img", properties: n, children: [] };
  return e.patch(t, r), e.applyData(t, r);
}
function ER(e, t) {
  const n = { type: "text", value: t.value.replace(/\r?\n|\r/g, " ") };
  e.patch(t, n);
  const r = {
    type: "element",
    tagName: "code",
    properties: {},
    children: [n]
  };
  return e.patch(t, r), e.applyData(t, r);
}
function wR(e, t) {
  const n = String(t.identifier).toUpperCase(), r = e.definitionById.get(n);
  if (!r)
    return _y(e, t);
  const i = { href: Oa(r.url || "") };
  r.title !== null && r.title !== void 0 && (i.title = r.title);
  const a = {
    type: "element",
    tagName: "a",
    properties: i,
    children: e.all(t)
  };
  return e.patch(t, a), e.applyData(t, a);
}
function CR(e, t) {
  const n = { href: Oa(t.url) };
  t.title !== null && t.title !== void 0 && (n.title = t.title);
  const r = {
    type: "element",
    tagName: "a",
    properties: n,
    children: e.all(t)
  };
  return e.patch(t, r), e.applyData(t, r);
}
function IR(e, t, n) {
  const r = e.all(t), i = n ? SR(n) : vy(t), a = {}, s = [];
  if (typeof t.checked == "boolean") {
    const u = r[0];
    let d;
    u && u.type === "element" && u.tagName === "p" ? d = u : (d = { type: "element", tagName: "p", properties: {}, children: [] }, r.unshift(d)), d.children.length > 0 && d.children.unshift({ type: "text", value: " " }), d.children.unshift({
      type: "element",
      tagName: "input",
      properties: { type: "checkbox", checked: t.checked, disabled: !0 },
      children: []
    }), a.className = ["task-list-item"];
  }
  let o = -1;
  for (; ++o < r.length; ) {
    const u = r[o];
    (i || o !== 0 || u.type !== "element" || u.tagName !== "p") && s.push({ type: "text", value: `
` }), u.type === "element" && u.tagName === "p" && !i ? s.push(...u.children) : s.push(u);
  }
  const l = r[r.length - 1];
  l && (i || l.type !== "element" || l.tagName !== "p") && s.push({ type: "text", value: `
` });
  const c = { type: "element", tagName: "li", properties: a, children: s };
  return e.patch(t, c), e.applyData(t, c);
}
function SR(e) {
  let t = !1;
  if (e.type === "list") {
    t = e.spread || !1;
    const n = e.children;
    let r = -1;
    for (; !t && ++r < n.length; )
      t = vy(n[r]);
  }
  return t;
}
function vy(e) {
  const t = e.spread;
  return t ?? e.children.length > 1;
}
function AR(e, t) {
  const n = {}, r = e.all(t);
  let i = -1;
  for (typeof t.start == "number" && t.start !== 1 && (n.start = t.start); ++i < r.length; ) {
    const s = r[i];
    if (s.type === "element" && s.tagName === "li" && s.properties && Array.isArray(s.properties.className) && s.properties.className.includes("task-list-item")) {
      n.className = ["contains-task-list"];
      break;
    }
  }
  const a = {
    type: "element",
    tagName: t.ordered ? "ol" : "ul",
    properties: n,
    children: e.wrap(r, !0)
  };
  return e.patch(t, a), e.applyData(t, a);
}
function kR(e, t) {
  const n = {
    type: "element",
    tagName: "p",
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, n), e.applyData(t, n);
}
function TR(e, t) {
  const n = { type: "root", children: e.wrap(e.all(t)) };
  return e.patch(t, n), e.applyData(t, n);
}
function RR(e, t) {
  const n = {
    type: "element",
    tagName: "strong",
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, n), e.applyData(t, n);
}
function NR(e, t) {
  const n = e.all(t), r = n.shift(), i = [];
  if (r) {
    const s = {
      type: "element",
      tagName: "thead",
      properties: {},
      children: e.wrap([r], !0)
    };
    e.patch(t.children[0], s), i.push(s);
  }
  if (n.length > 0) {
    const s = {
      type: "element",
      tagName: "tbody",
      properties: {},
      children: e.wrap(n, !0)
    }, o = sf(t.children[1]), l = Qb(t.children[t.children.length - 1]);
    o && l && (s.position = { start: o, end: l }), i.push(s);
  }
  const a = {
    type: "element",
    tagName: "table",
    properties: {},
    children: e.wrap(i, !0)
  };
  return e.patch(t, a), e.applyData(t, a);
}
function OR(e, t, n) {
  const r = n ? n.children : void 0, a = (r ? r.indexOf(t) : 1) === 0 ? "th" : "td", s = n && n.type === "table" ? n.align : void 0, o = s ? s.length : t.children.length;
  let l = -1;
  const c = [];
  for (; ++l < o; ) {
    const d = t.children[l], f = {}, p = s ? s[l] : void 0;
    p && (f.align = p);
    let h = { type: "element", tagName: a, properties: f, children: [] };
    d && (h.children = e.all(d), e.patch(d, h), h = e.applyData(d, h)), c.push(h);
  }
  const u = {
    type: "element",
    tagName: "tr",
    properties: {},
    children: e.wrap(c, !0)
  };
  return e.patch(t, u), e.applyData(t, u);
}
function MR(e, t) {
  const n = {
    type: "element",
    tagName: "td",
    // Assume body cell.
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, n), e.applyData(t, n);
}
const Dh = 9, Lh = 32;
function PR(e) {
  const t = String(e), n = /\r?\n|\r/g;
  let r = n.exec(t), i = 0;
  const a = [];
  for (; r; )
    a.push(
      Fh(t.slice(i, r.index), i > 0, !0),
      r[0]
    ), i = r.index + r[0].length, r = n.exec(t);
  return a.push(Fh(t.slice(i), i > 0, !1)), a.join("");
}
function Fh(e, t, n) {
  let r = 0, i = e.length;
  if (t) {
    let a = e.codePointAt(r);
    for (; a === Dh || a === Lh; )
      r++, a = e.codePointAt(r);
  }
  if (n) {
    let a = e.codePointAt(i - 1);
    for (; a === Dh || a === Lh; )
      i--, a = e.codePointAt(i - 1);
  }
  return i > r ? e.slice(r, i) : "";
}
function DR(e, t) {
  const n = { type: "text", value: PR(String(t.value)) };
  return e.patch(t, n), e.applyData(t, n);
}
function LR(e, t) {
  const n = {
    type: "element",
    tagName: "hr",
    properties: {},
    children: []
  };
  return e.patch(t, n), e.applyData(t, n);
}
const FR = {
  blockquote: fR,
  break: pR,
  code: hR,
  delete: gR,
  emphasis: mR,
  footnoteReference: bR,
  heading: yR,
  html: _R,
  imageReference: vR,
  image: xR,
  inlineCode: ER,
  linkReference: wR,
  link: CR,
  listItem: IR,
  list: AR,
  paragraph: kR,
  // @ts-expect-error: root is different, but hard to type.
  root: TR,
  strong: RR,
  table: NR,
  tableCell: MR,
  tableRow: OR,
  text: DR,
  thematicBreak: LR,
  toml: bo,
  yaml: bo,
  definition: bo,
  footnoteDefinition: bo
};
function bo() {
}
const xy = -1, tc = 0, cs = 1, _l = 2, pf = 3, hf = 4, gf = 5, mf = 6, Ey = 7, wy = 8, Bh = typeof self == "object" ? self : globalThis, BR = (e, t) => {
  const n = (i, a) => (e.set(a, i), i), r = (i) => {
    if (e.has(i))
      return e.get(i);
    const [a, s] = t[i];
    switch (a) {
      case tc:
      case xy:
        return n(s, i);
      case cs: {
        const o = n([], i);
        for (const l of s)
          o.push(r(l));
        return o;
      }
      case _l: {
        const o = n({}, i);
        for (const [l, c] of s)
          o[r(l)] = r(c);
        return o;
      }
      case pf:
        return n(new Date(s), i);
      case hf: {
        const { source: o, flags: l } = s;
        return n(new RegExp(o, l), i);
      }
      case gf: {
        const o = n(/* @__PURE__ */ new Map(), i);
        for (const [l, c] of s)
          o.set(r(l), r(c));
        return o;
      }
      case mf: {
        const o = n(/* @__PURE__ */ new Set(), i);
        for (const l of s)
          o.add(r(l));
        return o;
      }
      case Ey: {
        const { name: o, message: l } = s;
        return n(new Bh[o](l), i);
      }
      case wy:
        return n(BigInt(s), i);
      case "BigInt":
        return n(Object(BigInt(s)), i);
      case "ArrayBuffer":
        return n(new Uint8Array(s).buffer, s);
      case "DataView": {
        const { buffer: o } = new Uint8Array(s);
        return n(new DataView(o), s);
      }
    }
    return n(new Bh[a](s), i);
  };
  return r;
}, zh = (e) => BR(/* @__PURE__ */ new Map(), e)(0), $i = "", { toString: zR } = {}, { keys: VR } = Object, Xa = (e) => {
  const t = typeof e;
  if (t !== "object" || !e)
    return [tc, t];
  const n = zR.call(e).slice(8, -1);
  switch (n) {
    case "Array":
      return [cs, $i];
    case "Object":
      return [_l, $i];
    case "Date":
      return [pf, $i];
    case "RegExp":
      return [hf, $i];
    case "Map":
      return [gf, $i];
    case "Set":
      return [mf, $i];
    case "DataView":
      return [cs, n];
  }
  return n.includes("Array") ? [cs, n] : n.includes("Error") ? [Ey, n] : [_l, n];
}, yo = ([e, t]) => e === tc && (t === "function" || t === "symbol"), GR = (e, t, n, r) => {
  const i = (s, o) => {
    const l = r.push(s) - 1;
    return n.set(o, l), l;
  }, a = (s) => {
    if (n.has(s))
      return n.get(s);
    let [o, l] = Xa(s);
    switch (o) {
      case tc: {
        let u = s;
        switch (l) {
          case "bigint":
            o = wy, u = s.toString();
            break;
          case "function":
          case "symbol":
            if (e)
              throw new TypeError("unable to serialize " + l);
            u = null;
            break;
          case "undefined":
            return i([xy], s);
        }
        return i([o, u], s);
      }
      case cs: {
        if (l) {
          let f = s;
          return l === "DataView" ? f = new Uint8Array(s.buffer) : l === "ArrayBuffer" && (f = new Uint8Array(s)), i([l, [...f]], s);
        }
        const u = [], d = i([o, u], s);
        for (const f of s)
          u.push(a(f));
        return d;
      }
      case _l: {
        if (l)
          switch (l) {
            case "BigInt":
              return i([l, s.toString()], s);
            case "Boolean":
            case "Number":
            case "String":
              return i([l, s.valueOf()], s);
          }
        if (t && "toJSON" in s)
          return a(s.toJSON());
        const u = [], d = i([o, u], s);
        for (const f of VR(s))
          (e || !yo(Xa(s[f]))) && u.push([a(f), a(s[f])]);
        return d;
      }
      case pf:
        return i([o, s.toISOString()], s);
      case hf: {
        const { source: u, flags: d } = s;
        return i([o, { source: u, flags: d }], s);
      }
      case gf: {
        const u = [], d = i([o, u], s);
        for (const [f, p] of s)
          (e || !(yo(Xa(f)) || yo(Xa(p)))) && u.push([a(f), a(p)]);
        return d;
      }
      case mf: {
        const u = [], d = i([o, u], s);
        for (const f of s)
          (e || !yo(Xa(f))) && u.push(a(f));
        return d;
      }
    }
    const { message: c } = s;
    return i([o, { name: l, message: c }], s);
  };
  return a;
}, Vh = (e, { json: t, lossy: n } = {}) => {
  const r = [];
  return GR(!(t || n), !!t, /* @__PURE__ */ new Map(), r)(e), r;
}, vl = typeof structuredClone == "function" ? (
  /* c8 ignore start */
  (e, t) => t && ("json" in t || "lossy" in t) ? zh(Vh(e, t)) : structuredClone(e)
) : (e, t) => zh(Vh(e, t));
function jR(e, t) {
  const n = [{ type: "text", value: "" }];
  return t > 1 && n.push({
    type: "element",
    tagName: "sup",
    properties: {},
    children: [{ type: "text", value: String(t) }]
  }), n;
}
function UR(e, t) {
  return "Back to reference " + (e + 1) + (t > 1 ? "-" + t : "");
}
function HR(e) {
  const t = typeof e.options.clobberPrefix == "string" ? e.options.clobberPrefix : "user-content-", n = e.options.footnoteBackContent || jR, r = e.options.footnoteBackLabel || UR, i = e.options.footnoteLabel || "Footnotes", a = e.options.footnoteLabelTagName || "h2", s = e.options.footnoteLabelProperties || {
    className: ["sr-only"]
  }, o = [];
  let l = -1;
  for (; ++l < e.footnoteOrder.length; ) {
    const c = e.footnoteById.get(
      e.footnoteOrder[l]
    );
    if (!c)
      continue;
    const u = e.all(c), d = String(c.identifier).toUpperCase(), f = Oa(d.toLowerCase());
    let p = 0;
    const h = [], g = e.footnoteCounts.get(d);
    for (; g !== void 0 && ++p <= g; ) {
      h.length > 0 && h.push({ type: "text", value: " " });
      let y = typeof n == "string" ? n : n(l, p);
      typeof y == "string" && (y = { type: "text", value: y }), h.push({
        type: "element",
        tagName: "a",
        properties: {
          href: "#" + t + "fnref-" + f + (p > 1 ? "-" + p : ""),
          dataFootnoteBackref: "",
          ariaLabel: typeof r == "string" ? r : r(l, p),
          className: ["data-footnote-backref"]
        },
        children: Array.isArray(y) ? y : [y]
      });
    }
    const m = u[u.length - 1];
    if (m && m.type === "element" && m.tagName === "p") {
      const y = m.children[m.children.length - 1];
      y && y.type === "text" ? y.value += " " : m.children.push({ type: "text", value: " " }), m.children.push(...h);
    } else
      u.push(...h);
    const b = {
      type: "element",
      tagName: "li",
      properties: { id: t + "fn-" + f },
      children: e.wrap(u, !0)
    };
    e.patch(c, b), o.push(b);
  }
  if (o.length !== 0)
    return {
      type: "element",
      tagName: "section",
      properties: { dataFootnotes: !0, className: ["footnotes"] },
      children: [
        {
          type: "element",
          tagName: a,
          properties: {
            ...vl(s),
            id: "footnote-label"
          },
          children: [{ type: "text", value: i }]
        },
        { type: "text", value: `
` },
        {
          type: "element",
          tagName: "ol",
          properties: {},
          children: e.wrap(o, !0)
        },
        { type: "text", value: `
` }
      ]
    };
}
const Qs = (
  // Note: overloads in JSDoc cant yet use different `@template`s.
  /**
   * @type {(
   *   (<Condition extends string>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & {type: Condition}) &
   *   (<Condition extends Props>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Condition) &
   *   (<Condition extends TestFunction>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Predicate<Condition, Node>) &
   *   ((test?: null | undefined) => (node?: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node) &
   *   ((test?: Test) => Check)
   * )}
   */
  /**
   * @param {Test} [test]
   * @returns {Check}
   */
  function(e) {
    if (e == null)
      return XR;
    if (typeof e == "function")
      return nc(e);
    if (typeof e == "object")
      return Array.isArray(e) ? WR(e) : ZR(e);
    if (typeof e == "string")
      return $R(e);
    throw new Error("Expected function, string, or object as test");
  }
);
function WR(e) {
  const t = [];
  let n = -1;
  for (; ++n < e.length; )
    t[n] = Qs(e[n]);
  return nc(r);
  function r(...i) {
    let a = -1;
    for (; ++a < t.length; )
      if (t[a].apply(this, i)) return !0;
    return !1;
  }
}
function ZR(e) {
  const t = (
    /** @type {Record<string, unknown>} */
    e
  );
  return nc(n);
  function n(r) {
    const i = (
      /** @type {Record<string, unknown>} */
      /** @type {unknown} */
      r
    );
    let a;
    for (a in e)
      if (i[a] !== t[a]) return !1;
    return !0;
  }
}
function $R(e) {
  return nc(t);
  function t(n) {
    return n && n.type === e;
  }
}
function nc(e) {
  return t;
  function t(n, r, i) {
    return !!(YR(n) && e.call(
      this,
      n,
      typeof r == "number" ? r : void 0,
      i || void 0
    ));
  }
}
function XR() {
  return !0;
}
function YR(e) {
  return e !== null && typeof e == "object" && "type" in e;
}
const Cy = [], JR = !0, Yu = !1, qR = "skip";
function Iy(e, t, n, r) {
  let i;
  typeof t == "function" && typeof n != "function" ? (r = n, n = t) : i = t;
  const a = Qs(i), s = r ? -1 : 1;
  o(e, void 0, [])();
  function o(l, c, u) {
    const d = (
      /** @type {Record<string, unknown>} */
      l && typeof l == "object" ? l : {}
    );
    if (typeof d.type == "string") {
      const p = (
        // `hast`
        typeof d.tagName == "string" ? d.tagName : (
          // `xast`
          typeof d.name == "string" ? d.name : void 0
        )
      );
      Object.defineProperty(f, "name", {
        value: "node (" + (l.type + (p ? "<" + p + ">" : "")) + ")"
      });
    }
    return f;
    function f() {
      let p = Cy, h, g, m;
      if ((!t || a(l, c, u[u.length - 1] || void 0)) && (p = KR(n(l, u)), p[0] === Yu))
        return p;
      if ("children" in l && l.children) {
        const b = (
          /** @type {UnistParent} */
          l
        );
        if (b.children && p[0] !== qR)
          for (g = (r ? b.children.length : -1) + s, m = u.concat(b); g > -1 && g < b.children.length; ) {
            const y = b.children[g];
            if (h = o(y, g, m)(), h[0] === Yu)
              return h;
            g = typeof h[1] == "number" ? h[1] : g + s;
          }
      }
      return p;
    }
  }
}
function KR(e) {
  return Array.isArray(e) ? e : typeof e == "number" ? [JR, e] : e == null ? Cy : [e];
}
function rc(e, t, n, r) {
  let i, a, s;
  typeof t == "function" && typeof n != "function" ? (a = void 0, s = t, i = n) : (a = t, s = n, i = r), Iy(e, a, o, i);
  function o(l, c) {
    const u = c[c.length - 1], d = u ? u.children.indexOf(l) : void 0;
    return s(l, d, u);
  }
}
const Ju = {}.hasOwnProperty, QR = {};
function eN(e, t) {
  const n = t || QR, r = /* @__PURE__ */ new Map(), i = /* @__PURE__ */ new Map(), a = /* @__PURE__ */ new Map(), s = { ...FR, ...n.handlers }, o = {
    all: c,
    applyData: nN,
    definitionById: r,
    footnoteById: i,
    footnoteCounts: a,
    footnoteOrder: [],
    handlers: s,
    one: l,
    options: n,
    patch: tN,
    wrap: iN
  };
  return rc(e, function(u) {
    if (u.type === "definition" || u.type === "footnoteDefinition") {
      const d = u.type === "definition" ? r : i, f = String(u.identifier).toUpperCase();
      d.has(f) || d.set(f, u);
    }
  }), o;
  function l(u, d) {
    const f = u.type, p = o.handlers[f];
    if (Ju.call(o.handlers, f) && p)
      return p(o, u, d);
    if (o.options.passThrough && o.options.passThrough.includes(f)) {
      if ("children" in u) {
        const { children: g, ...m } = u, b = vl(m);
        return b.children = o.all(u), b;
      }
      return vl(u);
    }
    return (o.options.unknownHandler || rN)(o, u, d);
  }
  function c(u) {
    const d = [];
    if ("children" in u) {
      const f = u.children;
      let p = -1;
      for (; ++p < f.length; ) {
        const h = o.one(f[p], u);
        if (h) {
          if (p && f[p - 1].type === "break" && (!Array.isArray(h) && h.type === "text" && (h.value = Gh(h.value)), !Array.isArray(h) && h.type === "element")) {
            const g = h.children[0];
            g && g.type === "text" && (g.value = Gh(g.value));
          }
          Array.isArray(h) ? d.push(...h) : d.push(h);
        }
      }
    }
    return d;
  }
}
function tN(e, t) {
  e.position && (t.position = GA(e));
}
function nN(e, t) {
  let n = t;
  if (e && e.data) {
    const r = e.data.hName, i = e.data.hChildren, a = e.data.hProperties;
    if (typeof r == "string")
      if (n.type === "element")
        n.tagName = r;
      else {
        const s = "children" in n ? n.children : [n];
        n = { type: "element", tagName: r, properties: {}, children: s };
      }
    n.type === "element" && a && Object.assign(n.properties, vl(a)), "children" in n && n.children && i !== null && i !== void 0 && (n.children = i);
  }
  return n;
}
function rN(e, t) {
  const n = t.data || {}, r = "value" in t && !(Ju.call(n, "hProperties") || Ju.call(n, "hChildren")) ? { type: "text", value: t.value } : {
    type: "element",
    tagName: "div",
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, r), e.applyData(t, r);
}
function iN(e, t) {
  const n = [];
  let r = -1;
  for (t && n.push({ type: "text", value: `
` }); ++r < e.length; )
    r && n.push({ type: "text", value: `
` }), n.push(e[r]);
  return t && e.length > 0 && n.push({ type: "text", value: `
` }), n;
}
function Gh(e) {
  let t = 0, n = e.charCodeAt(t);
  for (; n === 9 || n === 32; )
    t++, n = e.charCodeAt(t);
  return e.slice(t);
}
function jh(e, t) {
  const n = eN(e, t), r = n.one(e, void 0), i = HR(n), a = Array.isArray(r) ? { type: "root", children: r } : r || { type: "root", children: [] };
  return i && a.children.push({ type: "text", value: `
` }, i), a;
}
function aN(e, t) {
  return e && "run" in e ? async function(n, r) {
    const i = (
      /** @type {HastRoot} */
      jh(n, { file: r, ...t })
    );
    await e.run(i, r);
  } : function(n, r) {
    return (
      /** @type {HastRoot} */
      jh(n, { file: r, ...e || t })
    );
  };
}
function Uh(e) {
  if (e)
    throw e;
}
var $c, Hh;
function sN() {
  if (Hh) return $c;
  Hh = 1;
  var e = Object.prototype.hasOwnProperty, t = Object.prototype.toString, n = Object.defineProperty, r = Object.getOwnPropertyDescriptor, i = function(c) {
    return typeof Array.isArray == "function" ? Array.isArray(c) : t.call(c) === "[object Array]";
  }, a = function(c) {
    if (!c || t.call(c) !== "[object Object]")
      return !1;
    var u = e.call(c, "constructor"), d = c.constructor && c.constructor.prototype && e.call(c.constructor.prototype, "isPrototypeOf");
    if (c.constructor && !u && !d)
      return !1;
    var f;
    for (f in c)
      ;
    return typeof f > "u" || e.call(c, f);
  }, s = function(c, u) {
    n && u.name === "__proto__" ? n(c, u.name, {
      enumerable: !0,
      configurable: !0,
      value: u.newValue,
      writable: !0
    }) : c[u.name] = u.newValue;
  }, o = function(c, u) {
    if (u === "__proto__")
      if (e.call(c, u)) {
        if (r)
          return r(c, u).value;
      } else return;
    return c[u];
  };
  return $c = function l() {
    var c, u, d, f, p, h, g = arguments[0], m = 1, b = arguments.length, y = !1;
    for (typeof g == "boolean" && (y = g, g = arguments[1] || {}, m = 2), (g == null || typeof g != "object" && typeof g != "function") && (g = {}); m < b; ++m)
      if (c = arguments[m], c != null)
        for (u in c)
          d = o(g, u), f = o(c, u), g !== f && (y && f && (a(f) || (p = i(f))) ? (p ? (p = !1, h = d && i(d) ? d : []) : h = d && a(d) ? d : {}, s(g, { name: u, newValue: l(y, h, f) })) : typeof f < "u" && s(g, { name: u, newValue: f }));
    return g;
  }, $c;
}
var oN = sN();
const Xc = /* @__PURE__ */ Dd(oN);
function qu(e) {
  if (typeof e != "object" || e === null)
    return !1;
  const t = Object.getPrototypeOf(e);
  return (t === null || t === Object.prototype || Object.getPrototypeOf(t) === null) && !(Symbol.toStringTag in e) && !(Symbol.iterator in e);
}
function lN() {
  const e = [], t = { run: n, use: r };
  return t;
  function n(...i) {
    let a = -1;
    const s = i.pop();
    if (typeof s != "function")
      throw new TypeError("Expected function as last argument, not " + s);
    o(null, ...i);
    function o(l, ...c) {
      const u = e[++a];
      let d = -1;
      if (l) {
        s(l);
        return;
      }
      for (; ++d < i.length; )
        (c[d] === null || c[d] === void 0) && (c[d] = i[d]);
      i = c, u ? cN(u, o)(...c) : s(null, ...c);
    }
  }
  function r(i) {
    if (typeof i != "function")
      throw new TypeError(
        "Expected `middelware` to be a function, not " + i
      );
    return e.push(i), t;
  }
}
function cN(e, t) {
  let n;
  return r;
  function r(...s) {
    const o = e.length > s.length;
    let l;
    o && s.push(i);
    try {
      l = e.apply(this, s);
    } catch (c) {
      const u = (
        /** @type {Error} */
        c
      );
      if (o && n)
        throw u;
      return i(u);
    }
    o || (l && l.then && typeof l.then == "function" ? l.then(a, i) : l instanceof Error ? i(l) : a(l));
  }
  function i(s, ...o) {
    n || (n = !0, t(s, ...o));
  }
  function a(s) {
    i(null, s);
  }
}
const lr = { basename: uN, dirname: dN, extname: fN, join: pN, sep: "/" };
function uN(e, t) {
  if (t !== void 0 && typeof t != "string")
    throw new TypeError('"ext" argument must be a string');
  eo(e);
  let n = 0, r = -1, i = e.length, a;
  if (t === void 0 || t.length === 0 || t.length > e.length) {
    for (; i--; )
      if (e.codePointAt(i) === 47) {
        if (a) {
          n = i + 1;
          break;
        }
      } else r < 0 && (a = !0, r = i + 1);
    return r < 0 ? "" : e.slice(n, r);
  }
  if (t === e)
    return "";
  let s = -1, o = t.length - 1;
  for (; i--; )
    if (e.codePointAt(i) === 47) {
      if (a) {
        n = i + 1;
        break;
      }
    } else
      s < 0 && (a = !0, s = i + 1), o > -1 && (e.codePointAt(i) === t.codePointAt(o--) ? o < 0 && (r = i) : (o = -1, r = s));
  return n === r ? r = s : r < 0 && (r = e.length), e.slice(n, r);
}
function dN(e) {
  if (eo(e), e.length === 0)
    return ".";
  let t = -1, n = e.length, r;
  for (; --n; )
    if (e.codePointAt(n) === 47) {
      if (r) {
        t = n;
        break;
      }
    } else r || (r = !0);
  return t < 0 ? e.codePointAt(0) === 47 ? "/" : "." : t === 1 && e.codePointAt(0) === 47 ? "//" : e.slice(0, t);
}
function fN(e) {
  eo(e);
  let t = e.length, n = -1, r = 0, i = -1, a = 0, s;
  for (; t--; ) {
    const o = e.codePointAt(t);
    if (o === 47) {
      if (s) {
        r = t + 1;
        break;
      }
      continue;
    }
    n < 0 && (s = !0, n = t + 1), o === 46 ? i < 0 ? i = t : a !== 1 && (a = 1) : i > -1 && (a = -1);
  }
  return i < 0 || n < 0 || // We saw a non-dot character immediately before the dot.
  a === 0 || // The (right-most) trimmed path component is exactly `..`.
  a === 1 && i === n - 1 && i === r + 1 ? "" : e.slice(i, n);
}
function pN(...e) {
  let t = -1, n;
  for (; ++t < e.length; )
    eo(e[t]), e[t] && (n = n === void 0 ? e[t] : n + "/" + e[t]);
  return n === void 0 ? "." : hN(n);
}
function hN(e) {
  eo(e);
  const t = e.codePointAt(0) === 47;
  let n = gN(e, !t);
  return n.length === 0 && !t && (n = "."), n.length > 0 && e.codePointAt(e.length - 1) === 47 && (n += "/"), t ? "/" + n : n;
}
function gN(e, t) {
  let n = "", r = 0, i = -1, a = 0, s = -1, o, l;
  for (; ++s <= e.length; ) {
    if (s < e.length)
      o = e.codePointAt(s);
    else {
      if (o === 47)
        break;
      o = 47;
    }
    if (o === 47) {
      if (!(i === s - 1 || a === 1)) if (i !== s - 1 && a === 2) {
        if (n.length < 2 || r !== 2 || n.codePointAt(n.length - 1) !== 46 || n.codePointAt(n.length - 2) !== 46) {
          if (n.length > 2) {
            if (l = n.lastIndexOf("/"), l !== n.length - 1) {
              l < 0 ? (n = "", r = 0) : (n = n.slice(0, l), r = n.length - 1 - n.lastIndexOf("/")), i = s, a = 0;
              continue;
            }
          } else if (n.length > 0) {
            n = "", r = 0, i = s, a = 0;
            continue;
          }
        }
        t && (n = n.length > 0 ? n + "/.." : "..", r = 2);
      } else
        n.length > 0 ? n += "/" + e.slice(i + 1, s) : n = e.slice(i + 1, s), r = s - i - 1;
      i = s, a = 0;
    } else o === 46 && a > -1 ? a++ : a = -1;
  }
  return n;
}
function eo(e) {
  if (typeof e != "string")
    throw new TypeError(
      "Path must be a string. Received " + JSON.stringify(e)
    );
}
const mN = { cwd: bN };
function bN() {
  return "/";
}
function Ku(e) {
  return !!(e !== null && typeof e == "object" && "href" in e && e.href && "protocol" in e && e.protocol && // @ts-expect-error: indexing is fine.
  e.auth === void 0);
}
function yN(e) {
  if (typeof e == "string")
    e = new URL(e);
  else if (!Ku(e)) {
    const t = new TypeError(
      'The "path" argument must be of type string or an instance of URL. Received `' + e + "`"
    );
    throw t.code = "ERR_INVALID_ARG_TYPE", t;
  }
  if (e.protocol !== "file:") {
    const t = new TypeError("The URL must be of scheme file");
    throw t.code = "ERR_INVALID_URL_SCHEME", t;
  }
  return _N(e);
}
function _N(e) {
  if (e.hostname !== "") {
    const r = new TypeError(
      'File URL host must be "localhost" or empty on darwin'
    );
    throw r.code = "ERR_INVALID_FILE_URL_HOST", r;
  }
  const t = e.pathname;
  let n = -1;
  for (; ++n < t.length; )
    if (t.codePointAt(n) === 37 && t.codePointAt(n + 1) === 50) {
      const r = t.codePointAt(n + 2);
      if (r === 70 || r === 102) {
        const i = new TypeError(
          "File URL path must not include encoded / characters"
        );
        throw i.code = "ERR_INVALID_FILE_URL_PATH", i;
      }
    }
  return decodeURIComponent(t);
}
const Yc = (
  /** @type {const} */
  [
    "history",
    "path",
    "basename",
    "stem",
    "extname",
    "dirname"
  ]
);
class Sy {
  /**
   * Create a new virtual file.
   *
   * `options` is treated as:
   *
   * *   `string` or `Uint8Array`  `{value: options}`
   * *   `URL`  `{path: options}`
   * *   `VFile`  shallow copies its data over to the new file
   * *   `object`  all fields are shallow copied over to the new file
   *
   * Path related fields are set in the following order (least specific to
   * most specific): `history`, `path`, `basename`, `stem`, `extname`,
   * `dirname`.
   *
   * You cannot set `dirname` or `extname` without setting either `history`,
   * `path`, `basename`, or `stem` too.
   *
   * @param {Compatible | null | undefined} [value]
   *   File value.
   * @returns
   *   New instance.
   */
  constructor(t) {
    let n;
    t ? Ku(t) ? n = { path: t } : typeof t == "string" || vN(t) ? n = { value: t } : n = t : n = {}, this.cwd = "cwd" in n ? "" : mN.cwd(), this.data = {}, this.history = [], this.messages = [], this.value, this.map, this.result, this.stored;
    let r = -1;
    for (; ++r < Yc.length; ) {
      const a = Yc[r];
      a in n && n[a] !== void 0 && n[a] !== null && (this[a] = a === "history" ? [...n[a]] : n[a]);
    }
    let i;
    for (i in n)
      Yc.includes(i) || (this[i] = n[i]);
  }
  /**
   * Get the basename (including extname) (example: `'index.min.js'`).
   *
   * @returns {string | undefined}
   *   Basename.
   */
  get basename() {
    return typeof this.path == "string" ? lr.basename(this.path) : void 0;
  }
  /**
   * Set basename (including extname) (`'index.min.js'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be nullified (use `file.path = file.dirname` instead).
   *
   * @param {string} basename
   *   Basename.
   * @returns {undefined}
   *   Nothing.
   */
  set basename(t) {
    qc(t, "basename"), Jc(t, "basename"), this.path = lr.join(this.dirname || "", t);
  }
  /**
   * Get the parent path (example: `'~'`).
   *
   * @returns {string | undefined}
   *   Dirname.
   */
  get dirname() {
    return typeof this.path == "string" ? lr.dirname(this.path) : void 0;
  }
  /**
   * Set the parent path (example: `'~'`).
   *
   * Cannot be set if theres no `path` yet.
   *
   * @param {string | undefined} dirname
   *   Dirname.
   * @returns {undefined}
   *   Nothing.
   */
  set dirname(t) {
    Wh(this.basename, "dirname"), this.path = lr.join(t || "", this.basename);
  }
  /**
   * Get the extname (including dot) (example: `'.js'`).
   *
   * @returns {string | undefined}
   *   Extname.
   */
  get extname() {
    return typeof this.path == "string" ? lr.extname(this.path) : void 0;
  }
  /**
   * Set the extname (including dot) (example: `'.js'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be set if theres no `path` yet.
   *
   * @param {string | undefined} extname
   *   Extname.
   * @returns {undefined}
   *   Nothing.
   */
  set extname(t) {
    if (Jc(t, "extname"), Wh(this.dirname, "extname"), t) {
      if (t.codePointAt(0) !== 46)
        throw new Error("`extname` must start with `.`");
      if (t.includes(".", 1))
        throw new Error("`extname` cannot contain multiple dots");
    }
    this.path = lr.join(this.dirname, this.stem + (t || ""));
  }
  /**
   * Get the full path (example: `'~/index.min.js'`).
   *
   * @returns {string}
   *   Path.
   */
  get path() {
    return this.history[this.history.length - 1];
  }
  /**
   * Set the full path (example: `'~/index.min.js'`).
   *
   * Cannot be nullified.
   * You can set a file URL (a `URL` object with a `file:` protocol) which will
   * be turned into a path with `url.fileURLToPath`.
   *
   * @param {URL | string} path
   *   Path.
   * @returns {undefined}
   *   Nothing.
   */
  set path(t) {
    Ku(t) && (t = yN(t)), qc(t, "path"), this.path !== t && this.history.push(t);
  }
  /**
   * Get the stem (basename w/o extname) (example: `'index.min'`).
   *
   * @returns {string | undefined}
   *   Stem.
   */
  get stem() {
    return typeof this.path == "string" ? lr.basename(this.path, this.extname) : void 0;
  }
  /**
   * Set the stem (basename w/o extname) (example: `'index.min'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be nullified (use `file.path = file.dirname` instead).
   *
   * @param {string} stem
   *   Stem.
   * @returns {undefined}
   *   Nothing.
   */
  set stem(t) {
    qc(t, "stem"), Jc(t, "stem"), this.path = lr.join(this.dirname || "", t + (this.extname || ""));
  }
  // Normal prototypal methods.
  /**
   * Create a fatal message for `reason` associated with the file.
   *
   * The `fatal` field of the message is set to `true` (error; file not usable)
   * and the `file` field is set to the current file path.
   * The message is added to the `messages` field on `file`.
   *
   * >  **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {MessageOptions | null | undefined} [options]
   * @returns {never}
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {never}
   *   Never.
   * @throws {VFileMessage}
   *   Message.
   */
  fail(t, n, r) {
    const i = this.message(t, n, r);
    throw i.fatal = !0, i;
  }
  /**
   * Create an info message for `reason` associated with the file.
   *
   * The `fatal` field of the message is set to `undefined` (info; change
   * likely not needed) and the `file` field is set to the current file path.
   * The message is added to the `messages` field on `file`.
   *
   * >  **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {MessageOptions | null | undefined} [options]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {VFileMessage}
   *   Message.
   */
  info(t, n, r) {
    const i = this.message(t, n, r);
    return i.fatal = void 0, i;
  }
  /**
   * Create a message for `reason` associated with the file.
   *
   * The `fatal` field of the message is set to `false` (warning; change may be
   * needed) and the `file` field is set to the current file path.
   * The message is added to the `messages` field on `file`.
   *
   * >  **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {MessageOptions | null | undefined} [options]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {VFileMessage}
   *   Message.
   */
  message(t, n, r) {
    const i = new Qt(
      // @ts-expect-error: the overloads are fine.
      t,
      n,
      r
    );
    return this.path && (i.name = this.path + ":" + i.name, i.file = this.path), i.fatal = !1, this.messages.push(i), i;
  }
  /**
   * Serialize the file.
   *
   * > **Note**: which encodings are supported depends on the engine.
   * > For info on Node.js, see:
   * > <https://nodejs.org/api/util.html#whatwg-supported-encodings>.
   *
   * @param {string | null | undefined} [encoding='utf8']
   *   Character encoding to understand `value` as when its a `Uint8Array`
   *   (default: `'utf-8'`).
   * @returns {string}
   *   Serialized file.
   */
  toString(t) {
    return this.value === void 0 ? "" : typeof this.value == "string" ? this.value : new TextDecoder(t || void 0).decode(this.value);
  }
}
function Jc(e, t) {
  if (e && e.includes(lr.sep))
    throw new Error(
      "`" + t + "` cannot be a path: did not expect `" + lr.sep + "`"
    );
}
function qc(e, t) {
  if (!e)
    throw new Error("`" + t + "` cannot be empty");
}
function Wh(e, t) {
  if (!e)
    throw new Error("Setting `" + t + "` requires `path` to be set too");
}
function vN(e) {
  return !!(e && typeof e == "object" && "byteLength" in e && "byteOffset" in e);
}
const xN = (
  /**
   * @type {new <Parameters extends Array<unknown>, Result>(property: string | symbol) => (...parameters: Parameters) => Result}
   */
  /** @type {unknown} */
  /**
   * @this {Function}
   * @param {string | symbol} property
   * @returns {(...parameters: Array<unknown>) => unknown}
   */
  function(e) {
    const r = (
      /** @type {Record<string | symbol, Function>} */
      // Prototypes do exist.
      // type-coverage:ignore-next-line
      this.constructor.prototype
    ), i = r[e], a = function() {
      return i.apply(a, arguments);
    };
    return Object.setPrototypeOf(a, r), a;
  }
), EN = {}.hasOwnProperty;
class bf extends xN {
  /**
   * Create a processor.
   */
  constructor() {
    super("copy"), this.Compiler = void 0, this.Parser = void 0, this.attachers = [], this.compiler = void 0, this.freezeIndex = -1, this.frozen = void 0, this.namespace = {}, this.parser = void 0, this.transformers = lN();
  }
  /**
   * Copy a processor.
   *
   * @deprecated
   *   This is a private internal method and should not be used.
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *   New *unfrozen* processor ({@linkcode Processor}) that is
   *   configured to work the same as its ancestor.
   *   When the descendant processor is configured in the future it does not
   *   affect the ancestral processor.
   */
  copy() {
    const t = (
      /** @type {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>} */
      new bf()
    );
    let n = -1;
    for (; ++n < this.attachers.length; ) {
      const r = this.attachers[n];
      t.use(...r);
    }
    return t.data(Xc(!0, {}, this.namespace)), t;
  }
  /**
   * Configure the processor with info available to all plugins.
   * Information is stored in an object.
   *
   * Typically, options can be given to a specific plugin, but sometimes it
   * makes sense to have information shared with several plugins.
   * For example, a list of HTML elements that are self-closing, which is
   * needed during all phases.
   *
   * > **Note**: setting information cannot occur on *frozen* processors.
   * > Call the processor first to create a new unfrozen processor.
   *
   * > **Note**: to register custom data in TypeScript, augment the
   * > {@linkcode Data} interface.
   *
   * @example
   *   This example show how to get and set info:
   *
   *   ```js
   *   import {unified} from 'unified'
   *
   *   const processor = unified().data('alpha', 'bravo')
   *
   *   processor.data('alpha') // => 'bravo'
   *
   *   processor.data() // => {alpha: 'bravo'}
   *
   *   processor.data({charlie: 'delta'})
   *
   *   processor.data() // => {charlie: 'delta'}
   *   ```
   *
   * @template {keyof Data} Key
   *
   * @overload
   * @returns {Data}
   *
   * @overload
   * @param {Data} dataset
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @overload
   * @param {Key} key
   * @returns {Data[Key]}
   *
   * @overload
   * @param {Key} key
   * @param {Data[Key]} value
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @param {Data | Key} [key]
   *   Key to get or set, or entire dataset to set, or nothing to get the
   *   entire dataset (optional).
   * @param {Data[Key]} [value]
   *   Value to set (optional).
   * @returns {unknown}
   *   The current processor when setting, the value at `key` when getting, or
   *   the entire dataset when getting without key.
   */
  data(t, n) {
    return typeof t == "string" ? arguments.length === 2 ? (eu("data", this.frozen), this.namespace[t] = n, this) : EN.call(this.namespace, t) && this.namespace[t] || void 0 : t ? (eu("data", this.frozen), this.namespace = t, this) : this.namespace;
  }
  /**
   * Freeze a processor.
   *
   * Frozen processors are meant to be extended and not to be configured
   * directly.
   *
   * When a processor is frozen it cannot be unfrozen.
   * New processors working the same way can be created by calling the
   * processor.
   *
   * Its possible to freeze processors explicitly by calling `.freeze()`.
   * Processors freeze automatically when `.parse()`, `.run()`, `.runSync()`,
   * `.stringify()`, `.process()`, or `.processSync()` are called.
   *
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *   The current processor.
   */
  freeze() {
    if (this.frozen)
      return this;
    const t = (
      /** @type {Processor} */
      /** @type {unknown} */
      this
    );
    for (; ++this.freezeIndex < this.attachers.length; ) {
      const [n, ...r] = this.attachers[this.freezeIndex];
      if (r[0] === !1)
        continue;
      r[0] === !0 && (r[0] = void 0);
      const i = n.call(t, ...r);
      typeof i == "function" && this.transformers.use(i);
    }
    return this.frozen = !0, this.freezeIndex = Number.POSITIVE_INFINITY, this;
  }
  /**
   * Parse text to a syntax tree.
   *
   * > **Note**: `parse` freezes the processor if not already *frozen*.
   *
   * > **Note**: `parse` performs the parse phase, not the run phase or other
   * > phases.
   *
   * @param {Compatible | undefined} [file]
   *   file to parse (optional); typically `string` or `VFile`; any value
   *   accepted as `x` in `new VFile(x)`.
   * @returns {ParseTree extends undefined ? Node : ParseTree}
   *   Syntax tree representing `file`.
   */
  parse(t) {
    this.freeze();
    const n = _o(t), r = this.parser || this.Parser;
    return Kc("parse", r), r(String(n), n);
  }
  /**
   * Process the given file as configured on the processor.
   *
   * > **Note**: `process` freezes the processor if not already *frozen*.
   *
   * > **Note**: `process` performs the parse, run, and stringify phases.
   *
   * @overload
   * @param {Compatible | undefined} file
   * @param {ProcessCallback<VFileWithOutput<CompileResult>>} done
   * @returns {undefined}
   *
   * @overload
   * @param {Compatible | undefined} [file]
   * @returns {Promise<VFileWithOutput<CompileResult>>}
   *
   * @param {Compatible | undefined} [file]
   *   File (optional); typically `string` or `VFile`]; any value accepted as
   *   `x` in `new VFile(x)`.
   * @param {ProcessCallback<VFileWithOutput<CompileResult>> | undefined} [done]
   *   Callback (optional).
   * @returns {Promise<VFile> | undefined}
   *   Nothing if `done` is given.
   *   Otherwise a promise, rejected with a fatal error or resolved with the
   *   processed file.
   *
   *   The parsed, transformed, and compiled value is available at
   *   `file.value` (see note).
   *
   *   > **Note**: unified typically compiles by serializing: most
   *   > compilers return `string` (or `Uint8Array`).
   *   > Some compilers, such as the one configured with
   *   > [`rehype-react`][rehype-react], return other values (in this case, a
   *   > React tree).
   *   > If youre using a compiler that doesnt serialize, expect different
   *   > result values.
   *   >
   *   > To register custom results in TypeScript, add them to
   *   > {@linkcode CompileResultMap}.
   *
   *   [rehype-react]: https://github.com/rehypejs/rehype-react
   */
  process(t, n) {
    const r = this;
    return this.freeze(), Kc("process", this.parser || this.Parser), Qc("process", this.compiler || this.Compiler), n ? i(void 0, n) : new Promise(i);
    function i(a, s) {
      const o = _o(t), l = (
        /** @type {HeadTree extends undefined ? Node : HeadTree} */
        /** @type {unknown} */
        r.parse(o)
      );
      r.run(l, o, function(u, d, f) {
        if (u || !d || !f)
          return c(u);
        const p = (
          /** @type {CompileTree extends undefined ? Node : CompileTree} */
          /** @type {unknown} */
          d
        ), h = r.stringify(p, f);
        IN(h) ? f.value = h : f.result = h, c(
          u,
          /** @type {VFileWithOutput<CompileResult>} */
          f
        );
      });
      function c(u, d) {
        u || !d ? s(u) : a ? a(d) : n(void 0, d);
      }
    }
  }
  /**
   * Process the given file as configured on the processor.
   *
   * An error is thrown if asynchronous transforms are configured.
   *
   * > **Note**: `processSync` freezes the processor if not already *frozen*.
   *
   * > **Note**: `processSync` performs the parse, run, and stringify phases.
   *
   * @param {Compatible | undefined} [file]
   *   File (optional); typically `string` or `VFile`; any value accepted as
   *   `x` in `new VFile(x)`.
   * @returns {VFileWithOutput<CompileResult>}
   *   The processed file.
   *
   *   The parsed, transformed, and compiled value is available at
   *   `file.value` (see note).
   *
   *   > **Note**: unified typically compiles by serializing: most
   *   > compilers return `string` (or `Uint8Array`).
   *   > Some compilers, such as the one configured with
   *   > [`rehype-react`][rehype-react], return other values (in this case, a
   *   > React tree).
   *   > If youre using a compiler that doesnt serialize, expect different
   *   > result values.
   *   >
   *   > To register custom results in TypeScript, add them to
   *   > {@linkcode CompileResultMap}.
   *
   *   [rehype-react]: https://github.com/rehypejs/rehype-react
   */
  processSync(t) {
    let n = !1, r;
    return this.freeze(), Kc("processSync", this.parser || this.Parser), Qc("processSync", this.compiler || this.Compiler), this.process(t, i), $h("processSync", "process", n), r;
    function i(a, s) {
      n = !0, Uh(a), r = s;
    }
  }
  /**
   * Run *transformers* on a syntax tree.
   *
   * > **Note**: `run` freezes the processor if not already *frozen*.
   *
   * > **Note**: `run` performs the run phase, not other phases.
   *
   * @overload
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} done
   * @returns {undefined}
   *
   * @overload
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   * @param {Compatible | undefined} file
   * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} done
   * @returns {undefined}
   *
   * @overload
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   * @param {Compatible | undefined} [file]
   * @returns {Promise<TailTree extends undefined ? Node : TailTree>}
   *
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   *   Tree to transform and inspect.
   * @param {(
   *   RunCallback<TailTree extends undefined ? Node : TailTree> |
   *   Compatible
   * )} [file]
   *   File associated with `node` (optional); any value accepted as `x` in
   *   `new VFile(x)`.
   * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} [done]
   *   Callback (optional).
   * @returns {Promise<TailTree extends undefined ? Node : TailTree> | undefined}
   *   Nothing if `done` is given.
   *   Otherwise, a promise rejected with a fatal error or resolved with the
   *   transformed tree.
   */
  run(t, n, r) {
    Zh(t), this.freeze();
    const i = this.transformers;
    return !r && typeof n == "function" && (r = n, n = void 0), r ? a(void 0, r) : new Promise(a);
    function a(s, o) {
      const l = _o(n);
      i.run(t, l, c);
      function c(u, d, f) {
        const p = (
          /** @type {TailTree extends undefined ? Node : TailTree} */
          d || t
        );
        u ? o(u) : s ? s(p) : r(void 0, p, f);
      }
    }
  }
  /**
   * Run *transformers* on a syntax tree.
   *
   * An error is thrown if asynchronous transforms are configured.
   *
   * > **Note**: `runSync` freezes the processor if not already *frozen*.
   *
   * > **Note**: `runSync` performs the run phase, not other phases.
   *
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   *   Tree to transform and inspect.
   * @param {Compatible | undefined} [file]
   *   File associated with `node` (optional); any value accepted as `x` in
   *   `new VFile(x)`.
   * @returns {TailTree extends undefined ? Node : TailTree}
   *   Transformed tree.
   */
  runSync(t, n) {
    let r = !1, i;
    return this.run(t, n, a), $h("runSync", "run", r), i;
    function a(s, o) {
      Uh(s), i = o, r = !0;
    }
  }
  /**
   * Compile a syntax tree.
   *
   * > **Note**: `stringify` freezes the processor if not already *frozen*.
   *
   * > **Note**: `stringify` performs the stringify phase, not the run phase
   * > or other phases.
   *
   * @param {CompileTree extends undefined ? Node : CompileTree} tree
   *   Tree to compile.
   * @param {Compatible | undefined} [file]
   *   File associated with `node` (optional); any value accepted as `x` in
   *   `new VFile(x)`.
   * @returns {CompileResult extends undefined ? Value : CompileResult}
   *   Textual representation of the tree (see note).
   *
   *   > **Note**: unified typically compiles by serializing: most compilers
   *   > return `string` (or `Uint8Array`).
   *   > Some compilers, such as the one configured with
   *   > [`rehype-react`][rehype-react], return other values (in this case, a
   *   > React tree).
   *   > If youre using a compiler that doesnt serialize, expect different
   *   > result values.
   *   >
   *   > To register custom results in TypeScript, add them to
   *   > {@linkcode CompileResultMap}.
   *
   *   [rehype-react]: https://github.com/rehypejs/rehype-react
   */
  stringify(t, n) {
    this.freeze();
    const r = _o(n), i = this.compiler || this.Compiler;
    return Qc("stringify", i), Zh(t), i(t, r);
  }
  /**
   * Configure the processor to use a plugin, a list of usable values, or a
   * preset.
   *
   * If the processor is already using a plugin, the previous plugin
   * configuration is changed based on the options that are passed in.
   * In other words, the plugin is not added a second time.
   *
   * > **Note**: `use` cannot be called on *frozen* processors.
   * > Call the processor first to create a new unfrozen processor.
   *
   * @example
   *   There are many ways to pass plugins to `.use()`.
   *   This example gives an overview:
   *
   *   ```js
   *   import {unified} from 'unified'
   *
   *   unified()
   *     // Plugin with options:
   *     .use(pluginA, {x: true, y: true})
   *     // Passing the same plugin again merges configuration (to `{x: true, y: false, z: true}`):
   *     .use(pluginA, {y: false, z: true})
   *     // Plugins:
   *     .use([pluginB, pluginC])
   *     // Two plugins, the second with options:
   *     .use([pluginD, [pluginE, {}]])
   *     // Preset with plugins and settings:
   *     .use({plugins: [pluginF, [pluginG, {}]], settings: {position: false}})
   *     // Settings only:
   *     .use({settings: {position: false}})
   *   ```
   *
   * @template {Array<unknown>} [Parameters=[]]
   * @template {Node | string | undefined} [Input=undefined]
   * @template [Output=Input]
   *
   * @overload
   * @param {Preset | null | undefined} [preset]
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @overload
   * @param {PluggableList} list
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @overload
   * @param {Plugin<Parameters, Input, Output>} plugin
   * @param {...(Parameters | [boolean])} parameters
   * @returns {UsePlugin<ParseTree, HeadTree, TailTree, CompileTree, CompileResult, Input, Output>}
   *
   * @param {PluggableList | Plugin | Preset | null | undefined} value
   *   Usable value.
   * @param {...unknown} parameters
   *   Parameters, when a plugin is given as a usable value.
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *   Current processor.
   */
  use(t, ...n) {
    const r = this.attachers, i = this.namespace;
    if (eu("use", this.frozen), t != null) if (typeof t == "function")
      l(t, n);
    else if (typeof t == "object")
      Array.isArray(t) ? o(t) : s(t);
    else
      throw new TypeError("Expected usable value, not `" + t + "`");
    return this;
    function a(c) {
      if (typeof c == "function")
        l(c, []);
      else if (typeof c == "object")
        if (Array.isArray(c)) {
          const [u, ...d] = (
            /** @type {PluginTuple<Array<unknown>>} */
            c
          );
          l(u, d);
        } else
          s(c);
      else
        throw new TypeError("Expected usable value, not `" + c + "`");
    }
    function s(c) {
      if (!("plugins" in c) && !("settings" in c))
        throw new Error(
          "Expected usable value but received an empty preset, which is probably a mistake: presets typically come with `plugins` and sometimes with `settings`, but this has neither"
        );
      o(c.plugins), c.settings && (i.settings = Xc(!0, i.settings, c.settings));
    }
    function o(c) {
      let u = -1;
      if (c != null) if (Array.isArray(c))
        for (; ++u < c.length; ) {
          const d = c[u];
          a(d);
        }
      else
        throw new TypeError("Expected a list of plugins, not `" + c + "`");
    }
    function l(c, u) {
      let d = -1, f = -1;
      for (; ++d < r.length; )
        if (r[d][0] === c) {
          f = d;
          break;
        }
      if (f === -1)
        r.push([c, ...u]);
      else if (u.length > 0) {
        let [p, ...h] = u;
        const g = r[f][1];
        qu(g) && qu(p) && (p = Xc(!0, g, p)), r[f] = [c, p, ...h];
      }
    }
  }
}
const wN = new bf().freeze();
function Kc(e, t) {
  if (typeof t != "function")
    throw new TypeError("Cannot `" + e + "` without `parser`");
}
function Qc(e, t) {
  if (typeof t != "function")
    throw new TypeError("Cannot `" + e + "` without `compiler`");
}
function eu(e, t) {
  if (t)
    throw new Error(
      "Cannot call `" + e + "` on a frozen processor.\nCreate a new processor first, by calling it: use `processor()` instead of `processor`."
    );
}
function Zh(e) {
  if (!qu(e) || typeof e.type != "string")
    throw new TypeError("Expected node, got `" + e + "`");
}
function $h(e, t, n) {
  if (!n)
    throw new Error(
      "`" + e + "` finished async. Use `" + t + "` instead"
    );
}
function _o(e) {
  return CN(e) ? e : new Sy(e);
}
function CN(e) {
  return !!(e && typeof e == "object" && "message" in e && "messages" in e);
}
function IN(e) {
  return typeof e == "string" || SN(e);
}
function SN(e) {
  return !!(e && typeof e == "object" && "byteLength" in e && "byteOffset" in e);
}
const AN = "https://github.com/remarkjs/react-markdown/blob/main/changelog.md", Xh = [], Yh = { allowDangerousHtml: !0 }, kN = /^(https?|ircs?|mailto|xmpp)$/i, TN = [
  { from: "astPlugins", id: "remove-buggy-html-in-markdown-parser" },
  { from: "allowDangerousHtml", id: "remove-buggy-html-in-markdown-parser" },
  {
    from: "allowNode",
    id: "replace-allownode-allowedtypes-and-disallowedtypes",
    to: "allowElement"
  },
  {
    from: "allowedTypes",
    id: "replace-allownode-allowedtypes-and-disallowedtypes",
    to: "allowedElements"
  },
  {
    from: "disallowedTypes",
    id: "replace-allownode-allowedtypes-and-disallowedtypes",
    to: "disallowedElements"
  },
  { from: "escapeHtml", id: "remove-buggy-html-in-markdown-parser" },
  { from: "includeElementIndex", id: "#remove-includeelementindex" },
  {
    from: "includeNodeIndex",
    id: "change-includenodeindex-to-includeelementindex"
  },
  { from: "linkTarget", id: "remove-linktarget" },
  { from: "plugins", id: "change-plugins-to-remarkplugins", to: "remarkPlugins" },
  { from: "rawSourcePos", id: "#remove-rawsourcepos" },
  { from: "renderers", id: "change-renderers-to-components", to: "components" },
  { from: "source", id: "change-source-to-children", to: "children" },
  { from: "sourcePos", id: "#remove-sourcepos" },
  { from: "transformImageUri", id: "#add-urltransform", to: "urlTransform" },
  { from: "transformLinkUri", id: "#add-urltransform", to: "urlTransform" }
];
function RN(e) {
  const t = e.allowedElements, n = e.allowElement, r = e.children || "", i = e.className, a = e.components, s = e.disallowedElements, o = e.rehypePlugins || Xh, l = e.remarkPlugins || Xh, c = e.remarkRehypeOptions ? { ...e.remarkRehypeOptions, ...Yh } : Yh, u = e.skipHtml, d = e.unwrapDisallowed, f = e.urlTransform || NN, p = wN().use(dR).use(l).use(aN, c).use(o), h = new Sy();
  typeof r == "string" && (h.value = r);
  for (const y of TN)
    Object.hasOwn(e, y.from) && ("" + y.from + (y.to ? "use `" + y.to + "` instead" : "remove it") + AN + y.id, void 0);
  const g = p.parse(h);
  let m = p.runSync(g, h);
  return i && (m = {
    type: "element",
    tagName: "div",
    properties: { className: i },
    // Assume no doctypes.
    children: (
      /** @type {Array<ElementContent>} */
      m.type === "root" ? m.children : [m]
    )
  }), rc(m, b), $A(m, {
    Fragment: w.Fragment,
    // @ts-expect-error
    // React components are allowed to return numbers,
    // but not according to the types in hast-util-to-jsx-runtime
    components: a,
    ignoreInvalidStyle: !0,
    jsx: w.jsx,
    jsxs: w.jsxs,
    passKeys: !0,
    passNode: !0
  });
  function b(y, v, E) {
    if (y.type === "raw" && E && typeof v == "number")
      return u ? E.children.splice(v, 1) : E.children[v] = { type: "text", value: y.value }, v;
    if (y.type === "element") {
      let _;
      for (_ in Hc)
        if (Object.hasOwn(Hc, _) && Object.hasOwn(y.properties, _)) {
          const x = y.properties[_], I = Hc[_];
          (I === null || I.includes(y.tagName)) && (y.properties[_] = f(String(x || ""), _, y));
        }
    }
    if (y.type === "element") {
      let _ = t ? !t.includes(y.tagName) : s ? s.includes(y.tagName) : !1;
      if (!_ && n && typeof v == "number" && (_ = !n(y, v, E)), _ && E && typeof v == "number")
        return d && y.children ? E.children.splice(v, 1, ...y.children) : E.children.splice(v, 1), v;
    }
  }
}
function NN(e) {
  const t = e.indexOf(":"), n = e.indexOf("?"), r = e.indexOf("#"), i = e.indexOf("/");
  return (
    // If there is no protocol, its relative.
    t === -1 || // If the first colon is after a `?`, `#`, or `/`, its not a protocol.
    i !== -1 && t > i || n !== -1 && t > n || r !== -1 && t > r || // It is a protocol, it should be allowed.
    kN.test(e.slice(0, t)) ? e : ""
  );
}
function Jh(e, t) {
  const n = String(e);
  if (typeof t != "string")
    throw new TypeError("Expected character");
  let r = 0, i = n.indexOf(t);
  for (; i !== -1; )
    r++, i = n.indexOf(t, i + t.length);
  return r;
}
function ON(e) {
  if (typeof e != "string")
    throw new TypeError("Expected a string");
  return e.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
}
function MN(e, t, n) {
  const i = Qs((n || {}).ignore || []), a = PN(t);
  let s = -1;
  for (; ++s < a.length; )
    Iy(e, "text", o);
  function o(c, u) {
    let d = -1, f;
    for (; ++d < u.length; ) {
      const p = u[d], h = f ? f.children : void 0;
      if (i(
        p,
        h ? h.indexOf(p) : void 0,
        f
      ))
        return;
      f = p;
    }
    if (f)
      return l(c, u);
  }
  function l(c, u) {
    const d = u[u.length - 1], f = a[s][0], p = a[s][1];
    let h = 0;
    const m = d.children.indexOf(c);
    let b = !1, y = [];
    f.lastIndex = 0;
    let v = f.exec(c.value);
    for (; v; ) {
      const E = v.index, _ = {
        index: v.index,
        input: v.input,
        stack: [...u, c]
      };
      let x = p(...v, _);
      if (typeof x == "string" && (x = x.length > 0 ? { type: "text", value: x } : void 0), x === !1 ? f.lastIndex = E + 1 : (h !== E && y.push({
        type: "text",
        value: c.value.slice(h, E)
      }), Array.isArray(x) ? y.push(...x) : x && y.push(x), h = E + v[0].length, b = !0), !f.global)
        break;
      v = f.exec(c.value);
    }
    return b ? (h < c.value.length && y.push({ type: "text", value: c.value.slice(h) }), d.children.splice(m, 1, ...y)) : y = [c], m + y.length;
  }
}
function PN(e) {
  const t = [];
  if (!Array.isArray(e))
    throw new TypeError("Expected find and replace tuple or list of tuples");
  const n = !e[0] || Array.isArray(e[0]) ? e : [e];
  let r = -1;
  for (; ++r < n.length; ) {
    const i = n[r];
    t.push([DN(i[0]), LN(i[1])]);
  }
  return t;
}
function DN(e) {
  return typeof e == "string" ? new RegExp(ON(e), "g") : e;
}
function LN(e) {
  return typeof e == "function" ? e : function() {
    return e;
  };
}
const tu = "phrasing", nu = ["autolink", "link", "image", "label"];
function FN() {
  return {
    transforms: [HN],
    enter: {
      literalAutolink: zN,
      literalAutolinkEmail: ru,
      literalAutolinkHttp: ru,
      literalAutolinkWww: ru
    },
    exit: {
      literalAutolink: UN,
      literalAutolinkEmail: jN,
      literalAutolinkHttp: VN,
      literalAutolinkWww: GN
    }
  };
}
function BN() {
  return {
    unsafe: [
      {
        character: "@",
        before: "[+\\-.\\w]",
        after: "[\\-.\\w]",
        inConstruct: tu,
        notInConstruct: nu
      },
      {
        character: ".",
        before: "[Ww]",
        after: "[\\-.\\w]",
        inConstruct: tu,
        notInConstruct: nu
      },
      {
        character: ":",
        before: "[ps]",
        after: "\\/",
        inConstruct: tu,
        notInConstruct: nu
      }
    ]
  };
}
function zN(e) {
  this.enter({ type: "link", title: null, url: "", children: [] }, e);
}
function ru(e) {
  this.config.enter.autolinkProtocol.call(this, e);
}
function VN(e) {
  this.config.exit.autolinkProtocol.call(this, e);
}
function GN(e) {
  this.config.exit.data.call(this, e);
  const t = this.stack[this.stack.length - 1];
  t.type, t.url = "http://" + this.sliceSerialize(e);
}
function jN(e) {
  this.config.exit.autolinkEmail.call(this, e);
}
function UN(e) {
  this.exit(e);
}
function HN(e) {
  MN(
    e,
    [
      [/(https?:\/\/|www(?=\.))([-.\w]+)([^ \t\r\n]*)/gi, WN],
      [new RegExp("(?<=^|\\s|\\p{P}|\\p{S})([-.\\w+]+)@([-\\w]+(?:\\.[-\\w]+)+)", "gu"), ZN]
    ],
    { ignore: ["link", "linkReference"] }
  );
}
function WN(e, t, n, r, i) {
  let a = "";
  if (!Ay(i) || (/^w/i.test(t) && (n = t + n, t = "", a = "http://"), !$N(n)))
    return !1;
  const s = XN(n + r);
  if (!s[0]) return !1;
  const o = {
    type: "link",
    title: null,
    url: a + t + s[0],
    children: [{ type: "text", value: t + s[0] }]
  };
  return s[1] ? [o, { type: "text", value: s[1] }] : o;
}
function ZN(e, t, n, r) {
  return (
    // Not an expected previous character.
    !Ay(r, !0) || // Label ends in not allowed character.
    /[-\d_]$/.test(n) ? !1 : {
      type: "link",
      title: null,
      url: "mailto:" + t + "@" + n,
      children: [{ type: "text", value: t + "@" + n }]
    }
  );
}
function $N(e) {
  const t = e.split(".");
  return !(t.length < 2 || t[t.length - 1] && (/_/.test(t[t.length - 1]) || !/[a-zA-Z\d]/.test(t[t.length - 1])) || t[t.length - 2] && (/_/.test(t[t.length - 2]) || !/[a-zA-Z\d]/.test(t[t.length - 2])));
}
function XN(e) {
  const t = /[!"&'),.:;<>?\]}]+$/.exec(e);
  if (!t)
    return [e, void 0];
  e = e.slice(0, t.index);
  let n = t[0], r = n.indexOf(")");
  const i = Jh(e, "(");
  let a = Jh(e, ")");
  for (; r !== -1 && i > a; )
    e += n.slice(0, r + 1), n = n.slice(r + 1), r = n.indexOf(")"), a++;
  return [e, n];
}
function Ay(e, t) {
  const n = e.input.charCodeAt(e.index - 1);
  return (e.index === 0 || Ri(n) || Ql(n)) && // If its an email, the previous character should not be a slash.
  (!t || n !== 47);
}
ky.peek = aO;
function YN() {
  return {
    enter: {
      gfmFootnoteDefinition: qN,
      gfmFootnoteDefinitionLabelString: KN,
      gfmFootnoteCall: tO,
      gfmFootnoteCallString: nO
    },
    exit: {
      gfmFootnoteDefinition: eO,
      gfmFootnoteDefinitionLabelString: QN,
      gfmFootnoteCall: iO,
      gfmFootnoteCallString: rO
    }
  };
}
function JN() {
  return {
    // This is on by default already.
    unsafe: [{ character: "[", inConstruct: ["phrasing", "label", "reference"] }],
    handlers: { footnoteDefinition: sO, footnoteReference: ky }
  };
}
function qN(e) {
  this.enter(
    { type: "footnoteDefinition", identifier: "", label: "", children: [] },
    e
  );
}
function KN() {
  this.buffer();
}
function QN(e) {
  const t = this.resume(), n = this.stack[this.stack.length - 1];
  n.type, n.label = t, n.identifier = Qn(
    this.sliceSerialize(e)
  ).toLowerCase();
}
function eO(e) {
  this.exit(e);
}
function tO(e) {
  this.enter({ type: "footnoteReference", identifier: "", label: "" }, e);
}
function nO() {
  this.buffer();
}
function rO(e) {
  const t = this.resume(), n = this.stack[this.stack.length - 1];
  n.type, n.label = t, n.identifier = Qn(
    this.sliceSerialize(e)
  ).toLowerCase();
}
function iO(e) {
  this.exit(e);
}
function ky(e, t, n, r) {
  const i = n.createTracker(r);
  let a = i.move("[^");
  const s = n.enter("footnoteReference"), o = n.enter("reference");
  return a += i.move(
    n.safe(n.associationId(e), {
      ...i.current(),
      before: a,
      after: "]"
    })
  ), o(), s(), a += i.move("]"), a;
}
function aO() {
  return "[";
}
function sO(e, t, n, r) {
  const i = n.createTracker(r);
  let a = i.move("[^");
  const s = n.enter("footnoteDefinition"), o = n.enter("label");
  return a += i.move(
    n.safe(n.associationId(e), {
      ...i.current(),
      before: a,
      after: "]"
    })
  ), o(), a += i.move(
    "]:" + (e.children && e.children.length > 0 ? " " : "")
  ), i.shift(4), a += i.move(
    n.indentLines(n.containerFlow(e, i.current()), oO)
  ), s(), a;
}
function oO(e, t, n) {
  return t === 0 ? e : (n ? "" : "    ") + e;
}
const lO = [
  "autolink",
  "destinationLiteral",
  "destinationRaw",
  "reference",
  "titleQuote",
  "titleApostrophe"
];
Ty.peek = pO;
function cO() {
  return {
    canContainEols: ["delete"],
    enter: { strikethrough: dO },
    exit: { strikethrough: fO }
  };
}
function uO() {
  return {
    unsafe: [
      {
        character: "~",
        inConstruct: "phrasing",
        notInConstruct: lO
      }
    ],
    handlers: { delete: Ty }
  };
}
function dO(e) {
  this.enter({ type: "delete", children: [] }, e);
}
function fO(e) {
  this.exit(e);
}
function Ty(e, t, n, r) {
  const i = n.createTracker(r), a = n.enter("strikethrough");
  let s = i.move("~~");
  return s += n.containerPhrasing(e, {
    ...i.current(),
    before: s,
    after: "~"
  }), s += i.move("~~"), a(), s;
}
function pO() {
  return "~";
}
function hO(e) {
  return e.length;
}
function gO(e, t) {
  const n = t || {}, r = (n.align || []).concat(), i = n.stringLength || hO, a = [], s = [], o = [], l = [];
  let c = 0, u = -1;
  for (; ++u < e.length; ) {
    const g = [], m = [];
    let b = -1;
    for (e[u].length > c && (c = e[u].length); ++b < e[u].length; ) {
      const y = mO(e[u][b]);
      if (n.alignDelimiters !== !1) {
        const v = i(y);
        m[b] = v, (l[b] === void 0 || v > l[b]) && (l[b] = v);
      }
      g.push(y);
    }
    s[u] = g, o[u] = m;
  }
  let d = -1;
  if (typeof r == "object" && "length" in r)
    for (; ++d < c; )
      a[d] = qh(r[d]);
  else {
    const g = qh(r);
    for (; ++d < c; )
      a[d] = g;
  }
  d = -1;
  const f = [], p = [];
  for (; ++d < c; ) {
    const g = a[d];
    let m = "", b = "";
    g === 99 ? (m = ":", b = ":") : g === 108 ? m = ":" : g === 114 && (b = ":");
    let y = n.alignDelimiters === !1 ? 1 : Math.max(
      1,
      l[d] - m.length - b.length
    );
    const v = m + "-".repeat(y) + b;
    n.alignDelimiters !== !1 && (y = m.length + y + b.length, y > l[d] && (l[d] = y), p[d] = y), f[d] = v;
  }
  s.splice(1, 0, f), o.splice(1, 0, p), u = -1;
  const h = [];
  for (; ++u < s.length; ) {
    const g = s[u], m = o[u];
    d = -1;
    const b = [];
    for (; ++d < c; ) {
      const y = g[d] || "";
      let v = "", E = "";
      if (n.alignDelimiters !== !1) {
        const _ = l[d] - (m[d] || 0), x = a[d];
        x === 114 ? v = " ".repeat(_) : x === 99 ? _ % 2 ? (v = " ".repeat(_ / 2 + 0.5), E = " ".repeat(_ / 2 - 0.5)) : (v = " ".repeat(_ / 2), E = v) : E = " ".repeat(_);
      }
      n.delimiterStart !== !1 && !d && b.push("|"), n.padding !== !1 && // Dont add the opening space if were not aligning and the cell is
      // empty: there will be a closing space.
      !(n.alignDelimiters === !1 && y === "") && (n.delimiterStart !== !1 || d) && b.push(" "), n.alignDelimiters !== !1 && b.push(v), b.push(y), n.alignDelimiters !== !1 && b.push(E), n.padding !== !1 && b.push(" "), (n.delimiterEnd !== !1 || d !== c - 1) && b.push("|");
    }
    h.push(
      n.delimiterEnd === !1 ? b.join("").replace(/ +$/, "") : b.join("")
    );
  }
  return h.join(`
`);
}
function mO(e) {
  return e == null ? "" : String(e);
}
function qh(e) {
  const t = typeof e == "string" ? e.codePointAt(0) : 0;
  return t === 67 || t === 99 ? 99 : t === 76 || t === 108 ? 108 : t === 82 || t === 114 ? 114 : 0;
}
function bO(e, t, n, r) {
  const i = n.enter("blockquote"), a = n.createTracker(r);
  a.move("> "), a.shift(2);
  const s = n.indentLines(
    n.containerFlow(e, a.current()),
    yO
  );
  return i(), s;
}
function yO(e, t, n) {
  return ">" + (n ? "" : " ") + e;
}
function _O(e, t) {
  return Kh(e, t.inConstruct, !0) && !Kh(e, t.notInConstruct, !1);
}
function Kh(e, t, n) {
  if (typeof t == "string" && (t = [t]), !t || t.length === 0)
    return n;
  let r = -1;
  for (; ++r < t.length; )
    if (e.includes(t[r]))
      return !0;
  return !1;
}
function Qh(e, t, n, r) {
  let i = -1;
  for (; ++i < n.unsafe.length; )
    if (n.unsafe[i].character === `
` && _O(n.stack, n.unsafe[i]))
      return /[ \t]/.test(r.before) ? "" : " ";
  return `\\
`;
}
function vO(e, t) {
  const n = String(e);
  let r = n.indexOf(t), i = r, a = 0, s = 0;
  if (typeof t != "string")
    throw new TypeError("Expected substring");
  for (; r !== -1; )
    r === i ? ++a > s && (s = a) : a = 1, i = r + t.length, r = n.indexOf(t, i);
  return s;
}
function xO(e, t) {
  return !!(t.options.fences === !1 && e.value && // If theres no info
  !e.lang && // And theres a non-whitespace character
  /[^ \r\n]/.test(e.value) && // And the value doesnt start or end in a blank
  !/^[\t ]*(?:[\r\n]|$)|(?:^|[\r\n])[\t ]*$/.test(e.value));
}
function EO(e) {
  const t = e.options.fence || "`";
  if (t !== "`" && t !== "~")
    throw new Error(
      "Cannot serialize code with `" + t + "` for `options.fence`, expected `` ` `` or `~`"
    );
  return t;
}
function wO(e, t, n, r) {
  const i = EO(n), a = e.value || "", s = i === "`" ? "GraveAccent" : "Tilde";
  if (xO(e, n)) {
    const d = n.enter("codeIndented"), f = n.indentLines(a, CO);
    return d(), f;
  }
  const o = n.createTracker(r), l = i.repeat(Math.max(vO(a, i) + 1, 3)), c = n.enter("codeFenced");
  let u = o.move(l);
  if (e.lang) {
    const d = n.enter(`codeFencedLang${s}`);
    u += o.move(
      n.safe(e.lang, {
        before: u,
        after: " ",
        encode: ["`"],
        ...o.current()
      })
    ), d();
  }
  if (e.lang && e.meta) {
    const d = n.enter(`codeFencedMeta${s}`);
    u += o.move(" "), u += o.move(
      n.safe(e.meta, {
        before: u,
        after: `
`,
        encode: ["`"],
        ...o.current()
      })
    ), d();
  }
  return u += o.move(`
`), a && (u += o.move(a + `
`)), u += o.move(l), c(), u;
}
function CO(e, t, n) {
  return (n ? "" : "    ") + e;
}
function yf(e) {
  const t = e.options.quote || '"';
  if (t !== '"' && t !== "'")
    throw new Error(
      "Cannot serialize title with `" + t + "` for `options.quote`, expected `\"`, or `'`"
    );
  return t;
}
function IO(e, t, n, r) {
  const i = yf(n), a = i === '"' ? "Quote" : "Apostrophe", s = n.enter("definition");
  let o = n.enter("label");
  const l = n.createTracker(r);
  let c = l.move("[");
  return c += l.move(
    n.safe(n.associationId(e), {
      before: c,
      after: "]",
      ...l.current()
    })
  ), c += l.move("]: "), o(), // If theres no url, or
  !e.url || // If there are control characters or whitespace.
  /[\0- \u007F]/.test(e.url) ? (o = n.enter("destinationLiteral"), c += l.move("<"), c += l.move(
    n.safe(e.url, { before: c, after: ">", ...l.current() })
  ), c += l.move(">")) : (o = n.enter("destinationRaw"), c += l.move(
    n.safe(e.url, {
      before: c,
      after: e.title ? " " : `
`,
      ...l.current()
    })
  )), o(), e.title && (o = n.enter(`title${a}`), c += l.move(" " + i), c += l.move(
    n.safe(e.title, {
      before: c,
      after: i,
      ...l.current()
    })
  ), c += l.move(i), o()), s(), c;
}
function SO(e) {
  const t = e.options.emphasis || "*";
  if (t !== "*" && t !== "_")
    throw new Error(
      "Cannot serialize emphasis with `" + t + "` for `options.emphasis`, expected `*`, or `_`"
    );
  return t;
}
function Os(e) {
  return "&#x" + e.toString(16).toUpperCase() + ";";
}
function xl(e, t, n) {
  const r = xa(e), i = xa(t);
  return r === void 0 ? i === void 0 ? (
    // Letter inside:
    // we have to encode *both* letters for `_` as it is looser.
    // it already forms for `*` (and GFMs `~`).
    n === "_" ? { inside: !0, outside: !0 } : { inside: !1, outside: !1 }
  ) : i === 1 ? (
    // Whitespace inside: encode both (letter, whitespace).
    { inside: !0, outside: !0 }
  ) : (
    // Punctuation inside: encode outer (letter)
    { inside: !1, outside: !0 }
  ) : r === 1 ? i === void 0 ? (
    // Letter inside: already forms.
    { inside: !1, outside: !1 }
  ) : i === 1 ? (
    // Whitespace inside: encode both (whitespace).
    { inside: !0, outside: !0 }
  ) : (
    // Punctuation inside: already forms.
    { inside: !1, outside: !1 }
  ) : i === void 0 ? (
    // Letter inside: already forms.
    { inside: !1, outside: !1 }
  ) : i === 1 ? (
    // Whitespace inside: encode inner (whitespace).
    { inside: !0, outside: !1 }
  ) : (
    // Punctuation inside: already forms.
    { inside: !1, outside: !1 }
  );
}
Ry.peek = AO;
function Ry(e, t, n, r) {
  const i = SO(n), a = n.enter("emphasis"), s = n.createTracker(r), o = s.move(i);
  let l = s.move(
    n.containerPhrasing(e, {
      after: i,
      before: o,
      ...s.current()
    })
  );
  const c = l.charCodeAt(0), u = xl(
    r.before.charCodeAt(r.before.length - 1),
    c,
    i
  );
  u.inside && (l = Os(c) + l.slice(1));
  const d = l.charCodeAt(l.length - 1), f = xl(r.after.charCodeAt(0), d, i);
  f.inside && (l = l.slice(0, -1) + Os(d));
  const p = s.move(i);
  return a(), n.attentionEncodeSurroundingInfo = {
    after: f.outside,
    before: u.outside
  }, o + l + p;
}
function AO(e, t, n) {
  return n.options.emphasis || "*";
}
function kO(e, t) {
  let n = !1;
  return rc(e, function(r) {
    if ("value" in r && /\r?\n|\r/.test(r.value) || r.type === "break")
      return n = !0, Yu;
  }), !!((!e.depth || e.depth < 3) && uf(e) && (t.options.setext || n));
}
function TO(e, t, n, r) {
  const i = Math.max(Math.min(6, e.depth || 1), 1), a = n.createTracker(r);
  if (kO(e, n)) {
    const u = n.enter("headingSetext"), d = n.enter("phrasing"), f = n.containerPhrasing(e, {
      ...a.current(),
      before: `
`,
      after: `
`
    });
    return d(), u(), f + `
` + (i === 1 ? "=" : "-").repeat(
      // The whole size
      f.length - // Minus the position of the character after the last EOL (or
      // 0 if there is none)
      (Math.max(f.lastIndexOf("\r"), f.lastIndexOf(`
`)) + 1)
    );
  }
  const s = "#".repeat(i), o = n.enter("headingAtx"), l = n.enter("phrasing");
  a.move(s + " ");
  let c = n.containerPhrasing(e, {
    before: "# ",
    after: `
`,
    ...a.current()
  });
  return /^[\t ]/.test(c) && (c = Os(c.charCodeAt(0)) + c.slice(1)), c = c ? s + " " + c : s, n.options.closeAtx && (c += " " + s), l(), o(), c;
}
Ny.peek = RO;
function Ny(e) {
  return e.value || "";
}
function RO() {
  return "<";
}
Oy.peek = NO;
function Oy(e, t, n, r) {
  const i = yf(n), a = i === '"' ? "Quote" : "Apostrophe", s = n.enter("image");
  let o = n.enter("label");
  const l = n.createTracker(r);
  let c = l.move("![");
  return c += l.move(
    n.safe(e.alt, { before: c, after: "]", ...l.current() })
  ), c += l.move("]("), o(), // If theres no url but there is a title
  !e.url && e.title || // If there are control characters or whitespace.
  /[\0- \u007F]/.test(e.url) ? (o = n.enter("destinationLiteral"), c += l.move("<"), c += l.move(
    n.safe(e.url, { before: c, after: ">", ...l.current() })
  ), c += l.move(">")) : (o = n.enter("destinationRaw"), c += l.move(
    n.safe(e.url, {
      before: c,
      after: e.title ? " " : ")",
      ...l.current()
    })
  )), o(), e.title && (o = n.enter(`title${a}`), c += l.move(" " + i), c += l.move(
    n.safe(e.title, {
      before: c,
      after: i,
      ...l.current()
    })
  ), c += l.move(i), o()), c += l.move(")"), s(), c;
}
function NO() {
  return "!";
}
My.peek = OO;
function My(e, t, n, r) {
  const i = e.referenceType, a = n.enter("imageReference");
  let s = n.enter("label");
  const o = n.createTracker(r);
  let l = o.move("![");
  const c = n.safe(e.alt, {
    before: l,
    after: "]",
    ...o.current()
  });
  l += o.move(c + "]["), s();
  const u = n.stack;
  n.stack = [], s = n.enter("reference");
  const d = n.safe(n.associationId(e), {
    before: l,
    after: "]",
    ...o.current()
  });
  return s(), n.stack = u, a(), i === "full" || !c || c !== d ? l += o.move(d + "]") : i === "shortcut" ? l = l.slice(0, -1) : l += o.move("]"), l;
}
function OO() {
  return "!";
}
Py.peek = MO;
function Py(e, t, n) {
  let r = e.value || "", i = "`", a = -1;
  for (; new RegExp("(^|[^`])" + i + "([^`]|$)").test(r); )
    i += "`";
  for (/[^ \r\n]/.test(r) && (/^[ \r\n]/.test(r) && /[ \r\n]$/.test(r) || /^`|`$/.test(r)) && (r = " " + r + " "); ++a < n.unsafe.length; ) {
    const s = n.unsafe[a], o = n.compilePattern(s);
    let l;
    if (s.atBreak)
      for (; l = o.exec(r); ) {
        let c = l.index;
        r.charCodeAt(c) === 10 && r.charCodeAt(c - 1) === 13 && c--, r = r.slice(0, c) + " " + r.slice(l.index + 1);
      }
  }
  return i + r + i;
}
function MO() {
  return "`";
}
function Dy(e, t) {
  const n = uf(e);
  return !!(!t.options.resourceLink && // If theres a url
  e.url && // And theres a no title
  !e.title && // And the content of `node` is a single text node
  e.children && e.children.length === 1 && e.children[0].type === "text" && // And if the url is the same as the content
  (n === e.url || "mailto:" + n === e.url) && // And that starts w/ a protocol
  /^[a-z][a-z+.-]+:/i.test(e.url) && // And that doesnt contain ASCII control codes (character escapes and
  // references dont work), space, or angle brackets
  !/[\0- <>\u007F]/.test(e.url));
}
Ly.peek = PO;
function Ly(e, t, n, r) {
  const i = yf(n), a = i === '"' ? "Quote" : "Apostrophe", s = n.createTracker(r);
  let o, l;
  if (Dy(e, n)) {
    const u = n.stack;
    n.stack = [], o = n.enter("autolink");
    let d = s.move("<");
    return d += s.move(
      n.containerPhrasing(e, {
        before: d,
        after: ">",
        ...s.current()
      })
    ), d += s.move(">"), o(), n.stack = u, d;
  }
  o = n.enter("link"), l = n.enter("label");
  let c = s.move("[");
  return c += s.move(
    n.containerPhrasing(e, {
      before: c,
      after: "](",
      ...s.current()
    })
  ), c += s.move("]("), l(), // If theres no url but there is a title
  !e.url && e.title || // If there are control characters or whitespace.
  /[\0- \u007F]/.test(e.url) ? (l = n.enter("destinationLiteral"), c += s.move("<"), c += s.move(
    n.safe(e.url, { before: c, after: ">", ...s.current() })
  ), c += s.move(">")) : (l = n.enter("destinationRaw"), c += s.move(
    n.safe(e.url, {
      before: c,
      after: e.title ? " " : ")",
      ...s.current()
    })
  )), l(), e.title && (l = n.enter(`title${a}`), c += s.move(" " + i), c += s.move(
    n.safe(e.title, {
      before: c,
      after: i,
      ...s.current()
    })
  ), c += s.move(i), l()), c += s.move(")"), o(), c;
}
function PO(e, t, n) {
  return Dy(e, n) ? "<" : "[";
}
Fy.peek = DO;
function Fy(e, t, n, r) {
  const i = e.referenceType, a = n.enter("linkReference");
  let s = n.enter("label");
  const o = n.createTracker(r);
  let l = o.move("[");
  const c = n.containerPhrasing(e, {
    before: l,
    after: "]",
    ...o.current()
  });
  l += o.move(c + "]["), s();
  const u = n.stack;
  n.stack = [], s = n.enter("reference");
  const d = n.safe(n.associationId(e), {
    before: l,
    after: "]",
    ...o.current()
  });
  return s(), n.stack = u, a(), i === "full" || !c || c !== d ? l += o.move(d + "]") : i === "shortcut" ? l = l.slice(0, -1) : l += o.move("]"), l;
}
function DO() {
  return "[";
}
function _f(e) {
  const t = e.options.bullet || "*";
  if (t !== "*" && t !== "+" && t !== "-")
    throw new Error(
      "Cannot serialize items with `" + t + "` for `options.bullet`, expected `*`, `+`, or `-`"
    );
  return t;
}
function LO(e) {
  const t = _f(e), n = e.options.bulletOther;
  if (!n)
    return t === "*" ? "-" : "*";
  if (n !== "*" && n !== "+" && n !== "-")
    throw new Error(
      "Cannot serialize items with `" + n + "` for `options.bulletOther`, expected `*`, `+`, or `-`"
    );
  if (n === t)
    throw new Error(
      "Expected `bullet` (`" + t + "`) and `bulletOther` (`" + n + "`) to be different"
    );
  return n;
}
function FO(e) {
  const t = e.options.bulletOrdered || ".";
  if (t !== "." && t !== ")")
    throw new Error(
      "Cannot serialize items with `" + t + "` for `options.bulletOrdered`, expected `.` or `)`"
    );
  return t;
}
function By(e) {
  const t = e.options.rule || "*";
  if (t !== "*" && t !== "-" && t !== "_")
    throw new Error(
      "Cannot serialize rules with `" + t + "` for `options.rule`, expected `*`, `-`, or `_`"
    );
  return t;
}
function BO(e, t, n, r) {
  const i = n.enter("list"), a = n.bulletCurrent;
  let s = e.ordered ? FO(n) : _f(n);
  const o = e.ordered ? s === "." ? ")" : "." : LO(n);
  let l = t && n.bulletLastUsed ? s === n.bulletLastUsed : !1;
  if (!e.ordered) {
    const u = e.children ? e.children[0] : void 0;
    if (
      // Bullet could be used as a thematic break marker:
      (s === "*" || s === "-") && // Empty first list item:
      u && (!u.children || !u.children[0]) && // Directly in two other list items:
      n.stack[n.stack.length - 1] === "list" && n.stack[n.stack.length - 2] === "listItem" && n.stack[n.stack.length - 3] === "list" && n.stack[n.stack.length - 4] === "listItem" && // That are each the first child.
      n.indexStack[n.indexStack.length - 1] === 0 && n.indexStack[n.indexStack.length - 2] === 0 && n.indexStack[n.indexStack.length - 3] === 0 && (l = !0), By(n) === s && u
    ) {
      let d = -1;
      for (; ++d < e.children.length; ) {
        const f = e.children[d];
        if (f && f.type === "listItem" && f.children && f.children[0] && f.children[0].type === "thematicBreak") {
          l = !0;
          break;
        }
      }
    }
  }
  l && (s = o), n.bulletCurrent = s;
  const c = n.containerFlow(e, r);
  return n.bulletLastUsed = s, n.bulletCurrent = a, i(), c;
}
function zO(e) {
  const t = e.options.listItemIndent || "one";
  if (t !== "tab" && t !== "one" && t !== "mixed")
    throw new Error(
      "Cannot serialize items with `" + t + "` for `options.listItemIndent`, expected `tab`, `one`, or `mixed`"
    );
  return t;
}
function VO(e, t, n, r) {
  const i = zO(n);
  let a = n.bulletCurrent || _f(n);
  t && t.type === "list" && t.ordered && (a = (typeof t.start == "number" && t.start > -1 ? t.start : 1) + (n.options.incrementListMarker === !1 ? 0 : t.children.indexOf(e)) + a);
  let s = a.length + 1;
  (i === "tab" || i === "mixed" && (t && t.type === "list" && t.spread || e.spread)) && (s = Math.ceil(s / 4) * 4);
  const o = n.createTracker(r);
  o.move(a + " ".repeat(s - a.length)), o.shift(s);
  const l = n.enter("listItem"), c = n.indentLines(
    n.containerFlow(e, o.current()),
    u
  );
  return l(), c;
  function u(d, f, p) {
    return f ? (p ? "" : " ".repeat(s)) + d : (p ? a : a + " ".repeat(s - a.length)) + d;
  }
}
function GO(e, t, n, r) {
  const i = n.enter("paragraph"), a = n.enter("phrasing"), s = n.containerPhrasing(e, r);
  return a(), i(), s;
}
const jO = (
  /** @type {(node?: unknown) => node is Exclude<PhrasingContent, Html>} */
  Qs([
    "break",
    "delete",
    "emphasis",
    // To do: next major: removed since footnotes were added to GFM.
    "footnote",
    "footnoteReference",
    "image",
    "imageReference",
    "inlineCode",
    // Enabled by `mdast-util-math`:
    "inlineMath",
    "link",
    "linkReference",
    // Enabled by `mdast-util-mdx`:
    "mdxJsxTextElement",
    // Enabled by `mdast-util-mdx`:
    "mdxTextExpression",
    "strong",
    "text",
    // Enabled by `mdast-util-directive`:
    "textDirective"
  ])
);
function UO(e, t, n, r) {
  return (e.children.some(function(s) {
    return jO(s);
  }) ? n.containerPhrasing : n.containerFlow).call(n, e, r);
}
function HO(e) {
  const t = e.options.strong || "*";
  if (t !== "*" && t !== "_")
    throw new Error(
      "Cannot serialize strong with `" + t + "` for `options.strong`, expected `*`, or `_`"
    );
  return t;
}
zy.peek = WO;
function zy(e, t, n, r) {
  const i = HO(n), a = n.enter("strong"), s = n.createTracker(r), o = s.move(i + i);
  let l = s.move(
    n.containerPhrasing(e, {
      after: i,
      before: o,
      ...s.current()
    })
  );
  const c = l.charCodeAt(0), u = xl(
    r.before.charCodeAt(r.before.length - 1),
    c,
    i
  );
  u.inside && (l = Os(c) + l.slice(1));
  const d = l.charCodeAt(l.length - 1), f = xl(r.after.charCodeAt(0), d, i);
  f.inside && (l = l.slice(0, -1) + Os(d));
  const p = s.move(i + i);
  return a(), n.attentionEncodeSurroundingInfo = {
    after: f.outside,
    before: u.outside
  }, o + l + p;
}
function WO(e, t, n) {
  return n.options.strong || "*";
}
function ZO(e, t, n, r) {
  return n.safe(e.value, r);
}
function $O(e) {
  const t = e.options.ruleRepetition || 3;
  if (t < 3)
    throw new Error(
      "Cannot serialize rules with repetition `" + t + "` for `options.ruleRepetition`, expected `3` or more"
    );
  return t;
}
function XO(e, t, n) {
  const r = (By(n) + (n.options.ruleSpaces ? " " : "")).repeat($O(n));
  return n.options.ruleSpaces ? r.slice(0, -1) : r;
}
const Vy = {
  blockquote: bO,
  break: Qh,
  code: wO,
  definition: IO,
  emphasis: Ry,
  hardBreak: Qh,
  heading: TO,
  html: Ny,
  image: Oy,
  imageReference: My,
  inlineCode: Py,
  link: Ly,
  linkReference: Fy,
  list: BO,
  listItem: VO,
  paragraph: GO,
  root: UO,
  strong: zy,
  text: ZO,
  thematicBreak: XO
};
function YO() {
  return {
    enter: {
      table: JO,
      tableData: eg,
      tableHeader: eg,
      tableRow: KO
    },
    exit: {
      codeText: QO,
      table: qO,
      tableData: iu,
      tableHeader: iu,
      tableRow: iu
    }
  };
}
function JO(e) {
  const t = e._align;
  this.enter(
    {
      type: "table",
      align: t.map(function(n) {
        return n === "none" ? null : n;
      }),
      children: []
    },
    e
  ), this.data.inTable = !0;
}
function qO(e) {
  this.exit(e), this.data.inTable = void 0;
}
function KO(e) {
  this.enter({ type: "tableRow", children: [] }, e);
}
function iu(e) {
  this.exit(e);
}
function eg(e) {
  this.enter({ type: "tableCell", children: [] }, e);
}
function QO(e) {
  let t = this.resume();
  this.data.inTable && (t = t.replace(/\\([\\|])/g, eM));
  const n = this.stack[this.stack.length - 1];
  n.type, n.value = t, this.exit(e);
}
function eM(e, t) {
  return t === "|" ? t : e;
}
function tM(e) {
  const t = e || {}, n = t.tableCellPadding, r = t.tablePipeAlign, i = t.stringLength, a = n ? " " : "|";
  return {
    unsafe: [
      { character: "\r", inConstruct: "tableCell" },
      { character: `
`, inConstruct: "tableCell" },
      // A pipe, when followed by a tab or space (padding), or a dash or colon
      // (unpadded delimiter row), could result in a table.
      { atBreak: !0, character: "|", after: "[	 :-]" },
      // A pipe in a cell must be encoded.
      { character: "|", inConstruct: "tableCell" },
      // A colon must be followed by a dash, in which case it could start a
      // delimiter row.
      { atBreak: !0, character: ":", after: "-" },
      // A delimiter row can also start with a dash, when followed by more
      // dashes, a colon, or a pipe.
      // This is a stricter version than the built in check for lists, thematic
      // breaks, and setex heading underlines though:
      // <https://github.com/syntax-tree/mdast-util-to-markdown/blob/51a2038/lib/unsafe.js#L57>
      { atBreak: !0, character: "-", after: "[:|-]" }
    ],
    handlers: {
      inlineCode: f,
      table: s,
      tableCell: l,
      tableRow: o
    }
  };
  function s(p, h, g, m) {
    return c(u(p, g, m), p.align);
  }
  function o(p, h, g, m) {
    const b = d(p, g, m), y = c([b]);
    return y.slice(0, y.indexOf(`
`));
  }
  function l(p, h, g, m) {
    const b = g.enter("tableCell"), y = g.enter("phrasing"), v = g.containerPhrasing(p, {
      ...m,
      before: a,
      after: a
    });
    return y(), b(), v;
  }
  function c(p, h) {
    return gO(p, {
      align: h,
      // @ts-expect-error: `markdown-table` types should support `null`.
      alignDelimiters: r,
      // @ts-expect-error: `markdown-table` types should support `null`.
      padding: n,
      // @ts-expect-error: `markdown-table` types should support `null`.
      stringLength: i
    });
  }
  function u(p, h, g) {
    const m = p.children;
    let b = -1;
    const y = [], v = h.enter("table");
    for (; ++b < m.length; )
      y[b] = d(m[b], h, g);
    return v(), y;
  }
  function d(p, h, g) {
    const m = p.children;
    let b = -1;
    const y = [], v = h.enter("tableRow");
    for (; ++b < m.length; )
      y[b] = l(m[b], p, h, g);
    return v(), y;
  }
  function f(p, h, g) {
    let m = Vy.inlineCode(p, h, g);
    return g.stack.includes("tableCell") && (m = m.replace(/\|/g, "\\$&")), m;
  }
}
function nM() {
  return {
    exit: {
      taskListCheckValueChecked: tg,
      taskListCheckValueUnchecked: tg,
      paragraph: iM
    }
  };
}
function rM() {
  return {
    unsafe: [{ atBreak: !0, character: "-", after: "[:|-]" }],
    handlers: { listItem: aM }
  };
}
function tg(e) {
  const t = this.stack[this.stack.length - 2];
  t.type, t.checked = e.type === "taskListCheckValueChecked";
}
function iM(e) {
  const t = this.stack[this.stack.length - 2];
  if (t && t.type === "listItem" && typeof t.checked == "boolean") {
    const n = this.stack[this.stack.length - 1];
    n.type;
    const r = n.children[0];
    if (r && r.type === "text") {
      const i = t.children;
      let a = -1, s;
      for (; ++a < i.length; ) {
        const o = i[a];
        if (o.type === "paragraph") {
          s = o;
          break;
        }
      }
      s === n && (r.value = r.value.slice(1), r.value.length === 0 ? n.children.shift() : n.position && r.position && typeof r.position.start.offset == "number" && (r.position.start.column++, r.position.start.offset++, n.position.start = Object.assign({}, r.position.start)));
    }
  }
  this.exit(e);
}
function aM(e, t, n, r) {
  const i = e.children[0], a = typeof e.checked == "boolean" && i && i.type === "paragraph", s = "[" + (e.checked ? "x" : " ") + "] ", o = n.createTracker(r);
  a && o.move(s);
  let l = Vy.listItem(e, t, n, {
    ...r,
    ...o.current()
  });
  return a && (l = l.replace(/^(?:[*+-]|\d+\.)([\r\n]| {1,3})/, c)), l;
  function c(u) {
    return u + s;
  }
}
function sM() {
  return [
    FN(),
    YN(),
    cO(),
    YO(),
    nM()
  ];
}
function oM(e) {
  return {
    extensions: [
      BN(),
      JN(),
      uO(),
      tM(e),
      rM()
    ]
  };
}
const lM = {
  tokenize: hM,
  partial: !0
}, Gy = {
  tokenize: gM,
  partial: !0
}, jy = {
  tokenize: mM,
  partial: !0
}, Uy = {
  tokenize: bM,
  partial: !0
}, cM = {
  tokenize: yM,
  partial: !0
}, Hy = {
  name: "wwwAutolink",
  tokenize: fM,
  previous: Zy
}, Wy = {
  name: "protocolAutolink",
  tokenize: pM,
  previous: $y
}, Ur = {
  name: "emailAutolink",
  tokenize: dM,
  previous: Xy
}, Cr = {};
function uM() {
  return {
    text: Cr
  };
}
let ui = 48;
for (; ui < 123; )
  Cr[ui] = Ur, ui++, ui === 58 ? ui = 65 : ui === 91 && (ui = 97);
Cr[43] = Ur;
Cr[45] = Ur;
Cr[46] = Ur;
Cr[95] = Ur;
Cr[72] = [Ur, Wy];
Cr[104] = [Ur, Wy];
Cr[87] = [Ur, Hy];
Cr[119] = [Ur, Hy];
function dM(e, t, n) {
  const r = this;
  let i, a;
  return s;
  function s(d) {
    return !Qu(d) || !Xy.call(r, r.previous) || vf(r.events) ? n(d) : (e.enter("literalAutolink"), e.enter("literalAutolinkEmail"), o(d));
  }
  function o(d) {
    return Qu(d) ? (e.consume(d), o) : d === 64 ? (e.consume(d), l) : n(d);
  }
  function l(d) {
    return d === 46 ? e.check(cM, u, c)(d) : d === 45 || d === 95 || Yt(d) ? (a = !0, e.consume(d), l) : u(d);
  }
  function c(d) {
    return e.consume(d), i = !0, l;
  }
  function u(d) {
    return a && i && on(r.previous) ? (e.exit("literalAutolinkEmail"), e.exit("literalAutolink"), t(d)) : n(d);
  }
}
function fM(e, t, n) {
  const r = this;
  return i;
  function i(s) {
    return s !== 87 && s !== 119 || !Zy.call(r, r.previous) || vf(r.events) ? n(s) : (e.enter("literalAutolink"), e.enter("literalAutolinkWww"), e.check(lM, e.attempt(Gy, e.attempt(jy, a), n), n)(s));
  }
  function a(s) {
    return e.exit("literalAutolinkWww"), e.exit("literalAutolink"), t(s);
  }
}
function pM(e, t, n) {
  const r = this;
  let i = "", a = !1;
  return s;
  function s(d) {
    return (d === 72 || d === 104) && $y.call(r, r.previous) && !vf(r.events) ? (e.enter("literalAutolink"), e.enter("literalAutolinkHttp"), i += String.fromCodePoint(d), e.consume(d), o) : n(d);
  }
  function o(d) {
    if (on(d) && i.length < 5)
      return i += String.fromCodePoint(d), e.consume(d), o;
    if (d === 58) {
      const f = i.toLowerCase();
      if (f === "http" || f === "https")
        return e.consume(d), l;
    }
    return n(d);
  }
  function l(d) {
    return d === 47 ? (e.consume(d), a ? c : (a = !0, l)) : n(d);
  }
  function c(d) {
    return d === null || yl(d) || Qe(d) || Ri(d) || Ql(d) ? n(d) : e.attempt(Gy, e.attempt(jy, u), n)(d);
  }
  function u(d) {
    return e.exit("literalAutolinkHttp"), e.exit("literalAutolink"), t(d);
  }
}
function hM(e, t, n) {
  let r = 0;
  return i;
  function i(s) {
    return (s === 87 || s === 119) && r < 3 ? (r++, e.consume(s), i) : s === 46 && r === 3 ? (e.consume(s), a) : n(s);
  }
  function a(s) {
    return s === null ? n(s) : t(s);
  }
}
function gM(e, t, n) {
  let r, i, a;
  return s;
  function s(c) {
    return c === 46 || c === 95 ? e.check(Uy, l, o)(c) : c === null || Qe(c) || Ri(c) || c !== 45 && Ql(c) ? l(c) : (a = !0, e.consume(c), s);
  }
  function o(c) {
    return c === 95 ? r = !0 : (i = r, r = void 0), e.consume(c), s;
  }
  function l(c) {
    return i || r || !a ? n(c) : t(c);
  }
}
function mM(e, t) {
  let n = 0, r = 0;
  return i;
  function i(s) {
    return s === 40 ? (n++, e.consume(s), i) : s === 41 && r < n ? a(s) : s === 33 || s === 34 || s === 38 || s === 39 || s === 41 || s === 42 || s === 44 || s === 46 || s === 58 || s === 59 || s === 60 || s === 63 || s === 93 || s === 95 || s === 126 ? e.check(Uy, t, a)(s) : s === null || Qe(s) || Ri(s) ? t(s) : (e.consume(s), i);
  }
  function a(s) {
    return s === 41 && r++, e.consume(s), i;
  }
}
function bM(e, t, n) {
  return r;
  function r(o) {
    return o === 33 || o === 34 || o === 39 || o === 41 || o === 42 || o === 44 || o === 46 || o === 58 || o === 59 || o === 63 || o === 95 || o === 126 ? (e.consume(o), r) : o === 38 ? (e.consume(o), a) : o === 93 ? (e.consume(o), i) : (
      // `<` is an end.
      o === 60 || // So is whitespace.
      o === null || Qe(o) || Ri(o) ? t(o) : n(o)
    );
  }
  function i(o) {
    return o === null || o === 40 || o === 91 || Qe(o) || Ri(o) ? t(o) : r(o);
  }
  function a(o) {
    return on(o) ? s(o) : n(o);
  }
  function s(o) {
    return o === 59 ? (e.consume(o), r) : on(o) ? (e.consume(o), s) : n(o);
  }
}
function yM(e, t, n) {
  return r;
  function r(a) {
    return e.consume(a), i;
  }
  function i(a) {
    return Yt(a) ? n(a) : t(a);
  }
}
function Zy(e) {
  return e === null || e === 40 || e === 42 || e === 95 || e === 91 || e === 93 || e === 126 || Qe(e);
}
function $y(e) {
  return !on(e);
}
function Xy(e) {
  return !(e === 47 || Qu(e));
}
function Qu(e) {
  return e === 43 || e === 45 || e === 46 || e === 95 || Yt(e);
}
function vf(e) {
  let t = e.length, n = !1;
  for (; t--; ) {
    const r = e[t][1];
    if ((r.type === "labelLink" || r.type === "labelImage") && !r._balanced) {
      n = !0;
      break;
    }
    if (r._gfmAutolinkLiteralWalkedInto) {
      n = !1;
      break;
    }
  }
  return e.length > 0 && !n && (e[e.length - 1][1]._gfmAutolinkLiteralWalkedInto = !0), n;
}
const _M = {
  tokenize: AM,
  partial: !0
};
function vM() {
  return {
    document: {
      91: {
        name: "gfmFootnoteDefinition",
        tokenize: CM,
        continuation: {
          tokenize: IM
        },
        exit: SM
      }
    },
    text: {
      91: {
        name: "gfmFootnoteCall",
        tokenize: wM
      },
      93: {
        name: "gfmPotentialFootnoteCall",
        add: "after",
        tokenize: xM,
        resolveTo: EM
      }
    }
  };
}
function xM(e, t, n) {
  const r = this;
  let i = r.events.length;
  const a = r.parser.gfmFootnotes || (r.parser.gfmFootnotes = []);
  let s;
  for (; i--; ) {
    const l = r.events[i][1];
    if (l.type === "labelImage") {
      s = l;
      break;
    }
    if (l.type === "gfmFootnoteCall" || l.type === "labelLink" || l.type === "label" || l.type === "image" || l.type === "link")
      break;
  }
  return o;
  function o(l) {
    if (!s || !s._balanced)
      return n(l);
    const c = Qn(r.sliceSerialize({
      start: s.end,
      end: r.now()
    }));
    return c.codePointAt(0) !== 94 || !a.includes(c.slice(1)) ? n(l) : (e.enter("gfmFootnoteCallLabelMarker"), e.consume(l), e.exit("gfmFootnoteCallLabelMarker"), t(l));
  }
}
function EM(e, t) {
  let n = e.length;
  for (; n--; )
    if (e[n][1].type === "labelImage" && e[n][0] === "enter") {
      e[n][1];
      break;
    }
  e[n + 1][1].type = "data", e[n + 3][1].type = "gfmFootnoteCallLabelMarker";
  const r = {
    type: "gfmFootnoteCall",
    start: Object.assign({}, e[n + 3][1].start),
    end: Object.assign({}, e[e.length - 1][1].end)
  }, i = {
    type: "gfmFootnoteCallMarker",
    start: Object.assign({}, e[n + 3][1].end),
    end: Object.assign({}, e[n + 3][1].end)
  };
  i.end.column++, i.end.offset++, i.end._bufferIndex++;
  const a = {
    type: "gfmFootnoteCallString",
    start: Object.assign({}, i.end),
    end: Object.assign({}, e[e.length - 1][1].start)
  }, s = {
    type: "chunkString",
    contentType: "string",
    start: Object.assign({}, a.start),
    end: Object.assign({}, a.end)
  }, o = [
    // Take the `labelImageMarker` (now `data`, the `!`)
    e[n + 1],
    e[n + 2],
    ["enter", r, t],
    // The `[`
    e[n + 3],
    e[n + 4],
    // The `^`.
    ["enter", i, t],
    ["exit", i, t],
    // Everything in between.
    ["enter", a, t],
    ["enter", s, t],
    ["exit", s, t],
    ["exit", a, t],
    // The ending (`]`, properly parsed and labelled).
    e[e.length - 2],
    e[e.length - 1],
    ["exit", r, t]
  ];
  return e.splice(n, e.length - n + 1, ...o), e;
}
function wM(e, t, n) {
  const r = this, i = r.parser.gfmFootnotes || (r.parser.gfmFootnotes = []);
  let a = 0, s;
  return o;
  function o(d) {
    return e.enter("gfmFootnoteCall"), e.enter("gfmFootnoteCallLabelMarker"), e.consume(d), e.exit("gfmFootnoteCallLabelMarker"), l;
  }
  function l(d) {
    return d !== 94 ? n(d) : (e.enter("gfmFootnoteCallMarker"), e.consume(d), e.exit("gfmFootnoteCallMarker"), e.enter("gfmFootnoteCallString"), e.enter("chunkString").contentType = "string", c);
  }
  function c(d) {
    if (
      // Too long.
      a > 999 || // Closing brace with nothing.
      d === 93 && !s || // Space or tab is not supported by GFM for some reason.
      // `\n` and `[` not being supported makes sense.
      d === null || d === 91 || Qe(d)
    )
      return n(d);
    if (d === 93) {
      e.exit("chunkString");
      const f = e.exit("gfmFootnoteCallString");
      return i.includes(Qn(r.sliceSerialize(f))) ? (e.enter("gfmFootnoteCallLabelMarker"), e.consume(d), e.exit("gfmFootnoteCallLabelMarker"), e.exit("gfmFootnoteCall"), t) : n(d);
    }
    return Qe(d) || (s = !0), a++, e.consume(d), d === 92 ? u : c;
  }
  function u(d) {
    return d === 91 || d === 92 || d === 93 ? (e.consume(d), a++, c) : c(d);
  }
}
function CM(e, t, n) {
  const r = this, i = r.parser.gfmFootnotes || (r.parser.gfmFootnotes = []);
  let a, s = 0, o;
  return l;
  function l(h) {
    return e.enter("gfmFootnoteDefinition")._container = !0, e.enter("gfmFootnoteDefinitionLabel"), e.enter("gfmFootnoteDefinitionLabelMarker"), e.consume(h), e.exit("gfmFootnoteDefinitionLabelMarker"), c;
  }
  function c(h) {
    return h === 94 ? (e.enter("gfmFootnoteDefinitionMarker"), e.consume(h), e.exit("gfmFootnoteDefinitionMarker"), e.enter("gfmFootnoteDefinitionLabelString"), e.enter("chunkString").contentType = "string", u) : n(h);
  }
  function u(h) {
    if (
      // Too long.
      s > 999 || // Closing brace with nothing.
      h === 93 && !o || // Space or tab is not supported by GFM for some reason.
      // `\n` and `[` not being supported makes sense.
      h === null || h === 91 || Qe(h)
    )
      return n(h);
    if (h === 93) {
      e.exit("chunkString");
      const g = e.exit("gfmFootnoteDefinitionLabelString");
      return a = Qn(r.sliceSerialize(g)), e.enter("gfmFootnoteDefinitionLabelMarker"), e.consume(h), e.exit("gfmFootnoteDefinitionLabelMarker"), e.exit("gfmFootnoteDefinitionLabel"), f;
    }
    return Qe(h) || (o = !0), s++, e.consume(h), h === 92 ? d : u;
  }
  function d(h) {
    return h === 91 || h === 92 || h === 93 ? (e.consume(h), s++, u) : u(h);
  }
  function f(h) {
    return h === 58 ? (e.enter("definitionMarker"), e.consume(h), e.exit("definitionMarker"), i.includes(a) || i.push(a), je(e, p, "gfmFootnoteDefinitionWhitespace")) : n(h);
  }
  function p(h) {
    return t(h);
  }
}
function IM(e, t, n) {
  return e.check(Ks, t, e.attempt(_M, t, n));
}
function SM(e) {
  e.exit("gfmFootnoteDefinition");
}
function AM(e, t, n) {
  const r = this;
  return je(e, i, "gfmFootnoteDefinitionIndent", 5);
  function i(a) {
    const s = r.events[r.events.length - 1];
    return s && s[1].type === "gfmFootnoteDefinitionIndent" && s[2].sliceSerialize(s[1], !0).length === 4 ? t(a) : n(a);
  }
}
function kM(e) {
  let n = (e || {}).singleTilde;
  const r = {
    name: "strikethrough",
    tokenize: a,
    resolveAll: i
  };
  return n == null && (n = !0), {
    text: {
      126: r
    },
    insideSpan: {
      null: [r]
    },
    attentionMarkers: {
      null: [126]
    }
  };
  function i(s, o) {
    let l = -1;
    for (; ++l < s.length; )
      if (s[l][0] === "enter" && s[l][1].type === "strikethroughSequenceTemporary" && s[l][1]._close) {
        let c = l;
        for (; c--; )
          if (s[c][0] === "exit" && s[c][1].type === "strikethroughSequenceTemporary" && s[c][1]._open && // If the sizes are the same:
          s[l][1].end.offset - s[l][1].start.offset === s[c][1].end.offset - s[c][1].start.offset) {
            s[l][1].type = "strikethroughSequence", s[c][1].type = "strikethroughSequence";
            const u = {
              type: "strikethrough",
              start: Object.assign({}, s[c][1].start),
              end: Object.assign({}, s[l][1].end)
            }, d = {
              type: "strikethroughText",
              start: Object.assign({}, s[c][1].end),
              end: Object.assign({}, s[l][1].start)
            }, f = [["enter", u, o], ["enter", s[c][1], o], ["exit", s[c][1], o], ["enter", d, o]], p = o.parser.constructs.insideSpan.null;
            p && Nn(f, f.length, 0, ec(p, s.slice(c + 1, l), o)), Nn(f, f.length, 0, [["exit", d, o], ["enter", s[l][1], o], ["exit", s[l][1], o], ["exit", u, o]]), Nn(s, c - 1, l - c + 3, f), l = c + f.length - 2;
            break;
          }
      }
    for (l = -1; ++l < s.length; )
      s[l][1].type === "strikethroughSequenceTemporary" && (s[l][1].type = "data");
    return s;
  }
  function a(s, o, l) {
    const c = this.previous, u = this.events;
    let d = 0;
    return f;
    function f(h) {
      return c === 126 && u[u.length - 1][1].type !== "characterEscape" ? l(h) : (s.enter("strikethroughSequenceTemporary"), p(h));
    }
    function p(h) {
      const g = xa(c);
      if (h === 126)
        return d > 1 ? l(h) : (s.consume(h), d++, p);
      if (d < 2 && !n) return l(h);
      const m = s.exit("strikethroughSequenceTemporary"), b = xa(h);
      return m._open = !b || b === 2 && !!g, m._close = !g || g === 2 && !!b, o(h);
    }
  }
}
class TM {
  /**
   * Create a new edit map.
   */
  constructor() {
    this.map = [];
  }
  /**
   * Create an edit: a remove and/or add at a certain place.
   *
   * @param {number} index
   * @param {number} remove
   * @param {Array<Event>} add
   * @returns {undefined}
   */
  add(t, n, r) {
    RM(this, t, n, r);
  }
  // To do: add this when moving to `micromark`.
  // /**
  //  * Create an edit: but insert `add` before existing additions.
  //  *
  //  * @param {number} index
  //  * @param {number} remove
  //  * @param {Array<Event>} add
  //  * @returns {undefined}
  //  */
  // addBefore(index, remove, add) {
  //   addImplementation(this, index, remove, add, true)
  // }
  /**
   * Done, change the events.
   *
   * @param {Array<Event>} events
   * @returns {undefined}
   */
  consume(t) {
    if (this.map.sort(function(a, s) {
      return a[0] - s[0];
    }), this.map.length === 0)
      return;
    let n = this.map.length;
    const r = [];
    for (; n > 0; )
      n -= 1, r.push(t.slice(this.map[n][0] + this.map[n][1]), this.map[n][2]), t.length = this.map[n][0];
    r.push(t.slice()), t.length = 0;
    let i = r.pop();
    for (; i; ) {
      for (const a of i)
        t.push(a);
      i = r.pop();
    }
    this.map.length = 0;
  }
}
function RM(e, t, n, r) {
  let i = 0;
  if (!(n === 0 && r.length === 0)) {
    for (; i < e.map.length; ) {
      if (e.map[i][0] === t) {
        e.map[i][1] += n, e.map[i][2].push(...r);
        return;
      }
      i += 1;
    }
    e.map.push([t, n, r]);
  }
}
function NM(e, t) {
  let n = !1;
  const r = [];
  for (; t < e.length; ) {
    const i = e[t];
    if (n) {
      if (i[0] === "enter")
        i[1].type === "tableContent" && r.push(e[t + 1][1].type === "tableDelimiterMarker" ? "left" : "none");
      else if (i[1].type === "tableContent") {
        if (e[t - 1][1].type === "tableDelimiterMarker") {
          const a = r.length - 1;
          r[a] = r[a] === "left" ? "center" : "right";
        }
      } else if (i[1].type === "tableDelimiterRow")
        break;
    } else i[0] === "enter" && i[1].type === "tableDelimiterRow" && (n = !0);
    t += 1;
  }
  return r;
}
function OM() {
  return {
    flow: {
      null: {
        name: "table",
        tokenize: MM,
        resolveAll: PM
      }
    }
  };
}
function MM(e, t, n) {
  const r = this;
  let i = 0, a = 0, s;
  return o;
  function o(k) {
    let W = r.events.length - 1;
    for (; W > -1; ) {
      const z = r.events[W][1].type;
      if (z === "lineEnding" || // Note: markdown-rs uses `whitespace` instead of `linePrefix`
      z === "linePrefix") W--;
      else break;
    }
    const M = W > -1 ? r.events[W][1].type : null, L = M === "tableHead" || M === "tableRow" ? x : l;
    return L === x && r.parser.lazy[r.now().line] ? n(k) : L(k);
  }
  function l(k) {
    return e.enter("tableHead"), e.enter("tableRow"), c(k);
  }
  function c(k) {
    return k === 124 || (s = !0, a += 1), u(k);
  }
  function u(k) {
    return k === null ? n(k) : _e(k) ? a > 1 ? (a = 0, r.interrupt = !0, e.exit("tableRow"), e.enter("lineEnding"), e.consume(k), e.exit("lineEnding"), p) : n(k) : Le(k) ? je(e, u, "whitespace")(k) : (a += 1, s && (s = !1, i += 1), k === 124 ? (e.enter("tableCellDivider"), e.consume(k), e.exit("tableCellDivider"), s = !0, u) : (e.enter("data"), d(k)));
  }
  function d(k) {
    return k === null || k === 124 || Qe(k) ? (e.exit("data"), u(k)) : (e.consume(k), k === 92 ? f : d);
  }
  function f(k) {
    return k === 92 || k === 124 ? (e.consume(k), d) : d(k);
  }
  function p(k) {
    return r.interrupt = !1, r.parser.lazy[r.now().line] ? n(k) : (e.enter("tableDelimiterRow"), s = !1, Le(k) ? je(e, h, "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(k) : h(k));
  }
  function h(k) {
    return k === 45 || k === 58 ? m(k) : k === 124 ? (s = !0, e.enter("tableCellDivider"), e.consume(k), e.exit("tableCellDivider"), g) : _(k);
  }
  function g(k) {
    return Le(k) ? je(e, m, "whitespace")(k) : m(k);
  }
  function m(k) {
    return k === 58 ? (a += 1, s = !0, e.enter("tableDelimiterMarker"), e.consume(k), e.exit("tableDelimiterMarker"), b) : k === 45 ? (a += 1, b(k)) : k === null || _e(k) ? E(k) : _(k);
  }
  function b(k) {
    return k === 45 ? (e.enter("tableDelimiterFiller"), y(k)) : _(k);
  }
  function y(k) {
    return k === 45 ? (e.consume(k), y) : k === 58 ? (s = !0, e.exit("tableDelimiterFiller"), e.enter("tableDelimiterMarker"), e.consume(k), e.exit("tableDelimiterMarker"), v) : (e.exit("tableDelimiterFiller"), v(k));
  }
  function v(k) {
    return Le(k) ? je(e, E, "whitespace")(k) : E(k);
  }
  function E(k) {
    return k === 124 ? h(k) : k === null || _e(k) ? !s || i !== a ? _(k) : (e.exit("tableDelimiterRow"), e.exit("tableHead"), t(k)) : _(k);
  }
  function _(k) {
    return n(k);
  }
  function x(k) {
    return e.enter("tableRow"), I(k);
  }
  function I(k) {
    return k === 124 ? (e.enter("tableCellDivider"), e.consume(k), e.exit("tableCellDivider"), I) : k === null || _e(k) ? (e.exit("tableRow"), t(k)) : Le(k) ? je(e, I, "whitespace")(k) : (e.enter("data"), T(k));
  }
  function T(k) {
    return k === null || k === 124 || Qe(k) ? (e.exit("data"), I(k)) : (e.consume(k), k === 92 ? O : T);
  }
  function O(k) {
    return k === 92 || k === 124 ? (e.consume(k), T) : T(k);
  }
}
function PM(e, t) {
  let n = -1, r = !0, i = 0, a = [0, 0, 0, 0], s = [0, 0, 0, 0], o = !1, l = 0, c, u, d;
  const f = new TM();
  for (; ++n < e.length; ) {
    const p = e[n], h = p[1];
    p[0] === "enter" ? h.type === "tableHead" ? (o = !1, l !== 0 && (ng(f, t, l, c, u), u = void 0, l = 0), c = {
      type: "table",
      start: Object.assign({}, h.start),
      // Note: correct end is set later.
      end: Object.assign({}, h.end)
    }, f.add(n, 0, [["enter", c, t]])) : h.type === "tableRow" || h.type === "tableDelimiterRow" ? (r = !0, d = void 0, a = [0, 0, 0, 0], s = [0, n + 1, 0, 0], o && (o = !1, u = {
      type: "tableBody",
      start: Object.assign({}, h.start),
      // Note: correct end is set later.
      end: Object.assign({}, h.end)
    }, f.add(n, 0, [["enter", u, t]])), i = h.type === "tableDelimiterRow" ? 2 : u ? 3 : 1) : i && (h.type === "data" || h.type === "tableDelimiterMarker" || h.type === "tableDelimiterFiller") ? (r = !1, s[2] === 0 && (a[1] !== 0 && (s[0] = s[1], d = vo(f, t, a, i, void 0, d), a = [0, 0, 0, 0]), s[2] = n)) : h.type === "tableCellDivider" && (r ? r = !1 : (a[1] !== 0 && (s[0] = s[1], d = vo(f, t, a, i, void 0, d)), a = s, s = [a[1], n, 0, 0])) : h.type === "tableHead" ? (o = !0, l = n) : h.type === "tableRow" || h.type === "tableDelimiterRow" ? (l = n, a[1] !== 0 ? (s[0] = s[1], d = vo(f, t, a, i, n, d)) : s[1] !== 0 && (d = vo(f, t, s, i, n, d)), i = 0) : i && (h.type === "data" || h.type === "tableDelimiterMarker" || h.type === "tableDelimiterFiller") && (s[3] = n);
  }
  for (l !== 0 && ng(f, t, l, c, u), f.consume(t.events), n = -1; ++n < t.events.length; ) {
    const p = t.events[n];
    p[0] === "enter" && p[1].type === "table" && (p[1]._align = NM(t.events, n));
  }
  return e;
}
function vo(e, t, n, r, i, a) {
  const s = r === 1 ? "tableHeader" : r === 2 ? "tableDelimiter" : "tableData", o = "tableContent";
  n[0] !== 0 && (a.end = Object.assign({}, Ji(t.events, n[0])), e.add(n[0], 0, [["exit", a, t]]));
  const l = Ji(t.events, n[1]);
  if (a = {
    type: s,
    start: Object.assign({}, l),
    // Note: correct end is set later.
    end: Object.assign({}, l)
  }, e.add(n[1], 0, [["enter", a, t]]), n[2] !== 0) {
    const c = Ji(t.events, n[2]), u = Ji(t.events, n[3]), d = {
      type: o,
      start: Object.assign({}, c),
      end: Object.assign({}, u)
    };
    if (e.add(n[2], 0, [["enter", d, t]]), r !== 2) {
      const f = t.events[n[2]], p = t.events[n[3]];
      if (f[1].end = Object.assign({}, p[1].end), f[1].type = "chunkText", f[1].contentType = "text", n[3] > n[2] + 1) {
        const h = n[2] + 1, g = n[3] - n[2] - 1;
        e.add(h, g, []);
      }
    }
    e.add(n[3] + 1, 0, [["exit", d, t]]);
  }
  return i !== void 0 && (a.end = Object.assign({}, Ji(t.events, i)), e.add(i, 0, [["exit", a, t]]), a = void 0), a;
}
function ng(e, t, n, r, i) {
  const a = [], s = Ji(t.events, n);
  i && (i.end = Object.assign({}, s), a.push(["exit", i, t])), r.end = Object.assign({}, s), a.push(["exit", r, t]), e.add(n + 1, 0, a);
}
function Ji(e, t) {
  const n = e[t], r = n[0] === "enter" ? "start" : "end";
  return n[1][r];
}
const DM = {
  name: "tasklistCheck",
  tokenize: FM
};
function LM() {
  return {
    text: {
      91: DM
    }
  };
}
function FM(e, t, n) {
  const r = this;
  return i;
  function i(l) {
    return (
      // Exit if theres stuff before.
      r.previous !== null || // Exit if not in the first content that is the first child of a list
      // item.
      !r._gfmTasklistFirstContentOfListItem ? n(l) : (e.enter("taskListCheck"), e.enter("taskListCheckMarker"), e.consume(l), e.exit("taskListCheckMarker"), a)
    );
  }
  function a(l) {
    return Qe(l) ? (e.enter("taskListCheckValueUnchecked"), e.consume(l), e.exit("taskListCheckValueUnchecked"), s) : l === 88 || l === 120 ? (e.enter("taskListCheckValueChecked"), e.consume(l), e.exit("taskListCheckValueChecked"), s) : n(l);
  }
  function s(l) {
    return l === 93 ? (e.enter("taskListCheckMarker"), e.consume(l), e.exit("taskListCheckMarker"), e.exit("taskListCheck"), o) : n(l);
  }
  function o(l) {
    return _e(l) ? t(l) : Le(l) ? e.check({
      tokenize: BM
    }, t, n)(l) : n(l);
  }
}
function BM(e, t, n) {
  return je(e, r, "whitespace");
  function r(i) {
    return i === null ? n(i) : t(i);
  }
}
function zM(e) {
  return sy([
    uM(),
    vM(),
    kM(e),
    OM(),
    LM()
  ]);
}
const VM = {};
function GM(e) {
  const t = (
    /** @type {Processor<Root>} */
    this
  ), n = e || VM, r = t.data(), i = r.micromarkExtensions || (r.micromarkExtensions = []), a = r.fromMarkdownExtensions || (r.fromMarkdownExtensions = []), s = r.toMarkdownExtensions || (r.toMarkdownExtensions = []);
  i.push(zM(n)), a.push(sM()), s.push(oM(n));
}
const rg = (
  // Note: overloads like this are needed to support optional generics.
  /**
   * @type {(
   *   (<Kind extends UnistParent, Check extends Test>(parent: Kind, index: Child<Kind> | number, test: Check) => Matches<Child<Kind>, Check> | undefined) &
   *   (<Kind extends UnistParent>(parent: Kind, index: Child<Kind> | number, test?: null | undefined) => Child<Kind> | undefined)
   * )}
   */
  /**
   * @param {UnistParent} parent
   * @param {UnistNode | number} index
   * @param {Test} [test]
   * @returns {UnistNode | undefined}
   */
  function(e, t, n) {
    const r = Qs(n);
    if (!e || !e.type || !e.children)
      throw new Error("Expected parent node");
    if (typeof t == "number") {
      if (t < 0 || t === Number.POSITIVE_INFINITY)
        throw new Error("Expected positive finite number as index");
    } else if (t = e.children.indexOf(t), t < 0)
      throw new Error("Expected child node or index");
    for (; ++t < e.children.length; )
      if (r(e.children[t], t, e))
        return e.children[t];
  }
), Bi = (
  // Note: overloads in JSDoc cant yet use different `@template`s.
  /**
   * @type {(
   *   (<Condition extends TestFunction>(test: Condition) => (element: unknown, index?: number | null | undefined, parent?: Parents | null | undefined, context?: unknown) => element is Element & Predicate<Condition, Element>) &
   *   (<Condition extends string>(test: Condition) => (element: unknown, index?: number | null | undefined, parent?: Parents | null | undefined, context?: unknown) => element is Element & {tagName: Condition}) &
   *   ((test?: null | undefined) => (element?: unknown, index?: number | null | undefined, parent?: Parents | null | undefined, context?: unknown) => element is Element) &
   *   ((test?: Test) => Check)
   * )}
   */
  /**
   * @param {Test | null | undefined} [test]
   * @returns {Check}
   */
  function(e) {
    if (e == null)
      return HM;
    if (typeof e == "string")
      return UM(e);
    if (typeof e == "object")
      return jM(e);
    if (typeof e == "function")
      return xf(e);
    throw new Error("Expected function, string, or array as `test`");
  }
);
function jM(e) {
  const t = [];
  let n = -1;
  for (; ++n < e.length; )
    t[n] = Bi(e[n]);
  return xf(r);
  function r(...i) {
    let a = -1;
    for (; ++a < t.length; )
      if (t[a].apply(this, i)) return !0;
    return !1;
  }
}
function UM(e) {
  return xf(t);
  function t(n) {
    return n.tagName === e;
  }
}
function xf(e) {
  return t;
  function t(n, r, i) {
    return !!(WM(n) && e.call(
      this,
      n,
      typeof r == "number" ? r : void 0,
      i || void 0
    ));
  }
}
function HM(e) {
  return !!(e && typeof e == "object" && "type" in e && e.type === "element" && "tagName" in e && typeof e.tagName == "string");
}
function WM(e) {
  return e !== null && typeof e == "object" && "type" in e && "tagName" in e;
}
const ig = /\n/g, ag = /[\t ]+/g, ed = Bi("br"), sg = Bi(QM), ZM = Bi("p"), og = Bi("tr"), $M = Bi([
  // List from: <https://html.spec.whatwg.org/multipage/rendering.html#hidden-elements>
  "datalist",
  "head",
  "noembed",
  "noframes",
  "noscript",
  // Act as if we support scripting.
  "rp",
  "script",
  "style",
  "template",
  "title",
  // Hidden attribute.
  KM,
  // From: <https://html.spec.whatwg.org/multipage/rendering.html#flow-content-3>
  eP
]), Yy = Bi([
  "address",
  // Flow content
  "article",
  // Sections and headings
  "aside",
  // Sections and headings
  "blockquote",
  // Flow content
  "body",
  // Page
  "caption",
  // `table-caption`
  "center",
  // Flow content (legacy)
  "dd",
  // Lists
  "dialog",
  // Flow content
  "dir",
  // Lists (legacy)
  "dl",
  // Lists
  "dt",
  // Lists
  "div",
  // Flow content
  "figure",
  // Flow content
  "figcaption",
  // Flow content
  "footer",
  // Flow content
  "form,",
  // Flow content
  "h1",
  // Sections and headings
  "h2",
  // Sections and headings
  "h3",
  // Sections and headings
  "h4",
  // Sections and headings
  "h5",
  // Sections and headings
  "h6",
  // Sections and headings
  "header",
  // Flow content
  "hgroup",
  // Sections and headings
  "hr",
  // Flow content
  "html",
  // Page
  "legend",
  // Flow content
  "li",
  // Lists (as `display: list-item`)
  "listing",
  // Flow content (legacy)
  "main",
  // Flow content
  "menu",
  // Lists
  "nav",
  // Sections and headings
  "ol",
  // Lists
  "p",
  // Flow content
  "plaintext",
  // Flow content (legacy)
  "pre",
  // Flow content
  "section",
  // Sections and headings
  "ul",
  // Lists
  "xmp"
  // Flow content (legacy)
]);
function XM(e, t) {
  const n = t || {}, r = "children" in e ? e.children : [], i = Yy(e), a = Ky(e, {
    whitespace: n.whitespace || "normal"
  }), s = [];
  (e.type === "text" || e.type === "comment") && s.push(
    ...qy(e, {
      breakBefore: !0,
      breakAfter: !0
    })
  );
  let o = -1;
  for (; ++o < r.length; )
    s.push(
      ...Jy(
        r[o],
        // @ts-expect-error: `tree` is a parent if were here.
        e,
        {
          whitespace: a,
          breakBefore: o ? void 0 : i,
          breakAfter: o < r.length - 1 ? ed(r[o + 1]) : i
        }
      )
    );
  const l = [];
  let c;
  for (o = -1; ++o < s.length; ) {
    const u = s[o];
    typeof u == "number" ? c !== void 0 && u > c && (c = u) : u && (c !== void 0 && c > -1 && l.push(`
`.repeat(c) || " "), c = -1, l.push(u));
  }
  return l.join("");
}
function Jy(e, t, n) {
  return e.type === "element" ? YM(e, t, n) : e.type === "text" ? n.whitespace === "normal" ? qy(e, n) : JM(e) : [];
}
function YM(e, t, n) {
  const r = Ky(e, n), i = e.children || [];
  let a = -1, s = [];
  if ($M(e))
    return s;
  let o, l;
  for (ed(e) || og(e) && // @ts-expect-error: something up with types of parents.
  rg(t, e, og) ? l = `
` : ZM(e) ? (o = 2, l = 2) : Yy(e) && (o = 1, l = 1); ++a < i.length; )
    s = s.concat(
      Jy(i[a], e, {
        whitespace: r,
        breakBefore: a ? void 0 : o,
        breakAfter: a < i.length - 1 ? ed(i[a + 1]) : l
      })
    );
  return sg(e) && // @ts-expect-error: something up with types of parents.
  rg(t, e, sg) && s.push("	"), o && s.unshift(o), l && s.push(l), s;
}
function qy(e, t) {
  const n = String(e.value), r = [], i = [];
  let a = 0;
  for (; a <= n.length; ) {
    ig.lastIndex = a;
    const l = ig.exec(n), c = l && "index" in l ? l.index : n.length;
    r.push(
      // Any sequence of collapsible spaces and tabs immediately preceding or
      // following a segment break is removed.
      qM(
        // [] ignoring bidi formatting characters (characters with the
        // Bidi_Control property [UAX9]: ALM, LTR, RTL, LRE-RLO, LRI-PDI) as if
        // they were not there.
        n.slice(a, c).replace(/[\u061C\u200E\u200F\u202A-\u202E\u2066-\u2069]/g, ""),
        a === 0 ? t.breakBefore : !0,
        c === n.length ? t.breakAfter : !0
      )
    ), a = c + 1;
  }
  let s = -1, o;
  for (; ++s < r.length; )
    r[s].charCodeAt(r[s].length - 1) === 8203 || s < r.length - 1 && r[s + 1].charCodeAt(0) === 8203 ? (i.push(r[s]), o = void 0) : r[s] ? (typeof o == "number" && i.push(o), i.push(r[s]), o = 0) : (s === 0 || s === r.length - 1) && i.push(0);
  return i;
}
function JM(e) {
  return [String(e.value)];
}
function qM(e, t, n) {
  const r = [];
  let i = 0, a;
  for (; i < e.length; ) {
    ag.lastIndex = i;
    const s = ag.exec(e);
    a = s ? s.index : e.length, !i && !a && s && !t && r.push(""), i !== a && r.push(e.slice(i, a)), i = s ? a + s[0].length : a;
  }
  return i !== a && !n && r.push(""), r.join(" ");
}
function Ky(e, t) {
  if (e.type === "element") {
    const n = e.properties || {};
    switch (e.tagName) {
      case "listing":
      case "plaintext":
      case "xmp":
        return "pre";
      case "nobr":
        return "nowrap";
      case "pre":
        return n.wrap ? "pre-wrap" : "pre";
      case "td":
      case "th":
        return n.noWrap ? "nowrap" : t.whitespace;
      case "textarea":
        return "pre-wrap";
    }
  }
  return t.whitespace;
}
function KM(e) {
  return !!(e.properties || {}).hidden;
}
function QM(e) {
  return e.tagName === "td" || e.tagName === "th";
}
function eP(e) {
  return e.tagName === "dialog" && !(e.properties || {}).open;
}
function tP(e) {
  const t = e.regex, n = e.COMMENT("//", "$", { contains: [{ begin: /\\\n/ }] }), r = "decltype\\(auto\\)", i = "[a-zA-Z_]\\w*::", s = "(?!struct)(" + r + "|" + t.optional(i) + "[a-zA-Z_]\\w*" + t.optional("<[^<>]+>") + ")", o = {
    className: "type",
    begin: "\\b[a-z\\d_]*_t\\b"
  }, c = {
    className: "string",
    variants: [
      {
        begin: '(u8?|U|L)?"',
        end: '"',
        illegal: "\\n",
        contains: [e.BACKSLASH_ESCAPE]
      },
      {
        begin: "(u8?|U|L)?'(" + "\\\\(x[0-9A-Fa-f]{2}|u[0-9A-Fa-f]{4,8}|[0-7]{3}|\\S)" + "|.)",
        end: "'",
        illegal: "."
      },
      e.END_SAME_AS_BEGIN({
        begin: /(?:u8?|U|L)?R"([^()\\ ]{0,16})\(/,
        end: /\)([^()\\ ]{0,16})"/
      })
    ]
  }, u = {
    className: "number",
    variants: [
      // Floating-point literal.
      {
        begin: "[+-]?(?:(?:[0-9](?:'?[0-9])*\\.(?:[0-9](?:'?[0-9])*)?|\\.[0-9](?:'?[0-9])*)(?:[Ee][+-]?[0-9](?:'?[0-9])*)?|[0-9](?:'?[0-9])*[Ee][+-]?[0-9](?:'?[0-9])*|0[Xx](?:[0-9A-Fa-f](?:'?[0-9A-Fa-f])*(?:\\.(?:[0-9A-Fa-f](?:'?[0-9A-Fa-f])*)?)?|\\.[0-9A-Fa-f](?:'?[0-9A-Fa-f])*)[Pp][+-]?[0-9](?:'?[0-9])*)(?:[Ff](?:16|32|64|128)?|(BF|bf)16|[Ll]|)"
      },
      // Integer literal.
      {
        begin: "[+-]?\\b(?:0[Bb][01](?:'?[01])*|0[Xx][0-9A-Fa-f](?:'?[0-9A-Fa-f])*|0(?:'?[0-7])*|[1-9](?:'?[0-9])*)(?:[Uu](?:LL?|ll?)|[Uu][Zz]?|(?:LL?|ll?)[Uu]?|[Zz][Uu]|)"
        // Note: there are user-defined literal suffixes too, but perhaps having the custom suffix not part of the
        // literal highlight actually makes it stand out more.
      }
    ],
    relevance: 0
  }, d = {
    className: "meta",
    begin: /#\s*[a-z]+\b/,
    end: /$/,
    keywords: { keyword: "if else elif endif define undef warning error line pragma _Pragma ifdef ifndef include" },
    contains: [
      {
        begin: /\\\n/,
        relevance: 0
      },
      e.inherit(c, { className: "string" }),
      {
        className: "string",
        begin: /<.*?>/
      },
      n,
      e.C_BLOCK_COMMENT_MODE
    ]
  }, f = {
    className: "title",
    begin: t.optional(i) + e.IDENT_RE,
    relevance: 0
  }, p = t.optional(i) + e.IDENT_RE + "\\s*\\(", h = [
    "alignas",
    "alignof",
    "and",
    "and_eq",
    "asm",
    "atomic_cancel",
    "atomic_commit",
    "atomic_noexcept",
    "auto",
    "bitand",
    "bitor",
    "break",
    "case",
    "catch",
    "class",
    "co_await",
    "co_return",
    "co_yield",
    "compl",
    "concept",
    "const_cast|10",
    "consteval",
    "constexpr",
    "constinit",
    "continue",
    "decltype",
    "default",
    "delete",
    "do",
    "dynamic_cast|10",
    "else",
    "enum",
    "explicit",
    "export",
    "extern",
    "false",
    "final",
    "for",
    "friend",
    "goto",
    "if",
    "import",
    "inline",
    "module",
    "mutable",
    "namespace",
    "new",
    "noexcept",
    "not",
    "not_eq",
    "nullptr",
    "operator",
    "or",
    "or_eq",
    "override",
    "private",
    "protected",
    "public",
    "reflexpr",
    "register",
    "reinterpret_cast|10",
    "requires",
    "return",
    "sizeof",
    "static_assert",
    "static_cast|10",
    "struct",
    "switch",
    "synchronized",
    "template",
    "this",
    "thread_local",
    "throw",
    "transaction_safe",
    "transaction_safe_dynamic",
    "true",
    "try",
    "typedef",
    "typeid",
    "typename",
    "union",
    "using",
    "virtual",
    "volatile",
    "while",
    "xor",
    "xor_eq"
  ], g = [
    "bool",
    "char",
    "char16_t",
    "char32_t",
    "char8_t",
    "double",
    "float",
    "int",
    "long",
    "short",
    "void",
    "wchar_t",
    "unsigned",
    "signed",
    "const",
    "static"
  ], m = [
    "any",
    "auto_ptr",
    "barrier",
    "binary_semaphore",
    "bitset",
    "complex",
    "condition_variable",
    "condition_variable_any",
    "counting_semaphore",
    "deque",
    "false_type",
    "flat_map",
    "flat_set",
    "future",
    "imaginary",
    "initializer_list",
    "istringstream",
    "jthread",
    "latch",
    "lock_guard",
    "multimap",
    "multiset",
    "mutex",
    "optional",
    "ostringstream",
    "packaged_task",
    "pair",
    "promise",
    "priority_queue",
    "queue",
    "recursive_mutex",
    "recursive_timed_mutex",
    "scoped_lock",
    "set",
    "shared_future",
    "shared_lock",
    "shared_mutex",
    "shared_timed_mutex",
    "shared_ptr",
    "stack",
    "string_view",
    "stringstream",
    "timed_mutex",
    "thread",
    "true_type",
    "tuple",
    "unique_lock",
    "unique_ptr",
    "unordered_map",
    "unordered_multimap",
    "unordered_multiset",
    "unordered_set",
    "variant",
    "vector",
    "weak_ptr",
    "wstring",
    "wstring_view"
  ], b = [
    "abort",
    "abs",
    "acos",
    "apply",
    "as_const",
    "asin",
    "atan",
    "atan2",
    "calloc",
    "ceil",
    "cerr",
    "cin",
    "clog",
    "cos",
    "cosh",
    "cout",
    "declval",
    "endl",
    "exchange",
    "exit",
    "exp",
    "fabs",
    "floor",
    "fmod",
    "forward",
    "fprintf",
    "fputs",
    "free",
    "frexp",
    "fscanf",
    "future",
    "invoke",
    "isalnum",
    "isalpha",
    "iscntrl",
    "isdigit",
    "isgraph",
    "islower",
    "isprint",
    "ispunct",
    "isspace",
    "isupper",
    "isxdigit",
    "labs",
    "launder",
    "ldexp",
    "log",
    "log10",
    "make_pair",
    "make_shared",
    "make_shared_for_overwrite",
    "make_tuple",
    "make_unique",
    "malloc",
    "memchr",
    "memcmp",
    "memcpy",
    "memset",
    "modf",
    "move",
    "pow",
    "printf",
    "putchar",
    "puts",
    "realloc",
    "scanf",
    "sin",
    "sinh",
    "snprintf",
    "sprintf",
    "sqrt",
    "sscanf",
    "std",
    "stderr",
    "stdin",
    "stdout",
    "strcat",
    "strchr",
    "strcmp",
    "strcpy",
    "strcspn",
    "strlen",
    "strncat",
    "strncmp",
    "strncpy",
    "strpbrk",
    "strrchr",
    "strspn",
    "strstr",
    "swap",
    "tan",
    "tanh",
    "terminate",
    "to_underlying",
    "tolower",
    "toupper",
    "vfprintf",
    "visit",
    "vprintf",
    "vsprintf"
  ], E = {
    type: g,
    keyword: h,
    literal: [
      "NULL",
      "false",
      "nullopt",
      "nullptr",
      "true"
    ],
    built_in: ["_Pragma"],
    _type_hints: m
  }, _ = {
    className: "function.dispatch",
    relevance: 0,
    keywords: {
      // Only for relevance, not highlighting.
      _hint: b
    },
    begin: t.concat(
      /\b/,
      /(?!decltype)/,
      /(?!if)/,
      /(?!for)/,
      /(?!switch)/,
      /(?!while)/,
      e.IDENT_RE,
      t.lookahead(/(<[^<>]+>|)\s*\(/)
    )
  }, x = [
    _,
    d,
    o,
    n,
    e.C_BLOCK_COMMENT_MODE,
    u,
    c
  ], I = {
    // This mode covers expression context where we can't expect a function
    // definition and shouldn't highlight anything that looks like one:
    // `return some()`, `else if()`, `(x*sum(1, 2))`
    variants: [
      {
        begin: /=/,
        end: /;/
      },
      {
        begin: /\(/,
        end: /\)/
      },
      {
        beginKeywords: "new throw return else",
        end: /;/
      }
    ],
    keywords: E,
    contains: x.concat([
      {
        begin: /\(/,
        end: /\)/,
        keywords: E,
        contains: x.concat(["self"]),
        relevance: 0
      }
    ]),
    relevance: 0
  }, T = {
    className: "function",
    begin: "(" + s + "[\\*&\\s]+)+" + p,
    returnBegin: !0,
    end: /[{;=]/,
    excludeEnd: !0,
    keywords: E,
    illegal: /[^\w\s\*&:<>.]/,
    contains: [
      {
        // to prevent it from being confused as the function title
        begin: r,
        keywords: E,
        relevance: 0
      },
      {
        begin: p,
        returnBegin: !0,
        contains: [f],
        relevance: 0
      },
      // needed because we do not have look-behind on the below rule
      // to prevent it from grabbing the final : in a :: pair
      {
        begin: /::/,
        relevance: 0
      },
      // initializers
      {
        begin: /:/,
        endsWithParent: !0,
        contains: [
          c,
          u
        ]
      },
      // allow for multiple declarations, e.g.:
      // extern void f(int), g(char);
      {
        relevance: 0,
        match: /,/
      },
      {
        className: "params",
        begin: /\(/,
        end: /\)/,
        keywords: E,
        relevance: 0,
        contains: [
          n,
          e.C_BLOCK_COMMENT_MODE,
          c,
          u,
          o,
          // Count matching parentheses.
          {
            begin: /\(/,
            end: /\)/,
            keywords: E,
            relevance: 0,
            contains: [
              "self",
              n,
              e.C_BLOCK_COMMENT_MODE,
              c,
              u,
              o
            ]
          }
        ]
      },
      o,
      n,
      e.C_BLOCK_COMMENT_MODE,
      d
    ]
  };
  return {
    name: "C++",
    aliases: [
      "cc",
      "c++",
      "h++",
      "hpp",
      "hh",
      "hxx",
      "cxx"
    ],
    keywords: E,
    illegal: "</",
    classNameAliases: { "function.dispatch": "built_in" },
    contains: [].concat(
      I,
      T,
      _,
      x,
      [
        d,
        {
          // containers: ie, `vector <int> rooms (9);`
          begin: "\\b(deque|list|queue|priority_queue|pair|stack|vector|map|set|bitset|multiset|multimap|unordered_map|unordered_set|unordered_multiset|unordered_multimap|array|tuple|optional|variant|function|flat_map|flat_set)\\s*<(?!<)",
          end: ">",
          keywords: E,
          contains: [
            "self",
            o
          ]
        },
        {
          begin: e.IDENT_RE + "::",
          keywords: E
        },
        {
          match: [
            // extra complexity to deal with `enum class` and `enum struct`
            /\b(?:enum(?:\s+(?:class|struct))?|class|struct|union)/,
            /\s+/,
            /\w+/
          ],
          className: {
            1: "keyword",
            3: "title.class"
          }
        }
      ]
    )
  };
}
function nP(e) {
  const t = {
    type: [
      "boolean",
      "byte",
      "word",
      "String"
    ],
    built_in: [
      "KeyboardController",
      "MouseController",
      "SoftwareSerial",
      "EthernetServer",
      "EthernetClient",
      "LiquidCrystal",
      "RobotControl",
      "GSMVoiceCall",
      "EthernetUDP",
      "EsploraTFT",
      "HttpClient",
      "RobotMotor",
      "WiFiClient",
      "GSMScanner",
      "FileSystem",
      "Scheduler",
      "GSMServer",
      "YunClient",
      "YunServer",
      "IPAddress",
      "GSMClient",
      "GSMModem",
      "Keyboard",
      "Ethernet",
      "Console",
      "GSMBand",
      "Esplora",
      "Stepper",
      "Process",
      "WiFiUDP",
      "GSM_SMS",
      "Mailbox",
      "USBHost",
      "Firmata",
      "PImage",
      "Client",
      "Server",
      "GSMPIN",
      "FileIO",
      "Bridge",
      "Serial",
      "EEPROM",
      "Stream",
      "Mouse",
      "Audio",
      "Servo",
      "File",
      "Task",
      "GPRS",
      "WiFi",
      "Wire",
      "TFT",
      "GSM",
      "SPI",
      "SD"
    ],
    _hints: [
      "setup",
      "loop",
      "runShellCommandAsynchronously",
      "analogWriteResolution",
      "retrieveCallingNumber",
      "printFirmwareVersion",
      "analogReadResolution",
      "sendDigitalPortPair",
      "noListenOnLocalhost",
      "readJoystickButton",
      "setFirmwareVersion",
      "readJoystickSwitch",
      "scrollDisplayRight",
      "getVoiceCallStatus",
      "scrollDisplayLeft",
      "writeMicroseconds",
      "delayMicroseconds",
      "beginTransmission",
      "getSignalStrength",
      "runAsynchronously",
      "getAsynchronously",
      "listenOnLocalhost",
      "getCurrentCarrier",
      "readAccelerometer",
      "messageAvailable",
      "sendDigitalPorts",
      "lineFollowConfig",
      "countryNameWrite",
      "runShellCommand",
      "readStringUntil",
      "rewindDirectory",
      "readTemperature",
      "setClockDivider",
      "readLightSensor",
      "endTransmission",
      "analogReference",
      "detachInterrupt",
      "countryNameRead",
      "attachInterrupt",
      "encryptionType",
      "readBytesUntil",
      "robotNameWrite",
      "readMicrophone",
      "robotNameRead",
      "cityNameWrite",
      "userNameWrite",
      "readJoystickY",
      "readJoystickX",
      "mouseReleased",
      "openNextFile",
      "scanNetworks",
      "noInterrupts",
      "digitalWrite",
      "beginSpeaker",
      "mousePressed",
      "isActionDone",
      "mouseDragged",
      "displayLogos",
      "noAutoscroll",
      "addParameter",
      "remoteNumber",
      "getModifiers",
      "keyboardRead",
      "userNameRead",
      "waitContinue",
      "processInput",
      "parseCommand",
      "printVersion",
      "readNetworks",
      "writeMessage",
      "blinkVersion",
      "cityNameRead",
      "readMessage",
      "setDataMode",
      "parsePacket",
      "isListening",
      "setBitOrder",
      "beginPacket",
      "isDirectory",
      "motorsWrite",
      "drawCompass",
      "digitalRead",
      "clearScreen",
      "serialEvent",
      "rightToLeft",
      "setTextSize",
      "leftToRight",
      "requestFrom",
      "keyReleased",
      "compassRead",
      "analogWrite",
      "interrupts",
      "WiFiServer",
      "disconnect",
      "playMelody",
      "parseFloat",
      "autoscroll",
      "getPINUsed",
      "setPINUsed",
      "setTimeout",
      "sendAnalog",
      "readSlider",
      "analogRead",
      "beginWrite",
      "createChar",
      "motorsStop",
      "keyPressed",
      "tempoWrite",
      "readButton",
      "subnetMask",
      "debugPrint",
      "macAddress",
      "writeGreen",
      "randomSeed",
      "attachGPRS",
      "readString",
      "sendString",
      "remotePort",
      "releaseAll",
      "mouseMoved",
      "background",
      "getXChange",
      "getYChange",
      "answerCall",
      "getResult",
      "voiceCall",
      "endPacket",
      "constrain",
      "getSocket",
      "writeJSON",
      "getButton",
      "available",
      "connected",
      "findUntil",
      "readBytes",
      "exitValue",
      "readGreen",
      "writeBlue",
      "startLoop",
      "IPAddress",
      "isPressed",
      "sendSysex",
      "pauseMode",
      "gatewayIP",
      "setCursor",
      "getOemKey",
      "tuneWrite",
      "noDisplay",
      "loadImage",
      "switchPIN",
      "onRequest",
      "onReceive",
      "changePIN",
      "playFile",
      "noBuffer",
      "parseInt",
      "overflow",
      "checkPIN",
      "knobRead",
      "beginTFT",
      "bitClear",
      "updateIR",
      "bitWrite",
      "position",
      "writeRGB",
      "highByte",
      "writeRed",
      "setSpeed",
      "readBlue",
      "noStroke",
      "remoteIP",
      "transfer",
      "shutdown",
      "hangCall",
      "beginSMS",
      "endWrite",
      "attached",
      "maintain",
      "noCursor",
      "checkReg",
      "checkPUK",
      "shiftOut",
      "isValid",
      "shiftIn",
      "pulseIn",
      "connect",
      "println",
      "localIP",
      "pinMode",
      "getIMEI",
      "display",
      "noBlink",
      "process",
      "getBand",
      "running",
      "beginSD",
      "drawBMP",
      "lowByte",
      "setBand",
      "release",
      "bitRead",
      "prepare",
      "pointTo",
      "readRed",
      "setMode",
      "noFill",
      "remove",
      "listen",
      "stroke",
      "detach",
      "attach",
      "noTone",
      "exists",
      "buffer",
      "height",
      "bitSet",
      "circle",
      "config",
      "cursor",
      "random",
      "IRread",
      "setDNS",
      "endSMS",
      "getKey",
      "micros",
      "millis",
      "begin",
      "print",
      "write",
      "ready",
      "flush",
      "width",
      "isPIN",
      "blink",
      "clear",
      "press",
      "mkdir",
      "rmdir",
      "close",
      "point",
      "yield",
      "image",
      "BSSID",
      "click",
      "delay",
      "read",
      "text",
      "move",
      "peek",
      "beep",
      "rect",
      "line",
      "open",
      "seek",
      "fill",
      "size",
      "turn",
      "stop",
      "home",
      "find",
      "step",
      "tone",
      "sqrt",
      "RSSI",
      "SSID",
      "end",
      "bit",
      "tan",
      "cos",
      "sin",
      "pow",
      "map",
      "abs",
      "max",
      "min",
      "get",
      "run",
      "put"
    ],
    literal: [
      "DIGITAL_MESSAGE",
      "FIRMATA_STRING",
      "ANALOG_MESSAGE",
      "REPORT_DIGITAL",
      "REPORT_ANALOG",
      "INPUT_PULLUP",
      "SET_PIN_MODE",
      "INTERNAL2V56",
      "SYSTEM_RESET",
      "LED_BUILTIN",
      "INTERNAL1V1",
      "SYSEX_START",
      "INTERNAL",
      "EXTERNAL",
      "DEFAULT",
      "OUTPUT",
      "INPUT",
      "HIGH",
      "LOW"
    ]
  }, n = tP(e), r = (
    /** @type {Record<string,any>} */
    n.keywords
  );
  return r.type = [
    ...r.type,
    ...t.type
  ], r.literal = [
    ...r.literal,
    ...t.literal
  ], r.built_in = [
    ...r.built_in,
    ...t.built_in
  ], r._hints = t._hints, n.name = "Arduino", n.aliases = ["ino"], n.supersetOf = "cpp", n;
}
function rP(e) {
  const t = e.regex, n = {}, r = {
    begin: /\$\{/,
    end: /\}/,
    contains: [
      "self",
      {
        begin: /:-/,
        contains: [n]
      }
      // default values
    ]
  };
  Object.assign(n, {
    className: "variable",
    variants: [
      { begin: t.concat(
        /\$[\w\d#@][\w\d_]*/,
        // negative look-ahead tries to avoid matching patterns that are not
        // Perl at all like $ident$, @ident@, etc.
        "(?![\\w\\d])(?![$])"
      ) },
      r
    ]
  });
  const i = {
    className: "subst",
    begin: /\$\(/,
    end: /\)/,
    contains: [e.BACKSLASH_ESCAPE]
  }, a = e.inherit(
    e.COMMENT(),
    {
      match: [
        /(^|\s)/,
        /#.*$/
      ],
      scope: {
        2: "comment"
      }
    }
  ), s = {
    begin: /<<-?\s*(?=\w+)/,
    starts: { contains: [
      e.END_SAME_AS_BEGIN({
        begin: /(\w+)/,
        end: /(\w+)/,
        className: "string"
      })
    ] }
  }, o = {
    className: "string",
    begin: /"/,
    end: /"/,
    contains: [
      e.BACKSLASH_ESCAPE,
      n,
      i
    ]
  };
  i.contains.push(o);
  const l = {
    match: /\\"/
  }, c = {
    className: "string",
    begin: /'/,
    end: /'/
  }, u = {
    match: /\\'/
  }, d = {
    begin: /\$?\(\(/,
    end: /\)\)/,
    contains: [
      {
        begin: /\d+#[0-9a-f]+/,
        className: "number"
      },
      e.NUMBER_MODE,
      n
    ]
  }, f = [
    "fish",
    "bash",
    "zsh",
    "sh",
    "csh",
    "ksh",
    "tcsh",
    "dash",
    "scsh"
  ], p = e.SHEBANG({
    binary: `(${f.join("|")})`,
    relevance: 10
  }), h = {
    className: "function",
    begin: /\w[\w\d_]*\s*\(\s*\)\s*\{/,
    returnBegin: !0,
    contains: [e.inherit(e.TITLE_MODE, { begin: /\w[\w\d_]*/ })],
    relevance: 0
  }, g = [
    "if",
    "then",
    "else",
    "elif",
    "fi",
    "time",
    "for",
    "while",
    "until",
    "in",
    "do",
    "done",
    "case",
    "esac",
    "coproc",
    "function",
    "select"
  ], m = [
    "true",
    "false"
  ], b = { match: /(\/[a-z._-]+)+/ }, y = [
    "break",
    "cd",
    "continue",
    "eval",
    "exec",
    "exit",
    "export",
    "getopts",
    "hash",
    "pwd",
    "readonly",
    "return",
    "shift",
    "test",
    "times",
    "trap",
    "umask",
    "unset"
  ], v = [
    "alias",
    "bind",
    "builtin",
    "caller",
    "command",
    "declare",
    "echo",
    "enable",
    "help",
    "let",
    "local",
    "logout",
    "mapfile",
    "printf",
    "read",
    "readarray",
    "source",
    "sudo",
    "type",
    "typeset",
    "ulimit",
    "unalias"
  ], E = [
    "autoload",
    "bg",
    "bindkey",
    "bye",
    "cap",
    "chdir",
    "clone",
    "comparguments",
    "compcall",
    "compctl",
    "compdescribe",
    "compfiles",
    "compgroups",
    "compquote",
    "comptags",
    "comptry",
    "compvalues",
    "dirs",
    "disable",
    "disown",
    "echotc",
    "echoti",
    "emulate",
    "fc",
    "fg",
    "float",
    "functions",
    "getcap",
    "getln",
    "history",
    "integer",
    "jobs",
    "kill",
    "limit",
    "log",
    "noglob",
    "popd",
    "print",
    "pushd",
    "pushln",
    "rehash",
    "sched",
    "setcap",
    "setopt",
    "stat",
    "suspend",
    "ttyctl",
    "unfunction",
    "unhash",
    "unlimit",
    "unsetopt",
    "vared",
    "wait",
    "whence",
    "where",
    "which",
    "zcompile",
    "zformat",
    "zftp",
    "zle",
    "zmodload",
    "zparseopts",
    "zprof",
    "zpty",
    "zregexparse",
    "zsocket",
    "zstyle",
    "ztcp"
  ], _ = [
    "chcon",
    "chgrp",
    "chown",
    "chmod",
    "cp",
    "dd",
    "df",
    "dir",
    "dircolors",
    "ln",
    "ls",
    "mkdir",
    "mkfifo",
    "mknod",
    "mktemp",
    "mv",
    "realpath",
    "rm",
    "rmdir",
    "shred",
    "sync",
    "touch",
    "truncate",
    "vdir",
    "b2sum",
    "base32",
    "base64",
    "cat",
    "cksum",
    "comm",
    "csplit",
    "cut",
    "expand",
    "fmt",
    "fold",
    "head",
    "join",
    "md5sum",
    "nl",
    "numfmt",
    "od",
    "paste",
    "ptx",
    "pr",
    "sha1sum",
    "sha224sum",
    "sha256sum",
    "sha384sum",
    "sha512sum",
    "shuf",
    "sort",
    "split",
    "sum",
    "tac",
    "tail",
    "tr",
    "tsort",
    "unexpand",
    "uniq",
    "wc",
    "arch",
    "basename",
    "chroot",
    "date",
    "dirname",
    "du",
    "echo",
    "env",
    "expr",
    "factor",
    // "false", // keyword literal already
    "groups",
    "hostid",
    "id",
    "link",
    "logname",
    "nice",
    "nohup",
    "nproc",
    "pathchk",
    "pinky",
    "printenv",
    "printf",
    "pwd",
    "readlink",
    "runcon",
    "seq",
    "sleep",
    "stat",
    "stdbuf",
    "stty",
    "tee",
    "test",
    "timeout",
    // "true", // keyword literal already
    "tty",
    "uname",
    "unlink",
    "uptime",
    "users",
    "who",
    "whoami",
    "yes"
  ];
  return {
    name: "Bash",
    aliases: [
      "sh",
      "zsh"
    ],
    keywords: {
      $pattern: /\b[a-z][a-z0-9._-]+\b/,
      keyword: g,
      literal: m,
      built_in: [
        ...y,
        ...v,
        // Shell modifiers
        "set",
        "shopt",
        ...E,
        ..._
      ]
    },
    contains: [
      p,
      // to catch known shells and boost relevancy
      e.SHEBANG(),
      // to catch unknown shells but still highlight the shebang
      h,
      d,
      a,
      s,
      b,
      o,
      l,
      c,
      u,
      n
    ]
  };
}
function iP(e) {
  const t = e.regex, n = e.COMMENT("//", "$", { contains: [{ begin: /\\\n/ }] }), r = "decltype\\(auto\\)", i = "[a-zA-Z_]\\w*::", s = "(" + r + "|" + t.optional(i) + "[a-zA-Z_]\\w*" + t.optional("<[^<>]+>") + ")", o = {
    className: "type",
    variants: [
      { begin: "\\b[a-z\\d_]*_t\\b" },
      { match: /\batomic_[a-z]{3,6}\b/ }
    ]
  }, c = {
    className: "string",
    variants: [
      {
        begin: '(u8?|U|L)?"',
        end: '"',
        illegal: "\\n",
        contains: [e.BACKSLASH_ESCAPE]
      },
      {
        begin: "(u8?|U|L)?'(" + "\\\\(x[0-9A-Fa-f]{2}|u[0-9A-Fa-f]{4,8}|[0-7]{3}|\\S)" + "|.)",
        end: "'",
        illegal: "."
      },
      e.END_SAME_AS_BEGIN({
        begin: /(?:u8?|U|L)?R"([^()\\ ]{0,16})\(/,
        end: /\)([^()\\ ]{0,16})"/
      })
    ]
  }, u = {
    className: "number",
    variants: [
      { match: /\b(0b[01']+)/ },
      { match: /(-?)\b([\d']+(\.[\d']*)?|\.[\d']+)((ll|LL|l|L)(u|U)?|(u|U)(ll|LL|l|L)?|f|F|b|B)/ },
      { match: /(-?)\b(0[xX][a-fA-F0-9]+(?:'[a-fA-F0-9]+)*(?:\.[a-fA-F0-9]*(?:'[a-fA-F0-9]*)*)?(?:[pP][-+]?[0-9]+)?(l|L)?(u|U)?)/ },
      { match: /(-?)\b\d+(?:'\d+)*(?:\.\d*(?:'\d*)*)?(?:[eE][-+]?\d+)?/ }
    ],
    relevance: 0
  }, d = {
    className: "meta",
    begin: /#\s*[a-z]+\b/,
    end: /$/,
    keywords: { keyword: "if else elif endif define undef warning error line pragma _Pragma ifdef ifndef elifdef elifndef include" },
    contains: [
      {
        begin: /\\\n/,
        relevance: 0
      },
      e.inherit(c, { className: "string" }),
      {
        className: "string",
        begin: /<.*?>/
      },
      n,
      e.C_BLOCK_COMMENT_MODE
    ]
  }, f = {
    className: "title",
    begin: t.optional(i) + e.IDENT_RE,
    relevance: 0
  }, p = t.optional(i) + e.IDENT_RE + "\\s*\\(", m = {
    keyword: [
      "asm",
      "auto",
      "break",
      "case",
      "continue",
      "default",
      "do",
      "else",
      "enum",
      "extern",
      "for",
      "fortran",
      "goto",
      "if",
      "inline",
      "register",
      "restrict",
      "return",
      "sizeof",
      "typeof",
      "typeof_unqual",
      "struct",
      "switch",
      "typedef",
      "union",
      "volatile",
      "while",
      "_Alignas",
      "_Alignof",
      "_Atomic",
      "_Generic",
      "_Noreturn",
      "_Static_assert",
      "_Thread_local",
      // aliases
      "alignas",
      "alignof",
      "noreturn",
      "static_assert",
      "thread_local",
      // not a C keyword but is, for all intents and purposes, treated exactly like one.
      "_Pragma"
    ],
    type: [
      "float",
      "double",
      "signed",
      "unsigned",
      "int",
      "short",
      "long",
      "char",
      "void",
      "_Bool",
      "_BitInt",
      "_Complex",
      "_Imaginary",
      "_Decimal32",
      "_Decimal64",
      "_Decimal96",
      "_Decimal128",
      "_Decimal64x",
      "_Decimal128x",
      "_Float16",
      "_Float32",
      "_Float64",
      "_Float128",
      "_Float32x",
      "_Float64x",
      "_Float128x",
      // modifiers
      "const",
      "static",
      "constexpr",
      // aliases
      "complex",
      "bool",
      "imaginary"
    ],
    literal: "true false NULL",
    // TODO: apply hinting work similar to what was done in cpp.js
    built_in: "std string wstring cin cout cerr clog stdin stdout stderr stringstream istringstream ostringstream auto_ptr deque list queue stack vector map set pair bitset multiset multimap unordered_set unordered_map unordered_multiset unordered_multimap priority_queue make_pair array shared_ptr abort terminate abs acos asin atan2 atan calloc ceil cosh cos exit exp fabs floor fmod fprintf fputs free frexp fscanf future isalnum isalpha iscntrl isdigit isgraph islower isprint ispunct isspace isupper isxdigit tolower toupper labs ldexp log10 log malloc realloc memchr memcmp memcpy memset modf pow printf putchar puts scanf sinh sin snprintf sprintf sqrt sscanf strcat strchr strcmp strcpy strcspn strlen strncat strncmp strncpy strpbrk strrchr strspn strstr tanh tan vfprintf vprintf vsprintf endl initializer_list unique_ptr"
  }, b = [
    d,
    o,
    n,
    e.C_BLOCK_COMMENT_MODE,
    u,
    c
  ], y = {
    // This mode covers expression context where we can't expect a function
    // definition and shouldn't highlight anything that looks like one:
    // `return some()`, `else if()`, `(x*sum(1, 2))`
    variants: [
      {
        begin: /=/,
        end: /;/
      },
      {
        begin: /\(/,
        end: /\)/
      },
      {
        beginKeywords: "new throw return else",
        end: /;/
      }
    ],
    keywords: m,
    contains: b.concat([
      {
        begin: /\(/,
        end: /\)/,
        keywords: m,
        contains: b.concat(["self"]),
        relevance: 0
      }
    ]),
    relevance: 0
  }, v = {
    begin: "(" + s + "[\\*&\\s]+)+" + p,
    returnBegin: !0,
    end: /[{;=]/,
    excludeEnd: !0,
    keywords: m,
    illegal: /[^\w\s\*&:<>.]/,
    contains: [
      {
        // to prevent it from being confused as the function title
        begin: r,
        keywords: m,
        relevance: 0
      },
      {
        begin: p,
        returnBegin: !0,
        contains: [e.inherit(f, { className: "title.function" })],
        relevance: 0
      },
      // allow for multiple declarations, e.g.:
      // extern void f(int), g(char);
      {
        relevance: 0,
        match: /,/
      },
      {
        className: "params",
        begin: /\(/,
        end: /\)/,
        keywords: m,
        relevance: 0,
        contains: [
          n,
          e.C_BLOCK_COMMENT_MODE,
          c,
          u,
          o,
          // Count matching parentheses.
          {
            begin: /\(/,
            end: /\)/,
            keywords: m,
            relevance: 0,
            contains: [
              "self",
              n,
              e.C_BLOCK_COMMENT_MODE,
              c,
              u,
              o
            ]
          }
        ]
      },
      o,
      n,
      e.C_BLOCK_COMMENT_MODE,
      d
    ]
  };
  return {
    name: "C",
    aliases: ["h"],
    keywords: m,
    // Until differentiations are added between `c` and `cpp`, `c` will
    // not be auto-detected to avoid auto-detect conflicts between C and C++
    disableAutodetect: !0,
    illegal: "</",
    contains: [].concat(
      y,
      v,
      b,
      [
        d,
        {
          begin: e.IDENT_RE + "::",
          keywords: m
        },
        {
          className: "class",
          beginKeywords: "enum class struct union",
          end: /[{;:<>=]/,
          contains: [
            { beginKeywords: "final class struct" },
            e.TITLE_MODE
          ]
        }
      ]
    ),
    exports: {
      preprocessor: d,
      strings: c,
      keywords: m
    }
  };
}
function aP(e) {
  const t = e.regex, n = e.COMMENT("//", "$", { contains: [{ begin: /\\\n/ }] }), r = "decltype\\(auto\\)", i = "[a-zA-Z_]\\w*::", s = "(?!struct)(" + r + "|" + t.optional(i) + "[a-zA-Z_]\\w*" + t.optional("<[^<>]+>") + ")", o = {
    className: "type",
    begin: "\\b[a-z\\d_]*_t\\b"
  }, c = {
    className: "string",
    variants: [
      {
        begin: '(u8?|U|L)?"',
        end: '"',
        illegal: "\\n",
        contains: [e.BACKSLASH_ESCAPE]
      },
      {
        begin: "(u8?|U|L)?'(" + "\\\\(x[0-9A-Fa-f]{2}|u[0-9A-Fa-f]{4,8}|[0-7]{3}|\\S)" + "|.)",
        end: "'",
        illegal: "."
      },
      e.END_SAME_AS_BEGIN({
        begin: /(?:u8?|U|L)?R"([^()\\ ]{0,16})\(/,
        end: /\)([^()\\ ]{0,16})"/
      })
    ]
  }, u = {
    className: "number",
    variants: [
      // Floating-point literal.
      {
        begin: "[+-]?(?:(?:[0-9](?:'?[0-9])*\\.(?:[0-9](?:'?[0-9])*)?|\\.[0-9](?:'?[0-9])*)(?:[Ee][+-]?[0-9](?:'?[0-9])*)?|[0-9](?:'?[0-9])*[Ee][+-]?[0-9](?:'?[0-9])*|0[Xx](?:[0-9A-Fa-f](?:'?[0-9A-Fa-f])*(?:\\.(?:[0-9A-Fa-f](?:'?[0-9A-Fa-f])*)?)?|\\.[0-9A-Fa-f](?:'?[0-9A-Fa-f])*)[Pp][+-]?[0-9](?:'?[0-9])*)(?:[Ff](?:16|32|64|128)?|(BF|bf)16|[Ll]|)"
      },
      // Integer literal.
      {
        begin: "[+-]?\\b(?:0[Bb][01](?:'?[01])*|0[Xx][0-9A-Fa-f](?:'?[0-9A-Fa-f])*|0(?:'?[0-7])*|[1-9](?:'?[0-9])*)(?:[Uu](?:LL?|ll?)|[Uu][Zz]?|(?:LL?|ll?)[Uu]?|[Zz][Uu]|)"
        // Note: there are user-defined literal suffixes too, but perhaps having the custom suffix not part of the
        // literal highlight actually makes it stand out more.
      }
    ],
    relevance: 0
  }, d = {
    className: "meta",
    begin: /#\s*[a-z]+\b/,
    end: /$/,
    keywords: { keyword: "if else elif endif define undef warning error line pragma _Pragma ifdef ifndef include" },
    contains: [
      {
        begin: /\\\n/,
        relevance: 0
      },
      e.inherit(c, { className: "string" }),
      {
        className: "string",
        begin: /<.*?>/
      },
      n,
      e.C_BLOCK_COMMENT_MODE
    ]
  }, f = {
    className: "title",
    begin: t.optional(i) + e.IDENT_RE,
    relevance: 0
  }, p = t.optional(i) + e.IDENT_RE + "\\s*\\(", h = [
    "alignas",
    "alignof",
    "and",
    "and_eq",
    "asm",
    "atomic_cancel",
    "atomic_commit",
    "atomic_noexcept",
    "auto",
    "bitand",
    "bitor",
    "break",
    "case",
    "catch",
    "class",
    "co_await",
    "co_return",
    "co_yield",
    "compl",
    "concept",
    "const_cast|10",
    "consteval",
    "constexpr",
    "constinit",
    "continue",
    "decltype",
    "default",
    "delete",
    "do",
    "dynamic_cast|10",
    "else",
    "enum",
    "explicit",
    "export",
    "extern",
    "false",
    "final",
    "for",
    "friend",
    "goto",
    "if",
    "import",
    "inline",
    "module",
    "mutable",
    "namespace",
    "new",
    "noexcept",
    "not",
    "not_eq",
    "nullptr",
    "operator",
    "or",
    "or_eq",
    "override",
    "private",
    "protected",
    "public",
    "reflexpr",
    "register",
    "reinterpret_cast|10",
    "requires",
    "return",
    "sizeof",
    "static_assert",
    "static_cast|10",
    "struct",
    "switch",
    "synchronized",
    "template",
    "this",
    "thread_local",
    "throw",
    "transaction_safe",
    "transaction_safe_dynamic",
    "true",
    "try",
    "typedef",
    "typeid",
    "typename",
    "union",
    "using",
    "virtual",
    "volatile",
    "while",
    "xor",
    "xor_eq"
  ], g = [
    "bool",
    "char",
    "char16_t",
    "char32_t",
    "char8_t",
    "double",
    "float",
    "int",
    "long",
    "short",
    "void",
    "wchar_t",
    "unsigned",
    "signed",
    "const",
    "static"
  ], m = [
    "any",
    "auto_ptr",
    "barrier",
    "binary_semaphore",
    "bitset",
    "complex",
    "condition_variable",
    "condition_variable_any",
    "counting_semaphore",
    "deque",
    "false_type",
    "flat_map",
    "flat_set",
    "future",
    "imaginary",
    "initializer_list",
    "istringstream",
    "jthread",
    "latch",
    "lock_guard",
    "multimap",
    "multiset",
    "mutex",
    "optional",
    "ostringstream",
    "packaged_task",
    "pair",
    "promise",
    "priority_queue",
    "queue",
    "recursive_mutex",
    "recursive_timed_mutex",
    "scoped_lock",
    "set",
    "shared_future",
    "shared_lock",
    "shared_mutex",
    "shared_timed_mutex",
    "shared_ptr",
    "stack",
    "string_view",
    "stringstream",
    "timed_mutex",
    "thread",
    "true_type",
    "tuple",
    "unique_lock",
    "unique_ptr",
    "unordered_map",
    "unordered_multimap",
    "unordered_multiset",
    "unordered_set",
    "variant",
    "vector",
    "weak_ptr",
    "wstring",
    "wstring_view"
  ], b = [
    "abort",
    "abs",
    "acos",
    "apply",
    "as_const",
    "asin",
    "atan",
    "atan2",
    "calloc",
    "ceil",
    "cerr",
    "cin",
    "clog",
    "cos",
    "cosh",
    "cout",
    "declval",
    "endl",
    "exchange",
    "exit",
    "exp",
    "fabs",
    "floor",
    "fmod",
    "forward",
    "fprintf",
    "fputs",
    "free",
    "frexp",
    "fscanf",
    "future",
    "invoke",
    "isalnum",
    "isalpha",
    "iscntrl",
    "isdigit",
    "isgraph",
    "islower",
    "isprint",
    "ispunct",
    "isspace",
    "isupper",
    "isxdigit",
    "labs",
    "launder",
    "ldexp",
    "log",
    "log10",
    "make_pair",
    "make_shared",
    "make_shared_for_overwrite",
    "make_tuple",
    "make_unique",
    "malloc",
    "memchr",
    "memcmp",
    "memcpy",
    "memset",
    "modf",
    "move",
    "pow",
    "printf",
    "putchar",
    "puts",
    "realloc",
    "scanf",
    "sin",
    "sinh",
    "snprintf",
    "sprintf",
    "sqrt",
    "sscanf",
    "std",
    "stderr",
    "stdin",
    "stdout",
    "strcat",
    "strchr",
    "strcmp",
    "strcpy",
    "strcspn",
    "strlen",
    "strncat",
    "strncmp",
    "strncpy",
    "strpbrk",
    "strrchr",
    "strspn",
    "strstr",
    "swap",
    "tan",
    "tanh",
    "terminate",
    "to_underlying",
    "tolower",
    "toupper",
    "vfprintf",
    "visit",
    "vprintf",
    "vsprintf"
  ], E = {
    type: g,
    keyword: h,
    literal: [
      "NULL",
      "false",
      "nullopt",
      "nullptr",
      "true"
    ],
    built_in: ["_Pragma"],
    _type_hints: m
  }, _ = {
    className: "function.dispatch",
    relevance: 0,
    keywords: {
      // Only for relevance, not highlighting.
      _hint: b
    },
    begin: t.concat(
      /\b/,
      /(?!decltype)/,
      /(?!if)/,
      /(?!for)/,
      /(?!switch)/,
      /(?!while)/,
      e.IDENT_RE,
      t.lookahead(/(<[^<>]+>|)\s*\(/)
    )
  }, x = [
    _,
    d,
    o,
    n,
    e.C_BLOCK_COMMENT_MODE,
    u,
    c
  ], I = {
    // This mode covers expression context where we can't expect a function
    // definition and shouldn't highlight anything that looks like one:
    // `return some()`, `else if()`, `(x*sum(1, 2))`
    variants: [
      {
        begin: /=/,
        end: /;/
      },
      {
        begin: /\(/,
        end: /\)/
      },
      {
        beginKeywords: "new throw return else",
        end: /;/
      }
    ],
    keywords: E,
    contains: x.concat([
      {
        begin: /\(/,
        end: /\)/,
        keywords: E,
        contains: x.concat(["self"]),
        relevance: 0
      }
    ]),
    relevance: 0
  }, T = {
    className: "function",
    begin: "(" + s + "[\\*&\\s]+)+" + p,
    returnBegin: !0,
    end: /[{;=]/,
    excludeEnd: !0,
    keywords: E,
    illegal: /[^\w\s\*&:<>.]/,
    contains: [
      {
        // to prevent it from being confused as the function title
        begin: r,
        keywords: E,
        relevance: 0
      },
      {
        begin: p,
        returnBegin: !0,
        contains: [f],
        relevance: 0
      },
      // needed because we do not have look-behind on the below rule
      // to prevent it from grabbing the final : in a :: pair
      {
        begin: /::/,
        relevance: 0
      },
      // initializers
      {
        begin: /:/,
        endsWithParent: !0,
        contains: [
          c,
          u
        ]
      },
      // allow for multiple declarations, e.g.:
      // extern void f(int), g(char);
      {
        relevance: 0,
        match: /,/
      },
      {
        className: "params",
        begin: /\(/,
        end: /\)/,
        keywords: E,
        relevance: 0,
        contains: [
          n,
          e.C_BLOCK_COMMENT_MODE,
          c,
          u,
          o,
          // Count matching parentheses.
          {
            begin: /\(/,
            end: /\)/,
            keywords: E,
            relevance: 0,
            contains: [
              "self",
              n,
              e.C_BLOCK_COMMENT_MODE,
              c,
              u,
              o
            ]
          }
        ]
      },
      o,
      n,
      e.C_BLOCK_COMMENT_MODE,
      d
    ]
  };
  return {
    name: "C++",
    aliases: [
      "cc",
      "c++",
      "h++",
      "hpp",
      "hh",
      "hxx",
      "cxx"
    ],
    keywords: E,
    illegal: "</",
    classNameAliases: { "function.dispatch": "built_in" },
    contains: [].concat(
      I,
      T,
      _,
      x,
      [
        d,
        {
          // containers: ie, `vector <int> rooms (9);`
          begin: "\\b(deque|list|queue|priority_queue|pair|stack|vector|map|set|bitset|multiset|multimap|unordered_map|unordered_set|unordered_multiset|unordered_multimap|array|tuple|optional|variant|function|flat_map|flat_set)\\s*<(?!<)",
          end: ">",
          keywords: E,
          contains: [
            "self",
            o
          ]
        },
        {
          begin: e.IDENT_RE + "::",
          keywords: E
        },
        {
          match: [
            // extra complexity to deal with `enum class` and `enum struct`
            /\b(?:enum(?:\s+(?:class|struct))?|class|struct|union)/,
            /\s+/,
            /\w+/
          ],
          className: {
            1: "keyword",
            3: "title.class"
          }
        }
      ]
    )
  };
}
function sP(e) {
  const t = [
    "bool",
    "byte",
    "char",
    "decimal",
    "delegate",
    "double",
    "dynamic",
    "enum",
    "float",
    "int",
    "long",
    "nint",
    "nuint",
    "object",
    "sbyte",
    "short",
    "string",
    "ulong",
    "uint",
    "ushort"
  ], n = [
    "public",
    "private",
    "protected",
    "static",
    "internal",
    "protected",
    "abstract",
    "async",
    "extern",
    "override",
    "unsafe",
    "virtual",
    "new",
    "sealed",
    "partial"
  ], r = [
    "default",
    "false",
    "null",
    "true"
  ], i = [
    "abstract",
    "as",
    "base",
    "break",
    "case",
    "catch",
    "class",
    "const",
    "continue",
    "do",
    "else",
    "event",
    "explicit",
    "extern",
    "finally",
    "fixed",
    "for",
    "foreach",
    "goto",
    "if",
    "implicit",
    "in",
    "interface",
    "internal",
    "is",
    "lock",
    "namespace",
    "new",
    "operator",
    "out",
    "override",
    "params",
    "private",
    "protected",
    "public",
    "readonly",
    "record",
    "ref",
    "return",
    "scoped",
    "sealed",
    "sizeof",
    "stackalloc",
    "static",
    "struct",
    "switch",
    "this",
    "throw",
    "try",
    "typeof",
    "unchecked",
    "unsafe",
    "using",
    "virtual",
    "void",
    "volatile",
    "while"
  ], a = [
    "add",
    "alias",
    "and",
    "ascending",
    "args",
    "async",
    "await",
    "by",
    "descending",
    "dynamic",
    "equals",
    "file",
    "from",
    "get",
    "global",
    "group",
    "init",
    "into",
    "join",
    "let",
    "nameof",
    "not",
    "notnull",
    "on",
    "or",
    "orderby",
    "partial",
    "record",
    "remove",
    "required",
    "scoped",
    "select",
    "set",
    "unmanaged",
    "value|0",
    "var",
    "when",
    "where",
    "with",
    "yield"
  ], s = {
    keyword: i.concat(a),
    built_in: t,
    literal: r
  }, o = e.inherit(e.TITLE_MODE, { begin: "[a-zA-Z](\\.?\\w)*" }), l = {
    className: "number",
    variants: [
      { begin: "\\b(0b[01']+)" },
      { begin: "(-?)\\b([\\d']+(\\.[\\d']*)?|\\.[\\d']+)(u|U|l|L|ul|UL|f|F|b|B)" },
      { begin: "(-?)(\\b0[xX][a-fA-F0-9']+|(\\b[\\d']+(\\.[\\d']*)?|\\.[\\d']+)([eE][-+]?[\\d']+)?)" }
    ],
    relevance: 0
  }, c = {
    className: "string",
    begin: /"""("*)(?!")(.|\n)*?"""\1/,
    relevance: 1
  }, u = {
    className: "string",
    begin: '@"',
    end: '"',
    contains: [{ begin: '""' }]
  }, d = e.inherit(u, { illegal: /\n/ }), f = {
    className: "subst",
    begin: /\{/,
    end: /\}/,
    keywords: s
  }, p = e.inherit(f, { illegal: /\n/ }), h = {
    className: "string",
    begin: /\$"/,
    end: '"',
    illegal: /\n/,
    contains: [
      { begin: /\{\{/ },
      { begin: /\}\}/ },
      e.BACKSLASH_ESCAPE,
      p
    ]
  }, g = {
    className: "string",
    begin: /\$@"/,
    end: '"',
    contains: [
      { begin: /\{\{/ },
      { begin: /\}\}/ },
      { begin: '""' },
      f
    ]
  }, m = e.inherit(g, {
    illegal: /\n/,
    contains: [
      { begin: /\{\{/ },
      { begin: /\}\}/ },
      { begin: '""' },
      p
    ]
  });
  f.contains = [
    g,
    h,
    u,
    e.APOS_STRING_MODE,
    e.QUOTE_STRING_MODE,
    l,
    e.C_BLOCK_COMMENT_MODE
  ], p.contains = [
    m,
    h,
    d,
    e.APOS_STRING_MODE,
    e.QUOTE_STRING_MODE,
    l,
    e.inherit(e.C_BLOCK_COMMENT_MODE, { illegal: /\n/ })
  ];
  const b = { variants: [
    c,
    g,
    h,
    u,
    e.APOS_STRING_MODE,
    e.QUOTE_STRING_MODE
  ] }, y = {
    begin: "<",
    end: ">",
    contains: [
      { beginKeywords: "in out" },
      o
    ]
  }, v = e.IDENT_RE + "(<" + e.IDENT_RE + "(\\s*,\\s*" + e.IDENT_RE + ")*>)?(\\[\\])?", E = {
    // prevents expressions like `@class` from incorrect flagging
    // `class` as a keyword
    begin: "@" + e.IDENT_RE,
    relevance: 0
  };
  return {
    name: "C#",
    aliases: [
      "cs",
      "c#"
    ],
    keywords: s,
    illegal: /::/,
    contains: [
      e.COMMENT(
        "///",
        "$",
        {
          returnBegin: !0,
          contains: [
            {
              className: "doctag",
              variants: [
                {
                  begin: "///",
                  relevance: 0
                },
                { begin: "<!--|-->" },
                {
                  begin: "</?",
                  end: ">"
                }
              ]
            }
          ]
        }
      ),
      e.C_LINE_COMMENT_MODE,
      e.C_BLOCK_COMMENT_MODE,
      {
        className: "meta",
        begin: "#",
        end: "$",
        keywords: { keyword: "if else elif endif define undef warning error line region endregion pragma checksum" }
      },
      b,
      l,
      {
        beginKeywords: "class interface",
        relevance: 0,
        end: /[{;=]/,
        illegal: /[^\s:,]/,
        contains: [
          { beginKeywords: "where class" },
          o,
          y,
          e.C_LINE_COMMENT_MODE,
          e.C_BLOCK_COMMENT_MODE
        ]
      },
      {
        beginKeywords: "namespace",
        relevance: 0,
        end: /[{;=]/,
        illegal: /[^\s:]/,
        contains: [
          o,
          e.C_LINE_COMMENT_MODE,
          e.C_BLOCK_COMMENT_MODE
        ]
      },
      {
        beginKeywords: "record",
        relevance: 0,
        end: /[{;=]/,
        illegal: /[^\s:]/,
        contains: [
          o,
          y,
          e.C_LINE_COMMENT_MODE,
          e.C_BLOCK_COMMENT_MODE
        ]
      },
      {
        // [Attributes("")]
        className: "meta",
        begin: "^\\s*\\[(?=[\\w])",
        excludeBegin: !0,
        end: "\\]",
        excludeEnd: !0,
        contains: [
          {
            className: "string",
            begin: /"/,
            end: /"/
          }
        ]
      },
      {
        // Expression keywords prevent 'keyword Name(...)' from being
        // recognized as a function definition
        beginKeywords: "new return throw await else",
        relevance: 0
      },
      {
        className: "function",
        begin: "(" + v + "\\s+)+" + e.IDENT_RE + "\\s*(<[^=]+>\\s*)?\\(",
        returnBegin: !0,
        end: /\s*[{;=]/,
        excludeEnd: !0,
        keywords: s,
        contains: [
          // prevents these from being highlighted `title`
          {
            beginKeywords: n.join(" "),
            relevance: 0
          },
          {
            begin: e.IDENT_RE + "\\s*(<[^=]+>\\s*)?\\(",
            returnBegin: !0,
            contains: [
              e.TITLE_MODE,
              y
            ],
            relevance: 0
          },
          { match: /\(\)/ },
          {
            className: "params",
            begin: /\(/,
            end: /\)/,
            excludeBegin: !0,
            excludeEnd: !0,
            keywords: s,
            relevance: 0,
            contains: [
              b,
              l,
              e.C_BLOCK_COMMENT_MODE
            ]
          },
          e.C_LINE_COMMENT_MODE,
          e.C_BLOCK_COMMENT_MODE
        ]
      },
      E
    ]
  };
}
const oP = (e) => ({
  IMPORTANT: {
    scope: "meta",
    begin: "!important"
  },
  BLOCK_COMMENT: e.C_BLOCK_COMMENT_MODE,
  HEXCOLOR: {
    scope: "number",
    begin: /#(([0-9a-fA-F]{3,4})|(([0-9a-fA-F]{2}){3,4}))\b/
  },
  FUNCTION_DISPATCH: {
    className: "built_in",
    begin: /[\w-]+(?=\()/
  },
  ATTRIBUTE_SELECTOR_MODE: {
    scope: "selector-attr",
    begin: /\[/,
    end: /\]/,
    illegal: "$",
    contains: [
      e.APOS_STRING_MODE,
      e.QUOTE_STRING_MODE
    ]
  },
  CSS_NUMBER_MODE: {
    scope: "number",
    begin: e.NUMBER_RE + "(%|em|ex|ch|rem|vw|vh|vmin|vmax|cm|mm|in|pt|pc|px|deg|grad|rad|turn|s|ms|Hz|kHz|dpi|dpcm|dppx)?",
    relevance: 0
  },
  CSS_VARIABLE: {
    className: "attr",
    begin: /--[A-Za-z_][A-Za-z0-9_-]*/
  }
}), lP = [
  "a",
  "abbr",
  "address",
  "article",
  "aside",
  "audio",
  "b",
  "blockquote",
  "body",
  "button",
  "canvas",
  "caption",
  "cite",
  "code",
  "dd",
  "del",
  "details",
  "dfn",
  "div",
  "dl",
  "dt",
  "em",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "header",
  "hgroup",
  "html",
  "i",
  "iframe",
  "img",
  "input",
  "ins",
  "kbd",
  "label",
  "legend",
  "li",
  "main",
  "mark",
  "menu",
  "nav",
  "object",
  "ol",
  "optgroup",
  "option",
  "p",
  "picture",
  "q",
  "quote",
  "samp",
  "section",
  "select",
  "source",
  "span",
  "strong",
  "summary",
  "sup",
  "table",
  "tbody",
  "td",
  "textarea",
  "tfoot",
  "th",
  "thead",
  "time",
  "tr",
  "ul",
  "var",
  "video"
], cP = [
  "defs",
  "g",
  "marker",
  "mask",
  "pattern",
  "svg",
  "switch",
  "symbol",
  "feBlend",
  "feColorMatrix",
  "feComponentTransfer",
  "feComposite",
  "feConvolveMatrix",
  "feDiffuseLighting",
  "feDisplacementMap",
  "feFlood",
  "feGaussianBlur",
  "feImage",
  "feMerge",
  "feMorphology",
  "feOffset",
  "feSpecularLighting",
  "feTile",
  "feTurbulence",
  "linearGradient",
  "radialGradient",
  "stop",
  "circle",
  "ellipse",
  "image",
  "line",
  "path",
  "polygon",
  "polyline",
  "rect",
  "text",
  "use",
  "textPath",
  "tspan",
  "foreignObject",
  "clipPath"
], uP = [
  ...lP,
  ...cP
], dP = [
  "any-hover",
  "any-pointer",
  "aspect-ratio",
  "color",
  "color-gamut",
  "color-index",
  "device-aspect-ratio",
  "device-height",
  "device-width",
  "display-mode",
  "forced-colors",
  "grid",
  "height",
  "hover",
  "inverted-colors",
  "monochrome",
  "orientation",
  "overflow-block",
  "overflow-inline",
  "pointer",
  "prefers-color-scheme",
  "prefers-contrast",
  "prefers-reduced-motion",
  "prefers-reduced-transparency",
  "resolution",
  "scan",
  "scripting",
  "update",
  "width",
  // TODO: find a better solution?
  "min-width",
  "max-width",
  "min-height",
  "max-height"
].sort().reverse(), fP = [
  "active",
  "any-link",
  "blank",
  "checked",
  "current",
  "default",
  "defined",
  "dir",
  // dir()
  "disabled",
  "drop",
  "empty",
  "enabled",
  "first",
  "first-child",
  "first-of-type",
  "fullscreen",
  "future",
  "focus",
  "focus-visible",
  "focus-within",
  "has",
  // has()
  "host",
  // host or host()
  "host-context",
  // host-context()
  "hover",
  "indeterminate",
  "in-range",
  "invalid",
  "is",
  // is()
  "lang",
  // lang()
  "last-child",
  "last-of-type",
  "left",
  "link",
  "local-link",
  "not",
  // not()
  "nth-child",
  // nth-child()
  "nth-col",
  // nth-col()
  "nth-last-child",
  // nth-last-child()
  "nth-last-col",
  // nth-last-col()
  "nth-last-of-type",
  //nth-last-of-type()
  "nth-of-type",
  //nth-of-type()
  "only-child",
  "only-of-type",
  "optional",
  "out-of-range",
  "past",
  "placeholder-shown",
  "read-only",
  "read-write",
  "required",
  "right",
  "root",
  "scope",
  "target",
  "target-within",
  "user-invalid",
  "valid",
  "visited",
  "where"
  // where()
].sort().reverse(), pP = [
  "after",
  "backdrop",
  "before",
  "cue",
  "cue-region",
  "first-letter",
  "first-line",
  "grammar-error",
  "marker",
  "part",
  "placeholder",
  "selection",
  "slotted",
  "spelling-error"
].sort().reverse(), hP = [
  "accent-color",
  "align-content",
  "align-items",
  "align-self",
  "alignment-baseline",
  "all",
  "anchor-name",
  "animation",
  "animation-composition",
  "animation-delay",
  "animation-direction",
  "animation-duration",
  "animation-fill-mode",
  "animation-iteration-count",
  "animation-name",
  "animation-play-state",
  "animation-range",
  "animation-range-end",
  "animation-range-start",
  "animation-timeline",
  "animation-timing-function",
  "appearance",
  "aspect-ratio",
  "backdrop-filter",
  "backface-visibility",
  "background",
  "background-attachment",
  "background-blend-mode",
  "background-clip",
  "background-color",
  "background-image",
  "background-origin",
  "background-position",
  "background-position-x",
  "background-position-y",
  "background-repeat",
  "background-size",
  "baseline-shift",
  "block-size",
  "border",
  "border-block",
  "border-block-color",
  "border-block-end",
  "border-block-end-color",
  "border-block-end-style",
  "border-block-end-width",
  "border-block-start",
  "border-block-start-color",
  "border-block-start-style",
  "border-block-start-width",
  "border-block-style",
  "border-block-width",
  "border-bottom",
  "border-bottom-color",
  "border-bottom-left-radius",
  "border-bottom-right-radius",
  "border-bottom-style",
  "border-bottom-width",
  "border-collapse",
  "border-color",
  "border-end-end-radius",
  "border-end-start-radius",
  "border-image",
  "border-image-outset",
  "border-image-repeat",
  "border-image-slice",
  "border-image-source",
  "border-image-width",
  "border-inline",
  "border-inline-color",
  "border-inline-end",
  "border-inline-end-color",
  "border-inline-end-style",
  "border-inline-end-width",
  "border-inline-start",
  "border-inline-start-color",
  "border-inline-start-style",
  "border-inline-start-width",
  "border-inline-style",
  "border-inline-width",
  "border-left",
  "border-left-color",
  "border-left-style",
  "border-left-width",
  "border-radius",
  "border-right",
  "border-right-color",
  "border-right-style",
  "border-right-width",
  "border-spacing",
  "border-start-end-radius",
  "border-start-start-radius",
  "border-style",
  "border-top",
  "border-top-color",
  "border-top-left-radius",
  "border-top-right-radius",
  "border-top-style",
  "border-top-width",
  "border-width",
  "bottom",
  "box-align",
  "box-decoration-break",
  "box-direction",
  "box-flex",
  "box-flex-group",
  "box-lines",
  "box-ordinal-group",
  "box-orient",
  "box-pack",
  "box-shadow",
  "box-sizing",
  "break-after",
  "break-before",
  "break-inside",
  "caption-side",
  "caret-color",
  "clear",
  "clip",
  "clip-path",
  "clip-rule",
  "color",
  "color-interpolation",
  "color-interpolation-filters",
  "color-profile",
  "color-rendering",
  "color-scheme",
  "column-count",
  "column-fill",
  "column-gap",
  "column-rule",
  "column-rule-color",
  "column-rule-style",
  "column-rule-width",
  "column-span",
  "column-width",
  "columns",
  "contain",
  "contain-intrinsic-block-size",
  "contain-intrinsic-height",
  "contain-intrinsic-inline-size",
  "contain-intrinsic-size",
  "contain-intrinsic-width",
  "container",
  "container-name",
  "container-type",
  "content",
  "content-visibility",
  "counter-increment",
  "counter-reset",
  "counter-set",
  "cue",
  "cue-after",
  "cue-before",
  "cursor",
  "cx",
  "cy",
  "direction",
  "display",
  "dominant-baseline",
  "empty-cells",
  "enable-background",
  "field-sizing",
  "fill",
  "fill-opacity",
  "fill-rule",
  "filter",
  "flex",
  "flex-basis",
  "flex-direction",
  "flex-flow",
  "flex-grow",
  "flex-shrink",
  "flex-wrap",
  "float",
  "flood-color",
  "flood-opacity",
  "flow",
  "font",
  "font-display",
  "font-family",
  "font-feature-settings",
  "font-kerning",
  "font-language-override",
  "font-optical-sizing",
  "font-palette",
  "font-size",
  "font-size-adjust",
  "font-smooth",
  "font-smoothing",
  "font-stretch",
  "font-style",
  "font-synthesis",
  "font-synthesis-position",
  "font-synthesis-small-caps",
  "font-synthesis-style",
  "font-synthesis-weight",
  "font-variant",
  "font-variant-alternates",
  "font-variant-caps",
  "font-variant-east-asian",
  "font-variant-emoji",
  "font-variant-ligatures",
  "font-variant-numeric",
  "font-variant-position",
  "font-variation-settings",
  "font-weight",
  "forced-color-adjust",
  "gap",
  "glyph-orientation-horizontal",
  "glyph-orientation-vertical",
  "grid",
  "grid-area",
  "grid-auto-columns",
  "grid-auto-flow",
  "grid-auto-rows",
  "grid-column",
  "grid-column-end",
  "grid-column-start",
  "grid-gap",
  "grid-row",
  "grid-row-end",
  "grid-row-start",
  "grid-template",
  "grid-template-areas",
  "grid-template-columns",
  "grid-template-rows",
  "hanging-punctuation",
  "height",
  "hyphenate-character",
  "hyphenate-limit-chars",
  "hyphens",
  "icon",
  "image-orientation",
  "image-rendering",
  "image-resolution",
  "ime-mode",
  "initial-letter",
  "initial-letter-align",
  "inline-size",
  "inset",
  "inset-area",
  "inset-block",
  "inset-block-end",
  "inset-block-start",
  "inset-inline",
  "inset-inline-end",
  "inset-inline-start",
  "isolation",
  "justify-content",
  "justify-items",
  "justify-self",
  "kerning",
  "left",
  "letter-spacing",
  "lighting-color",
  "line-break",
  "line-height",
  "line-height-step",
  "list-style",
  "list-style-image",
  "list-style-position",
  "list-style-type",
  "margin",
  "margin-block",
  "margin-block-end",
  "margin-block-start",
  "margin-bottom",
  "margin-inline",
  "margin-inline-end",
  "margin-inline-start",
  "margin-left",
  "margin-right",
  "margin-top",
  "margin-trim",
  "marker",
  "marker-end",
  "marker-mid",
  "marker-start",
  "marks",
  "mask",
  "mask-border",
  "mask-border-mode",
  "mask-border-outset",
  "mask-border-repeat",
  "mask-border-slice",
  "mask-border-source",
  "mask-border-width",
  "mask-clip",
  "mask-composite",
  "mask-image",
  "mask-mode",
  "mask-origin",
  "mask-position",
  "mask-repeat",
  "mask-size",
  "mask-type",
  "masonry-auto-flow",
  "math-depth",
  "math-shift",
  "math-style",
  "max-block-size",
  "max-height",
  "max-inline-size",
  "max-width",
  "min-block-size",
  "min-height",
  "min-inline-size",
  "min-width",
  "mix-blend-mode",
  "nav-down",
  "nav-index",
  "nav-left",
  "nav-right",
  "nav-up",
  "none",
  "normal",
  "object-fit",
  "object-position",
  "offset",
  "offset-anchor",
  "offset-distance",
  "offset-path",
  "offset-position",
  "offset-rotate",
  "opacity",
  "order",
  "orphans",
  "outline",
  "outline-color",
  "outline-offset",
  "outline-style",
  "outline-width",
  "overflow",
  "overflow-anchor",
  "overflow-block",
  "overflow-clip-margin",
  "overflow-inline",
  "overflow-wrap",
  "overflow-x",
  "overflow-y",
  "overlay",
  "overscroll-behavior",
  "overscroll-behavior-block",
  "overscroll-behavior-inline",
  "overscroll-behavior-x",
  "overscroll-behavior-y",
  "padding",
  "padding-block",
  "padding-block-end",
  "padding-block-start",
  "padding-bottom",
  "padding-inline",
  "padding-inline-end",
  "padding-inline-start",
  "padding-left",
  "padding-right",
  "padding-top",
  "page",
  "page-break-after",
  "page-break-before",
  "page-break-inside",
  "paint-order",
  "pause",
  "pause-after",
  "pause-before",
  "perspective",
  "perspective-origin",
  "place-content",
  "place-items",
  "place-self",
  "pointer-events",
  "position",
  "position-anchor",
  "position-visibility",
  "print-color-adjust",
  "quotes",
  "r",
  "resize",
  "rest",
  "rest-after",
  "rest-before",
  "right",
  "rotate",
  "row-gap",
  "ruby-align",
  "ruby-position",
  "scale",
  "scroll-behavior",
  "scroll-margin",
  "scroll-margin-block",
  "scroll-margin-block-end",
  "scroll-margin-block-start",
  "scroll-margin-bottom",
  "scroll-margin-inline",
  "scroll-margin-inline-end",
  "scroll-margin-inline-start",
  "scroll-margin-left",
  "scroll-margin-right",
  "scroll-margin-top",
  "scroll-padding",
  "scroll-padding-block",
  "scroll-padding-block-end",
  "scroll-padding-block-start",
  "scroll-padding-bottom",
  "scroll-padding-inline",
  "scroll-padding-inline-end",
  "scroll-padding-inline-start",
  "scroll-padding-left",
  "scroll-padding-right",
  "scroll-padding-top",
  "scroll-snap-align",
  "scroll-snap-stop",
  "scroll-snap-type",
  "scroll-timeline",
  "scroll-timeline-axis",
  "scroll-timeline-name",
  "scrollbar-color",
  "scrollbar-gutter",
  "scrollbar-width",
  "shape-image-threshold",
  "shape-margin",
  "shape-outside",
  "shape-rendering",
  "speak",
  "speak-as",
  "src",
  // @font-face
  "stop-color",
  "stop-opacity",
  "stroke",
  "stroke-dasharray",
  "stroke-dashoffset",
  "stroke-linecap",
  "stroke-linejoin",
  "stroke-miterlimit",
  "stroke-opacity",
  "stroke-width",
  "tab-size",
  "table-layout",
  "text-align",
  "text-align-all",
  "text-align-last",
  "text-anchor",
  "text-combine-upright",
  "text-decoration",
  "text-decoration-color",
  "text-decoration-line",
  "text-decoration-skip",
  "text-decoration-skip-ink",
  "text-decoration-style",
  "text-decoration-thickness",
  "text-emphasis",
  "text-emphasis-color",
  "text-emphasis-position",
  "text-emphasis-style",
  "text-indent",
  "text-justify",
  "text-orientation",
  "text-overflow",
  "text-rendering",
  "text-shadow",
  "text-size-adjust",
  "text-transform",
  "text-underline-offset",
  "text-underline-position",
  "text-wrap",
  "text-wrap-mode",
  "text-wrap-style",
  "timeline-scope",
  "top",
  "touch-action",
  "transform",
  "transform-box",
  "transform-origin",
  "transform-style",
  "transition",
  "transition-behavior",
  "transition-delay",
  "transition-duration",
  "transition-property",
  "transition-timing-function",
  "translate",
  "unicode-bidi",
  "user-modify",
  "user-select",
  "vector-effect",
  "vertical-align",
  "view-timeline",
  "view-timeline-axis",
  "view-timeline-inset",
  "view-timeline-name",
  "view-transition-name",
  "visibility",
  "voice-balance",
  "voice-duration",
  "voice-family",
  "voice-pitch",
  "voice-range",
  "voice-rate",
  "voice-stress",
  "voice-volume",
  "white-space",
  "white-space-collapse",
  "widows",
  "width",
  "will-change",
  "word-break",
  "word-spacing",
  "word-wrap",
  "writing-mode",
  "x",
  "y",
  "z-index",
  "zoom"
].sort().reverse();
function gP(e) {
  const t = e.regex, n = oP(e), r = { begin: /-(webkit|moz|ms|o)-(?=[a-z])/ }, i = "and or not only", a = /@-?\w[\w]*(-\w+)*/, s = "[a-zA-Z-][a-zA-Z0-9_-]*", o = [
    e.APOS_STRING_MODE,
    e.QUOTE_STRING_MODE
  ];
  return {
    name: "CSS",
    case_insensitive: !0,
    illegal: /[=|'\$]/,
    keywords: { keyframePosition: "from to" },
    classNameAliases: {
      // for visual continuity with `tag {}` and because we
      // don't have a great class for this?
      keyframePosition: "selector-tag"
    },
    contains: [
      n.BLOCK_COMMENT,
      r,
      // to recognize keyframe 40% etc which are outside the scope of our
      // attribute value mode
      n.CSS_NUMBER_MODE,
      {
        className: "selector-id",
        begin: /#[A-Za-z0-9_-]+/,
        relevance: 0
      },
      {
        className: "selector-class",
        begin: "\\." + s,
        relevance: 0
      },
      n.ATTRIBUTE_SELECTOR_MODE,
      {
        className: "selector-pseudo",
        variants: [
          { begin: ":(" + fP.join("|") + ")" },
          { begin: ":(:)?(" + pP.join("|") + ")" }
        ]
      },
      // we may actually need this (12/2020)
      // { // pseudo-selector params
      //   begin: /\(/,
      //   end: /\)/,
      //   contains: [ hljs.CSS_NUMBER_MODE ]
      // },
      n.CSS_VARIABLE,
      {
        className: "attribute",
        begin: "\\b(" + hP.join("|") + ")\\b"
      },
      // attribute values
      {
        begin: /:/,
        end: /[;}{]/,
        contains: [
          n.BLOCK_COMMENT,
          n.HEXCOLOR,
          n.IMPORTANT,
          n.CSS_NUMBER_MODE,
          ...o,
          // needed to highlight these as strings and to avoid issues with
          // illegal characters that might be inside urls that would tigger the
          // languages illegal stack
          {
            begin: /(url|data-uri)\(/,
            end: /\)/,
            relevance: 0,
            // from keywords
            keywords: { built_in: "url data-uri" },
            contains: [
              ...o,
              {
                className: "string",
                // any character other than `)` as in `url()` will be the start
                // of a string, which ends with `)` (from the parent mode)
                begin: /[^)]/,
                endsWithParent: !0,
                excludeEnd: !0
              }
            ]
          },
          n.FUNCTION_DISPATCH
        ]
      },
      {
        begin: t.lookahead(/@/),
        end: "[{;]",
        relevance: 0,
        illegal: /:/,
        // break on Less variables @var: ...
        contains: [
          {
            className: "keyword",
            begin: a
          },
          {
            begin: /\s/,
            endsWithParent: !0,
            excludeEnd: !0,
            relevance: 0,
            keywords: {
              $pattern: /[a-z-]+/,
              keyword: i,
              attribute: dP.join(" ")
            },
            contains: [
              {
                begin: /[a-z-]+(?=:)/,
                className: "attribute"
              },
              ...o,
              n.CSS_NUMBER_MODE
            ]
          }
        ]
      },
      {
        className: "selector-tag",
        begin: "\\b(" + uP.join("|") + ")\\b"
      }
    ]
  };
}
function mP(e) {
  const t = e.regex;
  return {
    name: "Diff",
    aliases: ["patch"],
    contains: [
      {
        className: "meta",
        relevance: 10,
        match: t.either(
          /^@@ +-\d+,\d+ +\+\d+,\d+ +@@/,
          /^\*\*\* +\d+,\d+ +\*\*\*\*$/,
          /^--- +\d+,\d+ +----$/
        )
      },
      {
        className: "comment",
        variants: [
          {
            begin: t.either(
              /Index: /,
              /^index/,
              /={3,}/,
              /^-{3}/,
              /^\*{3} /,
              /^\+{3}/,
              /^diff --git/
            ),
            end: /$/
          },
          { match: /^\*{15}$/ }
        ]
      },
      {
        className: "addition",
        begin: /^\+/,
        end: /$/
      },
      {
        className: "deletion",
        begin: /^-/,
        end: /$/
      },
      {
        className: "addition",
        begin: /^!/,
        end: /$/
      }
    ]
  };
}
function bP(e) {
  const a = {
    keyword: [
      "break",
      "case",
      "chan",
      "const",
      "continue",
      "default",
      "defer",
      "else",
      "fallthrough",
      "for",
      "func",
      "go",
      "goto",
      "if",
      "import",
      "interface",
      "map",
      "package",
      "range",
      "return",
      "select",
      "struct",
      "switch",
      "type",
      "var"
    ],
    type: [
      "bool",
      "byte",
      "complex64",
      "complex128",
      "error",
      "float32",
      "float64",
      "int8",
      "int16",
      "int32",
      "int64",
      "string",
      "uint8",
      "uint16",
      "uint32",
      "uint64",
      "int",
      "uint",
      "uintptr",
      "rune"
    ],
    literal: [
      "true",
      "false",
      "iota",
      "nil"
    ],
    built_in: [
      "append",
      "cap",
      "close",
      "complex",
      "copy",
      "imag",
      "len",
      "make",
      "new",
      "panic",
      "print",
      "println",
      "real",
      "recover",
      "delete"
    ]
  };
  return {
    name: "Go",
    aliases: ["golang"],
    keywords: a,
    illegal: "</",
    contains: [
      e.C_LINE_COMMENT_MODE,
      e.C_BLOCK_COMMENT_MODE,
      {
        className: "string",
        variants: [
          e.QUOTE_STRING_MODE,
          e.APOS_STRING_MODE,
          {
            begin: "`",
            end: "`"
          }
        ]
      },
      {
        className: "number",
        variants: [
          {
            match: /-?\b0[xX]\.[a-fA-F0-9](_?[a-fA-F0-9])*[pP][+-]?\d(_?\d)*i?/,
            // hex without a present digit before . (making a digit afterwards required)
            relevance: 0
          },
          {
            match: /-?\b0[xX](_?[a-fA-F0-9])+((\.([a-fA-F0-9](_?[a-fA-F0-9])*)?)?[pP][+-]?\d(_?\d)*)?i?/,
            // hex with a present digit before . (making a digit afterwards optional)
            relevance: 0
          },
          {
            match: /-?\b0[oO](_?[0-7])*i?/,
            // leading 0o octal
            relevance: 0
          },
          {
            match: /-?\.\d(_?\d)*([eE][+-]?\d(_?\d)*)?i?/,
            // decimal without a present digit before . (making a digit afterwards required)
            relevance: 0
          },
          {
            match: /-?\b\d(_?\d)*(\.(\d(_?\d)*)?)?([eE][+-]?\d(_?\d)*)?i?/,
            // decimal with a present digit before . (making a digit afterwards optional)
            relevance: 0
          }
        ]
      },
      {
        begin: /:=/
        // relevance booster
      },
      {
        className: "function",
        beginKeywords: "func",
        end: "\\s*(\\{|$)",
        excludeEnd: !0,
        contains: [
          e.TITLE_MODE,
          {
            className: "params",
            begin: /\(/,
            end: /\)/,
            endsParent: !0,
            keywords: a,
            illegal: /["']/
          }
        ]
      }
    ]
  };
}
function yP(e) {
  const t = e.regex, n = /[_A-Za-z][_0-9A-Za-z]*/;
  return {
    name: "GraphQL",
    aliases: ["gql"],
    case_insensitive: !0,
    disableAutodetect: !1,
    keywords: {
      keyword: [
        "query",
        "mutation",
        "subscription",
        "type",
        "input",
        "schema",
        "directive",
        "interface",
        "union",
        "scalar",
        "fragment",
        "enum",
        "on"
      ],
      literal: [
        "true",
        "false",
        "null"
      ]
    },
    contains: [
      e.HASH_COMMENT_MODE,
      e.QUOTE_STRING_MODE,
      e.NUMBER_MODE,
      {
        scope: "punctuation",
        match: /[.]{3}/,
        relevance: 0
      },
      {
        scope: "punctuation",
        begin: /[\!\(\)\:\=\[\]\{\|\}]{1}/,
        relevance: 0
      },
      {
        scope: "variable",
        begin: /\$/,
        end: /\W/,
        excludeEnd: !0,
        relevance: 0
      },
      {
        scope: "meta",
        match: /@\w+/,
        excludeEnd: !0
      },
      {
        scope: "symbol",
        begin: t.concat(n, t.lookahead(/\s*:/)),
        relevance: 0
      }
    ],
    illegal: [
      /[;<']/,
      /BEGIN/
    ]
  };
}
function _P(e) {
  const t = e.regex, n = {
    className: "number",
    relevance: 0,
    variants: [
      { begin: /([+-]+)?[\d]+_[\d_]+/ },
      { begin: e.NUMBER_RE }
    ]
  }, r = e.COMMENT();
  r.variants = [
    {
      begin: /;/,
      end: /$/
    },
    {
      begin: /#/,
      end: /$/
    }
  ];
  const i = {
    className: "variable",
    variants: [
      { begin: /\$[\w\d"][\w\d_]*/ },
      { begin: /\$\{(.*?)\}/ }
    ]
  }, a = {
    className: "literal",
    begin: /\bon|off|true|false|yes|no\b/
  }, s = {
    className: "string",
    contains: [e.BACKSLASH_ESCAPE],
    variants: [
      {
        begin: "'''",
        end: "'''",
        relevance: 10
      },
      {
        begin: '"""',
        end: '"""',
        relevance: 10
      },
      {
        begin: '"',
        end: '"'
      },
      {
        begin: "'",
        end: "'"
      }
    ]
  }, o = {
    begin: /\[/,
    end: /\]/,
    contains: [
      r,
      a,
      i,
      s,
      n,
      "self"
    ],
    relevance: 0
  }, l = /[A-Za-z0-9_-]+/, c = /"(\\"|[^"])*"/, u = /'[^']*'/, d = t.either(
    l,
    c,
    u
  ), f = t.concat(
    d,
    "(\\s*\\.\\s*",
    d,
    ")*",
    t.lookahead(/\s*=\s*[^#\s]/)
  );
  return {
    name: "TOML, also INI",
    aliases: ["toml"],
    case_insensitive: !0,
    illegal: /\S/,
    contains: [
      r,
      {
        className: "section",
        begin: /\[+/,
        end: /\]+/
      },
      {
        begin: f,
        className: "attr",
        starts: {
          end: /$/,
          contains: [
            r,
            o,
            a,
            i,
            s,
            n
          ]
        }
      }
    ]
  };
}
var qi = "[0-9](_*[0-9])*", xo = `\\.(${qi})`, Eo = "[0-9a-fA-F](_*[0-9a-fA-F])*", lg = {
  className: "number",
  variants: [
    // DecimalFloatingPointLiteral
    // including ExponentPart
    { begin: `(\\b(${qi})((${xo})|\\.)?|(${xo}))[eE][+-]?(${qi})[fFdD]?\\b` },
    // excluding ExponentPart
    { begin: `\\b(${qi})((${xo})[fFdD]?\\b|\\.([fFdD]\\b)?)` },
    { begin: `(${xo})[fFdD]?\\b` },
    { begin: `\\b(${qi})[fFdD]\\b` },
    // HexadecimalFloatingPointLiteral
    { begin: `\\b0[xX]((${Eo})\\.?|(${Eo})?\\.(${Eo}))[pP][+-]?(${qi})[fFdD]?\\b` },
    // DecimalIntegerLiteral
    { begin: "\\b(0|[1-9](_*[0-9])*)[lL]?\\b" },
    // HexIntegerLiteral
    { begin: `\\b0[xX](${Eo})[lL]?\\b` },
    // OctalIntegerLiteral
    { begin: "\\b0(_*[0-7])*[lL]?\\b" },
    // BinaryIntegerLiteral
    { begin: "\\b0[bB][01](_*[01])*[lL]?\\b" }
  ],
  relevance: 0
};
function Qy(e, t, n) {
  return n === -1 ? "" : e.replace(t, (r) => Qy(e, t, n - 1));
}
function vP(e) {
  const t = e.regex, n = "[-a-zA-Z_$][-a-zA-Z_$0-9]*", r = n + Qy("(?:<" + n + "~~~(?:\\s*,\\s*" + n + "~~~)*>)?", /~~~/g, 2), l = {
    keyword: [
      "synchronized",
      "abstract",
      "private",
      "var",
      "static",
      "if",
      "const ",
      "for",
      "while",
      "strictfp",
      "finally",
      "protected",
      "import",
      "native",
      "final",
      "void",
      "enum",
      "else",
      "break",
      "transient",
      "catch",
      "instanceof",
      "volatile",
      "case",
      "assert",
      "package",
      "default",
      "public",
      "try",
      "switch",
      "continue",
      "throws",
      "protected",
      "public",
      "private",
      "module",
      "requires",
      "exports",
      "do",
      "sealed",
      "yield",
      "permits",
      "goto",
      "when"
    ],
    literal: [
      "false",
      "true",
      "null"
    ],
    type: [
      "char",
      "boolean",
      "long",
      "float",
      "int",
      "byte",
      "short",
      "double"
    ],
    built_in: [
      "super",
      "this"
    ]
  }, c = {
    className: "meta",
    begin: "@" + n,
    contains: [
      {
        begin: /\(/,
        end: /\)/,
        contains: ["self"]
        // allow nested () inside our annotation
      }
    ]
  }, u = {
    className: "params",
    begin: /\(/,
    end: /\)/,
    keywords: l,
    relevance: 0,
    contains: [e.C_BLOCK_COMMENT_MODE],
    endsParent: !0
  };
  return {
    name: "Java",
    aliases: ["jsp"],
    keywords: l,
    illegal: /<\/|#/,
    contains: [
      e.COMMENT(
        "/\\*\\*",
        "\\*/",
        {
          relevance: 0,
          contains: [
            {
              // eat up @'s in emails to prevent them to be recognized as doctags
              begin: /\w+@/,
              relevance: 0
            },
            {
              className: "doctag",
              begin: "@[A-Za-z]+"
            }
          ]
        }
      ),
      // relevance boost
      {
        begin: /import java\.[a-z]+\./,
        keywords: "import",
        relevance: 2
      },
      e.C_LINE_COMMENT_MODE,
      e.C_BLOCK_COMMENT_MODE,
      {
        begin: /"""/,
        end: /"""/,
        className: "string",
        contains: [e.BACKSLASH_ESCAPE]
      },
      e.APOS_STRING_MODE,
      e.QUOTE_STRING_MODE,
      {
        match: [
          /\b(?:class|interface|enum|extends|implements|new)/,
          /\s+/,
          n
        ],
        className: {
          1: "keyword",
          3: "title.class"
        }
      },
      {
        // Exceptions for hyphenated keywords
        match: /non-sealed/,
        scope: "keyword"
      },
      {
        begin: [
          t.concat(/(?!else)/, n),
          /\s+/,
          n,
          /\s+/,
          /=(?!=)/
        ],
        className: {
          1: "type",
          3: "variable",
          5: "operator"
        }
      },
      {
        begin: [
          /record/,
          /\s+/,
          n
        ],
        className: {
          1: "keyword",
          3: "title.class"
        },
        contains: [
          u,
          e.C_LINE_COMMENT_MODE,
          e.C_BLOCK_COMMENT_MODE
        ]
      },
      {
        // Expression keywords prevent 'keyword Name(...)' from being
        // recognized as a function definition
        beginKeywords: "new throw return else",
        relevance: 0
      },
      {
        begin: [
          "(?:" + r + "\\s+)",
          e.UNDERSCORE_IDENT_RE,
          /\s*(?=\()/
        ],
        className: { 2: "title.function" },
        keywords: l,
        contains: [
          {
            className: "params",
            begin: /\(/,
            end: /\)/,
            keywords: l,
            relevance: 0,
            contains: [
              c,
              e.APOS_STRING_MODE,
              e.QUOTE_STRING_MODE,
              lg,
              e.C_BLOCK_COMMENT_MODE
            ]
          },
          e.C_LINE_COMMENT_MODE,
          e.C_BLOCK_COMMENT_MODE
        ]
      },
      lg,
      c
    ]
  };
}
const cg = "[A-Za-z$_][0-9A-Za-z$_]*", xP = [
  "as",
  // for exports
  "in",
  "of",
  "if",
  "for",
  "while",
  "finally",
  "var",
  "new",
  "function",
  "do",
  "return",
  "void",
  "else",
  "break",
  "catch",
  "instanceof",
  "with",
  "throw",
  "case",
  "default",
  "try",
  "switch",
  "continue",
  "typeof",
  "delete",
  "let",
  "yield",
  "const",
  "class",
  // JS handles these with a special rule
  // "get",
  // "set",
  "debugger",
  "async",
  "await",
  "static",
  "import",
  "from",
  "export",
  "extends",
  // It's reached stage 3, which is "recommended for implementation":
  "using"
], EP = [
  "true",
  "false",
  "null",
  "undefined",
  "NaN",
  "Infinity"
], e_ = [
  // Fundamental objects
  "Object",
  "Function",
  "Boolean",
  "Symbol",
  // numbers and dates
  "Math",
  "Date",
  "Number",
  "BigInt",
  // text
  "String",
  "RegExp",
  // Indexed collections
  "Array",
  "Float32Array",
  "Float64Array",
  "Int8Array",
  "Uint8Array",
  "Uint8ClampedArray",
  "Int16Array",
  "Int32Array",
  "Uint16Array",
  "Uint32Array",
  "BigInt64Array",
  "BigUint64Array",
  // Keyed collections
  "Set",
  "Map",
  "WeakSet",
  "WeakMap",
  // Structured data
  "ArrayBuffer",
  "SharedArrayBuffer",
  "Atomics",
  "DataView",
  "JSON",
  // Control abstraction objects
  "Promise",
  "Generator",
  "GeneratorFunction",
  "AsyncFunction",
  // Reflection
  "Reflect",
  "Proxy",
  // Internationalization
  "Intl",
  // WebAssembly
  "WebAssembly"
], t_ = [
  "Error",
  "EvalError",
  "InternalError",
  "RangeError",
  "ReferenceError",
  "SyntaxError",
  "TypeError",
  "URIError"
], n_ = [
  "setInterval",
  "setTimeout",
  "clearInterval",
  "clearTimeout",
  "require",
  "exports",
  "eval",
  "isFinite",
  "isNaN",
  "parseFloat",
  "parseInt",
  "decodeURI",
  "decodeURIComponent",
  "encodeURI",
  "encodeURIComponent",
  "escape",
  "unescape"
], wP = [
  "arguments",
  "this",
  "super",
  "console",
  "window",
  "document",
  "localStorage",
  "sessionStorage",
  "module",
  "global"
  // Node.js
], CP = [].concat(
  n_,
  e_,
  t_
);
function IP(e) {
  const t = e.regex, n = (K, { after: fe }) => {
    const S = "</" + K[0].slice(1);
    return K.input.indexOf(S, fe) !== -1;
  }, r = cg, i = {
    begin: "<>",
    end: "</>"
  }, a = /<[A-Za-z0-9\\._:-]+\s*\/>/, s = {
    begin: /<[A-Za-z0-9\\._:-]+/,
    end: /\/[A-Za-z0-9\\._:-]+>|\/>/,
    /**
     * @param {RegExpMatchArray} match
     * @param {CallbackResponse} response
     */
    isTrulyOpeningTag: (K, fe) => {
      const S = K[0].length + K.index, me = K.input[S];
      if (
        // HTML should not include another raw `<` inside a tag
        // nested type?
        // `<Array<Array<number>>`, etc.
        me === "<" || // the , gives away that this is not HTML
        // `<T, A extends keyof T, V>`
        me === ","
      ) {
        fe.ignoreMatch();
        return;
      }
      me === ">" && (n(K, { after: S }) || fe.ignoreMatch());
      let se;
      const A = K.input.substring(S);
      if (se = A.match(/^\s*=/)) {
        fe.ignoreMatch();
        return;
      }
      if ((se = A.match(/^\s+extends\s+/)) && se.index === 0) {
        fe.ignoreMatch();
        return;
      }
    }
  }, o = {
    $pattern: cg,
    keyword: xP,
    literal: EP,
    built_in: CP,
    "variable.language": wP
  }, l = "[0-9](_?[0-9])*", c = `\\.(${l})`, u = "0|[1-9](_?[0-9])*|0[0-7]*[89][0-9]*", d = {
    className: "number",
    variants: [
      // DecimalLiteral
      { begin: `(\\b(${u})((${c})|\\.)?|(${c}))[eE][+-]?(${l})\\b` },
      { begin: `\\b(${u})\\b((${c})\\b|\\.)?|(${c})\\b` },
      // DecimalBigIntegerLiteral
      { begin: "\\b(0|[1-9](_?[0-9])*)n\\b" },
      // NonDecimalIntegerLiteral
      { begin: "\\b0[xX][0-9a-fA-F](_?[0-9a-fA-F])*n?\\b" },
      { begin: "\\b0[bB][0-1](_?[0-1])*n?\\b" },
      { begin: "\\b0[oO][0-7](_?[0-7])*n?\\b" },
      // LegacyOctalIntegerLiteral (does not include underscore separators)
      // https://tc39.es/ecma262/#sec-additional-syntax-numeric-literals
      { begin: "\\b0[0-7]+n?\\b" }
    ],
    relevance: 0
  }, f = {
    className: "subst",
    begin: "\\$\\{",
    end: "\\}",
    keywords: o,
    contains: []
    // defined later
  }, p = {
    begin: ".?html`",
    end: "",
    starts: {
      end: "`",
      returnEnd: !1,
      contains: [
        e.BACKSLASH_ESCAPE,
        f
      ],
      subLanguage: "xml"
    }
  }, h = {
    begin: ".?css`",
    end: "",
    starts: {
      end: "`",
      returnEnd: !1,
      contains: [
        e.BACKSLASH_ESCAPE,
        f
      ],
      subLanguage: "css"
    }
  }, g = {
    begin: ".?gql`",
    end: "",
    starts: {
      end: "`",
      returnEnd: !1,
      contains: [
        e.BACKSLASH_ESCAPE,
        f
      ],
      subLanguage: "graphql"
    }
  }, m = {
    className: "string",
    begin: "`",
    end: "`",
    contains: [
      e.BACKSLASH_ESCAPE,
      f
    ]
  }, y = {
    className: "comment",
    variants: [
      e.COMMENT(
        /\/\*\*(?!\/)/,
        "\\*/",
        {
          relevance: 0,
          contains: [
            {
              begin: "(?=@[A-Za-z]+)",
              relevance: 0,
              contains: [
                {
                  className: "doctag",
                  begin: "@[A-Za-z]+"
                },
                {
                  className: "type",
                  begin: "\\{",
                  end: "\\}",
                  excludeEnd: !0,
                  excludeBegin: !0,
                  relevance: 0
                },
                {
                  className: "variable",
                  begin: r + "(?=\\s*(-)|$)",
                  endsParent: !0,
                  relevance: 0
                },
                // eat spaces (not newlines) so we can find
                // types or variables
                {
                  begin: /(?=[^\n])\s/,
                  relevance: 0
                }
              ]
            }
          ]
        }
      ),
      e.C_BLOCK_COMMENT_MODE,
      e.C_LINE_COMMENT_MODE
    ]
  }, v = [
    e.APOS_STRING_MODE,
    e.QUOTE_STRING_MODE,
    p,
    h,
    g,
    m,
    // Skip numbers when they are part of a variable name
    { match: /\$\d+/ },
    d
    // This is intentional:
    // See https://github.com/highlightjs/highlight.js/issues/3288
    // hljs.REGEXP_MODE
  ];
  f.contains = v.concat({
    // we need to pair up {} inside our subst to prevent
    // it from ending too early by matching another }
    begin: /\{/,
    end: /\}/,
    keywords: o,
    contains: [
      "self"
    ].concat(v)
  });
  const E = [].concat(y, f.contains), _ = E.concat([
    // eat recursive parens in sub expressions
    {
      begin: /(\s*)\(/,
      end: /\)/,
      keywords: o,
      contains: ["self"].concat(E)
    }
  ]), x = {
    className: "params",
    // convert this to negative lookbehind in v12
    begin: /(\s*)\(/,
    // to match the parms with
    end: /\)/,
    excludeBegin: !0,
    excludeEnd: !0,
    keywords: o,
    contains: _
  }, I = {
    variants: [
      // class Car extends vehicle
      {
        match: [
          /class/,
          /\s+/,
          r,
          /\s+/,
          /extends/,
          /\s+/,
          t.concat(r, "(", t.concat(/\./, r), ")*")
        ],
        scope: {
          1: "keyword",
          3: "title.class",
          5: "keyword",
          7: "title.class.inherited"
        }
      },
      // class Car
      {
        match: [
          /class/,
          /\s+/,
          r
        ],
        scope: {
          1: "keyword",
          3: "title.class"
        }
      }
    ]
  }, T = {
    relevance: 0,
    match: t.either(
      // Hard coded exceptions
      /\bJSON/,
      // Float32Array, OutT
      /\b[A-Z][a-z]+([A-Z][a-z]*|\d)*/,
      // CSSFactory, CSSFactoryT
      /\b[A-Z]{2,}([A-Z][a-z]+|\d)+([A-Z][a-z]*)*/,
      // FPs, FPsT
      /\b[A-Z]{2,}[a-z]+([A-Z][a-z]+|\d)*([A-Z][a-z]*)*/
      // P
      // single letters are not highlighted
      // BLAH
      // this will be flagged as a UPPER_CASE_CONSTANT instead
    ),
    className: "title.class",
    keywords: {
      _: [
        // se we still get relevance credit for JS library classes
        ...e_,
        ...t_
      ]
    }
  }, O = {
    label: "use_strict",
    className: "meta",
    relevance: 10,
    begin: /^\s*['"]use (strict|asm)['"]/
  }, k = {
    variants: [
      {
        match: [
          /function/,
          /\s+/,
          r,
          /(?=\s*\()/
        ]
      },
      // anonymous function
      {
        match: [
          /function/,
          /\s*(?=\()/
        ]
      }
    ],
    className: {
      1: "keyword",
      3: "title.function"
    },
    label: "func.def",
    contains: [x],
    illegal: /%/
  }, W = {
    relevance: 0,
    match: /\b[A-Z][A-Z_0-9]+\b/,
    className: "variable.constant"
  };
  function M(K) {
    return t.concat("(?!", K.join("|"), ")");
  }
  const L = {
    match: t.concat(
      /\b/,
      M([
        ...n_,
        "super",
        "import"
      ].map((K) => `${K}\\s*\\(`)),
      r,
      t.lookahead(/\s*\(/)
    ),
    className: "title.function",
    relevance: 0
  }, z = {
    begin: t.concat(/\./, t.lookahead(
      t.concat(r, /(?![0-9A-Za-z$_(])/)
    )),
    end: r,
    excludeBegin: !0,
    keywords: "prototype",
    className: "property",
    relevance: 0
  }, U = {
    match: [
      /get|set/,
      /\s+/,
      r,
      /(?=\()/
    ],
    className: {
      1: "keyword",
      3: "title.function"
    },
    contains: [
      {
        // eat to avoid empty params
        begin: /\(\)/
      },
      x
    ]
  }, $ = "(\\([^()]*(\\([^()]*(\\([^()]*\\)[^()]*)*\\)[^()]*)*\\)|" + e.UNDERSCORE_IDENT_RE + ")\\s*=>", Q = {
    match: [
      /const|var|let/,
      /\s+/,
      r,
      /\s*/,
      /=\s*/,
      /(async\s*)?/,
      // async is optional
      t.lookahead($)
    ],
    keywords: "async",
    className: {
      1: "keyword",
      3: "title.function"
    },
    contains: [
      x
    ]
  };
  return {
    name: "JavaScript",
    aliases: ["js", "jsx", "mjs", "cjs"],
    keywords: o,
    // this will be extended by TypeScript
    exports: { PARAMS_CONTAINS: _, CLASS_REFERENCE: T },
    illegal: /#(?![$_A-z])/,
    contains: [
      e.SHEBANG({
        label: "shebang",
        binary: "node",
        relevance: 5
      }),
      O,
      e.APOS_STRING_MODE,
      e.QUOTE_STRING_MODE,
      p,
      h,
      g,
      m,
      y,
      // Skip numbers when they are part of a variable name
      { match: /\$\d+/ },
      d,
      T,
      {
        scope: "attr",
        match: r + t.lookahead(":"),
        relevance: 0
      },
      Q,
      {
        // "value" container
        begin: "(" + e.RE_STARTERS_RE + "|\\b(case|return|throw)\\b)\\s*",
        keywords: "return throw case",
        relevance: 0,
        contains: [
          y,
          e.REGEXP_MODE,
          {
            className: "function",
            // we have to count the parens to make sure we actually have the
            // correct bounding ( ) before the =>.  There could be any number of
            // sub-expressions inside also surrounded by parens.
            begin: $,
            returnBegin: !0,
            end: "\\s*=>",
            contains: [
              {
                className: "params",
                variants: [
                  {
                    begin: e.UNDERSCORE_IDENT_RE,
                    relevance: 0
                  },
                  {
                    className: null,
                    begin: /\(\s*\)/,
                    skip: !0
                  },
                  {
                    begin: /(\s*)\(/,
                    end: /\)/,
                    excludeBegin: !0,
                    excludeEnd: !0,
                    keywords: o,
                    contains: _
                  }
                ]
              }
            ]
          },
          {
            // could be a comma delimited list of params to a function call
            begin: /,/,
            relevance: 0
          },
          {
            match: /\s+/,
            relevance: 0
          },
          {
            // JSX
            variants: [
              { begin: i.begin, end: i.end },
              { match: a },
              {
                begin: s.begin,
                // we carefully check the opening tag to see if it truly
                // is a tag and not a false positive
                "on:begin": s.isTrulyOpeningTag,
                end: s.end
              }
            ],
            subLanguage: "xml",
            contains: [
              {
                begin: s.begin,
                end: s.end,
                skip: !0,
                contains: ["self"]
              }
            ]
          }
        ]
      },
      k,
      {
        // prevent this from getting swallowed up by function
        // since they appear "function like"
        beginKeywords: "while if switch catch for"
      },
      {
        // we have to count the parens to make sure we actually have the correct
        // bounding ( ).  There could be any number of sub-expressions inside
        // also surrounded by parens.
        begin: "\\b(?!function)" + e.UNDERSCORE_IDENT_RE + "\\([^()]*(\\([^()]*(\\([^()]*\\)[^()]*)*\\)[^()]*)*\\)\\s*\\{",
        // end parens
        returnBegin: !0,
        label: "func.def",
        contains: [
          x,
          e.inherit(e.TITLE_MODE, { begin: r, className: "title.function" })
        ]
      },
      // catch ... so it won't trigger the property rule below
      {
        match: /\.\.\./,
        relevance: 0
      },
      z,
      // hack: prevents detection of keywords in some circumstances
      // .keyword()
      // $keyword = x
      {
        match: "\\$" + r,
        relevance: 0
      },
      {
        match: [/\bconstructor(?=\s*\()/],
        className: { 1: "title.function" },
        contains: [x]
      },
      L,
      W,
      I,
      U,
      {
        match: /\$[(.]/
        // relevance booster for a pattern common to JS libs: `$(something)` and `$.something`
      }
    ]
  };
}
function SP(e) {
  const t = {
    className: "attr",
    begin: /"(\\.|[^\\"\r\n])*"(?=\s*:)/,
    relevance: 1.01
  }, n = {
    match: /[{}[\],:]/,
    className: "punctuation",
    relevance: 0
  }, r = [
    "true",
    "false",
    "null"
  ], i = {
    scope: "literal",
    beginKeywords: r.join(" ")
  };
  return {
    name: "JSON",
    aliases: ["jsonc"],
    keywords: {
      literal: r
    },
    contains: [
      t,
      n,
      e.QUOTE_STRING_MODE,
      i,
      e.C_NUMBER_MODE,
      e.C_LINE_COMMENT_MODE,
      e.C_BLOCK_COMMENT_MODE
    ],
    illegal: "\\S"
  };
}
var Ki = "[0-9](_*[0-9])*", wo = `\\.(${Ki})`, Co = "[0-9a-fA-F](_*[0-9a-fA-F])*", AP = {
  className: "number",
  variants: [
    // DecimalFloatingPointLiteral
    // including ExponentPart
    { begin: `(\\b(${Ki})((${wo})|\\.)?|(${wo}))[eE][+-]?(${Ki})[fFdD]?\\b` },
    // excluding ExponentPart
    { begin: `\\b(${Ki})((${wo})[fFdD]?\\b|\\.([fFdD]\\b)?)` },
    { begin: `(${wo})[fFdD]?\\b` },
    { begin: `\\b(${Ki})[fFdD]\\b` },
    // HexadecimalFloatingPointLiteral
    { begin: `\\b0[xX]((${Co})\\.?|(${Co})?\\.(${Co}))[pP][+-]?(${Ki})[fFdD]?\\b` },
    // DecimalIntegerLiteral
    { begin: "\\b(0|[1-9](_*[0-9])*)[lL]?\\b" },
    // HexIntegerLiteral
    { begin: `\\b0[xX](${Co})[lL]?\\b` },
    // OctalIntegerLiteral
    { begin: "\\b0(_*[0-7])*[lL]?\\b" },
    // BinaryIntegerLiteral
    { begin: "\\b0[bB][01](_*[01])*[lL]?\\b" }
  ],
  relevance: 0
};
function kP(e) {
  const t = {
    keyword: "abstract as val var vararg get set class object open private protected public noinline crossinline dynamic final enum if else do while for when throw try catch finally import package is in fun override companion reified inline lateinit init interface annotation data sealed internal infix operator out by constructor super tailrec where const inner suspend typealias external expect actual",
    built_in: "Byte Short Char Int Long Boolean Float Double Void Unit Nothing",
    literal: "true false null"
  }, n = {
    className: "keyword",
    begin: /\b(break|continue|return|this)\b/,
    starts: { contains: [
      {
        className: "symbol",
        begin: /@\w+/
      }
    ] }
  }, r = {
    className: "symbol",
    begin: e.UNDERSCORE_IDENT_RE + "@"
  }, i = {
    className: "subst",
    begin: /\$\{/,
    end: /\}/,
    contains: [e.C_NUMBER_MODE]
  }, a = {
    className: "variable",
    begin: "\\$" + e.UNDERSCORE_IDENT_RE
  }, s = {
    className: "string",
    variants: [
      {
        begin: '"""',
        end: '"""(?=[^"])',
        contains: [
          a,
          i
        ]
      },
      // Can't use built-in modes easily, as we want to use STRING in the meta
      // context as 'meta-string' and there's no syntax to remove explicitly set
      // classNames in built-in modes.
      {
        begin: "'",
        end: "'",
        illegal: /\n/,
        contains: [e.BACKSLASH_ESCAPE]
      },
      {
        begin: '"',
        end: '"',
        illegal: /\n/,
        contains: [
          e.BACKSLASH_ESCAPE,
          a,
          i
        ]
      }
    ]
  };
  i.contains.push(s);
  const o = {
    className: "meta",
    begin: "@(?:file|property|field|get|set|receiver|param|setparam|delegate)\\s*:(?:\\s*" + e.UNDERSCORE_IDENT_RE + ")?"
  }, l = {
    className: "meta",
    begin: "@" + e.UNDERSCORE_IDENT_RE,
    contains: [
      {
        begin: /\(/,
        end: /\)/,
        contains: [
          e.inherit(s, { className: "string" }),
          "self"
        ]
      }
    ]
  }, c = AP, u = e.COMMENT(
    "/\\*",
    "\\*/",
    { contains: [e.C_BLOCK_COMMENT_MODE] }
  ), d = { variants: [
    {
      className: "type",
      begin: e.UNDERSCORE_IDENT_RE
    },
    {
      begin: /\(/,
      end: /\)/,
      contains: []
      // defined later
    }
  ] }, f = d;
  return f.variants[1].contains = [d], d.variants[1].contains = [f], {
    name: "Kotlin",
    aliases: [
      "kt",
      "kts"
    ],
    keywords: t,
    contains: [
      e.COMMENT(
        "/\\*\\*",
        "\\*/",
        {
          relevance: 0,
          contains: [
            {
              className: "doctag",
              begin: "@[A-Za-z]+"
            }
          ]
        }
      ),
      e.C_LINE_COMMENT_MODE,
      u,
      n,
      r,
      o,
      l,
      {
        className: "function",
        beginKeywords: "fun",
        end: "[(]|$",
        returnBegin: !0,
        excludeEnd: !0,
        keywords: t,
        relevance: 5,
        contains: [
          {
            begin: e.UNDERSCORE_IDENT_RE + "\\s*\\(",
            returnBegin: !0,
            relevance: 0,
            contains: [e.UNDERSCORE_TITLE_MODE]
          },
          {
            className: "type",
            begin: /</,
            end: />/,
            keywords: "reified",
            relevance: 0
          },
          {
            className: "params",
            begin: /\(/,
            end: /\)/,
            endsParent: !0,
            keywords: t,
            relevance: 0,
            contains: [
              {
                begin: /:/,
                end: /[=,\/]/,
                endsWithParent: !0,
                contains: [
                  d,
                  e.C_LINE_COMMENT_MODE,
                  u
                ],
                relevance: 0
              },
              e.C_LINE_COMMENT_MODE,
              u,
              o,
              l,
              s,
              e.C_NUMBER_MODE
            ]
          },
          u
        ]
      },
      {
        begin: [
          /class|interface|trait/,
          /\s+/,
          e.UNDERSCORE_IDENT_RE
        ],
        beginScope: {
          3: "title.class"
        },
        keywords: "class interface trait",
        end: /[:\{(]|$/,
        excludeEnd: !0,
        illegal: "extends implements",
        contains: [
          { beginKeywords: "public protected internal private constructor" },
          e.UNDERSCORE_TITLE_MODE,
          {
            className: "type",
            begin: /</,
            end: />/,
            excludeBegin: !0,
            excludeEnd: !0,
            relevance: 0
          },
          {
            className: "type",
            begin: /[,:]\s*/,
            end: /[<\(,){\s]|$/,
            excludeBegin: !0,
            returnEnd: !0
          },
          o,
          l
        ]
      },
      s,
      {
        className: "meta",
        begin: "^#!/usr/bin/env",
        end: "$",
        illegal: `
`
      },
      c
    ]
  };
}
const TP = (e) => ({
  IMPORTANT: {
    scope: "meta",
    begin: "!important"
  },
  BLOCK_COMMENT: e.C_BLOCK_COMMENT_MODE,
  HEXCOLOR: {
    scope: "number",
    begin: /#(([0-9a-fA-F]{3,4})|(([0-9a-fA-F]{2}){3,4}))\b/
  },
  FUNCTION_DISPATCH: {
    className: "built_in",
    begin: /[\w-]+(?=\()/
  },
  ATTRIBUTE_SELECTOR_MODE: {
    scope: "selector-attr",
    begin: /\[/,
    end: /\]/,
    illegal: "$",
    contains: [
      e.APOS_STRING_MODE,
      e.QUOTE_STRING_MODE
    ]
  },
  CSS_NUMBER_MODE: {
    scope: "number",
    begin: e.NUMBER_RE + "(%|em|ex|ch|rem|vw|vh|vmin|vmax|cm|mm|in|pt|pc|px|deg|grad|rad|turn|s|ms|Hz|kHz|dpi|dpcm|dppx)?",
    relevance: 0
  },
  CSS_VARIABLE: {
    className: "attr",
    begin: /--[A-Za-z_][A-Za-z0-9_-]*/
  }
}), RP = [
  "a",
  "abbr",
  "address",
  "article",
  "aside",
  "audio",
  "b",
  "blockquote",
  "body",
  "button",
  "canvas",
  "caption",
  "cite",
  "code",
  "dd",
  "del",
  "details",
  "dfn",
  "div",
  "dl",
  "dt",
  "em",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "header",
  "hgroup",
  "html",
  "i",
  "iframe",
  "img",
  "input",
  "ins",
  "kbd",
  "label",
  "legend",
  "li",
  "main",
  "mark",
  "menu",
  "nav",
  "object",
  "ol",
  "optgroup",
  "option",
  "p",
  "picture",
  "q",
  "quote",
  "samp",
  "section",
  "select",
  "source",
  "span",
  "strong",
  "summary",
  "sup",
  "table",
  "tbody",
  "td",
  "textarea",
  "tfoot",
  "th",
  "thead",
  "time",
  "tr",
  "ul",
  "var",
  "video"
], NP = [
  "defs",
  "g",
  "marker",
  "mask",
  "pattern",
  "svg",
  "switch",
  "symbol",
  "feBlend",
  "feColorMatrix",
  "feComponentTransfer",
  "feComposite",
  "feConvolveMatrix",
  "feDiffuseLighting",
  "feDisplacementMap",
  "feFlood",
  "feGaussianBlur",
  "feImage",
  "feMerge",
  "feMorphology",
  "feOffset",
  "feSpecularLighting",
  "feTile",
  "feTurbulence",
  "linearGradient",
  "radialGradient",
  "stop",
  "circle",
  "ellipse",
  "image",
  "line",
  "path",
  "polygon",
  "polyline",
  "rect",
  "text",
  "use",
  "textPath",
  "tspan",
  "foreignObject",
  "clipPath"
], OP = [
  ...RP,
  ...NP
], MP = [
  "any-hover",
  "any-pointer",
  "aspect-ratio",
  "color",
  "color-gamut",
  "color-index",
  "device-aspect-ratio",
  "device-height",
  "device-width",
  "display-mode",
  "forced-colors",
  "grid",
  "height",
  "hover",
  "inverted-colors",
  "monochrome",
  "orientation",
  "overflow-block",
  "overflow-inline",
  "pointer",
  "prefers-color-scheme",
  "prefers-contrast",
  "prefers-reduced-motion",
  "prefers-reduced-transparency",
  "resolution",
  "scan",
  "scripting",
  "update",
  "width",
  // TODO: find a better solution?
  "min-width",
  "max-width",
  "min-height",
  "max-height"
].sort().reverse(), r_ = [
  "active",
  "any-link",
  "blank",
  "checked",
  "current",
  "default",
  "defined",
  "dir",
  // dir()
  "disabled",
  "drop",
  "empty",
  "enabled",
  "first",
  "first-child",
  "first-of-type",
  "fullscreen",
  "future",
  "focus",
  "focus-visible",
  "focus-within",
  "has",
  // has()
  "host",
  // host or host()
  "host-context",
  // host-context()
  "hover",
  "indeterminate",
  "in-range",
  "invalid",
  "is",
  // is()
  "lang",
  // lang()
  "last-child",
  "last-of-type",
  "left",
  "link",
  "local-link",
  "not",
  // not()
  "nth-child",
  // nth-child()
  "nth-col",
  // nth-col()
  "nth-last-child",
  // nth-last-child()
  "nth-last-col",
  // nth-last-col()
  "nth-last-of-type",
  //nth-last-of-type()
  "nth-of-type",
  //nth-of-type()
  "only-child",
  "only-of-type",
  "optional",
  "out-of-range",
  "past",
  "placeholder-shown",
  "read-only",
  "read-write",
  "required",
  "right",
  "root",
  "scope",
  "target",
  "target-within",
  "user-invalid",
  "valid",
  "visited",
  "where"
  // where()
].sort().reverse(), i_ = [
  "after",
  "backdrop",
  "before",
  "cue",
  "cue-region",
  "first-letter",
  "first-line",
  "grammar-error",
  "marker",
  "part",
  "placeholder",
  "selection",
  "slotted",
  "spelling-error"
].sort().reverse(), PP = [
  "accent-color",
  "align-content",
  "align-items",
  "align-self",
  "alignment-baseline",
  "all",
  "anchor-name",
  "animation",
  "animation-composition",
  "animation-delay",
  "animation-direction",
  "animation-duration",
  "animation-fill-mode",
  "animation-iteration-count",
  "animation-name",
  "animation-play-state",
  "animation-range",
  "animation-range-end",
  "animation-range-start",
  "animation-timeline",
  "animation-timing-function",
  "appearance",
  "aspect-ratio",
  "backdrop-filter",
  "backface-visibility",
  "background",
  "background-attachment",
  "background-blend-mode",
  "background-clip",
  "background-color",
  "background-image",
  "background-origin",
  "background-position",
  "background-position-x",
  "background-position-y",
  "background-repeat",
  "background-size",
  "baseline-shift",
  "block-size",
  "border",
  "border-block",
  "border-block-color",
  "border-block-end",
  "border-block-end-color",
  "border-block-end-style",
  "border-block-end-width",
  "border-block-start",
  "border-block-start-color",
  "border-block-start-style",
  "border-block-start-width",
  "border-block-style",
  "border-block-width",
  "border-bottom",
  "border-bottom-color",
  "border-bottom-left-radius",
  "border-bottom-right-radius",
  "border-bottom-style",
  "border-bottom-width",
  "border-collapse",
  "border-color",
  "border-end-end-radius",
  "border-end-start-radius",
  "border-image",
  "border-image-outset",
  "border-image-repeat",
  "border-image-slice",
  "border-image-source",
  "border-image-width",
  "border-inline",
  "border-inline-color",
  "border-inline-end",
  "border-inline-end-color",
  "border-inline-end-style",
  "border-inline-end-width",
  "border-inline-start",
  "border-inline-start-color",
  "border-inline-start-style",
  "border-inline-start-width",
  "border-inline-style",
  "border-inline-width",
  "border-left",
  "border-left-color",
  "border-left-style",
  "border-left-width",
  "border-radius",
  "border-right",
  "border-right-color",
  "border-right-style",
  "border-right-width",
  "border-spacing",
  "border-start-end-radius",
  "border-start-start-radius",
  "border-style",
  "border-top",
  "border-top-color",
  "border-top-left-radius",
  "border-top-right-radius",
  "border-top-style",
  "border-top-width",
  "border-width",
  "bottom",
  "box-align",
  "box-decoration-break",
  "box-direction",
  "box-flex",
  "box-flex-group",
  "box-lines",
  "box-ordinal-group",
  "box-orient",
  "box-pack",
  "box-shadow",
  "box-sizing",
  "break-after",
  "break-before",
  "break-inside",
  "caption-side",
  "caret-color",
  "clear",
  "clip",
  "clip-path",
  "clip-rule",
  "color",
  "color-interpolation",
  "color-interpolation-filters",
  "color-profile",
  "color-rendering",
  "color-scheme",
  "column-count",
  "column-fill",
  "column-gap",
  "column-rule",
  "column-rule-color",
  "column-rule-style",
  "column-rule-width",
  "column-span",
  "column-width",
  "columns",
  "contain",
  "contain-intrinsic-block-size",
  "contain-intrinsic-height",
  "contain-intrinsic-inline-size",
  "contain-intrinsic-size",
  "contain-intrinsic-width",
  "container",
  "container-name",
  "container-type",
  "content",
  "content-visibility",
  "counter-increment",
  "counter-reset",
  "counter-set",
  "cue",
  "cue-after",
  "cue-before",
  "cursor",
  "cx",
  "cy",
  "direction",
  "display",
  "dominant-baseline",
  "empty-cells",
  "enable-background",
  "field-sizing",
  "fill",
  "fill-opacity",
  "fill-rule",
  "filter",
  "flex",
  "flex-basis",
  "flex-direction",
  "flex-flow",
  "flex-grow",
  "flex-shrink",
  "flex-wrap",
  "float",
  "flood-color",
  "flood-opacity",
  "flow",
  "font",
  "font-display",
  "font-family",
  "font-feature-settings",
  "font-kerning",
  "font-language-override",
  "font-optical-sizing",
  "font-palette",
  "font-size",
  "font-size-adjust",
  "font-smooth",
  "font-smoothing",
  "font-stretch",
  "font-style",
  "font-synthesis",
  "font-synthesis-position",
  "font-synthesis-small-caps",
  "font-synthesis-style",
  "font-synthesis-weight",
  "font-variant",
  "font-variant-alternates",
  "font-variant-caps",
  "font-variant-east-asian",
  "font-variant-emoji",
  "font-variant-ligatures",
  "font-variant-numeric",
  "font-variant-position",
  "font-variation-settings",
  "font-weight",
  "forced-color-adjust",
  "gap",
  "glyph-orientation-horizontal",
  "glyph-orientation-vertical",
  "grid",
  "grid-area",
  "grid-auto-columns",
  "grid-auto-flow",
  "grid-auto-rows",
  "grid-column",
  "grid-column-end",
  "grid-column-start",
  "grid-gap",
  "grid-row",
  "grid-row-end",
  "grid-row-start",
  "grid-template",
  "grid-template-areas",
  "grid-template-columns",
  "grid-template-rows",
  "hanging-punctuation",
  "height",
  "hyphenate-character",
  "hyphenate-limit-chars",
  "hyphens",
  "icon",
  "image-orientation",
  "image-rendering",
  "image-resolution",
  "ime-mode",
  "initial-letter",
  "initial-letter-align",
  "inline-size",
  "inset",
  "inset-area",
  "inset-block",
  "inset-block-end",
  "inset-block-start",
  "inset-inline",
  "inset-inline-end",
  "inset-inline-start",
  "isolation",
  "justify-content",
  "justify-items",
  "justify-self",
  "kerning",
  "left",
  "letter-spacing",
  "lighting-color",
  "line-break",
  "line-height",
  "line-height-step",
  "list-style",
  "list-style-image",
  "list-style-position",
  "list-style-type",
  "margin",
  "margin-block",
  "margin-block-end",
  "margin-block-start",
  "margin-bottom",
  "margin-inline",
  "margin-inline-end",
  "margin-inline-start",
  "margin-left",
  "margin-right",
  "margin-top",
  "margin-trim",
  "marker",
  "marker-end",
  "marker-mid",
  "marker-start",
  "marks",
  "mask",
  "mask-border",
  "mask-border-mode",
  "mask-border-outset",
  "mask-border-repeat",
  "mask-border-slice",
  "mask-border-source",
  "mask-border-width",
  "mask-clip",
  "mask-composite",
  "mask-image",
  "mask-mode",
  "mask-origin",
  "mask-position",
  "mask-repeat",
  "mask-size",
  "mask-type",
  "masonry-auto-flow",
  "math-depth",
  "math-shift",
  "math-style",
  "max-block-size",
  "max-height",
  "max-inline-size",
  "max-width",
  "min-block-size",
  "min-height",
  "min-inline-size",
  "min-width",
  "mix-blend-mode",
  "nav-down",
  "nav-index",
  "nav-left",
  "nav-right",
  "nav-up",
  "none",
  "normal",
  "object-fit",
  "object-position",
  "offset",
  "offset-anchor",
  "offset-distance",
  "offset-path",
  "offset-position",
  "offset-rotate",
  "opacity",
  "order",
  "orphans",
  "outline",
  "outline-color",
  "outline-offset",
  "outline-style",
  "outline-width",
  "overflow",
  "overflow-anchor",
  "overflow-block",
  "overflow-clip-margin",
  "overflow-inline",
  "overflow-wrap",
  "overflow-x",
  "overflow-y",
  "overlay",
  "overscroll-behavior",
  "overscroll-behavior-block",
  "overscroll-behavior-inline",
  "overscroll-behavior-x",
  "overscroll-behavior-y",
  "padding",
  "padding-block",
  "padding-block-end",
  "padding-block-start",
  "padding-bottom",
  "padding-inline",
  "padding-inline-end",
  "padding-inline-start",
  "padding-left",
  "padding-right",
  "padding-top",
  "page",
  "page-break-after",
  "page-break-before",
  "page-break-inside",
  "paint-order",
  "pause",
  "pause-after",
  "pause-before",
  "perspective",
  "perspective-origin",
  "place-content",
  "place-items",
  "place-self",
  "pointer-events",
  "position",
  "position-anchor",
  "position-visibility",
  "print-color-adjust",
  "quotes",
  "r",
  "resize",
  "rest",
  "rest-after",
  "rest-before",
  "right",
  "rotate",
  "row-gap",
  "ruby-align",
  "ruby-position",
  "scale",
  "scroll-behavior",
  "scroll-margin",
  "scroll-margin-block",
  "scroll-margin-block-end",
  "scroll-margin-block-start",
  "scroll-margin-bottom",
  "scroll-margin-inline",
  "scroll-margin-inline-end",
  "scroll-margin-inline-start",
  "scroll-margin-left",
  "scroll-margin-right",
  "scroll-margin-top",
  "scroll-padding",
  "scroll-padding-block",
  "scroll-padding-block-end",
  "scroll-padding-block-start",
  "scroll-padding-bottom",
  "scroll-padding-inline",
  "scroll-padding-inline-end",
  "scroll-padding-inline-start",
  "scroll-padding-left",
  "scroll-padding-right",
  "scroll-padding-top",
  "scroll-snap-align",
  "scroll-snap-stop",
  "scroll-snap-type",
  "scroll-timeline",
  "scroll-timeline-axis",
  "scroll-timeline-name",
  "scrollbar-color",
  "scrollbar-gutter",
  "scrollbar-width",
  "shape-image-threshold",
  "shape-margin",
  "shape-outside",
  "shape-rendering",
  "speak",
  "speak-as",
  "src",
  // @font-face
  "stop-color",
  "stop-opacity",
  "stroke",
  "stroke-dasharray",
  "stroke-dashoffset",
  "stroke-linecap",
  "stroke-linejoin",
  "stroke-miterlimit",
  "stroke-opacity",
  "stroke-width",
  "tab-size",
  "table-layout",
  "text-align",
  "text-align-all",
  "text-align-last",
  "text-anchor",
  "text-combine-upright",
  "text-decoration",
  "text-decoration-color",
  "text-decoration-line",
  "text-decoration-skip",
  "text-decoration-skip-ink",
  "text-decoration-style",
  "text-decoration-thickness",
  "text-emphasis",
  "text-emphasis-color",
  "text-emphasis-position",
  "text-emphasis-style",
  "text-indent",
  "text-justify",
  "text-orientation",
  "text-overflow",
  "text-rendering",
  "text-shadow",
  "text-size-adjust",
  "text-transform",
  "text-underline-offset",
  "text-underline-position",
  "text-wrap",
  "text-wrap-mode",
  "text-wrap-style",
  "timeline-scope",
  "top",
  "touch-action",
  "transform",
  "transform-box",
  "transform-origin",
  "transform-style",
  "transition",
  "transition-behavior",
  "transition-delay",
  "transition-duration",
  "transition-property",
  "transition-timing-function",
  "translate",
  "unicode-bidi",
  "user-modify",
  "user-select",
  "vector-effect",
  "vertical-align",
  "view-timeline",
  "view-timeline-axis",
  "view-timeline-inset",
  "view-timeline-name",
  "view-transition-name",
  "visibility",
  "voice-balance",
  "voice-duration",
  "voice-family",
  "voice-pitch",
  "voice-range",
  "voice-rate",
  "voice-stress",
  "voice-volume",
  "white-space",
  "white-space-collapse",
  "widows",
  "width",
  "will-change",
  "word-break",
  "word-spacing",
  "word-wrap",
  "writing-mode",
  "x",
  "y",
  "z-index",
  "zoom"
].sort().reverse(), DP = r_.concat(i_).sort().reverse();
function LP(e) {
  const t = TP(e), n = DP, r = "and or not only", i = "[\\w-]+", a = "(" + i + "|@\\{" + i + "\\})", s = [], o = [], l = function(v) {
    return {
      // Less strings are not multiline (also include '~' for more consistent coloring of "escaped" strings)
      className: "string",
      begin: "~?" + v + ".*?" + v
    };
  }, c = function(v, E, _) {
    return {
      className: v,
      begin: E,
      relevance: _
    };
  }, u = {
    $pattern: /[a-z-]+/,
    keyword: r,
    attribute: MP.join(" ")
  }, d = {
    // used only to properly balance nested parens inside mixin call, def. arg list
    begin: "\\(",
    end: "\\)",
    contains: o,
    keywords: u,
    relevance: 0
  };
  o.push(
    e.C_LINE_COMMENT_MODE,
    e.C_BLOCK_COMMENT_MODE,
    l("'"),
    l('"'),
    t.CSS_NUMBER_MODE,
    // fixme: it does not include dot for numbers like .5em :(
    {
      begin: "(url|data-uri)\\(",
      starts: {
        className: "string",
        end: "[\\)\\n]",
        excludeEnd: !0
      }
    },
    t.HEXCOLOR,
    d,
    c("variable", "@@?" + i, 10),
    c("variable", "@\\{" + i + "\\}"),
    c("built_in", "~?`[^`]*?`"),
    // inline javascript (or whatever host language) *multiline* string
    {
      // @media features (its here to not duplicate things in AT_RULE_MODE with extra PARENS_MODE overriding):
      className: "attribute",
      begin: i + "\\s*:",
      end: ":",
      returnBegin: !0,
      excludeEnd: !0
    },
    t.IMPORTANT,
    { beginKeywords: "and not" },
    t.FUNCTION_DISPATCH
  );
  const f = o.concat({
    begin: /\{/,
    end: /\}/,
    contains: s
  }), p = {
    beginKeywords: "when",
    endsWithParent: !0,
    contains: [{ beginKeywords: "and not" }].concat(o)
    // using this form to override VALUEs 'function' match
  }, h = {
    begin: a + "\\s*:",
    returnBegin: !0,
    end: /[;}]/,
    relevance: 0,
    contains: [
      { begin: /-(webkit|moz|ms|o)-/ },
      t.CSS_VARIABLE,
      {
        className: "attribute",
        begin: "\\b(" + PP.join("|") + ")\\b",
        end: /(?=:)/,
        starts: {
          endsWithParent: !0,
          illegal: "[<=$]",
          relevance: 0,
          contains: o
        }
      }
    ]
  }, g = {
    className: "keyword",
    begin: "@(import|media|charset|font-face|(-[a-z]+-)?keyframes|supports|document|namespace|page|viewport|host)\\b",
    starts: {
      end: "[;{}]",
      keywords: u,
      returnEnd: !0,
      contains: o,
      relevance: 0
    }
  }, m = {
    className: "variable",
    variants: [
      // using more strict pattern for higher relevance to increase chances of Less detection.
      // this is *the only* Less specific statement used in most of the sources, so...
      // (well still often loose to the css-parser unless there's '//' comment,
      // simply because 1 variable just can't beat 99 properties :)
      {
        begin: "@" + i + "\\s*:",
        relevance: 15
      },
      { begin: "@" + i }
    ],
    starts: {
      end: "[;}]",
      returnEnd: !0,
      contains: f
    }
  }, b = {
    // first parse unambiguous selectors (i.e. those not starting with tag)
    // then fall into the scary lookahead-discriminator variant.
    // this mode also handles mixin definitions and calls
    variants: [
      {
        begin: "[\\.#:&\\[>]",
        end: "[;{}]"
        // mixin calls end with ';'
      },
      {
        begin: a,
        end: /\{/
      }
    ],
    returnBegin: !0,
    returnEnd: !0,
    illegal: `[<='$"]`,
    relevance: 0,
    contains: [
      e.C_LINE_COMMENT_MODE,
      e.C_BLOCK_COMMENT_MODE,
      p,
      c("keyword", "all\\b"),
      c("variable", "@\\{" + i + "\\}"),
      // otherwise its identified as tag
      {
        begin: "\\b(" + OP.join("|") + ")\\b",
        className: "selector-tag"
      },
      t.CSS_NUMBER_MODE,
      c("selector-tag", a, 0),
      c("selector-id", "#" + a),
      c("selector-class", "\\." + a, 0),
      c("selector-tag", "&", 0),
      t.ATTRIBUTE_SELECTOR_MODE,
      {
        className: "selector-pseudo",
        begin: ":(" + r_.join("|") + ")"
      },
      {
        className: "selector-pseudo",
        begin: ":(:)?(" + i_.join("|") + ")"
      },
      {
        begin: /\(/,
        end: /\)/,
        relevance: 0,
        contains: f
      },
      // argument list of parametric mixins
      { begin: "!important" },
      // eat !important after mixin call or it will be colored as tag
      t.FUNCTION_DISPATCH
    ]
  }, y = {
    begin: i + `:(:)?(${n.join("|")})`,
    returnBegin: !0,
    contains: [b]
  };
  return s.push(
    e.C_LINE_COMMENT_MODE,
    e.C_BLOCK_COMMENT_MODE,
    g,
    m,
    y,
    h,
    b,
    p,
    t.FUNCTION_DISPATCH
  ), {
    name: "Less",
    case_insensitive: !0,
    illegal: `[=>'/<($"]`,
    contains: s
  };
}
function FP(e) {
  const t = "\\[=*\\[", n = "\\]=*\\]", r = {
    begin: t,
    end: n,
    contains: ["self"]
  }, i = [
    e.COMMENT("--(?!" + t + ")", "$"),
    e.COMMENT(
      "--" + t,
      n,
      {
        contains: [r],
        relevance: 10
      }
    )
  ];
  return {
    name: "Lua",
    aliases: ["pluto"],
    keywords: {
      $pattern: e.UNDERSCORE_IDENT_RE,
      literal: "true false nil",
      keyword: "and break do else elseif end for goto if in local not or repeat return then until while",
      built_in: (
        // Metatags and globals:
        "_G _ENV _VERSION __index __newindex __mode __call __metatable __tostring __len __gc __add __sub __mul __div __mod __pow __concat __unm __eq __lt __le assert collectgarbage dofile error getfenv getmetatable ipairs load loadfile loadstring module next pairs pcall print rawequal rawget rawset require select setfenv setmetatable tonumber tostring type unpack xpcall arg self coroutine resume yield status wrap create running debug getupvalue debug sethook getmetatable gethook setmetatable setlocal traceback setfenv getinfo setupvalue getlocal getregistry getfenv io lines write close flush open output type read stderr stdin input stdout popen tmpfile math log max acos huge ldexp pi cos tanh pow deg tan cosh sinh random randomseed frexp ceil floor rad abs sqrt modf asin min mod fmod log10 atan2 exp sin atan os exit setlocale date getenv difftime remove time clock tmpname rename execute package preload loadlib loaded loaders cpath config path seeall string sub upper len gfind rep find match char dump gmatch reverse byte format gsub lower table setn insert getn foreachi maxn foreach concat sort remove"
      )
    },
    contains: i.concat([
      {
        className: "function",
        beginKeywords: "function",
        end: "\\)",
        contains: [
          e.inherit(e.TITLE_MODE, { begin: "([_a-zA-Z]\\w*\\.)*([_a-zA-Z]\\w*:)?[_a-zA-Z]\\w*" }),
          {
            className: "params",
            begin: "\\(",
            endsWithParent: !0,
            contains: i
          }
        ].concat(i)
      },
      e.C_NUMBER_MODE,
      e.APOS_STRING_MODE,
      e.QUOTE_STRING_MODE,
      {
        className: "string",
        begin: t,
        end: n,
        contains: [r],
        relevance: 5
      }
    ])
  };
}
function BP(e) {
  const t = {
    className: "variable",
    variants: [
      {
        begin: "\\$\\(" + e.UNDERSCORE_IDENT_RE + "\\)",
        contains: [e.BACKSLASH_ESCAPE]
      },
      { begin: /\$[@%<?\^\+\*]/ }
    ]
  }, n = {
    className: "string",
    begin: /"/,
    end: /"/,
    contains: [
      e.BACKSLASH_ESCAPE,
      t
    ]
  }, r = {
    className: "variable",
    begin: /\$\([\w-]+\s/,
    end: /\)/,
    keywords: { built_in: "subst patsubst strip findstring filter filter-out sort word wordlist firstword lastword dir notdir suffix basename addsuffix addprefix join wildcard realpath abspath error warning shell origin flavor foreach if or and call eval file value" },
    contains: [
      t,
      n
      // Added QUOTE_STRING as they can be a part of functions
    ]
  }, i = { begin: "^" + e.UNDERSCORE_IDENT_RE + "\\s*(?=[:+?]?=)" }, a = {
    className: "meta",
    begin: /^\.PHONY:/,
    end: /$/,
    keywords: {
      $pattern: /[\.\w]+/,
      keyword: ".PHONY"
    }
  }, s = {
    className: "section",
    begin: /^[^\s]+:/,
    end: /$/,
    contains: [t]
  };
  return {
    name: "Makefile",
    aliases: [
      "mk",
      "mak",
      "make"
    ],
    keywords: {
      $pattern: /[\w-]+/,
      keyword: "define endef undefine ifdef ifndef ifeq ifneq else endif include -include sinclude override export unexport private vpath"
    },
    contains: [
      e.HASH_COMMENT_MODE,
      t,
      n,
      r,
      i,
      a,
      s
    ]
  };
}
function zP(e) {
  const t = e.regex, n = {
    begin: /<\/?[A-Za-z_]/,
    end: ">",
    subLanguage: "xml",
    relevance: 0
  }, r = {
    begin: "^[-\\*]{3,}",
    end: "$"
  }, i = {
    className: "code",
    variants: [
      // TODO: fix to allow these to work with sublanguage also
      { begin: "(`{3,})[^`](.|\\n)*?\\1`*[ ]*" },
      { begin: "(~{3,})[^~](.|\\n)*?\\1~*[ ]*" },
      // needed to allow markdown as a sublanguage to work
      {
        begin: "```",
        end: "```+[ ]*$"
      },
      {
        begin: "~~~",
        end: "~~~+[ ]*$"
      },
      { begin: "`.+?`" },
      {
        begin: "(?=^( {4}|\\t))",
        // use contains to gobble up multiple lines to allow the block to be whatever size
        // but only have a single open/close tag vs one per line
        contains: [
          {
            begin: "^( {4}|\\t)",
            end: "(\\n)$"
          }
        ],
        relevance: 0
      }
    ]
  }, a = {
    className: "bullet",
    begin: "^[ 	]*([*+-]|(\\d+\\.))(?=\\s+)",
    end: "\\s+",
    excludeEnd: !0
  }, s = {
    begin: /^\[[^\n]+\]:/,
    returnBegin: !0,
    contains: [
      {
        className: "symbol",
        begin: /\[/,
        end: /\]/,
        excludeBegin: !0,
        excludeEnd: !0
      },
      {
        className: "link",
        begin: /:\s*/,
        end: /$/,
        excludeBegin: !0
      }
    ]
  }, o = /[A-Za-z][A-Za-z0-9+.-]*/, l = {
    variants: [
      // too much like nested array access in so many languages
      // to have any real relevance
      {
        begin: /\[.+?\]\[.*?\]/,
        relevance: 0
      },
      // popular internet URLs
      {
        begin: /\[.+?\]\(((data|javascript|mailto):|(?:http|ftp)s?:\/\/).*?\)/,
        relevance: 2
      },
      {
        begin: t.concat(/\[.+?\]\(/, o, /:\/\/.*?\)/),
        relevance: 2
      },
      // relative urls
      {
        begin: /\[.+?\]\([./?&#].*?\)/,
        relevance: 1
      },
      // whatever else, lower relevance (might not be a link at all)
      {
        begin: /\[.*?\]\(.*?\)/,
        relevance: 0
      }
    ],
    returnBegin: !0,
    contains: [
      {
        // empty strings for alt or link text
        match: /\[(?=\])/
      },
      {
        className: "string",
        relevance: 0,
        begin: "\\[",
        end: "\\]",
        excludeBegin: !0,
        returnEnd: !0
      },
      {
        className: "link",
        relevance: 0,
        begin: "\\]\\(",
        end: "\\)",
        excludeBegin: !0,
        excludeEnd: !0
      },
      {
        className: "symbol",
        relevance: 0,
        begin: "\\]\\[",
        end: "\\]",
        excludeBegin: !0,
        excludeEnd: !0
      }
    ]
  }, c = {
    className: "strong",
    contains: [],
    // defined later
    variants: [
      {
        begin: /_{2}(?!\s)/,
        end: /_{2}/
      },
      {
        begin: /\*{2}(?!\s)/,
        end: /\*{2}/
      }
    ]
  }, u = {
    className: "emphasis",
    contains: [],
    // defined later
    variants: [
      {
        begin: /\*(?![*\s])/,
        end: /\*/
      },
      {
        begin: /_(?![_\s])/,
        end: /_/,
        relevance: 0
      }
    ]
  }, d = e.inherit(c, { contains: [] }), f = e.inherit(u, { contains: [] });
  c.contains.push(f), u.contains.push(d);
  let p = [
    n,
    l
  ];
  return [
    c,
    u,
    d,
    f
  ].forEach((b) => {
    b.contains = b.contains.concat(p);
  }), p = p.concat(c, u), {
    name: "Markdown",
    aliases: [
      "md",
      "mkdown",
      "mkd"
    ],
    contains: [
      {
        className: "section",
        variants: [
          {
            begin: "^#{1,6}",
            end: "$",
            contains: p
          },
          {
            begin: "(?=^.+?\\n[=-]{2,}$)",
            contains: [
              { begin: "^[=-]*$" },
              {
                begin: "^",
                end: "\\n",
                contains: p
              }
            ]
          }
        ]
      },
      n,
      a,
      c,
      u,
      {
        className: "quote",
        begin: "^>\\s+",
        contains: p,
        end: "$"
      },
      i,
      r,
      l,
      s,
      {
        //https://spec.commonmark.org/0.31.2/#entity-references
        scope: "literal",
        match: /&([a-zA-Z0-9]+|#[0-9]{1,7}|#[Xx][0-9a-fA-F]{1,6});/
      }
    ]
  };
}
function VP(e) {
  const t = {
    className: "built_in",
    begin: "\\b(AV|CA|CF|CG|CI|CL|CM|CN|CT|MK|MP|MTK|MTL|NS|SCN|SK|UI|WK|XC)\\w+"
  }, n = /[a-zA-Z@][a-zA-Z0-9_]*/, o = {
    "variable.language": [
      "this",
      "super"
    ],
    $pattern: n,
    keyword: [
      "while",
      "export",
      "sizeof",
      "typedef",
      "const",
      "struct",
      "for",
      "union",
      "volatile",
      "static",
      "mutable",
      "if",
      "do",
      "return",
      "goto",
      "enum",
      "else",
      "break",
      "extern",
      "asm",
      "case",
      "default",
      "register",
      "explicit",
      "typename",
      "switch",
      "continue",
      "inline",
      "readonly",
      "assign",
      "readwrite",
      "self",
      "@synchronized",
      "id",
      "typeof",
      "nonatomic",
      "IBOutlet",
      "IBAction",
      "strong",
      "weak",
      "copy",
      "in",
      "out",
      "inout",
      "bycopy",
      "byref",
      "oneway",
      "__strong",
      "__weak",
      "__block",
      "__autoreleasing",
      "@private",
      "@protected",
      "@public",
      "@try",
      "@property",
      "@end",
      "@throw",
      "@catch",
      "@finally",
      "@autoreleasepool",
      "@synthesize",
      "@dynamic",
      "@selector",
      "@optional",
      "@required",
      "@encode",
      "@package",
      "@import",
      "@defs",
      "@compatibility_alias",
      "__bridge",
      "__bridge_transfer",
      "__bridge_retained",
      "__bridge_retain",
      "__covariant",
      "__contravariant",
      "__kindof",
      "_Nonnull",
      "_Nullable",
      "_Null_unspecified",
      "__FUNCTION__",
      "__PRETTY_FUNCTION__",
      "__attribute__",
      "getter",
      "setter",
      "retain",
      "unsafe_unretained",
      "nonnull",
      "nullable",
      "null_unspecified",
      "null_resettable",
      "class",
      "instancetype",
      "NS_DESIGNATED_INITIALIZER",
      "NS_UNAVAILABLE",
      "NS_REQUIRES_SUPER",
      "NS_RETURNS_INNER_POINTER",
      "NS_INLINE",
      "NS_AVAILABLE",
      "NS_DEPRECATED",
      "NS_ENUM",
      "NS_OPTIONS",
      "NS_SWIFT_UNAVAILABLE",
      "NS_ASSUME_NONNULL_BEGIN",
      "NS_ASSUME_NONNULL_END",
      "NS_REFINED_FOR_SWIFT",
      "NS_SWIFT_NAME",
      "NS_SWIFT_NOTHROW",
      "NS_DURING",
      "NS_HANDLER",
      "NS_ENDHANDLER",
      "NS_VALUERETURN",
      "NS_VOIDRETURN"
    ],
    literal: [
      "false",
      "true",
      "FALSE",
      "TRUE",
      "nil",
      "YES",
      "NO",
      "NULL"
    ],
    built_in: [
      "dispatch_once_t",
      "dispatch_queue_t",
      "dispatch_sync",
      "dispatch_async",
      "dispatch_once"
    ],
    type: [
      "int",
      "float",
      "char",
      "unsigned",
      "signed",
      "short",
      "long",
      "double",
      "wchar_t",
      "unichar",
      "void",
      "bool",
      "BOOL",
      "id|0",
      "_Bool"
    ]
  }, l = {
    $pattern: n,
    keyword: [
      "@interface",
      "@class",
      "@protocol",
      "@implementation"
    ]
  };
  return {
    name: "Objective-C",
    aliases: [
      "mm",
      "objc",
      "obj-c",
      "obj-c++",
      "objective-c++"
    ],
    keywords: o,
    illegal: "</",
    contains: [
      t,
      e.C_LINE_COMMENT_MODE,
      e.C_BLOCK_COMMENT_MODE,
      e.C_NUMBER_MODE,
      e.QUOTE_STRING_MODE,
      e.APOS_STRING_MODE,
      {
        className: "string",
        variants: [
          {
            begin: '@"',
            end: '"',
            illegal: "\\n",
            contains: [e.BACKSLASH_ESCAPE]
          }
        ]
      },
      {
        className: "meta",
        begin: /#\s*[a-z]+\b/,
        end: /$/,
        keywords: { keyword: "if else elif endif define undef warning error line pragma ifdef ifndef include" },
        contains: [
          {
            begin: /\\\n/,
            relevance: 0
          },
          e.inherit(e.QUOTE_STRING_MODE, { className: "string" }),
          {
            className: "string",
            begin: /<.*?>/,
            end: /$/,
            illegal: "\\n"
          },
          e.C_LINE_COMMENT_MODE,
          e.C_BLOCK_COMMENT_MODE
        ]
      },
      {
        className: "class",
        begin: "(" + l.keyword.join("|") + ")\\b",
        end: /(\{|$)/,
        excludeEnd: !0,
        keywords: l,
        contains: [e.UNDERSCORE_TITLE_MODE]
      },
      {
        begin: "\\." + e.UNDERSCORE_IDENT_RE,
        relevance: 0
      }
    ]
  };
}
function GP(e) {
  const t = e.regex, n = [
    "abs",
    "accept",
    "alarm",
    "and",
    "atan2",
    "bind",
    "binmode",
    "bless",
    "break",
    "caller",
    "chdir",
    "chmod",
    "chomp",
    "chop",
    "chown",
    "chr",
    "chroot",
    "class",
    "close",
    "closedir",
    "connect",
    "continue",
    "cos",
    "crypt",
    "dbmclose",
    "dbmopen",
    "defined",
    "delete",
    "die",
    "do",
    "dump",
    "each",
    "else",
    "elsif",
    "endgrent",
    "endhostent",
    "endnetent",
    "endprotoent",
    "endpwent",
    "endservent",
    "eof",
    "eval",
    "exec",
    "exists",
    "exit",
    "exp",
    "fcntl",
    "field",
    "fileno",
    "flock",
    "for",
    "foreach",
    "fork",
    "format",
    "formline",
    "getc",
    "getgrent",
    "getgrgid",
    "getgrnam",
    "gethostbyaddr",
    "gethostbyname",
    "gethostent",
    "getlogin",
    "getnetbyaddr",
    "getnetbyname",
    "getnetent",
    "getpeername",
    "getpgrp",
    "getpriority",
    "getprotobyname",
    "getprotobynumber",
    "getprotoent",
    "getpwent",
    "getpwnam",
    "getpwuid",
    "getservbyname",
    "getservbyport",
    "getservent",
    "getsockname",
    "getsockopt",
    "given",
    "glob",
    "gmtime",
    "goto",
    "grep",
    "gt",
    "hex",
    "if",
    "index",
    "int",
    "ioctl",
    "join",
    "keys",
    "kill",
    "last",
    "lc",
    "lcfirst",
    "length",
    "link",
    "listen",
    "local",
    "localtime",
    "log",
    "lstat",
    "lt",
    "ma",
    "map",
    "method",
    "mkdir",
    "msgctl",
    "msgget",
    "msgrcv",
    "msgsnd",
    "my",
    "ne",
    "next",
    "no",
    "not",
    "oct",
    "open",
    "opendir",
    "or",
    "ord",
    "our",
    "pack",
    "package",
    "pipe",
    "pop",
    "pos",
    "print",
    "printf",
    "prototype",
    "push",
    "q|0",
    "qq",
    "quotemeta",
    "qw",
    "qx",
    "rand",
    "read",
    "readdir",
    "readline",
    "readlink",
    "readpipe",
    "recv",
    "redo",
    "ref",
    "rename",
    "require",
    "reset",
    "return",
    "reverse",
    "rewinddir",
    "rindex",
    "rmdir",
    "say",
    "scalar",
    "seek",
    "seekdir",
    "select",
    "semctl",
    "semget",
    "semop",
    "send",
    "setgrent",
    "sethostent",
    "setnetent",
    "setpgrp",
    "setpriority",
    "setprotoent",
    "setpwent",
    "setservent",
    "setsockopt",
    "shift",
    "shmctl",
    "shmget",
    "shmread",
    "shmwrite",
    "shutdown",
    "sin",
    "sleep",
    "socket",
    "socketpair",
    "sort",
    "splice",
    "split",
    "sprintf",
    "sqrt",
    "srand",
    "stat",
    "state",
    "study",
    "sub",
    "substr",
    "symlink",
    "syscall",
    "sysopen",
    "sysread",
    "sysseek",
    "system",
    "syswrite",
    "tell",
    "telldir",
    "tie",
    "tied",
    "time",
    "times",
    "tr",
    "truncate",
    "uc",
    "ucfirst",
    "umask",
    "undef",
    "unless",
    "unlink",
    "unpack",
    "unshift",
    "untie",
    "until",
    "use",
    "utime",
    "values",
    "vec",
    "wait",
    "waitpid",
    "wantarray",
    "warn",
    "when",
    "while",
    "write",
    "x|0",
    "xor",
    "y|0"
  ], r = /[dualxmsipngr]{0,12}/, i = {
    $pattern: /[\w.]+/,
    keyword: n.join(" ")
  }, a = {
    className: "subst",
    begin: "[$@]\\{",
    end: "\\}",
    keywords: i
  }, s = {
    begin: /->\{/,
    end: /\}/
    // contains defined later
  }, o = {
    scope: "attr",
    match: /\s+:\s*\w+(\s*\(.*?\))?/
  }, l = {
    scope: "variable",
    variants: [
      { begin: /\$\d/ },
      {
        begin: t.concat(
          /[$%@](?!")(\^\w\b|#\w+(::\w+)*|\{\w+\}|\w+(::\w*)*)/,
          // negative look-ahead tries to avoid matching patterns that are not
          // Perl at all like $ident$, @ident@, etc.
          "(?![A-Za-z])(?![@$%])"
        )
      },
      {
        // Only $= is a special Perl variable and one can't declare @= or %=.
        begin: /[$%@](?!")[^\s\w{=]|\$=/,
        relevance: 0
      }
    ],
    contains: [o]
  }, c = {
    className: "number",
    variants: [
      // decimal numbers:
      // include the case where a number starts with a dot (eg. .9), and
      // the leading 0? avoids mixing the first and second match on 0.x cases
      { match: /0?\.[0-9][0-9_]+\b/ },
      // include the special versioned number (eg. v5.38)
      { match: /\bv?(0|[1-9][0-9_]*(\.[0-9_]+)?|[1-9][0-9_]*)\b/ },
      // non-decimal numbers:
      { match: /\b0[0-7][0-7_]*\b/ },
      { match: /\b0x[0-9a-fA-F][0-9a-fA-F_]*\b/ },
      { match: /\b0b[0-1][0-1_]*\b/ }
    ],
    relevance: 0
  }, u = [
    e.BACKSLASH_ESCAPE,
    a,
    l
  ], d = [
    /!/,
    /\//,
    /\|/,
    /\?/,
    /'/,
    /"/,
    // valid but infrequent and weird
    /#/
    // valid but infrequent and weird
  ], f = (g, m, b = "\\1") => {
    const y = b === "\\1" ? b : t.concat(b, m);
    return t.concat(
      t.concat("(?:", g, ")"),
      m,
      /(?:\\.|[^\\\/])*?/,
      y,
      /(?:\\.|[^\\\/])*?/,
      b,
      r
    );
  }, p = (g, m, b) => t.concat(
    t.concat("(?:", g, ")"),
    m,
    /(?:\\.|[^\\\/])*?/,
    b,
    r
  ), h = [
    l,
    e.HASH_COMMENT_MODE,
    e.COMMENT(
      /^=\w/,
      /=cut/,
      { endsWithParent: !0 }
    ),
    s,
    {
      className: "string",
      contains: u,
      variants: [
        {
          begin: "q[qwxr]?\\s*\\(",
          end: "\\)",
          relevance: 5
        },
        {
          begin: "q[qwxr]?\\s*\\[",
          end: "\\]",
          relevance: 5
        },
        {
          begin: "q[qwxr]?\\s*\\{",
          end: "\\}",
          relevance: 5
        },
        {
          begin: "q[qwxr]?\\s*\\|",
          end: "\\|",
          relevance: 5
        },
        {
          begin: "q[qwxr]?\\s*<",
          end: ">",
          relevance: 5
        },
        {
          begin: "qw\\s+q",
          end: "q",
          relevance: 5
        },
        {
          begin: "'",
          end: "'",
          contains: [e.BACKSLASH_ESCAPE]
        },
        {
          begin: '"',
          end: '"'
        },
        {
          begin: "`",
          end: "`",
          contains: [e.BACKSLASH_ESCAPE]
        },
        {
          begin: /\{\w+\}/,
          relevance: 0
        },
        {
          begin: "-?\\w+\\s*=>",
          relevance: 0
        }
      ]
    },
    c,
    {
      // regexp container
      begin: "(\\/\\/|" + e.RE_STARTERS_RE + "|\\b(split|return|print|reverse|grep)\\b)\\s*",
      keywords: "split return print reverse grep",
      relevance: 0,
      contains: [
        e.HASH_COMMENT_MODE,
        {
          className: "regexp",
          variants: [
            // allow matching common delimiters
            { begin: f("s|tr|y", t.either(...d, { capture: !0 })) },
            // and then paired delmis
            { begin: f("s|tr|y", "\\(", "\\)") },
            { begin: f("s|tr|y", "\\[", "\\]") },
            { begin: f("s|tr|y", "\\{", "\\}") }
          ],
          relevance: 2
        },
        {
          className: "regexp",
          variants: [
            {
              // could be a comment in many languages so do not count
              // as relevant
              begin: /(m|qr)\/\//,
              relevance: 0
            },
            // prefix is optional with /regex/
            { begin: p("(?:m|qr)?", /\//, /\//) },
            // allow matching common delimiters
            { begin: p("m|qr", t.either(...d, { capture: !0 }), /\1/) },
            // allow common paired delmins
            { begin: p("m|qr", /\(/, /\)/) },
            { begin: p("m|qr", /\[/, /\]/) },
            { begin: p("m|qr", /\{/, /\}/) }
          ]
        }
      ]
    },
    {
      className: "function",
      beginKeywords: "sub method",
      end: "(\\s*\\(.*?\\))?[;{]",
      excludeEnd: !0,
      relevance: 5,
      contains: [e.TITLE_MODE, o]
    },
    {
      className: "class",
      beginKeywords: "class",
      end: "[;{]",
      excludeEnd: !0,
      relevance: 5,
      contains: [e.TITLE_MODE, o, c]
    },
    {
      begin: "-\\w\\b",
      relevance: 0
    },
    {
      begin: "^__DATA__$",
      end: "^__END__$",
      subLanguage: "mojolicious",
      contains: [
        {
          begin: "^@@.*",
          end: "$",
          className: "comment"
        }
      ]
    }
  ];
  return a.contains = h, s.contains = h, {
    name: "Perl",
    aliases: [
      "pl",
      "pm"
    ],
    keywords: i,
    contains: h
  };
}
function jP(e) {
  const t = e.regex, n = /(?![A-Za-z0-9])(?![$])/, r = t.concat(
    /[a-zA-Z_\x7f-\xff][a-zA-Z0-9_\x7f-\xff]*/,
    n
  ), i = t.concat(
    /(\\?[A-Z][a-z0-9_\x7f-\xff]+|\\?[A-Z]+(?=[A-Z][a-z0-9_\x7f-\xff])){1,}/,
    n
  ), a = t.concat(
    /[A-Z]+/,
    n
  ), s = {
    scope: "variable",
    match: "\\$+" + r
  }, o = {
    scope: "meta",
    variants: [
      { begin: /<\?php/, relevance: 10 },
      // boost for obvious PHP
      { begin: /<\?=/ },
      // less relevant per PSR-1 which says not to use short-tags
      { begin: /<\?/, relevance: 0.1 },
      { begin: /\?>/ }
      // end php tag
    ]
  }, l = {
    scope: "subst",
    variants: [
      { begin: /\$\w+/ },
      {
        begin: /\{\$/,
        end: /\}/
      }
    ]
  }, c = e.inherit(e.APOS_STRING_MODE, { illegal: null }), u = e.inherit(e.QUOTE_STRING_MODE, {
    illegal: null,
    contains: e.QUOTE_STRING_MODE.contains.concat(l)
  }), d = {
    begin: /<<<[ \t]*(?:(\w+)|"(\w+)")\n/,
    end: /[ \t]*(\w+)\b/,
    contains: e.QUOTE_STRING_MODE.contains.concat(l),
    "on:begin": (z, U) => {
      U.data._beginMatch = z[1] || z[2];
    },
    "on:end": (z, U) => {
      U.data._beginMatch !== z[1] && U.ignoreMatch();
    }
  }, f = e.END_SAME_AS_BEGIN({
    begin: /<<<[ \t]*'(\w+)'\n/,
    end: /[ \t]*(\w+)\b/
  }), p = `[ 	
]`, h = {
    scope: "string",
    variants: [
      u,
      c,
      d,
      f
    ]
  }, g = {
    scope: "number",
    variants: [
      { begin: "\\b0[bB][01]+(?:_[01]+)*\\b" },
      // Binary w/ underscore support
      { begin: "\\b0[oO][0-7]+(?:_[0-7]+)*\\b" },
      // Octals w/ underscore support
      { begin: "\\b0[xX][\\da-fA-F]+(?:_[\\da-fA-F]+)*\\b" },
      // Hex w/ underscore support
      // Decimals w/ underscore support, with optional fragments and scientific exponent (e) suffix.
      { begin: "(?:\\b\\d+(?:_\\d+)*(\\.(?:\\d+(?:_\\d+)*))?|\\B\\.\\d+)(?:[eE][+-]?\\d+)?" }
    ],
    relevance: 0
  }, m = [
    "false",
    "null",
    "true"
  ], b = [
    // Magic constants:
    // <https://www.php.net/manual/en/language.constants.predefined.php>
    "__CLASS__",
    "__DIR__",
    "__FILE__",
    "__FUNCTION__",
    "__COMPILER_HALT_OFFSET__",
    "__LINE__",
    "__METHOD__",
    "__NAMESPACE__",
    "__TRAIT__",
    // Function that look like language construct or language construct that look like function:
    // List of keywords that may not require parenthesis
    "die",
    "echo",
    "exit",
    "include",
    "include_once",
    "print",
    "require",
    "require_once",
    // These are not language construct (function) but operate on the currently-executing function and can access the current symbol table
    // 'compact extract func_get_arg func_get_args func_num_args get_called_class get_parent_class ' +
    // Other keywords:
    // <https://www.php.net/manual/en/reserved.php>
    // <https://www.php.net/manual/en/language.types.type-juggling.php>
    "array",
    "abstract",
    "and",
    "as",
    "binary",
    "bool",
    "boolean",
    "break",
    "callable",
    "case",
    "catch",
    "class",
    "clone",
    "const",
    "continue",
    "declare",
    "default",
    "do",
    "double",
    "else",
    "elseif",
    "empty",
    "enddeclare",
    "endfor",
    "endforeach",
    "endif",
    "endswitch",
    "endwhile",
    "enum",
    "eval",
    "extends",
    "final",
    "finally",
    "float",
    "for",
    "foreach",
    "from",
    "global",
    "goto",
    "if",
    "implements",
    "instanceof",
    "insteadof",
    "int",
    "integer",
    "interface",
    "isset",
    "iterable",
    "list",
    "match|0",
    "mixed",
    "new",
    "never",
    "object",
    "or",
    "private",
    "protected",
    "public",
    "readonly",
    "real",
    "return",
    "string",
    "switch",
    "throw",
    "trait",
    "try",
    "unset",
    "use",
    "var",
    "void",
    "while",
    "xor",
    "yield"
  ], y = [
    // Standard PHP library:
    // <https://www.php.net/manual/en/book.spl.php>
    "Error|0",
    "AppendIterator",
    "ArgumentCountError",
    "ArithmeticError",
    "ArrayIterator",
    "ArrayObject",
    "AssertionError",
    "BadFunctionCallException",
    "BadMethodCallException",
    "CachingIterator",
    "CallbackFilterIterator",
    "CompileError",
    "Countable",
    "DirectoryIterator",
    "DivisionByZeroError",
    "DomainException",
    "EmptyIterator",
    "ErrorException",
    "Exception",
    "FilesystemIterator",
    "FilterIterator",
    "GlobIterator",
    "InfiniteIterator",
    "InvalidArgumentException",
    "IteratorIterator",
    "LengthException",
    "LimitIterator",
    "LogicException",
    "MultipleIterator",
    "NoRewindIterator",
    "OutOfBoundsException",
    "OutOfRangeException",
    "OuterIterator",
    "OverflowException",
    "ParentIterator",
    "ParseError",
    "RangeException",
    "RecursiveArrayIterator",
    "RecursiveCachingIterator",
    "RecursiveCallbackFilterIterator",
    "RecursiveDirectoryIterator",
    "RecursiveFilterIterator",
    "RecursiveIterator",
    "RecursiveIteratorIterator",
    "RecursiveRegexIterator",
    "RecursiveTreeIterator",
    "RegexIterator",
    "RuntimeException",
    "SeekableIterator",
    "SplDoublyLinkedList",
    "SplFileInfo",
    "SplFileObject",
    "SplFixedArray",
    "SplHeap",
    "SplMaxHeap",
    "SplMinHeap",
    "SplObjectStorage",
    "SplObserver",
    "SplPriorityQueue",
    "SplQueue",
    "SplStack",
    "SplSubject",
    "SplTempFileObject",
    "TypeError",
    "UnderflowException",
    "UnexpectedValueException",
    "UnhandledMatchError",
    // Reserved interfaces:
    // <https://www.php.net/manual/en/reserved.interfaces.php>
    "ArrayAccess",
    "BackedEnum",
    "Closure",
    "Fiber",
    "Generator",
    "Iterator",
    "IteratorAggregate",
    "Serializable",
    "Stringable",
    "Throwable",
    "Traversable",
    "UnitEnum",
    "WeakReference",
    "WeakMap",
    // Reserved classes:
    // <https://www.php.net/manual/en/reserved.classes.php>
    "Directory",
    "__PHP_Incomplete_Class",
    "parent",
    "php_user_filter",
    "self",
    "static",
    "stdClass"
  ], E = {
    keyword: b,
    literal: ((z) => {
      const U = [];
      return z.forEach(($) => {
        U.push($), $.toLowerCase() === $ ? U.push($.toUpperCase()) : U.push($.toLowerCase());
      }), U;
    })(m),
    built_in: y
  }, _ = (z) => z.map((U) => U.replace(/\|\d+$/, "")), x = { variants: [
    {
      match: [
        /new/,
        t.concat(p, "+"),
        // to prevent built ins from being confused as the class constructor call
        t.concat("(?!", _(y).join("\\b|"), "\\b)"),
        i
      ],
      scope: {
        1: "keyword",
        4: "title.class"
      }
    }
  ] }, I = t.concat(r, "\\b(?!\\()"), T = { variants: [
    {
      match: [
        t.concat(
          /::/,
          t.lookahead(/(?!class\b)/)
        ),
        I
      ],
      scope: { 2: "variable.constant" }
    },
    {
      match: [
        /::/,
        /class/
      ],
      scope: { 2: "variable.language" }
    },
    {
      match: [
        i,
        t.concat(
          /::/,
          t.lookahead(/(?!class\b)/)
        ),
        I
      ],
      scope: {
        1: "title.class",
        3: "variable.constant"
      }
    },
    {
      match: [
        i,
        t.concat(
          "::",
          t.lookahead(/(?!class\b)/)
        )
      ],
      scope: { 1: "title.class" }
    },
    {
      match: [
        i,
        /::/,
        /class/
      ],
      scope: {
        1: "title.class",
        3: "variable.language"
      }
    }
  ] }, O = {
    scope: "attr",
    match: t.concat(r, t.lookahead(":"), t.lookahead(/(?!::)/))
  }, k = {
    relevance: 0,
    begin: /\(/,
    end: /\)/,
    keywords: E,
    contains: [
      O,
      s,
      T,
      e.C_BLOCK_COMMENT_MODE,
      h,
      g,
      x
    ]
  }, W = {
    relevance: 0,
    match: [
      /\b/,
      // to prevent keywords from being confused as the function title
      t.concat("(?!fn\\b|function\\b|", _(b).join("\\b|"), "|", _(y).join("\\b|"), "\\b)"),
      r,
      t.concat(p, "*"),
      t.lookahead(/(?=\()/)
    ],
    scope: { 3: "title.function.invoke" },
    contains: [k]
  };
  k.contains.push(W);
  const M = [
    O,
    T,
    e.C_BLOCK_COMMENT_MODE,
    h,
    g,
    x
  ], L = {
    begin: t.concat(
      /#\[\s*\\?/,
      t.either(
        i,
        a
      )
    ),
    beginScope: "meta",
    end: /]/,
    endScope: "meta",
    keywords: {
      literal: m,
      keyword: [
        "new",
        "array"
      ]
    },
    contains: [
      {
        begin: /\[/,
        end: /]/,
        keywords: {
          literal: m,
          keyword: [
            "new",
            "array"
          ]
        },
        contains: [
          "self",
          ...M
        ]
      },
      ...M,
      {
        scope: "meta",
        variants: [
          { match: i },
          { match: a }
        ]
      }
    ]
  };
  return {
    case_insensitive: !1,
    keywords: E,
    contains: [
      L,
      e.HASH_COMMENT_MODE,
      e.COMMENT("//", "$"),
      e.COMMENT(
        "/\\*",
        "\\*/",
        { contains: [
          {
            scope: "doctag",
            match: "@[A-Za-z]+"
          }
        ] }
      ),
      {
        match: /__halt_compiler\(\);/,
        keywords: "__halt_compiler",
        starts: {
          scope: "comment",
          end: e.MATCH_NOTHING_RE,
          contains: [
            {
              match: /\?>/,
              scope: "meta",
              endsParent: !0
            }
          ]
        }
      },
      o,
      {
        scope: "variable.language",
        match: /\$this\b/
      },
      s,
      W,
      T,
      {
        match: [
          /const/,
          /\s/,
          r
        ],
        scope: {
          1: "keyword",
          3: "variable.constant"
        }
      },
      x,
      {
        scope: "function",
        relevance: 0,
        beginKeywords: "fn function",
        end: /[;{]/,
        excludeEnd: !0,
        illegal: "[$%\\[]",
        contains: [
          { beginKeywords: "use" },
          e.UNDERSCORE_TITLE_MODE,
          {
            begin: "=>",
            // No markup, just a relevance booster
            endsParent: !0
          },
          {
            scope: "params",
            begin: "\\(",
            end: "\\)",
            excludeBegin: !0,
            excludeEnd: !0,
            keywords: E,
            contains: [
              "self",
              L,
              s,
              T,
              e.C_BLOCK_COMMENT_MODE,
              h,
              g
            ]
          }
        ]
      },
      {
        scope: "class",
        variants: [
          {
            beginKeywords: "enum",
            illegal: /[($"]/
          },
          {
            beginKeywords: "class interface trait",
            illegal: /[:($"]/
          }
        ],
        relevance: 0,
        end: /\{/,
        excludeEnd: !0,
        contains: [
          { beginKeywords: "extends implements" },
          e.UNDERSCORE_TITLE_MODE
        ]
      },
      // both use and namespace still use "old style" rules (vs multi-match)
      // because the namespace name can include `\` and we still want each
      // element to be treated as its own *individual* title
      {
        beginKeywords: "namespace",
        relevance: 0,
        end: ";",
        illegal: /[.']/,
        contains: [e.inherit(e.UNDERSCORE_TITLE_MODE, { scope: "title.class" })]
      },
      {
        beginKeywords: "use",
        relevance: 0,
        end: ";",
        contains: [
          // TODO: title.function vs title.class
          {
            match: /\b(as|const|function)\b/,
            scope: "keyword"
          },
          // TODO: could be title.class or title.function
          e.UNDERSCORE_TITLE_MODE
        ]
      },
      h,
      g
    ]
  };
}
function UP(e) {
  return {
    name: "PHP template",
    subLanguage: "xml",
    contains: [
      {
        begin: /<\?(php|=)?/,
        end: /\?>/,
        subLanguage: "php",
        contains: [
          // We don't want the php closing tag ?> to close the PHP block when
          // inside any of the following blocks:
          {
            begin: "/\\*",
            end: "\\*/",
            skip: !0
          },
          {
            begin: 'b"',
            end: '"',
            skip: !0
          },
          {
            begin: "b'",
            end: "'",
            skip: !0
          },
          e.inherit(e.APOS_STRING_MODE, {
            illegal: null,
            className: null,
            contains: null,
            skip: !0
          }),
          e.inherit(e.QUOTE_STRING_MODE, {
            illegal: null,
            className: null,
            contains: null,
            skip: !0
          })
        ]
      }
    ]
  };
}
function HP(e) {
  return {
    name: "Plain text",
    aliases: [
      "text",
      "txt"
    ],
    disableAutodetect: !0
  };
}
function WP(e) {
  const t = e.regex, n = new RegExp("[\\p{XID_Start}_]\\p{XID_Continue}*", "u"), r = [
    "and",
    "as",
    "assert",
    "async",
    "await",
    "break",
    "case",
    "class",
    "continue",
    "def",
    "del",
    "elif",
    "else",
    "except",
    "finally",
    "for",
    "from",
    "global",
    "if",
    "import",
    "in",
    "is",
    "lambda",
    "match",
    "nonlocal|10",
    "not",
    "or",
    "pass",
    "raise",
    "return",
    "try",
    "while",
    "with",
    "yield"
  ], o = {
    $pattern: /[A-Za-z]\w+|__\w+__/,
    keyword: r,
    built_in: [
      "__import__",
      "abs",
      "all",
      "any",
      "ascii",
      "bin",
      "bool",
      "breakpoint",
      "bytearray",
      "bytes",
      "callable",
      "chr",
      "classmethod",
      "compile",
      "complex",
      "delattr",
      "dict",
      "dir",
      "divmod",
      "enumerate",
      "eval",
      "exec",
      "filter",
      "float",
      "format",
      "frozenset",
      "getattr",
      "globals",
      "hasattr",
      "hash",
      "help",
      "hex",
      "id",
      "input",
      "int",
      "isinstance",
      "issubclass",
      "iter",
      "len",
      "list",
      "locals",
      "map",
      "max",
      "memoryview",
      "min",
      "next",
      "object",
      "oct",
      "open",
      "ord",
      "pow",
      "print",
      "property",
      "range",
      "repr",
      "reversed",
      "round",
      "set",
      "setattr",
      "slice",
      "sorted",
      "staticmethod",
      "str",
      "sum",
      "super",
      "tuple",
      "type",
      "vars",
      "zip"
    ],
    literal: [
      "__debug__",
      "Ellipsis",
      "False",
      "None",
      "NotImplemented",
      "True"
    ],
    type: [
      "Any",
      "Callable",
      "Coroutine",
      "Dict",
      "List",
      "Literal",
      "Generic",
      "Optional",
      "Sequence",
      "Set",
      "Tuple",
      "Type",
      "Union"
    ]
  }, l = {
    className: "meta",
    begin: /^(>>>|\.\.\.) /
  }, c = {
    className: "subst",
    begin: /\{/,
    end: /\}/,
    keywords: o,
    illegal: /#/
  }, u = {
    begin: /\{\{/,
    relevance: 0
  }, d = {
    className: "string",
    contains: [e.BACKSLASH_ESCAPE],
    variants: [
      {
        begin: /([uU]|[bB]|[rR]|[bB][rR]|[rR][bB])?'''/,
        end: /'''/,
        contains: [
          e.BACKSLASH_ESCAPE,
          l
        ],
        relevance: 10
      },
      {
        begin: /([uU]|[bB]|[rR]|[bB][rR]|[rR][bB])?"""/,
        end: /"""/,
        contains: [
          e.BACKSLASH_ESCAPE,
          l
        ],
        relevance: 10
      },
      {
        begin: /([fF][rR]|[rR][fF]|[fF])'''/,
        end: /'''/,
        contains: [
          e.BACKSLASH_ESCAPE,
          l,
          u,
          c
        ]
      },
      {
        begin: /([fF][rR]|[rR][fF]|[fF])"""/,
        end: /"""/,
        contains: [
          e.BACKSLASH_ESCAPE,
          l,
          u,
          c
        ]
      },
      {
        begin: /([uU]|[rR])'/,
        end: /'/,
        relevance: 10
      },
      {
        begin: /([uU]|[rR])"/,
        end: /"/,
        relevance: 10
      },
      {
        begin: /([bB]|[bB][rR]|[rR][bB])'/,
        end: /'/
      },
      {
        begin: /([bB]|[bB][rR]|[rR][bB])"/,
        end: /"/
      },
      {
        begin: /([fF][rR]|[rR][fF]|[fF])'/,
        end: /'/,
        contains: [
          e.BACKSLASH_ESCAPE,
          u,
          c
        ]
      },
      {
        begin: /([fF][rR]|[rR][fF]|[fF])"/,
        end: /"/,
        contains: [
          e.BACKSLASH_ESCAPE,
          u,
          c
        ]
      },
      e.APOS_STRING_MODE,
      e.QUOTE_STRING_MODE
    ]
  }, f = "[0-9](_?[0-9])*", p = `(\\b(${f}))?\\.(${f})|\\b(${f})\\.`, h = `\\b|${r.join("|")}`, g = {
    className: "number",
    relevance: 0,
    variants: [
      // exponentfloat, pointfloat
      // https://docs.python.org/3.9/reference/lexical_analysis.html#floating-point-literals
      // optionally imaginary
      // https://docs.python.org/3.9/reference/lexical_analysis.html#imaginary-literals
      // Note: no leading \b because floats can start with a decimal point
      // and we don't want to mishandle e.g. `fn(.5)`,
      // no trailing \b for pointfloat because it can end with a decimal point
      // and we don't want to mishandle e.g. `0..hex()`; this should be safe
      // because both MUST contain a decimal point and so cannot be confused with
      // the interior part of an identifier
      {
        begin: `(\\b(${f})|(${p}))[eE][+-]?(${f})[jJ]?(?=${h})`
      },
      {
        begin: `(${p})[jJ]?`
      },
      // decinteger, bininteger, octinteger, hexinteger
      // https://docs.python.org/3.9/reference/lexical_analysis.html#integer-literals
      // optionally "long" in Python 2
      // https://docs.python.org/2.7/reference/lexical_analysis.html#integer-and-long-integer-literals
      // decinteger is optionally imaginary
      // https://docs.python.org/3.9/reference/lexical_analysis.html#imaginary-literals
      {
        begin: `\\b([1-9](_?[0-9])*|0+(_?0)*)[lLjJ]?(?=${h})`
      },
      {
        begin: `\\b0[bB](_?[01])+[lL]?(?=${h})`
      },
      {
        begin: `\\b0[oO](_?[0-7])+[lL]?(?=${h})`
      },
      {
        begin: `\\b0[xX](_?[0-9a-fA-F])+[lL]?(?=${h})`
      },
      // imagnumber (digitpart-based)
      // https://docs.python.org/3.9/reference/lexical_analysis.html#imaginary-literals
      {
        begin: `\\b(${f})[jJ](?=${h})`
      }
    ]
  }, m = {
    className: "comment",
    begin: t.lookahead(/# type:/),
    end: /$/,
    keywords: o,
    contains: [
      {
        // prevent keywords from coloring `type`
        begin: /# type:/
      },
      // comment within a datatype comment includes no keywords
      {
        begin: /#/,
        end: /\b\B/,
        endsWithParent: !0
      }
    ]
  }, b = {
    className: "params",
    variants: [
      // Exclude params in functions without params
      {
        className: "",
        begin: /\(\s*\)/,
        skip: !0
      },
      {
        begin: /\(/,
        end: /\)/,
        excludeBegin: !0,
        excludeEnd: !0,
        keywords: o,
        contains: [
          "self",
          l,
          g,
          d,
          e.HASH_COMMENT_MODE
        ]
      }
    ]
  };
  return c.contains = [
    d,
    g,
    l
  ], {
    name: "Python",
    aliases: [
      "py",
      "gyp",
      "ipython"
    ],
    unicodeRegex: !0,
    keywords: o,
    illegal: /(<\/|\?)|=>/,
    contains: [
      l,
      g,
      {
        // very common convention
        scope: "variable.language",
        match: /\bself\b/
      },
      {
        // eat "if" prior to string so that it won't accidentally be
        // labeled as an f-string
        beginKeywords: "if",
        relevance: 0
      },
      { match: /\bor\b/, scope: "keyword" },
      d,
      m,
      e.HASH_COMMENT_MODE,
      {
        match: [
          /\bdef/,
          /\s+/,
          n
        ],
        scope: {
          1: "keyword",
          3: "title.function"
        },
        contains: [b]
      },
      {
        variants: [
          {
            match: [
              /\bclass/,
              /\s+/,
              n,
              /\s*/,
              /\(\s*/,
              n,
              /\s*\)/
            ]
          },
          {
            match: [
              /\bclass/,
              /\s+/,
              n
            ]
          }
        ],
        scope: {
          1: "keyword",
          3: "title.class",
          6: "title.class.inherited"
        }
      },
      {
        className: "meta",
        begin: /^[\t ]*@/,
        end: /(?=#)|$/,
        contains: [
          g,
          b,
          d
        ]
      }
    ]
  };
}
function ZP(e) {
  return {
    aliases: ["pycon"],
    contains: [
      {
        className: "meta.prompt",
        starts: {
          // a space separates the REPL prefix from the actual code
          // this is purely for cleaner HTML output
          end: / |$/,
          starts: {
            end: "$",
            subLanguage: "python"
          }
        },
        variants: [
          { begin: /^>>>(?=[ ]|$)/ },
          { begin: /^\.\.\.(?=[ ]|$)/ }
        ]
      }
    ]
  };
}
function $P(e) {
  const t = e.regex, n = /(?:(?:[a-zA-Z]|\.[._a-zA-Z])[._a-zA-Z0-9]*)|\.(?!\d)/, r = t.either(
    // Special case: only hexadecimal binary powers can contain fractions
    /0[xX][0-9a-fA-F]+\.[0-9a-fA-F]*[pP][+-]?\d+i?/,
    // Hexadecimal numbers without fraction and optional binary power
    /0[xX][0-9a-fA-F]+(?:[pP][+-]?\d+)?[Li]?/,
    // Decimal numbers
    /(?:\d+(?:\.\d*)?|\.\d+)(?:[eE][+-]?\d+)?[Li]?/
  ), i = /[=!<>:]=|\|\||&&|:::?|<-|<<-|->>|->|\|>|[-+*\/?!$&|:<=>@^~]|\*\*/, a = t.either(
    /[()]/,
    /[{}]/,
    /\[\[/,
    /[[\]]/,
    /\\/,
    /,/
  );
  return {
    name: "R",
    keywords: {
      $pattern: n,
      keyword: "function if in break next repeat else for while",
      literal: "NULL NA TRUE FALSE Inf NaN NA_integer_|10 NA_real_|10 NA_character_|10 NA_complex_|10",
      built_in: (
        // Builtin constants
        "LETTERS letters month.abb month.name pi T F abs acos acosh all any anyNA Arg as.call as.character as.complex as.double as.environment as.integer as.logical as.null.default as.numeric as.raw asin asinh atan atanh attr attributes baseenv browser c call ceiling class Conj cos cosh cospi cummax cummin cumprod cumsum digamma dim dimnames emptyenv exp expression floor forceAndCall gamma gc.time globalenv Im interactive invisible is.array is.atomic is.call is.character is.complex is.double is.environment is.expression is.finite is.function is.infinite is.integer is.language is.list is.logical is.matrix is.na is.name is.nan is.null is.numeric is.object is.pairlist is.raw is.recursive is.single is.symbol lazyLoadDBfetch length lgamma list log max min missing Mod names nargs nzchar oldClass on.exit pos.to.env proc.time prod quote range Re rep retracemem return round seq_along seq_len seq.int sign signif sin sinh sinpi sqrt standardGeneric substitute sum switch tan tanh tanpi tracemem trigamma trunc unclass untracemem UseMethod xtfrm"
      )
    },
    contains: [
      // Roxygen comments
      e.COMMENT(
        /#'/,
        /$/,
        { contains: [
          {
            // Handle `@examples` separately to cause all subsequent code
            // until the next `@`-tag on its own line to be kept as-is,
            // preventing highlighting. This code is example R code, so nested
            // doctags shouldnt be treated as such. See
            // `test/markup/r/roxygen.txt` for an example.
            scope: "doctag",
            match: /@examples/,
            starts: {
              end: t.lookahead(t.either(
                // end if another doc comment
                /\n^#'\s*(?=@[a-zA-Z]+)/,
                // or a line with no comment
                /\n^(?!#')/
              )),
              endsParent: !0
            }
          },
          {
            // Handle `@param` to highlight the parameter name following
            // after.
            scope: "doctag",
            begin: "@param",
            end: /$/,
            contains: [
              {
                scope: "variable",
                variants: [
                  { match: n },
                  { match: /`(?:\\.|[^`\\])+`/ }
                ],
                endsParent: !0
              }
            ]
          },
          {
            scope: "doctag",
            match: /@[a-zA-Z]+/
          },
          {
            scope: "keyword",
            match: /\\[a-zA-Z]+/
          }
        ] }
      ),
      e.HASH_COMMENT_MODE,
      {
        scope: "string",
        contains: [e.BACKSLASH_ESCAPE],
        variants: [
          e.END_SAME_AS_BEGIN({
            begin: /[rR]"(-*)\(/,
            end: /\)(-*)"/
          }),
          e.END_SAME_AS_BEGIN({
            begin: /[rR]"(-*)\{/,
            end: /\}(-*)"/
          }),
          e.END_SAME_AS_BEGIN({
            begin: /[rR]"(-*)\[/,
            end: /\](-*)"/
          }),
          e.END_SAME_AS_BEGIN({
            begin: /[rR]'(-*)\(/,
            end: /\)(-*)'/
          }),
          e.END_SAME_AS_BEGIN({
            begin: /[rR]'(-*)\{/,
            end: /\}(-*)'/
          }),
          e.END_SAME_AS_BEGIN({
            begin: /[rR]'(-*)\[/,
            end: /\](-*)'/
          }),
          {
            begin: '"',
            end: '"',
            relevance: 0
          },
          {
            begin: "'",
            end: "'",
            relevance: 0
          }
        ]
      },
      // Matching numbers immediately following punctuation and operators is
      // tricky since we need to look at the character ahead of a number to
      // ensure the number is not part of an identifier, and we cannot use
      // negative look-behind assertions. So instead we explicitly handle all
      // possible combinations of (operator|punctuation), number.
      // TODO: replace with negative look-behind when available
      // { begin: /(?<![a-zA-Z0-9._])0[xX][0-9a-fA-F]+\.[0-9a-fA-F]*[pP][+-]?\d+i?/ },
      // { begin: /(?<![a-zA-Z0-9._])0[xX][0-9a-fA-F]+([pP][+-]?\d+)?[Li]?/ },
      // { begin: /(?<![a-zA-Z0-9._])(\d+(\.\d*)?|\.\d+)([eE][+-]?\d+)?[Li]?/ }
      {
        relevance: 0,
        variants: [
          {
            scope: {
              1: "operator",
              2: "number"
            },
            match: [
              i,
              r
            ]
          },
          {
            scope: {
              1: "operator",
              2: "number"
            },
            match: [
              /%[^%]*%/,
              r
            ]
          },
          {
            scope: {
              1: "punctuation",
              2: "number"
            },
            match: [
              a,
              r
            ]
          },
          {
            scope: { 2: "number" },
            match: [
              /[^a-zA-Z0-9._]|^/,
              // not part of an identifier, or start of document
              r
            ]
          }
        ]
      },
      // Operators/punctuation when they're not directly followed by numbers
      {
        // Relevance boost for the most common assignment form.
        scope: { 3: "operator" },
        match: [
          n,
          /\s+/,
          /<-/,
          /\s+/
        ]
      },
      {
        scope: "operator",
        relevance: 0,
        variants: [
          { match: i },
          { match: /%[^%]*%/ }
        ]
      },
      {
        scope: "punctuation",
        relevance: 0,
        match: a
      },
      {
        // Escaped identifier
        begin: "`",
        end: "`",
        contains: [{ begin: /\\./ }]
      }
    ]
  };
}
function XP(e) {
  const t = e.regex, n = "([a-zA-Z_]\\w*[!?=]?|[-+~]@|<<|>>|=~|===?|<=>|[<>]=?|\\*\\*|[-/+%^&*~`|]|\\[\\]=?)", r = t.either(
    /\b([A-Z]+[a-z0-9]+)+/,
    // ends in caps
    /\b([A-Z]+[a-z0-9]+)+[A-Z]+/
  ), i = t.concat(r, /(::\w+)*/), s = {
    "variable.constant": [
      "__FILE__",
      "__LINE__",
      "__ENCODING__"
    ],
    "variable.language": [
      "self",
      "super"
    ],
    keyword: [
      "alias",
      "and",
      "begin",
      "BEGIN",
      "break",
      "case",
      "class",
      "defined",
      "do",
      "else",
      "elsif",
      "end",
      "END",
      "ensure",
      "for",
      "if",
      "in",
      "module",
      "next",
      "not",
      "or",
      "redo",
      "require",
      "rescue",
      "retry",
      "return",
      "then",
      "undef",
      "unless",
      "until",
      "when",
      "while",
      "yield",
      ...[
        "include",
        "extend",
        "prepend",
        "public",
        "private",
        "protected",
        "raise",
        "throw"
      ]
    ],
    built_in: [
      "proc",
      "lambda",
      "attr_accessor",
      "attr_reader",
      "attr_writer",
      "define_method",
      "private_constant",
      "module_function"
    ],
    literal: [
      "true",
      "false",
      "nil"
    ]
  }, o = {
    className: "doctag",
    begin: "@[A-Za-z]+"
  }, l = {
    begin: "#<",
    end: ">"
  }, c = [
    e.COMMENT(
      "#",
      "$",
      { contains: [o] }
    ),
    e.COMMENT(
      "^=begin",
      "^=end",
      {
        contains: [o],
        relevance: 10
      }
    ),
    e.COMMENT("^__END__", e.MATCH_NOTHING_RE)
  ], u = {
    className: "subst",
    begin: /#\{/,
    end: /\}/,
    keywords: s
  }, d = {
    className: "string",
    contains: [
      e.BACKSLASH_ESCAPE,
      u
    ],
    variants: [
      {
        begin: /'/,
        end: /'/
      },
      {
        begin: /"/,
        end: /"/
      },
      {
        begin: /`/,
        end: /`/
      },
      {
        begin: /%[qQwWx]?\(/,
        end: /\)/
      },
      {
        begin: /%[qQwWx]?\[/,
        end: /\]/
      },
      {
        begin: /%[qQwWx]?\{/,
        end: /\}/
      },
      {
        begin: /%[qQwWx]?</,
        end: />/
      },
      {
        begin: /%[qQwWx]?\//,
        end: /\//
      },
      {
        begin: /%[qQwWx]?%/,
        end: /%/
      },
      {
        begin: /%[qQwWx]?-/,
        end: /-/
      },
      {
        begin: /%[qQwWx]?\|/,
        end: /\|/
      },
      // in the following expressions, \B in the beginning suppresses recognition of ?-sequences
      // where ? is the last character of a preceding identifier, as in: `func?4`
      { begin: /\B\?(\\\d{1,3})/ },
      { begin: /\B\?(\\x[A-Fa-f0-9]{1,2})/ },
      { begin: /\B\?(\\u\{?[A-Fa-f0-9]{1,6}\}?)/ },
      { begin: /\B\?(\\M-\\C-|\\M-\\c|\\c\\M-|\\M-|\\C-\\M-)[\x20-\x7e]/ },
      { begin: /\B\?\\(c|C-)[\x20-\x7e]/ },
      { begin: /\B\?\\?\S/ },
      // heredocs
      {
        // this guard makes sure that we have an entire heredoc and not a false
        // positive (auto-detect, etc.)
        begin: t.concat(
          /<<[-~]?'?/,
          t.lookahead(/(\w+)(?=\W)[^\n]*\n(?:[^\n]*\n)*?\s*\1\b/)
        ),
        contains: [
          e.END_SAME_AS_BEGIN({
            begin: /(\w+)/,
            end: /(\w+)/,
            contains: [
              e.BACKSLASH_ESCAPE,
              u
            ]
          })
        ]
      }
    ]
  }, f = "[1-9](_?[0-9])*|0", p = "[0-9](_?[0-9])*", h = {
    className: "number",
    relevance: 0,
    variants: [
      // decimal integer/float, optionally exponential or rational, optionally imaginary
      { begin: `\\b(${f})(\\.(${p}))?([eE][+-]?(${p})|r)?i?\\b` },
      // explicit decimal/binary/octal/hexadecimal integer,
      // optionally rational and/or imaginary
      { begin: "\\b0[dD][0-9](_?[0-9])*r?i?\\b" },
      { begin: "\\b0[bB][0-1](_?[0-1])*r?i?\\b" },
      { begin: "\\b0[oO][0-7](_?[0-7])*r?i?\\b" },
      { begin: "\\b0[xX][0-9a-fA-F](_?[0-9a-fA-F])*r?i?\\b" },
      // 0-prefixed implicit octal integer, optionally rational and/or imaginary
      { begin: "\\b0(_?[0-7])+r?i?\\b" }
    ]
  }, g = {
    variants: [
      {
        match: /\(\)/
      },
      {
        className: "params",
        begin: /\(/,
        end: /(?=\))/,
        excludeBegin: !0,
        endsParent: !0,
        keywords: s
      }
    ]
  }, x = [
    d,
    {
      variants: [
        {
          match: [
            /class\s+/,
            i,
            /\s+<\s+/,
            i
          ]
        },
        {
          match: [
            /\b(class|module)\s+/,
            i
          ]
        }
      ],
      scope: {
        2: "title.class",
        4: "title.class.inherited"
      },
      keywords: s
    },
    {
      match: [
        /(include|extend)\s+/,
        i
      ],
      scope: {
        2: "title.class"
      },
      keywords: s
    },
    {
      relevance: 0,
      match: [
        i,
        /\.new[. (]/
      ],
      scope: {
        1: "title.class"
      }
    },
    {
      relevance: 0,
      match: /\b[A-Z][A-Z_0-9]+\b/,
      className: "variable.constant"
    },
    {
      relevance: 0,
      match: r,
      scope: "title.class"
    },
    {
      match: [
        /def/,
        /\s+/,
        n
      ],
      scope: {
        1: "keyword",
        3: "title.function"
      },
      contains: [
        g
      ]
    },
    {
      // swallow namespace qualifiers before symbols
      begin: e.IDENT_RE + "::"
    },
    {
      className: "symbol",
      begin: e.UNDERSCORE_IDENT_RE + "(!|\\?)?:",
      relevance: 0
    },
    {
      className: "symbol",
      begin: ":(?!\\s)",
      contains: [
        d,
        { begin: n }
      ],
      relevance: 0
    },
    h,
    {
      // negative-look forward attempts to prevent false matches like:
      // @ident@ or $ident$ that might indicate this is not ruby at all
      className: "variable",
      begin: "(\\$\\W)|((\\$|@@?)(\\w+))(?=[^@$?])(?![A-Za-z])(?![@$?'])"
    },
    {
      className: "params",
      begin: /\|(?!=)/,
      end: /\|/,
      excludeBegin: !0,
      excludeEnd: !0,
      relevance: 0,
      // this could be a lot of things (in other languages) other than params
      keywords: s
    },
    {
      // regexp container
      begin: "(" + e.RE_STARTERS_RE + "|unless)\\s*",
      keywords: "unless",
      contains: [
        {
          className: "regexp",
          contains: [
            e.BACKSLASH_ESCAPE,
            u
          ],
          illegal: /\n/,
          variants: [
            {
              begin: "/",
              end: "/[a-z]*"
            },
            {
              begin: /%r\{/,
              end: /\}[a-z]*/
            },
            {
              begin: "%r\\(",
              end: "\\)[a-z]*"
            },
            {
              begin: "%r!",
              end: "![a-z]*"
            },
            {
              begin: "%r\\[",
              end: "\\][a-z]*"
            }
          ]
        }
      ].concat(l, c),
      relevance: 0
    }
  ].concat(l, c);
  u.contains = x, g.contains = x;
  const k = [
    {
      begin: /^\s*=>/,
      starts: {
        end: "$",
        contains: x
      }
    },
    {
      className: "meta.prompt",
      begin: "^(" + "[>?]>" + "|" + "[\\w#]+\\(\\w+\\):\\d+:\\d+[>*]" + "|" + "(\\w+-)?\\d+\\.\\d+\\.\\d+(p\\d+)?[^\\d][^>]+>" + ")(?=[ ])",
      starts: {
        end: "$",
        keywords: s,
        contains: x
      }
    }
  ];
  return c.unshift(l), {
    name: "Ruby",
    aliases: [
      "rb",
      "gemspec",
      "podspec",
      "thor",
      "irb"
    ],
    keywords: s,
    illegal: /\/\*/,
    contains: [e.SHEBANG({ binary: "ruby" })].concat(k).concat(c).concat(x)
  };
}
function YP(e) {
  const t = e.regex, n = /(r#)?/, r = t.concat(n, e.UNDERSCORE_IDENT_RE), i = t.concat(n, e.IDENT_RE), a = {
    className: "title.function.invoke",
    relevance: 0,
    begin: t.concat(
      /\b/,
      /(?!let|for|while|if|else|match\b)/,
      i,
      t.lookahead(/\s*\(/)
    )
  }, s = "([ui](8|16|32|64|128|size)|f(32|64))?", o = [
    "abstract",
    "as",
    "async",
    "await",
    "become",
    "box",
    "break",
    "const",
    "continue",
    "crate",
    "do",
    "dyn",
    "else",
    "enum",
    "extern",
    "false",
    "final",
    "fn",
    "for",
    "if",
    "impl",
    "in",
    "let",
    "loop",
    "macro",
    "match",
    "mod",
    "move",
    "mut",
    "override",
    "priv",
    "pub",
    "ref",
    "return",
    "self",
    "Self",
    "static",
    "struct",
    "super",
    "trait",
    "true",
    "try",
    "type",
    "typeof",
    "union",
    "unsafe",
    "unsized",
    "use",
    "virtual",
    "where",
    "while",
    "yield"
  ], l = [
    "true",
    "false",
    "Some",
    "None",
    "Ok",
    "Err"
  ], c = [
    // functions
    "drop ",
    // traits
    "Copy",
    "Send",
    "Sized",
    "Sync",
    "Drop",
    "Fn",
    "FnMut",
    "FnOnce",
    "ToOwned",
    "Clone",
    "Debug",
    "PartialEq",
    "PartialOrd",
    "Eq",
    "Ord",
    "AsRef",
    "AsMut",
    "Into",
    "From",
    "Default",
    "Iterator",
    "Extend",
    "IntoIterator",
    "DoubleEndedIterator",
    "ExactSizeIterator",
    "SliceConcatExt",
    "ToString",
    // macros
    "assert!",
    "assert_eq!",
    "bitflags!",
    "bytes!",
    "cfg!",
    "col!",
    "concat!",
    "concat_idents!",
    "debug_assert!",
    "debug_assert_eq!",
    "env!",
    "eprintln!",
    "panic!",
    "file!",
    "format!",
    "format_args!",
    "include_bytes!",
    "include_str!",
    "line!",
    "local_data_key!",
    "module_path!",
    "option_env!",
    "print!",
    "println!",
    "select!",
    "stringify!",
    "try!",
    "unimplemented!",
    "unreachable!",
    "vec!",
    "write!",
    "writeln!",
    "macro_rules!",
    "assert_ne!",
    "debug_assert_ne!"
  ], u = [
    "i8",
    "i16",
    "i32",
    "i64",
    "i128",
    "isize",
    "u8",
    "u16",
    "u32",
    "u64",
    "u128",
    "usize",
    "f32",
    "f64",
    "str",
    "char",
    "bool",
    "Box",
    "Option",
    "Result",
    "String",
    "Vec"
  ];
  return {
    name: "Rust",
    aliases: ["rs"],
    keywords: {
      $pattern: e.IDENT_RE + "!?",
      type: u,
      keyword: o,
      literal: l,
      built_in: c
    },
    illegal: "</",
    contains: [
      e.C_LINE_COMMENT_MODE,
      e.COMMENT("/\\*", "\\*/", { contains: ["self"] }),
      e.inherit(e.QUOTE_STRING_MODE, {
        begin: /b?"/,
        illegal: null
      }),
      {
        className: "symbol",
        // negative lookahead to avoid matching `'`
        begin: /'[a-zA-Z_][a-zA-Z0-9_]*(?!')/
      },
      {
        scope: "string",
        variants: [
          { begin: /b?r(#*)"(.|\n)*?"\1(?!#)/ },
          {
            begin: /b?'/,
            end: /'/,
            contains: [
              {
                scope: "char.escape",
                match: /\\('|\w|x\w{2}|u\w{4}|U\w{8})/
              }
            ]
          }
        ]
      },
      {
        className: "number",
        variants: [
          { begin: "\\b0b([01_]+)" + s },
          { begin: "\\b0o([0-7_]+)" + s },
          { begin: "\\b0x([A-Fa-f0-9_]+)" + s },
          { begin: "\\b(\\d[\\d_]*(\\.[0-9_]+)?([eE][+-]?[0-9_]+)?)" + s }
        ],
        relevance: 0
      },
      {
        begin: [
          /fn/,
          /\s+/,
          r
        ],
        className: {
          1: "keyword",
          3: "title.function"
        }
      },
      {
        className: "meta",
        begin: "#!?\\[",
        end: "\\]",
        contains: [
          {
            className: "string",
            begin: /"/,
            end: /"/,
            contains: [
              e.BACKSLASH_ESCAPE
            ]
          }
        ]
      },
      {
        begin: [
          /let/,
          /\s+/,
          /(?:mut\s+)?/,
          r
        ],
        className: {
          1: "keyword",
          3: "keyword",
          4: "variable"
        }
      },
      // must come before impl/for rule later
      {
        begin: [
          /for/,
          /\s+/,
          r,
          /\s+/,
          /in/
        ],
        className: {
          1: "keyword",
          3: "variable",
          5: "keyword"
        }
      },
      {
        begin: [
          /type/,
          /\s+/,
          r
        ],
        className: {
          1: "keyword",
          3: "title.class"
        }
      },
      {
        begin: [
          /(?:trait|enum|struct|union|impl|for)/,
          /\s+/,
          r
        ],
        className: {
          1: "keyword",
          3: "title.class"
        }
      },
      {
        begin: e.IDENT_RE + "::",
        keywords: {
          keyword: "Self",
          built_in: c,
          type: u
        }
      },
      {
        className: "punctuation",
        begin: "->"
      },
      a
    ]
  };
}
const JP = (e) => ({
  IMPORTANT: {
    scope: "meta",
    begin: "!important"
  },
  BLOCK_COMMENT: e.C_BLOCK_COMMENT_MODE,
  HEXCOLOR: {
    scope: "number",
    begin: /#(([0-9a-fA-F]{3,4})|(([0-9a-fA-F]{2}){3,4}))\b/
  },
  FUNCTION_DISPATCH: {
    className: "built_in",
    begin: /[\w-]+(?=\()/
  },
  ATTRIBUTE_SELECTOR_MODE: {
    scope: "selector-attr",
    begin: /\[/,
    end: /\]/,
    illegal: "$",
    contains: [
      e.APOS_STRING_MODE,
      e.QUOTE_STRING_MODE
    ]
  },
  CSS_NUMBER_MODE: {
    scope: "number",
    begin: e.NUMBER_RE + "(%|em|ex|ch|rem|vw|vh|vmin|vmax|cm|mm|in|pt|pc|px|deg|grad|rad|turn|s|ms|Hz|kHz|dpi|dpcm|dppx)?",
    relevance: 0
  },
  CSS_VARIABLE: {
    className: "attr",
    begin: /--[A-Za-z_][A-Za-z0-9_-]*/
  }
}), qP = [
  "a",
  "abbr",
  "address",
  "article",
  "aside",
  "audio",
  "b",
  "blockquote",
  "body",
  "button",
  "canvas",
  "caption",
  "cite",
  "code",
  "dd",
  "del",
  "details",
  "dfn",
  "div",
  "dl",
  "dt",
  "em",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "header",
  "hgroup",
  "html",
  "i",
  "iframe",
  "img",
  "input",
  "ins",
  "kbd",
  "label",
  "legend",
  "li",
  "main",
  "mark",
  "menu",
  "nav",
  "object",
  "ol",
  "optgroup",
  "option",
  "p",
  "picture",
  "q",
  "quote",
  "samp",
  "section",
  "select",
  "source",
  "span",
  "strong",
  "summary",
  "sup",
  "table",
  "tbody",
  "td",
  "textarea",
  "tfoot",
  "th",
  "thead",
  "time",
  "tr",
  "ul",
  "var",
  "video"
], KP = [
  "defs",
  "g",
  "marker",
  "mask",
  "pattern",
  "svg",
  "switch",
  "symbol",
  "feBlend",
  "feColorMatrix",
  "feComponentTransfer",
  "feComposite",
  "feConvolveMatrix",
  "feDiffuseLighting",
  "feDisplacementMap",
  "feFlood",
  "feGaussianBlur",
  "feImage",
  "feMerge",
  "feMorphology",
  "feOffset",
  "feSpecularLighting",
  "feTile",
  "feTurbulence",
  "linearGradient",
  "radialGradient",
  "stop",
  "circle",
  "ellipse",
  "image",
  "line",
  "path",
  "polygon",
  "polyline",
  "rect",
  "text",
  "use",
  "textPath",
  "tspan",
  "foreignObject",
  "clipPath"
], QP = [
  ...qP,
  ...KP
], eD = [
  "any-hover",
  "any-pointer",
  "aspect-ratio",
  "color",
  "color-gamut",
  "color-index",
  "device-aspect-ratio",
  "device-height",
  "device-width",
  "display-mode",
  "forced-colors",
  "grid",
  "height",
  "hover",
  "inverted-colors",
  "monochrome",
  "orientation",
  "overflow-block",
  "overflow-inline",
  "pointer",
  "prefers-color-scheme",
  "prefers-contrast",
  "prefers-reduced-motion",
  "prefers-reduced-transparency",
  "resolution",
  "scan",
  "scripting",
  "update",
  "width",
  // TODO: find a better solution?
  "min-width",
  "max-width",
  "min-height",
  "max-height"
].sort().reverse(), tD = [
  "active",
  "any-link",
  "blank",
  "checked",
  "current",
  "default",
  "defined",
  "dir",
  // dir()
  "disabled",
  "drop",
  "empty",
  "enabled",
  "first",
  "first-child",
  "first-of-type",
  "fullscreen",
  "future",
  "focus",
  "focus-visible",
  "focus-within",
  "has",
  // has()
  "host",
  // host or host()
  "host-context",
  // host-context()
  "hover",
  "indeterminate",
  "in-range",
  "invalid",
  "is",
  // is()
  "lang",
  // lang()
  "last-child",
  "last-of-type",
  "left",
  "link",
  "local-link",
  "not",
  // not()
  "nth-child",
  // nth-child()
  "nth-col",
  // nth-col()
  "nth-last-child",
  // nth-last-child()
  "nth-last-col",
  // nth-last-col()
  "nth-last-of-type",
  //nth-last-of-type()
  "nth-of-type",
  //nth-of-type()
  "only-child",
  "only-of-type",
  "optional",
  "out-of-range",
  "past",
  "placeholder-shown",
  "read-only",
  "read-write",
  "required",
  "right",
  "root",
  "scope",
  "target",
  "target-within",
  "user-invalid",
  "valid",
  "visited",
  "where"
  // where()
].sort().reverse(), nD = [
  "after",
  "backdrop",
  "before",
  "cue",
  "cue-region",
  "first-letter",
  "first-line",
  "grammar-error",
  "marker",
  "part",
  "placeholder",
  "selection",
  "slotted",
  "spelling-error"
].sort().reverse(), rD = [
  "accent-color",
  "align-content",
  "align-items",
  "align-self",
  "alignment-baseline",
  "all",
  "anchor-name",
  "animation",
  "animation-composition",
  "animation-delay",
  "animation-direction",
  "animation-duration",
  "animation-fill-mode",
  "animation-iteration-count",
  "animation-name",
  "animation-play-state",
  "animation-range",
  "animation-range-end",
  "animation-range-start",
  "animation-timeline",
  "animation-timing-function",
  "appearance",
  "aspect-ratio",
  "backdrop-filter",
  "backface-visibility",
  "background",
  "background-attachment",
  "background-blend-mode",
  "background-clip",
  "background-color",
  "background-image",
  "background-origin",
  "background-position",
  "background-position-x",
  "background-position-y",
  "background-repeat",
  "background-size",
  "baseline-shift",
  "block-size",
  "border",
  "border-block",
  "border-block-color",
  "border-block-end",
  "border-block-end-color",
  "border-block-end-style",
  "border-block-end-width",
  "border-block-start",
  "border-block-start-color",
  "border-block-start-style",
  "border-block-start-width",
  "border-block-style",
  "border-block-width",
  "border-bottom",
  "border-bottom-color",
  "border-bottom-left-radius",
  "border-bottom-right-radius",
  "border-bottom-style",
  "border-bottom-width",
  "border-collapse",
  "border-color",
  "border-end-end-radius",
  "border-end-start-radius",
  "border-image",
  "border-image-outset",
  "border-image-repeat",
  "border-image-slice",
  "border-image-source",
  "border-image-width",
  "border-inline",
  "border-inline-color",
  "border-inline-end",
  "border-inline-end-color",
  "border-inline-end-style",
  "border-inline-end-width",
  "border-inline-start",
  "border-inline-start-color",
  "border-inline-start-style",
  "border-inline-start-width",
  "border-inline-style",
  "border-inline-width",
  "border-left",
  "border-left-color",
  "border-left-style",
  "border-left-width",
  "border-radius",
  "border-right",
  "border-right-color",
  "border-right-style",
  "border-right-width",
  "border-spacing",
  "border-start-end-radius",
  "border-start-start-radius",
  "border-style",
  "border-top",
  "border-top-color",
  "border-top-left-radius",
  "border-top-right-radius",
  "border-top-style",
  "border-top-width",
  "border-width",
  "bottom",
  "box-align",
  "box-decoration-break",
  "box-direction",
  "box-flex",
  "box-flex-group",
  "box-lines",
  "box-ordinal-group",
  "box-orient",
  "box-pack",
  "box-shadow",
  "box-sizing",
  "break-after",
  "break-before",
  "break-inside",
  "caption-side",
  "caret-color",
  "clear",
  "clip",
  "clip-path",
  "clip-rule",
  "color",
  "color-interpolation",
  "color-interpolation-filters",
  "color-profile",
  "color-rendering",
  "color-scheme",
  "column-count",
  "column-fill",
  "column-gap",
  "column-rule",
  "column-rule-color",
  "column-rule-style",
  "column-rule-width",
  "column-span",
  "column-width",
  "columns",
  "contain",
  "contain-intrinsic-block-size",
  "contain-intrinsic-height",
  "contain-intrinsic-inline-size",
  "contain-intrinsic-size",
  "contain-intrinsic-width",
  "container",
  "container-name",
  "container-type",
  "content",
  "content-visibility",
  "counter-increment",
  "counter-reset",
  "counter-set",
  "cue",
  "cue-after",
  "cue-before",
  "cursor",
  "cx",
  "cy",
  "direction",
  "display",
  "dominant-baseline",
  "empty-cells",
  "enable-background",
  "field-sizing",
  "fill",
  "fill-opacity",
  "fill-rule",
  "filter",
  "flex",
  "flex-basis",
  "flex-direction",
  "flex-flow",
  "flex-grow",
  "flex-shrink",
  "flex-wrap",
  "float",
  "flood-color",
  "flood-opacity",
  "flow",
  "font",
  "font-display",
  "font-family",
  "font-feature-settings",
  "font-kerning",
  "font-language-override",
  "font-optical-sizing",
  "font-palette",
  "font-size",
  "font-size-adjust",
  "font-smooth",
  "font-smoothing",
  "font-stretch",
  "font-style",
  "font-synthesis",
  "font-synthesis-position",
  "font-synthesis-small-caps",
  "font-synthesis-style",
  "font-synthesis-weight",
  "font-variant",
  "font-variant-alternates",
  "font-variant-caps",
  "font-variant-east-asian",
  "font-variant-emoji",
  "font-variant-ligatures",
  "font-variant-numeric",
  "font-variant-position",
  "font-variation-settings",
  "font-weight",
  "forced-color-adjust",
  "gap",
  "glyph-orientation-horizontal",
  "glyph-orientation-vertical",
  "grid",
  "grid-area",
  "grid-auto-columns",
  "grid-auto-flow",
  "grid-auto-rows",
  "grid-column",
  "grid-column-end",
  "grid-column-start",
  "grid-gap",
  "grid-row",
  "grid-row-end",
  "grid-row-start",
  "grid-template",
  "grid-template-areas",
  "grid-template-columns",
  "grid-template-rows",
  "hanging-punctuation",
  "height",
  "hyphenate-character",
  "hyphenate-limit-chars",
  "hyphens",
  "icon",
  "image-orientation",
  "image-rendering",
  "image-resolution",
  "ime-mode",
  "initial-letter",
  "initial-letter-align",
  "inline-size",
  "inset",
  "inset-area",
  "inset-block",
  "inset-block-end",
  "inset-block-start",
  "inset-inline",
  "inset-inline-end",
  "inset-inline-start",
  "isolation",
  "justify-content",
  "justify-items",
  "justify-self",
  "kerning",
  "left",
  "letter-spacing",
  "lighting-color",
  "line-break",
  "line-height",
  "line-height-step",
  "list-style",
  "list-style-image",
  "list-style-position",
  "list-style-type",
  "margin",
  "margin-block",
  "margin-block-end",
  "margin-block-start",
  "margin-bottom",
  "margin-inline",
  "margin-inline-end",
  "margin-inline-start",
  "margin-left",
  "margin-right",
  "margin-top",
  "margin-trim",
  "marker",
  "marker-end",
  "marker-mid",
  "marker-start",
  "marks",
  "mask",
  "mask-border",
  "mask-border-mode",
  "mask-border-outset",
  "mask-border-repeat",
  "mask-border-slice",
  "mask-border-source",
  "mask-border-width",
  "mask-clip",
  "mask-composite",
  "mask-image",
  "mask-mode",
  "mask-origin",
  "mask-position",
  "mask-repeat",
  "mask-size",
  "mask-type",
  "masonry-auto-flow",
  "math-depth",
  "math-shift",
  "math-style",
  "max-block-size",
  "max-height",
  "max-inline-size",
  "max-width",
  "min-block-size",
  "min-height",
  "min-inline-size",
  "min-width",
  "mix-blend-mode",
  "nav-down",
  "nav-index",
  "nav-left",
  "nav-right",
  "nav-up",
  "none",
  "normal",
  "object-fit",
  "object-position",
  "offset",
  "offset-anchor",
  "offset-distance",
  "offset-path",
  "offset-position",
  "offset-rotate",
  "opacity",
  "order",
  "orphans",
  "outline",
  "outline-color",
  "outline-offset",
  "outline-style",
  "outline-width",
  "overflow",
  "overflow-anchor",
  "overflow-block",
  "overflow-clip-margin",
  "overflow-inline",
  "overflow-wrap",
  "overflow-x",
  "overflow-y",
  "overlay",
  "overscroll-behavior",
  "overscroll-behavior-block",
  "overscroll-behavior-inline",
  "overscroll-behavior-x",
  "overscroll-behavior-y",
  "padding",
  "padding-block",
  "padding-block-end",
  "padding-block-start",
  "padding-bottom",
  "padding-inline",
  "padding-inline-end",
  "padding-inline-start",
  "padding-left",
  "padding-right",
  "padding-top",
  "page",
  "page-break-after",
  "page-break-before",
  "page-break-inside",
  "paint-order",
  "pause",
  "pause-after",
  "pause-before",
  "perspective",
  "perspective-origin",
  "place-content",
  "place-items",
  "place-self",
  "pointer-events",
  "position",
  "position-anchor",
  "position-visibility",
  "print-color-adjust",
  "quotes",
  "r",
  "resize",
  "rest",
  "rest-after",
  "rest-before",
  "right",
  "rotate",
  "row-gap",
  "ruby-align",
  "ruby-position",
  "scale",
  "scroll-behavior",
  "scroll-margin",
  "scroll-margin-block",
  "scroll-margin-block-end",
  "scroll-margin-block-start",
  "scroll-margin-bottom",
  "scroll-margin-inline",
  "scroll-margin-inline-end",
  "scroll-margin-inline-start",
  "scroll-margin-left",
  "scroll-margin-right",
  "scroll-margin-top",
  "scroll-padding",
  "scroll-padding-block",
  "scroll-padding-block-end",
  "scroll-padding-block-start",
  "scroll-padding-bottom",
  "scroll-padding-inline",
  "scroll-padding-inline-end",
  "scroll-padding-inline-start",
  "scroll-padding-left",
  "scroll-padding-right",
  "scroll-padding-top",
  "scroll-snap-align",
  "scroll-snap-stop",
  "scroll-snap-type",
  "scroll-timeline",
  "scroll-timeline-axis",
  "scroll-timeline-name",
  "scrollbar-color",
  "scrollbar-gutter",
  "scrollbar-width",
  "shape-image-threshold",
  "shape-margin",
  "shape-outside",
  "shape-rendering",
  "speak",
  "speak-as",
  "src",
  // @font-face
  "stop-color",
  "stop-opacity",
  "stroke",
  "stroke-dasharray",
  "stroke-dashoffset",
  "stroke-linecap",
  "stroke-linejoin",
  "stroke-miterlimit",
  "stroke-opacity",
  "stroke-width",
  "tab-size",
  "table-layout",
  "text-align",
  "text-align-all",
  "text-align-last",
  "text-anchor",
  "text-combine-upright",
  "text-decoration",
  "text-decoration-color",
  "text-decoration-line",
  "text-decoration-skip",
  "text-decoration-skip-ink",
  "text-decoration-style",
  "text-decoration-thickness",
  "text-emphasis",
  "text-emphasis-color",
  "text-emphasis-position",
  "text-emphasis-style",
  "text-indent",
  "text-justify",
  "text-orientation",
  "text-overflow",
  "text-rendering",
  "text-shadow",
  "text-size-adjust",
  "text-transform",
  "text-underline-offset",
  "text-underline-position",
  "text-wrap",
  "text-wrap-mode",
  "text-wrap-style",
  "timeline-scope",
  "top",
  "touch-action",
  "transform",
  "transform-box",
  "transform-origin",
  "transform-style",
  "transition",
  "transition-behavior",
  "transition-delay",
  "transition-duration",
  "transition-property",
  "transition-timing-function",
  "translate",
  "unicode-bidi",
  "user-modify",
  "user-select",
  "vector-effect",
  "vertical-align",
  "view-timeline",
  "view-timeline-axis",
  "view-timeline-inset",
  "view-timeline-name",
  "view-transition-name",
  "visibility",
  "voice-balance",
  "voice-duration",
  "voice-family",
  "voice-pitch",
  "voice-range",
  "voice-rate",
  "voice-stress",
  "voice-volume",
  "white-space",
  "white-space-collapse",
  "widows",
  "width",
  "will-change",
  "word-break",
  "word-spacing",
  "word-wrap",
  "writing-mode",
  "x",
  "y",
  "z-index",
  "zoom"
].sort().reverse();
function iD(e) {
  const t = JP(e), n = nD, r = tD, i = "@[a-z-]+", a = "and or not only", o = {
    className: "variable",
    begin: "(\\$" + "[a-zA-Z-][a-zA-Z0-9_-]*" + ")\\b",
    relevance: 0
  };
  return {
    name: "SCSS",
    case_insensitive: !0,
    illegal: "[=/|']",
    contains: [
      e.C_LINE_COMMENT_MODE,
      e.C_BLOCK_COMMENT_MODE,
      // to recognize keyframe 40% etc which are outside the scope of our
      // attribute value mode
      t.CSS_NUMBER_MODE,
      {
        className: "selector-id",
        begin: "#[A-Za-z0-9_-]+",
        relevance: 0
      },
      {
        className: "selector-class",
        begin: "\\.[A-Za-z0-9_-]+",
        relevance: 0
      },
      t.ATTRIBUTE_SELECTOR_MODE,
      {
        className: "selector-tag",
        begin: "\\b(" + QP.join("|") + ")\\b",
        // was there, before, but why?
        relevance: 0
      },
      {
        className: "selector-pseudo",
        begin: ":(" + r.join("|") + ")"
      },
      {
        className: "selector-pseudo",
        begin: ":(:)?(" + n.join("|") + ")"
      },
      o,
      {
        // pseudo-selector params
        begin: /\(/,
        end: /\)/,
        contains: [t.CSS_NUMBER_MODE]
      },
      t.CSS_VARIABLE,
      {
        className: "attribute",
        begin: "\\b(" + rD.join("|") + ")\\b"
      },
      { begin: "\\b(whitespace|wait|w-resize|visible|vertical-text|vertical-ideographic|uppercase|upper-roman|upper-alpha|underline|transparent|top|thin|thick|text|text-top|text-bottom|tb-rl|table-header-group|table-footer-group|sw-resize|super|strict|static|square|solid|small-caps|separate|se-resize|scroll|s-resize|rtl|row-resize|ridge|right|repeat|repeat-y|repeat-x|relative|progress|pointer|overline|outside|outset|oblique|nowrap|not-allowed|normal|none|nw-resize|no-repeat|no-drop|newspaper|ne-resize|n-resize|move|middle|medium|ltr|lr-tb|lowercase|lower-roman|lower-alpha|loose|list-item|line|line-through|line-edge|lighter|left|keep-all|justify|italic|inter-word|inter-ideograph|inside|inset|inline|inline-block|inherit|inactive|ideograph-space|ideograph-parenthesis|ideograph-numeric|ideograph-alpha|horizontal|hidden|help|hand|groove|fixed|ellipsis|e-resize|double|dotted|distribute|distribute-space|distribute-letter|distribute-all-lines|disc|disabled|default|decimal|dashed|crosshair|collapse|col-resize|circle|char|center|capitalize|break-word|break-all|bottom|both|bolder|bold|block|bidi-override|below|baseline|auto|always|all-scroll|absolute|table|table-cell)\\b" },
      {
        begin: /:/,
        end: /[;}{]/,
        relevance: 0,
        contains: [
          t.BLOCK_COMMENT,
          o,
          t.HEXCOLOR,
          t.CSS_NUMBER_MODE,
          e.QUOTE_STRING_MODE,
          e.APOS_STRING_MODE,
          t.IMPORTANT,
          t.FUNCTION_DISPATCH
        ]
      },
      // matching these here allows us to treat them more like regular CSS
      // rules so everything between the {} gets regular rule highlighting,
      // which is what we want for page and font-face
      {
        begin: "@(page|font-face)",
        keywords: {
          $pattern: i,
          keyword: "@page @font-face"
        }
      },
      {
        begin: "@",
        end: "[{;]",
        returnBegin: !0,
        keywords: {
          $pattern: /[a-z-]+/,
          keyword: a,
          attribute: eD.join(" ")
        },
        contains: [
          {
            begin: i,
            className: "keyword"
          },
          {
            begin: /[a-z-]+(?=:)/,
            className: "attribute"
          },
          o,
          e.QUOTE_STRING_MODE,
          e.APOS_STRING_MODE,
          t.HEXCOLOR,
          t.CSS_NUMBER_MODE
        ]
      },
      t.FUNCTION_DISPATCH
    ]
  };
}
function aD(e) {
  return {
    name: "Shell Session",
    aliases: [
      "console",
      "shellsession"
    ],
    contains: [
      {
        className: "meta.prompt",
        // We cannot add \s (spaces) in the regular expression otherwise it will be too broad and produce unexpected result.
        // For instance, in the following example, it would match "echo /path/to/home >" as a prompt:
        // echo /path/to/home > t.exe
        begin: /^\s{0,3}[/~\w\d[\]()@-]*[>%$#][ ]?/,
        starts: {
          end: /[^\\](?=\s*$)/,
          subLanguage: "bash"
        }
      }
    ]
  };
}
function sD(e) {
  const t = e.regex, n = e.COMMENT("--", "$"), r = {
    scope: "string",
    variants: [
      {
        begin: /'/,
        end: /'/,
        contains: [{ match: /''/ }]
      }
    ]
  }, i = {
    begin: /"/,
    end: /"/,
    contains: [{ match: /""/ }]
  }, a = [
    "true",
    "false",
    // Not sure it's correct to call NULL literal, and clauses like IS [NOT] NULL look strange that way.
    // "null",
    "unknown"
  ], s = [
    "double precision",
    "large object",
    "with timezone",
    "without timezone"
  ], o = [
    "bigint",
    "binary",
    "blob",
    "boolean",
    "char",
    "character",
    "clob",
    "date",
    "dec",
    "decfloat",
    "decimal",
    "float",
    "int",
    "integer",
    "interval",
    "nchar",
    "nclob",
    "national",
    "numeric",
    "real",
    "row",
    "smallint",
    "time",
    "timestamp",
    "varchar",
    "varying",
    // modifier (character varying)
    "varbinary"
  ], l = [
    "add",
    "asc",
    "collation",
    "desc",
    "final",
    "first",
    "last",
    "view"
  ], c = [
    "abs",
    "acos",
    "all",
    "allocate",
    "alter",
    "and",
    "any",
    "are",
    "array",
    "array_agg",
    "array_max_cardinality",
    "as",
    "asensitive",
    "asin",
    "asymmetric",
    "at",
    "atan",
    "atomic",
    "authorization",
    "avg",
    "begin",
    "begin_frame",
    "begin_partition",
    "between",
    "bigint",
    "binary",
    "blob",
    "boolean",
    "both",
    "by",
    "call",
    "called",
    "cardinality",
    "cascaded",
    "case",
    "cast",
    "ceil",
    "ceiling",
    "char",
    "char_length",
    "character",
    "character_length",
    "check",
    "classifier",
    "clob",
    "close",
    "coalesce",
    "collate",
    "collect",
    "column",
    "commit",
    "condition",
    "connect",
    "constraint",
    "contains",
    "convert",
    "copy",
    "corr",
    "corresponding",
    "cos",
    "cosh",
    "count",
    "covar_pop",
    "covar_samp",
    "create",
    "cross",
    "cube",
    "cume_dist",
    "current",
    "current_catalog",
    "current_date",
    "current_default_transform_group",
    "current_path",
    "current_role",
    "current_row",
    "current_schema",
    "current_time",
    "current_timestamp",
    "current_path",
    "current_role",
    "current_transform_group_for_type",
    "current_user",
    "cursor",
    "cycle",
    "date",
    "day",
    "deallocate",
    "dec",
    "decimal",
    "decfloat",
    "declare",
    "default",
    "define",
    "delete",
    "dense_rank",
    "deref",
    "describe",
    "deterministic",
    "disconnect",
    "distinct",
    "double",
    "drop",
    "dynamic",
    "each",
    "element",
    "else",
    "empty",
    "end",
    "end_frame",
    "end_partition",
    "end-exec",
    "equals",
    "escape",
    "every",
    "except",
    "exec",
    "execute",
    "exists",
    "exp",
    "external",
    "extract",
    "false",
    "fetch",
    "filter",
    "first_value",
    "float",
    "floor",
    "for",
    "foreign",
    "frame_row",
    "free",
    "from",
    "full",
    "function",
    "fusion",
    "get",
    "global",
    "grant",
    "group",
    "grouping",
    "groups",
    "having",
    "hold",
    "hour",
    "identity",
    "in",
    "indicator",
    "initial",
    "inner",
    "inout",
    "insensitive",
    "insert",
    "int",
    "integer",
    "intersect",
    "intersection",
    "interval",
    "into",
    "is",
    "join",
    "json_array",
    "json_arrayagg",
    "json_exists",
    "json_object",
    "json_objectagg",
    "json_query",
    "json_table",
    "json_table_primitive",
    "json_value",
    "lag",
    "language",
    "large",
    "last_value",
    "lateral",
    "lead",
    "leading",
    "left",
    "like",
    "like_regex",
    "listagg",
    "ln",
    "local",
    "localtime",
    "localtimestamp",
    "log",
    "log10",
    "lower",
    "match",
    "match_number",
    "match_recognize",
    "matches",
    "max",
    "member",
    "merge",
    "method",
    "min",
    "minute",
    "mod",
    "modifies",
    "module",
    "month",
    "multiset",
    "national",
    "natural",
    "nchar",
    "nclob",
    "new",
    "no",
    "none",
    "normalize",
    "not",
    "nth_value",
    "ntile",
    "null",
    "nullif",
    "numeric",
    "octet_length",
    "occurrences_regex",
    "of",
    "offset",
    "old",
    "omit",
    "on",
    "one",
    "only",
    "open",
    "or",
    "order",
    "out",
    "outer",
    "over",
    "overlaps",
    "overlay",
    "parameter",
    "partition",
    "pattern",
    "per",
    "percent",
    "percent_rank",
    "percentile_cont",
    "percentile_disc",
    "period",
    "portion",
    "position",
    "position_regex",
    "power",
    "precedes",
    "precision",
    "prepare",
    "primary",
    "procedure",
    "ptf",
    "range",
    "rank",
    "reads",
    "real",
    "recursive",
    "ref",
    "references",
    "referencing",
    "regr_avgx",
    "regr_avgy",
    "regr_count",
    "regr_intercept",
    "regr_r2",
    "regr_slope",
    "regr_sxx",
    "regr_sxy",
    "regr_syy",
    "release",
    "result",
    "return",
    "returns",
    "revoke",
    "right",
    "rollback",
    "rollup",
    "row",
    "row_number",
    "rows",
    "running",
    "savepoint",
    "scope",
    "scroll",
    "search",
    "second",
    "seek",
    "select",
    "sensitive",
    "session_user",
    "set",
    "show",
    "similar",
    "sin",
    "sinh",
    "skip",
    "smallint",
    "some",
    "specific",
    "specifictype",
    "sql",
    "sqlexception",
    "sqlstate",
    "sqlwarning",
    "sqrt",
    "start",
    "static",
    "stddev_pop",
    "stddev_samp",
    "submultiset",
    "subset",
    "substring",
    "substring_regex",
    "succeeds",
    "sum",
    "symmetric",
    "system",
    "system_time",
    "system_user",
    "table",
    "tablesample",
    "tan",
    "tanh",
    "then",
    "time",
    "timestamp",
    "timezone_hour",
    "timezone_minute",
    "to",
    "trailing",
    "translate",
    "translate_regex",
    "translation",
    "treat",
    "trigger",
    "trim",
    "trim_array",
    "true",
    "truncate",
    "uescape",
    "union",
    "unique",
    "unknown",
    "unnest",
    "update",
    "upper",
    "user",
    "using",
    "value",
    "values",
    "value_of",
    "var_pop",
    "var_samp",
    "varbinary",
    "varchar",
    "varying",
    "versioning",
    "when",
    "whenever",
    "where",
    "width_bucket",
    "window",
    "with",
    "within",
    "without",
    "year"
  ], u = [
    "abs",
    "acos",
    "array_agg",
    "asin",
    "atan",
    "avg",
    "cast",
    "ceil",
    "ceiling",
    "coalesce",
    "corr",
    "cos",
    "cosh",
    "count",
    "covar_pop",
    "covar_samp",
    "cume_dist",
    "dense_rank",
    "deref",
    "element",
    "exp",
    "extract",
    "first_value",
    "floor",
    "json_array",
    "json_arrayagg",
    "json_exists",
    "json_object",
    "json_objectagg",
    "json_query",
    "json_table",
    "json_table_primitive",
    "json_value",
    "lag",
    "last_value",
    "lead",
    "listagg",
    "ln",
    "log",
    "log10",
    "lower",
    "max",
    "min",
    "mod",
    "nth_value",
    "ntile",
    "nullif",
    "percent_rank",
    "percentile_cont",
    "percentile_disc",
    "position",
    "position_regex",
    "power",
    "rank",
    "regr_avgx",
    "regr_avgy",
    "regr_count",
    "regr_intercept",
    "regr_r2",
    "regr_slope",
    "regr_sxx",
    "regr_sxy",
    "regr_syy",
    "row_number",
    "sin",
    "sinh",
    "sqrt",
    "stddev_pop",
    "stddev_samp",
    "substring",
    "substring_regex",
    "sum",
    "tan",
    "tanh",
    "translate",
    "translate_regex",
    "treat",
    "trim",
    "trim_array",
    "unnest",
    "upper",
    "value_of",
    "var_pop",
    "var_samp",
    "width_bucket"
  ], d = [
    "current_catalog",
    "current_date",
    "current_default_transform_group",
    "current_path",
    "current_role",
    "current_schema",
    "current_transform_group_for_type",
    "current_user",
    "session_user",
    "system_time",
    "system_user",
    "current_time",
    "localtime",
    "current_timestamp",
    "localtimestamp"
  ], f = [
    "create table",
    "insert into",
    "primary key",
    "foreign key",
    "not null",
    "alter table",
    "add constraint",
    "grouping sets",
    "on overflow",
    "character set",
    "respect nulls",
    "ignore nulls",
    "nulls first",
    "nulls last",
    "depth first",
    "breadth first"
  ], p = u, h = [
    ...c,
    ...l
  ].filter((_) => !u.includes(_)), g = {
    scope: "variable",
    match: /@[a-z0-9][a-z0-9_]*/
  }, m = {
    scope: "operator",
    match: /[-+*/=%^~]|&&?|\|\|?|!=?|<(?:=>?|<|>)?|>[>=]?/,
    relevance: 0
  }, b = {
    match: t.concat(/\b/, t.either(...p), /\s*\(/),
    relevance: 0,
    keywords: { built_in: p }
  };
  function y(_) {
    return t.concat(
      /\b/,
      t.either(..._.map((x) => x.replace(/\s+/, "\\s+"))),
      /\b/
    );
  }
  const v = {
    scope: "keyword",
    match: y(f),
    relevance: 0
  };
  function E(_, {
    exceptions: x,
    when: I
  } = {}) {
    const T = I;
    return x = x || [], _.map((O) => O.match(/\|\d+$/) || x.includes(O) ? O : T(O) ? `${O}|0` : O);
  }
  return {
    name: "SQL",
    case_insensitive: !0,
    // does not include {} or HTML tags `</`
    illegal: /[{}]|<\//,
    keywords: {
      $pattern: /\b[\w\.]+/,
      keyword: E(h, { when: (_) => _.length < 3 }),
      literal: a,
      type: o,
      built_in: d
    },
    contains: [
      {
        scope: "type",
        match: y(s)
      },
      v,
      b,
      g,
      r,
      i,
      e.C_NUMBER_MODE,
      e.C_BLOCK_COMMENT_MODE,
      n,
      m
    ]
  };
}
function a_(e) {
  return e ? typeof e == "string" ? e : e.source : null;
}
function Ya(e) {
  return qe("(?=", e, ")");
}
function qe(...e) {
  return e.map((n) => a_(n)).join("");
}
function oD(e) {
  const t = e[e.length - 1];
  return typeof t == "object" && t.constructor === Object ? (e.splice(e.length - 1, 1), t) : {};
}
function rn(...e) {
  return "(" + (oD(e).capture ? "" : "?:") + e.map((r) => a_(r)).join("|") + ")";
}
const Ef = (e) => qe(
  /\b/,
  e,
  /\w$/.test(e) ? /\b/ : /\B/
), lD = [
  "Protocol",
  // contextual
  "Type"
  // contextual
].map(Ef), ug = [
  "init",
  "self"
].map(Ef), cD = [
  "Any",
  "Self"
], au = [
  // strings below will be fed into the regular `keywords` engine while regex
  // will result in additional modes being created to scan for those keywords to
  // avoid conflicts with other rules
  "actor",
  "any",
  // contextual
  "associatedtype",
  "async",
  "await",
  /as\?/,
  // operator
  /as!/,
  // operator
  "as",
  // operator
  "borrowing",
  // contextual
  "break",
  "case",
  "catch",
  "class",
  "consume",
  // contextual
  "consuming",
  // contextual
  "continue",
  "convenience",
  // contextual
  "copy",
  // contextual
  "default",
  "defer",
  "deinit",
  "didSet",
  // contextual
  "distributed",
  "do",
  "dynamic",
  // contextual
  "each",
  "else",
  "enum",
  "extension",
  "fallthrough",
  /fileprivate\(set\)/,
  "fileprivate",
  "final",
  // contextual
  "for",
  "func",
  "get",
  // contextual
  "guard",
  "if",
  "import",
  "indirect",
  // contextual
  "infix",
  // contextual
  /init\?/,
  /init!/,
  "inout",
  /internal\(set\)/,
  "internal",
  "in",
  "is",
  // operator
  "isolated",
  // contextual
  "nonisolated",
  // contextual
  "lazy",
  // contextual
  "let",
  "macro",
  "mutating",
  // contextual
  "nonmutating",
  // contextual
  /open\(set\)/,
  // contextual
  "open",
  // contextual
  "operator",
  "optional",
  // contextual
  "override",
  // contextual
  "package",
  "postfix",
  // contextual
  "precedencegroup",
  "prefix",
  // contextual
  /private\(set\)/,
  "private",
  "protocol",
  /public\(set\)/,
  "public",
  "repeat",
  "required",
  // contextual
  "rethrows",
  "return",
  "set",
  // contextual
  "some",
  // contextual
  "static",
  "struct",
  "subscript",
  "super",
  "switch",
  "throws",
  "throw",
  /try\?/,
  // operator
  /try!/,
  // operator
  "try",
  // operator
  "typealias",
  /unowned\(safe\)/,
  // contextual
  /unowned\(unsafe\)/,
  // contextual
  "unowned",
  // contextual
  "var",
  "weak",
  // contextual
  "where",
  "while",
  "willSet"
  // contextual
], dg = [
  "false",
  "nil",
  "true"
], uD = [
  "assignment",
  "associativity",
  "higherThan",
  "left",
  "lowerThan",
  "none",
  "right"
], dD = [
  "#colorLiteral",
  "#column",
  "#dsohandle",
  "#else",
  "#elseif",
  "#endif",
  "#error",
  "#file",
  "#fileID",
  "#fileLiteral",
  "#filePath",
  "#function",
  "#if",
  "#imageLiteral",
  "#keyPath",
  "#line",
  "#selector",
  "#sourceLocation",
  "#warning"
], fg = [
  "abs",
  "all",
  "any",
  "assert",
  "assertionFailure",
  "debugPrint",
  "dump",
  "fatalError",
  "getVaList",
  "isKnownUniquelyReferenced",
  "max",
  "min",
  "numericCast",
  "pointwiseMax",
  "pointwiseMin",
  "precondition",
  "preconditionFailure",
  "print",
  "readLine",
  "repeatElement",
  "sequence",
  "stride",
  "swap",
  "swift_unboxFromSwiftValueWithType",
  "transcode",
  "type",
  "unsafeBitCast",
  "unsafeDowncast",
  "withExtendedLifetime",
  "withUnsafeMutablePointer",
  "withUnsafePointer",
  "withVaList",
  "withoutActuallyEscaping",
  "zip"
], s_ = rn(
  /[/=\-+!*%<>&|^~?]/,
  /[\u00A1-\u00A7]/,
  /[\u00A9\u00AB]/,
  /[\u00AC\u00AE]/,
  /[\u00B0\u00B1]/,
  /[\u00B6\u00BB\u00BF\u00D7\u00F7]/,
  /[\u2016-\u2017]/,
  /[\u2020-\u2027]/,
  /[\u2030-\u203E]/,
  /[\u2041-\u2053]/,
  /[\u2055-\u205E]/,
  /[\u2190-\u23FF]/,
  /[\u2500-\u2775]/,
  /[\u2794-\u2BFF]/,
  /[\u2E00-\u2E7F]/,
  /[\u3001-\u3003]/,
  /[\u3008-\u3020]/,
  /[\u3030]/
), o_ = rn(
  s_,
  /[\u0300-\u036F]/,
  /[\u1DC0-\u1DFF]/,
  /[\u20D0-\u20FF]/,
  /[\uFE00-\uFE0F]/,
  /[\uFE20-\uFE2F]/
  // TODO: The following characters are also allowed, but the regex isn't supported yet.
  // /[\u{E0100}-\u{E01EF}]/u
), su = qe(s_, o_, "*"), l_ = rn(
  /[a-zA-Z_]/,
  /[\u00A8\u00AA\u00AD\u00AF\u00B2-\u00B5\u00B7-\u00BA]/,
  /[\u00BC-\u00BE\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u00FF]/,
  /[\u0100-\u02FF\u0370-\u167F\u1681-\u180D\u180F-\u1DBF]/,
  /[\u1E00-\u1FFF]/,
  /[\u200B-\u200D\u202A-\u202E\u203F-\u2040\u2054\u2060-\u206F]/,
  /[\u2070-\u20CF\u2100-\u218F\u2460-\u24FF\u2776-\u2793]/,
  /[\u2C00-\u2DFF\u2E80-\u2FFF]/,
  /[\u3004-\u3007\u3021-\u302F\u3031-\u303F\u3040-\uD7FF]/,
  /[\uF900-\uFD3D\uFD40-\uFDCF\uFDF0-\uFE1F\uFE30-\uFE44]/,
  /[\uFE47-\uFEFE\uFF00-\uFFFD]/
  // Should be /[\uFE47-\uFFFD]/, but we have to exclude FEFF.
  // The following characters are also allowed, but the regexes aren't supported yet.
  // /[\u{10000}-\u{1FFFD}\u{20000-\u{2FFFD}\u{30000}-\u{3FFFD}\u{40000}-\u{4FFFD}]/u,
  // /[\u{50000}-\u{5FFFD}\u{60000-\u{6FFFD}\u{70000}-\u{7FFFD}\u{80000}-\u{8FFFD}]/u,
  // /[\u{90000}-\u{9FFFD}\u{A0000-\u{AFFFD}\u{B0000}-\u{BFFFD}\u{C0000}-\u{CFFFD}]/u,
  // /[\u{D0000}-\u{DFFFD}\u{E0000-\u{EFFFD}]/u
), El = rn(
  l_,
  /\d/,
  /[\u0300-\u036F\u1DC0-\u1DFF\u20D0-\u20FF\uFE20-\uFE2F]/
), or = qe(l_, El, "*"), Io = qe(/[A-Z]/, El, "*"), fD = [
  "attached",
  "autoclosure",
  qe(/convention\(/, rn("swift", "block", "c"), /\)/),
  "discardableResult",
  "dynamicCallable",
  "dynamicMemberLookup",
  "escaping",
  "freestanding",
  "frozen",
  "GKInspectable",
  "IBAction",
  "IBDesignable",
  "IBInspectable",
  "IBOutlet",
  "IBSegueAction",
  "inlinable",
  "main",
  "nonobjc",
  "NSApplicationMain",
  "NSCopying",
  "NSManaged",
  qe(/objc\(/, or, /\)/),
  "objc",
  "objcMembers",
  "propertyWrapper",
  "requires_stored_property_inits",
  "resultBuilder",
  "Sendable",
  "testable",
  "UIApplicationMain",
  "unchecked",
  "unknown",
  "usableFromInline",
  "warn_unqualified_access"
], pD = [
  "iOS",
  "iOSApplicationExtension",
  "macOS",
  "macOSApplicationExtension",
  "macCatalyst",
  "macCatalystApplicationExtension",
  "watchOS",
  "watchOSApplicationExtension",
  "tvOS",
  "tvOSApplicationExtension",
  "swift"
];
function hD(e) {
  const t = {
    match: /\s+/,
    relevance: 0
  }, n = e.COMMENT(
    "/\\*",
    "\\*/",
    { contains: ["self"] }
  ), r = [
    e.C_LINE_COMMENT_MODE,
    n
  ], i = {
    match: [
      /\./,
      rn(...lD, ...ug)
    ],
    className: { 2: "keyword" }
  }, a = {
    // Consume .keyword to prevent highlighting properties and methods as keywords.
    match: qe(/\./, rn(...au)),
    relevance: 0
  }, s = au.filter((Fe) => typeof Fe == "string").concat(["_|0"]), o = au.filter((Fe) => typeof Fe != "string").concat(cD).map(Ef), l = { variants: [
    {
      className: "keyword",
      match: rn(...o, ...ug)
    }
  ] }, c = {
    $pattern: rn(
      /\b\w+/,
      // regular keywords
      /#\w+/
      // number keywords
    ),
    keyword: s.concat(dD),
    literal: dg
  }, u = [
    i,
    a,
    l
  ], d = {
    // Consume .built_in to prevent highlighting properties and methods.
    match: qe(/\./, rn(...fg)),
    relevance: 0
  }, f = {
    className: "built_in",
    match: qe(/\b/, rn(...fg), /(?=\()/)
  }, p = [
    d,
    f
  ], h = {
    // Prevent -> from being highlighting as an operator.
    match: /->/,
    relevance: 0
  }, g = {
    className: "operator",
    relevance: 0,
    variants: [
      { match: su },
      {
        // dot-operator: only operators that start with a dot are allowed to use dots as
        // characters (..., ...<, .*, etc). So there rule here is: a dot followed by one or more
        // characters that may also include dots.
        match: `\\.(\\.|${o_})+`
      }
    ]
  }, m = [
    h,
    g
  ], b = "([0-9]_*)+", y = "([0-9a-fA-F]_*)+", v = {
    className: "number",
    relevance: 0,
    variants: [
      // decimal floating-point-literal (subsumes decimal-literal)
      { match: `\\b(${b})(\\.(${b}))?([eE][+-]?(${b}))?\\b` },
      // hexadecimal floating-point-literal (subsumes hexadecimal-literal)
      { match: `\\b0x(${y})(\\.(${y}))?([pP][+-]?(${b}))?\\b` },
      // octal-literal
      { match: /\b0o([0-7]_*)+\b/ },
      // binary-literal
      { match: /\b0b([01]_*)+\b/ }
    ]
  }, E = (Fe = "") => ({
    className: "subst",
    variants: [
      { match: qe(/\\/, Fe, /[0\\tnr"']/) },
      { match: qe(/\\/, Fe, /u\{[0-9a-fA-F]{1,8}\}/) }
    ]
  }), _ = (Fe = "") => ({
    className: "subst",
    match: qe(/\\/, Fe, /[\t ]*(?:[\r\n]|\r\n)/)
  }), x = (Fe = "") => ({
    className: "subst",
    label: "interpol",
    begin: qe(/\\/, Fe, /\(/),
    end: /\)/
  }), I = (Fe = "") => ({
    begin: qe(Fe, /"""/),
    end: qe(/"""/, Fe),
    contains: [
      E(Fe),
      _(Fe),
      x(Fe)
    ]
  }), T = (Fe = "") => ({
    begin: qe(Fe, /"/),
    end: qe(/"/, Fe),
    contains: [
      E(Fe),
      x(Fe)
    ]
  }), O = {
    className: "string",
    variants: [
      I(),
      I("#"),
      I("##"),
      I("###"),
      T(),
      T("#"),
      T("##"),
      T("###")
    ]
  }, k = [
    e.BACKSLASH_ESCAPE,
    {
      begin: /\[/,
      end: /\]/,
      relevance: 0,
      contains: [e.BACKSLASH_ESCAPE]
    }
  ], W = {
    begin: /\/[^\s](?=[^/\n]*\/)/,
    end: /\//,
    contains: k
  }, M = (Fe) => {
    const en = qe(Fe, /\//), R = qe(/\//, Fe);
    return {
      begin: en,
      end: R,
      contains: [
        ...k,
        {
          scope: "comment",
          begin: `#(?!.*${R})`,
          end: /$/
        }
      ]
    };
  }, L = {
    scope: "regexp",
    variants: [
      M("###"),
      M("##"),
      M("#"),
      W
    ]
  }, z = { match: qe(/`/, or, /`/) }, U = {
    className: "variable",
    match: /\$\d+/
  }, $ = {
    className: "variable",
    match: `\\$${El}+`
  }, Q = [
    z,
    U,
    $
  ], K = {
    match: /(@|#(un)?)available/,
    scope: "keyword",
    starts: { contains: [
      {
        begin: /\(/,
        end: /\)/,
        keywords: pD,
        contains: [
          ...m,
          v,
          O
        ]
      }
    ] }
  }, fe = {
    scope: "keyword",
    match: qe(/@/, rn(...fD), Ya(rn(/\(/, /\s+/)))
  }, S = {
    scope: "meta",
    match: qe(/@/, or)
  }, me = [
    K,
    fe,
    S
  ], se = {
    match: Ya(/\b[A-Z]/),
    relevance: 0,
    contains: [
      {
        // Common Apple frameworks, for relevance boost
        className: "type",
        match: qe(/(AV|CA|CF|CG|CI|CL|CM|CN|CT|MK|MP|MTK|MTL|NS|SCN|SK|UI|WK|XC)/, El, "+")
      },
      {
        // Type identifier
        className: "type",
        match: Io,
        relevance: 0
      },
      {
        // Optional type
        match: /[?!]+/,
        relevance: 0
      },
      {
        // Variadic parameter
        match: /\.\.\./,
        relevance: 0
      },
      {
        // Protocol composition
        match: qe(/\s+&\s+/, Ya(Io)),
        relevance: 0
      }
    ]
  }, A = {
    begin: /</,
    end: />/,
    keywords: c,
    contains: [
      ...r,
      ...u,
      ...me,
      h,
      se
    ]
  };
  se.contains.push(A);
  const ve = {
    match: qe(or, /\s*:/),
    keywords: "_|0",
    relevance: 0
  }, Te = {
    begin: /\(/,
    end: /\)/,
    relevance: 0,
    keywords: c,
    contains: [
      "self",
      ve,
      ...r,
      L,
      ...u,
      ...p,
      ...m,
      v,
      O,
      ...Q,
      ...me,
      se
    ]
  }, Ce = {
    begin: /</,
    end: />/,
    keywords: "repeat each",
    contains: [
      ...r,
      se
    ]
  }, Je = {
    begin: rn(
      Ya(qe(or, /\s*:/)),
      Ya(qe(or, /\s+/, or, /\s*:/))
    ),
    end: /:/,
    relevance: 0,
    contains: [
      {
        className: "keyword",
        match: /\b_\b/
      },
      {
        className: "params",
        match: or
      }
    ]
  }, Be = {
    begin: /\(/,
    end: /\)/,
    keywords: c,
    contains: [
      Je,
      ...r,
      ...u,
      ...m,
      v,
      O,
      ...me,
      se,
      Te
    ],
    endsParent: !0,
    illegal: /["']/
  }, it = {
    match: [
      /(func|macro)/,
      /\s+/,
      rn(z.match, or, su)
    ],
    className: {
      1: "keyword",
      3: "title.function"
    },
    contains: [
      Ce,
      Be,
      t
    ],
    illegal: [
      /\[/,
      /%/
    ]
  }, at = {
    match: [
      /\b(?:subscript|init[?!]?)/,
      /\s*(?=[<(])/
    ],
    className: { 1: "keyword" },
    contains: [
      Ce,
      Be,
      t
    ],
    illegal: /\[|%/
  }, mt = {
    match: [
      /operator/,
      /\s+/,
      su
    ],
    className: {
      1: "keyword",
      3: "title"
    }
  }, ie = {
    begin: [
      /precedencegroup/,
      /\s+/,
      Io
    ],
    className: {
      1: "keyword",
      3: "title"
    },
    contains: [se],
    keywords: [
      ...uD,
      ...dg
    ],
    end: /}/
  }, Rt = {
    match: [
      /class\b/,
      /\s+/,
      /func\b/,
      /\s+/,
      /\b[A-Za-z_][A-Za-z0-9_]*\b/
    ],
    scope: {
      1: "keyword",
      3: "keyword",
      5: "title.function"
    }
  }, ft = {
    match: [
      /class\b/,
      /\s+/,
      /var\b/
    ],
    scope: {
      1: "keyword",
      3: "keyword"
    }
  }, wt = {
    begin: [
      /(struct|protocol|class|extension|enum|actor)/,
      /\s+/,
      or,
      /\s*/
    ],
    beginScope: {
      1: "keyword",
      3: "title.class"
    },
    keywords: c,
    contains: [
      Ce,
      ...u,
      {
        begin: /:/,
        end: /\{/,
        keywords: c,
        contains: [
          {
            scope: "title.class.inherited",
            match: Io
          },
          ...u
        ],
        relevance: 0
      }
    ]
  };
  for (const Fe of O.variants) {
    const en = Fe.contains.find((D) => D.label === "interpol");
    en.keywords = c;
    const R = [
      ...u,
      ...p,
      ...m,
      v,
      O,
      ...Q
    ];
    en.contains = [
      ...R,
      {
        begin: /\(/,
        end: /\)/,
        contains: [
          "self",
          ...R
        ]
      }
    ];
  }
  return {
    name: "Swift",
    keywords: c,
    contains: [
      ...r,
      it,
      at,
      Rt,
      ft,
      wt,
      mt,
      ie,
      {
        beginKeywords: "import",
        end: /$/,
        contains: [...r],
        relevance: 0
      },
      L,
      ...u,
      ...p,
      ...m,
      v,
      O,
      ...Q,
      ...me,
      se,
      Te
    ]
  };
}
const wl = "[A-Za-z$_][0-9A-Za-z$_]*", c_ = [
  "as",
  // for exports
  "in",
  "of",
  "if",
  "for",
  "while",
  "finally",
  "var",
  "new",
  "function",
  "do",
  "return",
  "void",
  "else",
  "break",
  "catch",
  "instanceof",
  "with",
  "throw",
  "case",
  "default",
  "try",
  "switch",
  "continue",
  "typeof",
  "delete",
  "let",
  "yield",
  "const",
  "class",
  // JS handles these with a special rule
  // "get",
  // "set",
  "debugger",
  "async",
  "await",
  "static",
  "import",
  "from",
  "export",
  "extends",
  // It's reached stage 3, which is "recommended for implementation":
  "using"
], u_ = [
  "true",
  "false",
  "null",
  "undefined",
  "NaN",
  "Infinity"
], d_ = [
  // Fundamental objects
  "Object",
  "Function",
  "Boolean",
  "Symbol",
  // numbers and dates
  "Math",
  "Date",
  "Number",
  "BigInt",
  // text
  "String",
  "RegExp",
  // Indexed collections
  "Array",
  "Float32Array",
  "Float64Array",
  "Int8Array",
  "Uint8Array",
  "Uint8ClampedArray",
  "Int16Array",
  "Int32Array",
  "Uint16Array",
  "Uint32Array",
  "BigInt64Array",
  "BigUint64Array",
  // Keyed collections
  "Set",
  "Map",
  "WeakSet",
  "WeakMap",
  // Structured data
  "ArrayBuffer",
  "SharedArrayBuffer",
  "Atomics",
  "DataView",
  "JSON",
  // Control abstraction objects
  "Promise",
  "Generator",
  "GeneratorFunction",
  "AsyncFunction",
  // Reflection
  "Reflect",
  "Proxy",
  // Internationalization
  "Intl",
  // WebAssembly
  "WebAssembly"
], f_ = [
  "Error",
  "EvalError",
  "InternalError",
  "RangeError",
  "ReferenceError",
  "SyntaxError",
  "TypeError",
  "URIError"
], p_ = [
  "setInterval",
  "setTimeout",
  "clearInterval",
  "clearTimeout",
  "require",
  "exports",
  "eval",
  "isFinite",
  "isNaN",
  "parseFloat",
  "parseInt",
  "decodeURI",
  "decodeURIComponent",
  "encodeURI",
  "encodeURIComponent",
  "escape",
  "unescape"
], h_ = [
  "arguments",
  "this",
  "super",
  "console",
  "window",
  "document",
  "localStorage",
  "sessionStorage",
  "module",
  "global"
  // Node.js
], g_ = [].concat(
  p_,
  d_,
  f_
);
function gD(e) {
  const t = e.regex, n = (K, { after: fe }) => {
    const S = "</" + K[0].slice(1);
    return K.input.indexOf(S, fe) !== -1;
  }, r = wl, i = {
    begin: "<>",
    end: "</>"
  }, a = /<[A-Za-z0-9\\._:-]+\s*\/>/, s = {
    begin: /<[A-Za-z0-9\\._:-]+/,
    end: /\/[A-Za-z0-9\\._:-]+>|\/>/,
    /**
     * @param {RegExpMatchArray} match
     * @param {CallbackResponse} response
     */
    isTrulyOpeningTag: (K, fe) => {
      const S = K[0].length + K.index, me = K.input[S];
      if (
        // HTML should not include another raw `<` inside a tag
        // nested type?
        // `<Array<Array<number>>`, etc.
        me === "<" || // the , gives away that this is not HTML
        // `<T, A extends keyof T, V>`
        me === ","
      ) {
        fe.ignoreMatch();
        return;
      }
      me === ">" && (n(K, { after: S }) || fe.ignoreMatch());
      let se;
      const A = K.input.substring(S);
      if (se = A.match(/^\s*=/)) {
        fe.ignoreMatch();
        return;
      }
      if ((se = A.match(/^\s+extends\s+/)) && se.index === 0) {
        fe.ignoreMatch();
        return;
      }
    }
  }, o = {
    $pattern: wl,
    keyword: c_,
    literal: u_,
    built_in: g_,
    "variable.language": h_
  }, l = "[0-9](_?[0-9])*", c = `\\.(${l})`, u = "0|[1-9](_?[0-9])*|0[0-7]*[89][0-9]*", d = {
    className: "number",
    variants: [
      // DecimalLiteral
      { begin: `(\\b(${u})((${c})|\\.)?|(${c}))[eE][+-]?(${l})\\b` },
      { begin: `\\b(${u})\\b((${c})\\b|\\.)?|(${c})\\b` },
      // DecimalBigIntegerLiteral
      { begin: "\\b(0|[1-9](_?[0-9])*)n\\b" },
      // NonDecimalIntegerLiteral
      { begin: "\\b0[xX][0-9a-fA-F](_?[0-9a-fA-F])*n?\\b" },
      { begin: "\\b0[bB][0-1](_?[0-1])*n?\\b" },
      { begin: "\\b0[oO][0-7](_?[0-7])*n?\\b" },
      // LegacyOctalIntegerLiteral (does not include underscore separators)
      // https://tc39.es/ecma262/#sec-additional-syntax-numeric-literals
      { begin: "\\b0[0-7]+n?\\b" }
    ],
    relevance: 0
  }, f = {
    className: "subst",
    begin: "\\$\\{",
    end: "\\}",
    keywords: o,
    contains: []
    // defined later
  }, p = {
    begin: ".?html`",
    end: "",
    starts: {
      end: "`",
      returnEnd: !1,
      contains: [
        e.BACKSLASH_ESCAPE,
        f
      ],
      subLanguage: "xml"
    }
  }, h = {
    begin: ".?css`",
    end: "",
    starts: {
      end: "`",
      returnEnd: !1,
      contains: [
        e.BACKSLASH_ESCAPE,
        f
      ],
      subLanguage: "css"
    }
  }, g = {
    begin: ".?gql`",
    end: "",
    starts: {
      end: "`",
      returnEnd: !1,
      contains: [
        e.BACKSLASH_ESCAPE,
        f
      ],
      subLanguage: "graphql"
    }
  }, m = {
    className: "string",
    begin: "`",
    end: "`",
    contains: [
      e.BACKSLASH_ESCAPE,
      f
    ]
  }, y = {
    className: "comment",
    variants: [
      e.COMMENT(
        /\/\*\*(?!\/)/,
        "\\*/",
        {
          relevance: 0,
          contains: [
            {
              begin: "(?=@[A-Za-z]+)",
              relevance: 0,
              contains: [
                {
                  className: "doctag",
                  begin: "@[A-Za-z]+"
                },
                {
                  className: "type",
                  begin: "\\{",
                  end: "\\}",
                  excludeEnd: !0,
                  excludeBegin: !0,
                  relevance: 0
                },
                {
                  className: "variable",
                  begin: r + "(?=\\s*(-)|$)",
                  endsParent: !0,
                  relevance: 0
                },
                // eat spaces (not newlines) so we can find
                // types or variables
                {
                  begin: /(?=[^\n])\s/,
                  relevance: 0
                }
              ]
            }
          ]
        }
      ),
      e.C_BLOCK_COMMENT_MODE,
      e.C_LINE_COMMENT_MODE
    ]
  }, v = [
    e.APOS_STRING_MODE,
    e.QUOTE_STRING_MODE,
    p,
    h,
    g,
    m,
    // Skip numbers when they are part of a variable name
    { match: /\$\d+/ },
    d
    // This is intentional:
    // See https://github.com/highlightjs/highlight.js/issues/3288
    // hljs.REGEXP_MODE
  ];
  f.contains = v.concat({
    // we need to pair up {} inside our subst to prevent
    // it from ending too early by matching another }
    begin: /\{/,
    end: /\}/,
    keywords: o,
    contains: [
      "self"
    ].concat(v)
  });
  const E = [].concat(y, f.contains), _ = E.concat([
    // eat recursive parens in sub expressions
    {
      begin: /(\s*)\(/,
      end: /\)/,
      keywords: o,
      contains: ["self"].concat(E)
    }
  ]), x = {
    className: "params",
    // convert this to negative lookbehind in v12
    begin: /(\s*)\(/,
    // to match the parms with
    end: /\)/,
    excludeBegin: !0,
    excludeEnd: !0,
    keywords: o,
    contains: _
  }, I = {
    variants: [
      // class Car extends vehicle
      {
        match: [
          /class/,
          /\s+/,
          r,
          /\s+/,
          /extends/,
          /\s+/,
          t.concat(r, "(", t.concat(/\./, r), ")*")
        ],
        scope: {
          1: "keyword",
          3: "title.class",
          5: "keyword",
          7: "title.class.inherited"
        }
      },
      // class Car
      {
        match: [
          /class/,
          /\s+/,
          r
        ],
        scope: {
          1: "keyword",
          3: "title.class"
        }
      }
    ]
  }, T = {
    relevance: 0,
    match: t.either(
      // Hard coded exceptions
      /\bJSON/,
      // Float32Array, OutT
      /\b[A-Z][a-z]+([A-Z][a-z]*|\d)*/,
      // CSSFactory, CSSFactoryT
      /\b[A-Z]{2,}([A-Z][a-z]+|\d)+([A-Z][a-z]*)*/,
      // FPs, FPsT
      /\b[A-Z]{2,}[a-z]+([A-Z][a-z]+|\d)*([A-Z][a-z]*)*/
      // P
      // single letters are not highlighted
      // BLAH
      // this will be flagged as a UPPER_CASE_CONSTANT instead
    ),
    className: "title.class",
    keywords: {
      _: [
        // se we still get relevance credit for JS library classes
        ...d_,
        ...f_
      ]
    }
  }, O = {
    label: "use_strict",
    className: "meta",
    relevance: 10,
    begin: /^\s*['"]use (strict|asm)['"]/
  }, k = {
    variants: [
      {
        match: [
          /function/,
          /\s+/,
          r,
          /(?=\s*\()/
        ]
      },
      // anonymous function
      {
        match: [
          /function/,
          /\s*(?=\()/
        ]
      }
    ],
    className: {
      1: "keyword",
      3: "title.function"
    },
    label: "func.def",
    contains: [x],
    illegal: /%/
  }, W = {
    relevance: 0,
    match: /\b[A-Z][A-Z_0-9]+\b/,
    className: "variable.constant"
  };
  function M(K) {
    return t.concat("(?!", K.join("|"), ")");
  }
  const L = {
    match: t.concat(
      /\b/,
      M([
        ...p_,
        "super",
        "import"
      ].map((K) => `${K}\\s*\\(`)),
      r,
      t.lookahead(/\s*\(/)
    ),
    className: "title.function",
    relevance: 0
  }, z = {
    begin: t.concat(/\./, t.lookahead(
      t.concat(r, /(?![0-9A-Za-z$_(])/)
    )),
    end: r,
    excludeBegin: !0,
    keywords: "prototype",
    className: "property",
    relevance: 0
  }, U = {
    match: [
      /get|set/,
      /\s+/,
      r,
      /(?=\()/
    ],
    className: {
      1: "keyword",
      3: "title.function"
    },
    contains: [
      {
        // eat to avoid empty params
        begin: /\(\)/
      },
      x
    ]
  }, $ = "(\\([^()]*(\\([^()]*(\\([^()]*\\)[^()]*)*\\)[^()]*)*\\)|" + e.UNDERSCORE_IDENT_RE + ")\\s*=>", Q = {
    match: [
      /const|var|let/,
      /\s+/,
      r,
      /\s*/,
      /=\s*/,
      /(async\s*)?/,
      // async is optional
      t.lookahead($)
    ],
    keywords: "async",
    className: {
      1: "keyword",
      3: "title.function"
    },
    contains: [
      x
    ]
  };
  return {
    name: "JavaScript",
    aliases: ["js", "jsx", "mjs", "cjs"],
    keywords: o,
    // this will be extended by TypeScript
    exports: { PARAMS_CONTAINS: _, CLASS_REFERENCE: T },
    illegal: /#(?![$_A-z])/,
    contains: [
      e.SHEBANG({
        label: "shebang",
        binary: "node",
        relevance: 5
      }),
      O,
      e.APOS_STRING_MODE,
      e.QUOTE_STRING_MODE,
      p,
      h,
      g,
      m,
      y,
      // Skip numbers when they are part of a variable name
      { match: /\$\d+/ },
      d,
      T,
      {
        scope: "attr",
        match: r + t.lookahead(":"),
        relevance: 0
      },
      Q,
      {
        // "value" container
        begin: "(" + e.RE_STARTERS_RE + "|\\b(case|return|throw)\\b)\\s*",
        keywords: "return throw case",
        relevance: 0,
        contains: [
          y,
          e.REGEXP_MODE,
          {
            className: "function",
            // we have to count the parens to make sure we actually have the
            // correct bounding ( ) before the =>.  There could be any number of
            // sub-expressions inside also surrounded by parens.
            begin: $,
            returnBegin: !0,
            end: "\\s*=>",
            contains: [
              {
                className: "params",
                variants: [
                  {
                    begin: e.UNDERSCORE_IDENT_RE,
                    relevance: 0
                  },
                  {
                    className: null,
                    begin: /\(\s*\)/,
                    skip: !0
                  },
                  {
                    begin: /(\s*)\(/,
                    end: /\)/,
                    excludeBegin: !0,
                    excludeEnd: !0,
                    keywords: o,
                    contains: _
                  }
                ]
              }
            ]
          },
          {
            // could be a comma delimited list of params to a function call
            begin: /,/,
            relevance: 0
          },
          {
            match: /\s+/,
            relevance: 0
          },
          {
            // JSX
            variants: [
              { begin: i.begin, end: i.end },
              { match: a },
              {
                begin: s.begin,
                // we carefully check the opening tag to see if it truly
                // is a tag and not a false positive
                "on:begin": s.isTrulyOpeningTag,
                end: s.end
              }
            ],
            subLanguage: "xml",
            contains: [
              {
                begin: s.begin,
                end: s.end,
                skip: !0,
                contains: ["self"]
              }
            ]
          }
        ]
      },
      k,
      {
        // prevent this from getting swallowed up by function
        // since they appear "function like"
        beginKeywords: "while if switch catch for"
      },
      {
        // we have to count the parens to make sure we actually have the correct
        // bounding ( ).  There could be any number of sub-expressions inside
        // also surrounded by parens.
        begin: "\\b(?!function)" + e.UNDERSCORE_IDENT_RE + "\\([^()]*(\\([^()]*(\\([^()]*\\)[^()]*)*\\)[^()]*)*\\)\\s*\\{",
        // end parens
        returnBegin: !0,
        label: "func.def",
        contains: [
          x,
          e.inherit(e.TITLE_MODE, { begin: r, className: "title.function" })
        ]
      },
      // catch ... so it won't trigger the property rule below
      {
        match: /\.\.\./,
        relevance: 0
      },
      z,
      // hack: prevents detection of keywords in some circumstances
      // .keyword()
      // $keyword = x
      {
        match: "\\$" + r,
        relevance: 0
      },
      {
        match: [/\bconstructor(?=\s*\()/],
        className: { 1: "title.function" },
        contains: [x]
      },
      L,
      W,
      I,
      U,
      {
        match: /\$[(.]/
        // relevance booster for a pattern common to JS libs: `$(something)` and `$.something`
      }
    ]
  };
}
function mD(e) {
  const t = e.regex, n = gD(e), r = wl, i = [
    "any",
    "void",
    "number",
    "boolean",
    "string",
    "object",
    "never",
    "symbol",
    "bigint",
    "unknown"
  ], a = {
    begin: [
      /namespace/,
      /\s+/,
      e.IDENT_RE
    ],
    beginScope: {
      1: "keyword",
      3: "title.class"
    }
  }, s = {
    beginKeywords: "interface",
    end: /\{/,
    excludeEnd: !0,
    keywords: {
      keyword: "interface extends",
      built_in: i
    },
    contains: [n.exports.CLASS_REFERENCE]
  }, o = {
    className: "meta",
    relevance: 10,
    begin: /^\s*['"]use strict['"]/
  }, l = [
    "type",
    // "namespace",
    "interface",
    "public",
    "private",
    "protected",
    "implements",
    "declare",
    "abstract",
    "readonly",
    "enum",
    "override",
    "satisfies"
  ], c = {
    $pattern: wl,
    keyword: c_.concat(l),
    literal: u_,
    built_in: g_.concat(i),
    "variable.language": h_
  }, u = {
    className: "meta",
    begin: "@" + r
  }, d = (g, m, b) => {
    const y = g.contains.findIndex((v) => v.label === m);
    if (y === -1)
      throw new Error("can not find mode to replace");
    g.contains.splice(y, 1, b);
  };
  Object.assign(n.keywords, c), n.exports.PARAMS_CONTAINS.push(u);
  const f = n.contains.find((g) => g.scope === "attr"), p = Object.assign(
    {},
    f,
    { match: t.concat(r, t.lookahead(/\s*\?:/)) }
  );
  n.exports.PARAMS_CONTAINS.push([
    n.exports.CLASS_REFERENCE,
    // class reference for highlighting the params types
    f,
    // highlight the params key
    p
    // Added for optional property assignment highlighting
  ]), n.contains = n.contains.concat([
    u,
    a,
    s,
    p
    // Added for optional property assignment highlighting
  ]), d(n, "shebang", e.SHEBANG()), d(n, "use_strict", o);
  const h = n.contains.find((g) => g.label === "func.def");
  return h.relevance = 0, Object.assign(n, {
    name: "TypeScript",
    aliases: [
      "ts",
      "tsx",
      "mts",
      "cts"
    ]
  }), n;
}
function bD(e) {
  const t = e.regex, n = {
    className: "string",
    begin: /"(""|[^/n])"C\b/
  }, r = {
    className: "string",
    begin: /"/,
    end: /"/,
    illegal: /\n/,
    contains: [
      {
        // double quote escape
        begin: /""/
      }
    ]
  }, i = /\d{1,2}\/\d{1,2}\/\d{4}/, a = /\d{4}-\d{1,2}-\d{1,2}/, s = /(\d|1[012])(:\d+){0,2} *(AM|PM)/, o = /\d{1,2}(:\d{1,2}){1,2}/, l = {
    className: "literal",
    variants: [
      {
        // #YYYY-MM-DD# (ISO-Date) or #M/D/YYYY# (US-Date)
        begin: t.concat(/# */, t.either(a, i), / *#/)
      },
      {
        // #H:mm[:ss]# (24h Time)
        begin: t.concat(/# */, o, / *#/)
      },
      {
        // #h[:mm[:ss]] A# (12h Time)
        begin: t.concat(/# */, s, / *#/)
      },
      {
        // date plus time
        begin: t.concat(
          /# */,
          t.either(a, i),
          / +/,
          t.either(s, o),
          / *#/
        )
      }
    ]
  }, c = {
    className: "number",
    relevance: 0,
    variants: [
      {
        // Float
        begin: /\b\d[\d_]*((\.[\d_]+(E[+-]?[\d_]+)?)|(E[+-]?[\d_]+))[RFD@!#]?/
      },
      {
        // Integer (base 10)
        begin: /\b\d[\d_]*((U?[SIL])|[%&])?/
      },
      {
        // Integer (base 16)
        begin: /&H[\dA-F_]+((U?[SIL])|[%&])?/
      },
      {
        // Integer (base 8)
        begin: /&O[0-7_]+((U?[SIL])|[%&])?/
      },
      {
        // Integer (base 2)
        begin: /&B[01_]+((U?[SIL])|[%&])?/
      }
    ]
  }, u = {
    className: "label",
    begin: /^\w+:/
  }, d = e.COMMENT(/'''/, /$/, { contains: [
    {
      className: "doctag",
      begin: /<\/?/,
      end: />/
    }
  ] }), f = e.COMMENT(null, /$/, { variants: [
    { begin: /'/ },
    {
      // TODO: Use multi-class for leading spaces
      begin: /([\t ]|^)REM(?=\s)/
    }
  ] });
  return {
    name: "Visual Basic .NET",
    aliases: ["vb"],
    case_insensitive: !0,
    classNameAliases: { label: "symbol" },
    keywords: {
      keyword: "addhandler alias aggregate ansi as async assembly auto binary by byref byval call case catch class compare const continue custom declare default delegate dim distinct do each equals else elseif end enum erase error event exit explicit finally for friend from function get global goto group handles if implements imports in inherits interface into iterator join key let lib loop me mid module mustinherit mustoverride mybase myclass namespace narrowing new next notinheritable notoverridable of off on operator option optional order overloads overridable overrides paramarray partial preserve private property protected public raiseevent readonly redim removehandler resume return select set shadows shared skip static step stop structure strict sub synclock take text then throw to try unicode until using when where while widening with withevents writeonly yield",
      built_in: (
        // Operators https://docs.microsoft.com/dotnet/visual-basic/language-reference/operators
        "addressof and andalso await directcast gettype getxmlnamespace is isfalse isnot istrue like mod nameof new not or orelse trycast typeof xor cbool cbyte cchar cdate cdbl cdec cint clng cobj csbyte cshort csng cstr cuint culng cushort"
      ),
      type: (
        // Data types https://docs.microsoft.com/dotnet/visual-basic/language-reference/data-types
        "boolean byte char date decimal double integer long object sbyte short single string uinteger ulong ushort"
      ),
      literal: "true false nothing"
    },
    illegal: "//|\\{|\\}|endif|gosub|variant|wend|^\\$ ",
    contains: [
      n,
      r,
      l,
      c,
      u,
      d,
      f,
      {
        className: "meta",
        // TODO: Use multi-class for indentation once available
        begin: /[\t ]*#(const|disable|else|elseif|enable|end|externalsource|if|region)\b/,
        end: /$/,
        keywords: { keyword: "const disable else elseif enable end externalsource if region then" },
        contains: [f]
      }
    ]
  };
}
function yD(e) {
  e.regex;
  const t = e.COMMENT(/\(;/, /;\)/);
  t.contains.push("self");
  const n = e.COMMENT(/;;/, /$/), r = [
    "anyfunc",
    "block",
    "br",
    "br_if",
    "br_table",
    "call",
    "call_indirect",
    "data",
    "drop",
    "elem",
    "else",
    "end",
    "export",
    "func",
    "global.get",
    "global.set",
    "local.get",
    "local.set",
    "local.tee",
    "get_global",
    "get_local",
    "global",
    "if",
    "import",
    "local",
    "loop",
    "memory",
    "memory.grow",
    "memory.size",
    "module",
    "mut",
    "nop",
    "offset",
    "param",
    "result",
    "return",
    "select",
    "set_global",
    "set_local",
    "start",
    "table",
    "tee_local",
    "then",
    "type",
    "unreachable"
  ], i = {
    begin: [
      /(?:func|call|call_indirect)/,
      /\s+/,
      /\$[^\s)]+/
    ],
    className: {
      1: "keyword",
      3: "title.function"
    }
  }, a = {
    className: "variable",
    begin: /\$[\w_]+/
  }, s = {
    match: /(\((?!;)|\))+/,
    className: "punctuation",
    relevance: 0
  }, o = {
    className: "number",
    relevance: 0,
    // borrowed from Prism, TODO: split out into variants
    match: /[+-]?\b(?:\d(?:_?\d)*(?:\.\d(?:_?\d)*)?(?:[eE][+-]?\d(?:_?\d)*)?|0x[\da-fA-F](?:_?[\da-fA-F])*(?:\.[\da-fA-F](?:_?[\da-fA-D])*)?(?:[pP][+-]?\d(?:_?\d)*)?)\b|\binf\b|\bnan(?::0x[\da-fA-F](?:_?[\da-fA-D])*)?\b/
  }, l = {
    // look-ahead prevents us from gobbling up opcodes
    match: /(i32|i64|f32|f64)(?!\.)/,
    className: "type"
  }, c = {
    className: "keyword",
    // borrowed from Prism, TODO: split out into variants
    match: /\b(f32|f64|i32|i64)(?:\.(?:abs|add|and|ceil|clz|const|convert_[su]\/i(?:32|64)|copysign|ctz|demote\/f64|div(?:_[su])?|eqz?|extend_[su]\/i32|floor|ge(?:_[su])?|gt(?:_[su])?|le(?:_[su])?|load(?:(?:8|16|32)_[su])?|lt(?:_[su])?|max|min|mul|nearest|neg?|or|popcnt|promote\/f32|reinterpret\/[fi](?:32|64)|rem_[su]|rot[lr]|shl|shr_[su]|store(?:8|16|32)?|sqrt|sub|trunc(?:_[su]\/f(?:32|64))?|wrap\/i64|xor))\b/
  };
  return {
    name: "WebAssembly",
    keywords: {
      $pattern: /[\w.]+/,
      keyword: r
    },
    contains: [
      n,
      t,
      {
        match: [
          /(?:offset|align)/,
          /\s*/,
          /=/
        ],
        className: {
          1: "keyword",
          3: "operator"
        }
      },
      a,
      s,
      i,
      e.QUOTE_STRING_MODE,
      l,
      c,
      o
    ]
  };
}
function _D(e) {
  const t = e.regex, n = t.concat(/[\p{L}_]/u, t.optional(/[\p{L}0-9_.-]*:/u), /[\p{L}0-9_.-]*/u), r = /[\p{L}0-9._:-]+/u, i = {
    className: "symbol",
    begin: /&[a-z]+;|&#[0-9]+;|&#x[a-f0-9]+;/
  }, a = {
    begin: /\s/,
    contains: [
      {
        className: "keyword",
        begin: /#?[a-z_][a-z1-9_-]+/,
        illegal: /\n/
      }
    ]
  }, s = e.inherit(a, {
    begin: /\(/,
    end: /\)/
  }), o = e.inherit(e.APOS_STRING_MODE, { className: "string" }), l = e.inherit(e.QUOTE_STRING_MODE, { className: "string" }), c = {
    endsWithParent: !0,
    illegal: /</,
    relevance: 0,
    contains: [
      {
        className: "attr",
        begin: r,
        relevance: 0
      },
      {
        begin: /=\s*/,
        relevance: 0,
        contains: [
          {
            className: "string",
            endsParent: !0,
            variants: [
              {
                begin: /"/,
                end: /"/,
                contains: [i]
              },
              {
                begin: /'/,
                end: /'/,
                contains: [i]
              },
              { begin: /[^\s"'=<>`]+/ }
            ]
          }
        ]
      }
    ]
  };
  return {
    name: "HTML, XML",
    aliases: [
      "html",
      "xhtml",
      "rss",
      "atom",
      "xjb",
      "xsd",
      "xsl",
      "plist",
      "wsf",
      "svg"
    ],
    case_insensitive: !0,
    unicodeRegex: !0,
    contains: [
      {
        className: "meta",
        begin: /<![a-z]/,
        end: />/,
        relevance: 10,
        contains: [
          a,
          l,
          o,
          s,
          {
            begin: /\[/,
            end: /\]/,
            contains: [
              {
                className: "meta",
                begin: /<![a-z]/,
                end: />/,
                contains: [
                  a,
                  s,
                  l,
                  o
                ]
              }
            ]
          }
        ]
      },
      e.COMMENT(
        /<!--/,
        /-->/,
        { relevance: 10 }
      ),
      {
        begin: /<!\[CDATA\[/,
        end: /\]\]>/,
        relevance: 10
      },
      i,
      // xml processing instructions
      {
        className: "meta",
        end: /\?>/,
        variants: [
          {
            begin: /<\?xml/,
            relevance: 10,
            contains: [
              l
            ]
          },
          {
            begin: /<\?[a-z][a-z0-9]+/
          }
        ]
      },
      {
        className: "tag",
        /*
        The lookahead pattern (?=...) ensures that 'begin' only matches
        '<style' as a single word, followed by a whitespace or an
        ending bracket.
        */
        begin: /<style(?=\s|>)/,
        end: />/,
        keywords: { name: "style" },
        contains: [c],
        starts: {
          end: /<\/style>/,
          returnEnd: !0,
          subLanguage: [
            "css",
            "xml"
          ]
        }
      },
      {
        className: "tag",
        // See the comment in the <style tag about the lookahead pattern
        begin: /<script(?=\s|>)/,
        end: />/,
        keywords: { name: "script" },
        contains: [c],
        starts: {
          end: /<\/script>/,
          returnEnd: !0,
          subLanguage: [
            "javascript",
            "handlebars",
            "xml"
          ]
        }
      },
      // we need this for now for jSX
      {
        className: "tag",
        begin: /<>|<\/>/
      },
      // open tag
      {
        className: "tag",
        begin: t.concat(
          /</,
          t.lookahead(t.concat(
            n,
            // <tag/>
            // <tag>
            // <tag ...
            t.either(/\/>/, />/, /\s/)
          ))
        ),
        end: /\/?>/,
        contains: [
          {
            className: "name",
            begin: n,
            relevance: 0,
            starts: c
          }
        ]
      },
      // close tag
      {
        className: "tag",
        begin: t.concat(
          /<\//,
          t.lookahead(t.concat(
            n,
            />/
          ))
        ),
        contains: [
          {
            className: "name",
            begin: n,
            relevance: 0
          },
          {
            begin: />/,
            relevance: 0,
            endsParent: !0
          }
        ]
      }
    ]
  };
}
function vD(e) {
  const t = "true false yes no null", n = "[\\w#;/?:@&=+$,.~*'()[\\]]+", r = {
    className: "attr",
    variants: [
      // added brackets support and special char support
      { begin: /[\w*@][\w*@ :()\./-]*:(?=[ \t]|$)/ },
      {
        // double quoted keys - with brackets and special char support
        begin: /"[\w*@][\w*@ :()\./-]*":(?=[ \t]|$)/
      },
      {
        // single quoted keys - with brackets and special char support
        begin: /'[\w*@][\w*@ :()\./-]*':(?=[ \t]|$)/
      }
    ]
  }, i = {
    className: "template-variable",
    variants: [
      {
        // jinja templates Ansible
        begin: /\{\{/,
        end: /\}\}/
      },
      {
        // Ruby i18n
        begin: /%\{/,
        end: /\}/
      }
    ]
  }, a = {
    className: "string",
    relevance: 0,
    begin: /'/,
    end: /'/,
    contains: [
      {
        match: /''/,
        scope: "char.escape",
        relevance: 0
      }
    ]
  }, s = {
    className: "string",
    relevance: 0,
    variants: [
      {
        begin: /"/,
        end: /"/
      },
      { begin: /\S+/ }
    ],
    contains: [
      e.BACKSLASH_ESCAPE,
      i
    ]
  }, o = e.inherit(s, { variants: [
    {
      begin: /'/,
      end: /'/,
      contains: [
        {
          begin: /''/,
          relevance: 0
        }
      ]
    },
    {
      begin: /"/,
      end: /"/
    },
    { begin: /[^\s,{}[\]]+/ }
  ] }), f = {
    className: "number",
    begin: "\\b" + "[0-9]{4}(-[0-9][0-9]){0,2}" + "([Tt \\t][0-9][0-9]?(:[0-9][0-9]){2})?" + "(\\.[0-9]*)?" + "([ \\t])*(Z|[-+][0-9][0-9]?(:[0-9][0-9])?)?" + "\\b"
  }, p = {
    end: ",",
    endsWithParent: !0,
    excludeEnd: !0,
    keywords: t,
    relevance: 0
  }, h = {
    begin: /\{/,
    end: /\}/,
    contains: [p],
    illegal: "\\n",
    relevance: 0
  }, g = {
    begin: "\\[",
    end: "\\]",
    contains: [p],
    illegal: "\\n",
    relevance: 0
  }, m = [
    r,
    {
      className: "meta",
      begin: "^---\\s*$",
      relevance: 10
    },
    {
      // multi line string
      // Blocks start with a | or > followed by a newline
      //
      // Indentation of subsequent lines must be the same to
      // be considered part of the block
      className: "string",
      begin: "[\\|>]([1-9]?[+-])?[ ]*\\n( +)[^ ][^\\n]*\\n(\\2[^\\n]+\\n?)*"
    },
    {
      // Ruby/Rails erb
      begin: "<%[%=-]?",
      end: "[%-]?%>",
      subLanguage: "ruby",
      excludeBegin: !0,
      excludeEnd: !0,
      relevance: 0
    },
    {
      // named tags
      className: "type",
      begin: "!\\w+!" + n
    },
    // https://yaml.org/spec/1.2/spec.html#id2784064
    {
      // verbatim tags
      className: "type",
      begin: "!<" + n + ">"
    },
    {
      // primary tags
      className: "type",
      begin: "!" + n
    },
    {
      // secondary tags
      className: "type",
      begin: "!!" + n
    },
    {
      // fragment id &ref
      className: "meta",
      begin: "&" + e.UNDERSCORE_IDENT_RE + "$"
    },
    {
      // fragment reference *ref
      className: "meta",
      begin: "\\*" + e.UNDERSCORE_IDENT_RE + "$"
    },
    {
      // array listing
      className: "bullet",
      // TODO: remove |$ hack when we have proper look-ahead support
      begin: "-(?=[ ]|$)",
      relevance: 0
    },
    e.HASH_COMMENT_MODE,
    {
      beginKeywords: t,
      keywords: { literal: t }
    },
    f,
    // numbers are any valid C-style number that
    // sit isolated from other words
    {
      className: "number",
      begin: e.C_NUMBER_RE + "\\b",
      relevance: 0
    },
    h,
    g,
    a,
    s
  ], b = [...m];
  return b.pop(), b.push(o), p.contains = b, {
    name: "YAML",
    case_insensitive: !0,
    aliases: ["yml"],
    contains: m
  };
}
const xD = {
  arduino: nP,
  bash: rP,
  c: iP,
  cpp: aP,
  csharp: sP,
  css: gP,
  diff: mP,
  go: bP,
  graphql: yP,
  ini: _P,
  java: vP,
  javascript: IP,
  json: SP,
  kotlin: kP,
  less: LP,
  lua: FP,
  makefile: BP,
  markdown: zP,
  objectivec: VP,
  perl: GP,
  php: jP,
  "php-template": UP,
  plaintext: HP,
  python: WP,
  "python-repl": ZP,
  r: $P,
  ruby: XP,
  rust: YP,
  scss: iD,
  shell: aD,
  sql: sD,
  swift: hD,
  typescript: mD,
  vbnet: bD,
  wasm: yD,
  xml: _D,
  yaml: vD
};
var ou, pg;
function ED() {
  if (pg) return ou;
  pg = 1;
  function e(N) {
    return N instanceof Map ? N.clear = N.delete = N.set = function() {
      throw new Error("map is read-only");
    } : N instanceof Set && (N.add = N.clear = N.delete = function() {
      throw new Error("set is read-only");
    }), Object.freeze(N), Object.getOwnPropertyNames(N).forEach((Z) => {
      const te = N[Z], Ae = typeof te;
      (Ae === "object" || Ae === "function") && !Object.isFrozen(te) && e(te);
    }), N;
  }
  class t {
    /**
     * @param {CompiledMode} mode
     */
    constructor(Z) {
      Z.data === void 0 && (Z.data = {}), this.data = Z.data, this.isMatchIgnored = !1;
    }
    ignoreMatch() {
      this.isMatchIgnored = !0;
    }
  }
  function n(N) {
    return N.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#x27;");
  }
  function r(N, ...Z) {
    const te = /* @__PURE__ */ Object.create(null);
    for (const Ae in N)
      te[Ae] = N[Ae];
    return Z.forEach(function(Ae) {
      for (const bt in Ae)
        te[bt] = Ae[bt];
    }), /** @type {T} */
    te;
  }
  const i = "</span>", a = (N) => !!N.scope, s = (N, { prefix: Z }) => {
    if (N.startsWith("language:"))
      return N.replace("language:", "language-");
    if (N.includes(".")) {
      const te = N.split(".");
      return [
        `${Z}${te.shift()}`,
        ...te.map((Ae, bt) => `${Ae}${"_".repeat(bt + 1)}`)
      ].join(" ");
    }
    return `${Z}${N}`;
  };
  class o {
    /**
     * Creates a new HTMLRenderer
     *
     * @param {Tree} parseTree - the parse tree (must support `walk` API)
     * @param {{classPrefix: string}} options
     */
    constructor(Z, te) {
      this.buffer = "", this.classPrefix = te.classPrefix, Z.walk(this);
    }
    /**
     * Adds texts to the output stream
     *
     * @param {string} text */
    addText(Z) {
      this.buffer += n(Z);
    }
    /**
     * Adds a node open to the output stream (if needed)
     *
     * @param {Node} node */
    openNode(Z) {
      if (!a(Z)) return;
      const te = s(
        Z.scope,
        { prefix: this.classPrefix }
      );
      this.span(te);
    }
    /**
     * Adds a node close to the output stream (if needed)
     *
     * @param {Node} node */
    closeNode(Z) {
      a(Z) && (this.buffer += i);
    }
    /**
     * returns the accumulated buffer
    */
    value() {
      return this.buffer;
    }
    // helpers
    /**
     * Builds a span element
     *
     * @param {string} className */
    span(Z) {
      this.buffer += `<span class="${Z}">`;
    }
  }
  const l = (N = {}) => {
    const Z = { children: [] };
    return Object.assign(Z, N), Z;
  };
  class c {
    constructor() {
      this.rootNode = l(), this.stack = [this.rootNode];
    }
    get top() {
      return this.stack[this.stack.length - 1];
    }
    get root() {
      return this.rootNode;
    }
    /** @param {Node} node */
    add(Z) {
      this.top.children.push(Z);
    }
    /** @param {string} scope */
    openNode(Z) {
      const te = l({ scope: Z });
      this.add(te), this.stack.push(te);
    }
    closeNode() {
      if (this.stack.length > 1)
        return this.stack.pop();
    }
    closeAllNodes() {
      for (; this.closeNode(); ) ;
    }
    toJSON() {
      return JSON.stringify(this.rootNode, null, 4);
    }
    /**
     * @typedef { import("./html_renderer").Renderer } Renderer
     * @param {Renderer} builder
     */
    walk(Z) {
      return this.constructor._walk(Z, this.rootNode);
    }
    /**
     * @param {Renderer} builder
     * @param {Node} node
     */
    static _walk(Z, te) {
      return typeof te == "string" ? Z.addText(te) : te.children && (Z.openNode(te), te.children.forEach((Ae) => this._walk(Z, Ae)), Z.closeNode(te)), Z;
    }
    /**
     * @param {Node} node
     */
    static _collapse(Z) {
      typeof Z != "string" && Z.children && (Z.children.every((te) => typeof te == "string") ? Z.children = [Z.children.join("")] : Z.children.forEach((te) => {
        c._collapse(te);
      }));
    }
  }
  class u extends c {
    /**
     * @param {*} options
     */
    constructor(Z) {
      super(), this.options = Z;
    }
    /**
     * @param {string} text
     */
    addText(Z) {
      Z !== "" && this.add(Z);
    }
    /** @param {string} scope */
    startScope(Z) {
      this.openNode(Z);
    }
    endScope() {
      this.closeNode();
    }
    /**
     * @param {Emitter & {root: DataNode}} emitter
     * @param {string} name
     */
    __addSublanguage(Z, te) {
      const Ae = Z.root;
      te && (Ae.scope = `language:${te}`), this.add(Ae);
    }
    toHTML() {
      return new o(this, this.options).value();
    }
    finalize() {
      return this.closeAllNodes(), !0;
    }
  }
  function d(N) {
    return N ? typeof N == "string" ? N : N.source : null;
  }
  function f(N) {
    return g("(?=", N, ")");
  }
  function p(N) {
    return g("(?:", N, ")*");
  }
  function h(N) {
    return g("(?:", N, ")?");
  }
  function g(...N) {
    return N.map((te) => d(te)).join("");
  }
  function m(N) {
    const Z = N[N.length - 1];
    return typeof Z == "object" && Z.constructor === Object ? (N.splice(N.length - 1, 1), Z) : {};
  }
  function b(...N) {
    return "(" + (m(N).capture ? "" : "?:") + N.map((Ae) => d(Ae)).join("|") + ")";
  }
  function y(N) {
    return new RegExp(N.toString() + "|").exec("").length - 1;
  }
  function v(N, Z) {
    const te = N && N.exec(Z);
    return te && te.index === 0;
  }
  const E = /\[(?:[^\\\]]|\\.)*\]|\(\??|\\([1-9][0-9]*)|\\./;
  function _(N, { joinWith: Z }) {
    let te = 0;
    return N.map((Ae) => {
      te += 1;
      const bt = te;
      let yt = d(Ae), ue = "";
      for (; yt.length > 0; ) {
        const le = E.exec(yt);
        if (!le) {
          ue += yt;
          break;
        }
        ue += yt.substring(0, le.index), yt = yt.substring(le.index + le[0].length), le[0][0] === "\\" && le[1] ? ue += "\\" + String(Number(le[1]) + bt) : (ue += le[0], le[0] === "(" && te++);
      }
      return ue;
    }).map((Ae) => `(${Ae})`).join(Z);
  }
  const x = /\b\B/, I = "[a-zA-Z]\\w*", T = "[a-zA-Z_]\\w*", O = "\\b\\d+(\\.\\d+)?", k = "(-?)(\\b0[xX][a-fA-F0-9]+|(\\b\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)", W = "\\b(0b[01]+)", M = "!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|-|-=|/=|/|:|;|<<|<<=|<=|<|===|==|=|>>>=|>>=|>=|>>>|>>|>|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~", L = (N = {}) => {
    const Z = /^#![ ]*\//;
    return N.binary && (N.begin = g(
      Z,
      /.*\b/,
      N.binary,
      /\b.*/
    )), r({
      scope: "meta",
      begin: Z,
      end: /$/,
      relevance: 0,
      /** @type {ModeCallback} */
      "on:begin": (te, Ae) => {
        te.index !== 0 && Ae.ignoreMatch();
      }
    }, N);
  }, z = {
    begin: "\\\\[\\s\\S]",
    relevance: 0
  }, U = {
    scope: "string",
    begin: "'",
    end: "'",
    illegal: "\\n",
    contains: [z]
  }, $ = {
    scope: "string",
    begin: '"',
    end: '"',
    illegal: "\\n",
    contains: [z]
  }, Q = {
    begin: /\b(a|an|the|are|I'm|isn't|don't|doesn't|won't|but|just|should|pretty|simply|enough|gonna|going|wtf|so|such|will|you|your|they|like|more)\b/
  }, K = function(N, Z, te = {}) {
    const Ae = r(
      {
        scope: "comment",
        begin: N,
        end: Z,
        contains: []
      },
      te
    );
    Ae.contains.push({
      scope: "doctag",
      // hack to avoid the space from being included. the space is necessary to
      // match here to prevent the plain text rule below from gobbling up doctags
      begin: "[ ]*(?=(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):)",
      end: /(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):/,
      excludeBegin: !0,
      relevance: 0
    });
    const bt = b(
      // list of common 1 and 2 letter words in English
      "I",
      "a",
      "is",
      "so",
      "us",
      "to",
      "at",
      "if",
      "in",
      "it",
      "on",
      // note: this is not an exhaustive list of contractions, just popular ones
      /[A-Za-z]+['](d|ve|re|ll|t|s|n)/,
      // contractions - can't we'd they're let's, etc
      /[A-Za-z]+[-][a-z]+/,
      // `no-way`, etc.
      /[A-Za-z][a-z]{2,}/
      // allow capitalized words at beginning of sentences
    );
    return Ae.contains.push(
      {
        // TODO: how to include ", (, ) without breaking grammars that use these for
        // comment delimiters?
        // begin: /[ ]+([()"]?([A-Za-z'-]{3,}|is|a|I|so|us|[tT][oO]|at|if|in|it|on)[.]?[()":]?([.][ ]|[ ]|\))){3}/
        // ---
        // this tries to find sequences of 3 english words in a row (without any
        // "programming" type syntax) this gives us a strong signal that we've
        // TRULY found a comment - vs perhaps scanning with the wrong language.
        // It's possible to find something that LOOKS like the start of the
        // comment - but then if there is no readable text - good chance it is a
        // false match and not a comment.
        //
        // for a visual example please see:
        // https://github.com/highlightjs/highlight.js/issues/2827
        begin: g(
          /[ ]+/,
          // necessary to prevent us gobbling up doctags like /* @author Bob Mcgill */
          "(",
          bt,
          /[.]?[:]?([.][ ]|[ ])/,
          "){3}"
        )
        // look for 3 words in a row
      }
    ), Ae;
  }, fe = K("//", "$"), S = K("/\\*", "\\*/"), me = K("#", "$"), se = {
    scope: "number",
    begin: O,
    relevance: 0
  }, A = {
    scope: "number",
    begin: k,
    relevance: 0
  }, ve = {
    scope: "number",
    begin: W,
    relevance: 0
  }, Te = {
    scope: "regexp",
    begin: /\/(?=[^/\n]*\/)/,
    end: /\/[gimuy]*/,
    contains: [
      z,
      {
        begin: /\[/,
        end: /\]/,
        relevance: 0,
        contains: [z]
      }
    ]
  }, Ce = {
    scope: "title",
    begin: I,
    relevance: 0
  }, Je = {
    scope: "title",
    begin: T,
    relevance: 0
  }, Be = {
    // excludes method names from keyword processing
    begin: "\\.\\s*" + T,
    relevance: 0
  };
  var at = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    APOS_STRING_MODE: U,
    BACKSLASH_ESCAPE: z,
    BINARY_NUMBER_MODE: ve,
    BINARY_NUMBER_RE: W,
    COMMENT: K,
    C_BLOCK_COMMENT_MODE: S,
    C_LINE_COMMENT_MODE: fe,
    C_NUMBER_MODE: A,
    C_NUMBER_RE: k,
    END_SAME_AS_BEGIN: function(N) {
      return Object.assign(
        N,
        {
          /** @type {ModeCallback} */
          "on:begin": (Z, te) => {
            te.data._beginMatch = Z[1];
          },
          /** @type {ModeCallback} */
          "on:end": (Z, te) => {
            te.data._beginMatch !== Z[1] && te.ignoreMatch();
          }
        }
      );
    },
    HASH_COMMENT_MODE: me,
    IDENT_RE: I,
    MATCH_NOTHING_RE: x,
    METHOD_GUARD: Be,
    NUMBER_MODE: se,
    NUMBER_RE: O,
    PHRASAL_WORDS_MODE: Q,
    QUOTE_STRING_MODE: $,
    REGEXP_MODE: Te,
    RE_STARTERS_RE: M,
    SHEBANG: L,
    TITLE_MODE: Ce,
    UNDERSCORE_IDENT_RE: T,
    UNDERSCORE_TITLE_MODE: Je
  });
  function mt(N, Z) {
    N.input[N.index - 1] === "." && Z.ignoreMatch();
  }
  function ie(N, Z) {
    N.className !== void 0 && (N.scope = N.className, delete N.className);
  }
  function Rt(N, Z) {
    Z && N.beginKeywords && (N.begin = "\\b(" + N.beginKeywords.split(" ").join("|") + ")(?!\\.)(?=\\b|\\s)", N.__beforeBegin = mt, N.keywords = N.keywords || N.beginKeywords, delete N.beginKeywords, N.relevance === void 0 && (N.relevance = 0));
  }
  function ft(N, Z) {
    Array.isArray(N.illegal) && (N.illegal = b(...N.illegal));
  }
  function wt(N, Z) {
    if (N.match) {
      if (N.begin || N.end) throw new Error("begin & end are not supported with match");
      N.begin = N.match, delete N.match;
    }
  }
  function Fe(N, Z) {
    N.relevance === void 0 && (N.relevance = 1);
  }
  const en = (N, Z) => {
    if (!N.beforeMatch) return;
    if (N.starts) throw new Error("beforeMatch cannot be used with starts");
    const te = Object.assign({}, N);
    Object.keys(N).forEach((Ae) => {
      delete N[Ae];
    }), N.keywords = te.keywords, N.begin = g(te.beforeMatch, f(te.begin)), N.starts = {
      relevance: 0,
      contains: [
        Object.assign(te, { endsParent: !0 })
      ]
    }, N.relevance = 0, delete te.beforeMatch;
  }, R = [
    "of",
    "and",
    "for",
    "in",
    "not",
    "or",
    "if",
    "then",
    "parent",
    // common variable name
    "list",
    // common variable name
    "value"
    // common variable name
  ], D = "keyword";
  function V(N, Z, te = D) {
    const Ae = /* @__PURE__ */ Object.create(null);
    return typeof N == "string" ? bt(te, N.split(" ")) : Array.isArray(N) ? bt(te, N) : Object.keys(N).forEach(function(yt) {
      Object.assign(
        Ae,
        V(N[yt], Z, yt)
      );
    }), Ae;
    function bt(yt, ue) {
      Z && (ue = ue.map((le) => le.toLowerCase())), ue.forEach(function(le) {
        const Se = le.split("|");
        Ae[Se[0]] = [yt, C(Se[0], Se[1])];
      });
    }
  }
  function C(N, Z) {
    return Z ? Number(Z) : G(N) ? 0 : 1;
  }
  function G(N) {
    return R.includes(N.toLowerCase());
  }
  const B = {}, Y = (N) => {
    console.error(N);
  }, ce = (N, ...Z) => {
    console.log(`WARN: ${N}`, ...Z);
  }, P = (N, Z) => {
    B[`${N}/${Z}`] || (console.log(`Deprecated as of ${N}. ${Z}`), B[`${N}/${Z}`] = !0);
  }, j = new Error();
  function oe(N, Z, { key: te }) {
    let Ae = 0;
    const bt = N[te], yt = {}, ue = {};
    for (let le = 1; le <= Z.length; le++)
      ue[le + Ae] = bt[le], yt[le + Ae] = !0, Ae += y(Z[le - 1]);
    N[te] = ue, N[te]._emit = yt, N[te]._multi = !0;
  }
  function Ie(N) {
    if (Array.isArray(N.begin)) {
      if (N.skip || N.excludeBegin || N.returnBegin)
        throw Y("skip, excludeBegin, returnBegin not compatible with beginScope: {}"), j;
      if (typeof N.beginScope != "object" || N.beginScope === null)
        throw Y("beginScope must be object"), j;
      oe(N, N.begin, { key: "beginScope" }), N.begin = _(N.begin, { joinWith: "" });
    }
  }
  function xe(N) {
    if (Array.isArray(N.end)) {
      if (N.skip || N.excludeEnd || N.returnEnd)
        throw Y("skip, excludeEnd, returnEnd not compatible with endScope: {}"), j;
      if (typeof N.endScope != "object" || N.endScope === null)
        throw Y("endScope must be object"), j;
      oe(N, N.end, { key: "endScope" }), N.end = _(N.end, { joinWith: "" });
    }
  }
  function rt(N) {
    N.scope && typeof N.scope == "object" && N.scope !== null && (N.beginScope = N.scope, delete N.scope);
  }
  function Ft(N) {
    rt(N), typeof N.beginScope == "string" && (N.beginScope = { _wrap: N.beginScope }), typeof N.endScope == "string" && (N.endScope = { _wrap: N.endScope }), Ie(N), xe(N);
  }
  function ot(N) {
    function Z(ue, le) {
      return new RegExp(
        d(ue),
        "m" + (N.case_insensitive ? "i" : "") + (N.unicodeRegex ? "u" : "") + (le ? "g" : "")
      );
    }
    class te {
      constructor() {
        this.matchIndexes = {}, this.regexes = [], this.matchAt = 1, this.position = 0;
      }
      // @ts-ignore
      addRule(le, Se) {
        Se.position = this.position++, this.matchIndexes[this.matchAt] = Se, this.regexes.push([Se, le]), this.matchAt += y(le) + 1;
      }
      compile() {
        this.regexes.length === 0 && (this.exec = () => null);
        const le = this.regexes.map((Se) => Se[1]);
        this.matcherRe = Z(_(le, { joinWith: "|" }), !0), this.lastIndex = 0;
      }
      /** @param {string} s */
      exec(le) {
        this.matcherRe.lastIndex = this.lastIndex;
        const Se = this.matcherRe.exec(le);
        if (!Se)
          return null;
        const Mt = Se.findIndex((Ba, xc) => xc > 0 && Ba !== void 0), It = this.matchIndexes[Mt];
        return Se.splice(0, Mt), Object.assign(Se, It);
      }
    }
    class Ae {
      constructor() {
        this.rules = [], this.multiRegexes = [], this.count = 0, this.lastIndex = 0, this.regexIndex = 0;
      }
      // @ts-ignore
      getMatcher(le) {
        if (this.multiRegexes[le]) return this.multiRegexes[le];
        const Se = new te();
        return this.rules.slice(le).forEach(([Mt, It]) => Se.addRule(Mt, It)), Se.compile(), this.multiRegexes[le] = Se, Se;
      }
      resumingScanAtSamePosition() {
        return this.regexIndex !== 0;
      }
      considerAll() {
        this.regexIndex = 0;
      }
      // @ts-ignore
      addRule(le, Se) {
        this.rules.push([le, Se]), Se.type === "begin" && this.count++;
      }
      /** @param {string} s */
      exec(le) {
        const Se = this.getMatcher(this.regexIndex);
        Se.lastIndex = this.lastIndex;
        let Mt = Se.exec(le);
        if (this.resumingScanAtSamePosition() && !(Mt && Mt.index === this.lastIndex)) {
          const It = this.getMatcher(0);
          It.lastIndex = this.lastIndex + 1, Mt = It.exec(le);
        }
        return Mt && (this.regexIndex += Mt.position + 1, this.regexIndex === this.count && this.considerAll()), Mt;
      }
    }
    function bt(ue) {
      const le = new Ae();
      return ue.contains.forEach((Se) => le.addRule(Se.begin, { rule: Se, type: "begin" })), ue.terminatorEnd && le.addRule(ue.terminatorEnd, { type: "end" }), ue.illegal && le.addRule(ue.illegal, { type: "illegal" }), le;
    }
    function yt(ue, le) {
      const Se = (
        /** @type CompiledMode */
        ue
      );
      if (ue.isCompiled) return Se;
      [
        ie,
        // do this early so compiler extensions generally don't have to worry about
        // the distinction between match/begin
        wt,
        Ft,
        en
      ].forEach((It) => It(ue, le)), N.compilerExtensions.forEach((It) => It(ue, le)), ue.__beforeBegin = null, [
        Rt,
        // do this later so compiler extensions that come earlier have access to the
        // raw array if they wanted to perhaps manipulate it, etc.
        ft,
        // default to 1 relevance if not specified
        Fe
      ].forEach((It) => It(ue, le)), ue.isCompiled = !0;
      let Mt = null;
      return typeof ue.keywords == "object" && ue.keywords.$pattern && (ue.keywords = Object.assign({}, ue.keywords), Mt = ue.keywords.$pattern, delete ue.keywords.$pattern), Mt = Mt || /\w+/, ue.keywords && (ue.keywords = V(ue.keywords, N.case_insensitive)), Se.keywordPatternRe = Z(Mt, !0), le && (ue.begin || (ue.begin = /\B|\b/), Se.beginRe = Z(Se.begin), !ue.end && !ue.endsWithParent && (ue.end = /\B|\b/), ue.end && (Se.endRe = Z(Se.end)), Se.terminatorEnd = d(Se.end) || "", ue.endsWithParent && le.terminatorEnd && (Se.terminatorEnd += (ue.end ? "|" : "") + le.terminatorEnd)), ue.illegal && (Se.illegalRe = Z(
        /** @type {RegExp | string} */
        ue.illegal
      )), ue.contains || (ue.contains = []), ue.contains = [].concat(...ue.contains.map(function(It) {
        return Ct(It === "self" ? ue : It);
      })), ue.contains.forEach(function(It) {
        yt(
          /** @type Mode */
          It,
          Se
        );
      }), ue.starts && yt(ue.starts, le), Se.matcher = bt(Se), Se;
    }
    if (N.compilerExtensions || (N.compilerExtensions = []), N.contains && N.contains.includes("self"))
      throw new Error("ERR: contains `self` is not supported at the top-level of a language.  See documentation.");
    return N.classNameAliases = r(N.classNameAliases || {}), yt(
      /** @type Mode */
      N
    );
  }
  function tn(N) {
    return N ? N.endsWithParent || tn(N.starts) : !1;
  }
  function Ct(N) {
    return N.variants && !N.cachedVariants && (N.cachedVariants = N.variants.map(function(Z) {
      return r(N, { variants: null }, Z);
    })), N.cachedVariants ? N.cachedVariants : tn(N) ? r(N, { starts: N.starts ? r(N.starts) : null }) : Object.isFrozen(N) ? r(N) : N;
  }
  var nn = "11.11.1";
  class Zr extends Error {
    constructor(Z, te) {
      super(Z), this.name = "HTMLInjectionError", this.html = te;
    }
  }
  const wn = n, np = r, rp = Symbol("nomatch"), Ev = 7, ip = function(N) {
    const Z = /* @__PURE__ */ Object.create(null), te = /* @__PURE__ */ Object.create(null), Ae = [];
    let bt = !0;
    const yt = "Could not find the language '{}', did you forget to load/include a language module?", ue = { disableAutodetect: !0, name: "Plain text", contains: [] };
    let le = {
      ignoreUnescapedHTML: !1,
      throwUnescapedHTML: !1,
      noHighlightRe: /^(no-?highlight)$/i,
      languageDetectRe: /\blang(?:uage)?-([\w-]+)\b/i,
      classPrefix: "hljs-",
      cssSelector: "pre code",
      languages: null,
      // beta configuration options, subject to change, welcome to discuss
      // https://github.com/highlightjs/highlight.js/issues/1086
      __emitter: u
    };
    function Se(q) {
      return le.noHighlightRe.test(q);
    }
    function Mt(q) {
      let be = q.className + " ";
      be += q.parentNode ? q.parentNode.className : "";
      const ze = le.languageDetectRe.exec(be);
      if (ze) {
        const et = $r(ze[1]);
        return et || (ce(yt.replace("{}", ze[1])), ce("Falling back to no-highlight mode for this block.", q)), et ? ze[1] : "no-highlight";
      }
      return be.split(/\s+/).find((et) => Se(et) || $r(et));
    }
    function It(q, be, ze) {
      let et = "", Nt = "";
      typeof be == "object" ? (et = q, ze = be.ignoreIllegals, Nt = be.language) : (P("10.7.0", "highlight(lang, code, ...args) has been deprecated."), P("10.7.0", `Please use highlight(code, options) instead.
https://github.com/highlightjs/highlight.js/issues/2277`), Nt = q, et = be), ze === void 0 && (ze = !0);
      const Xn = {
        code: et,
        language: Nt
      };
      so("before:highlight", Xn);
      const Xr = Xn.result ? Xn.result : Ba(Xn.language, Xn.code, ze);
      return Xr.code = Xn.code, so("after:highlight", Xr), Xr;
    }
    function Ba(q, be, ze, et) {
      const Nt = /* @__PURE__ */ Object.create(null);
      function Xn(re, he) {
        return re.keywords[he];
      }
      function Xr() {
        if (!ke.keywords) {
          Bt.addText(tt);
          return;
        }
        let re = 0;
        ke.keywordPatternRe.lastIndex = 0;
        let he = ke.keywordPatternRe.exec(tt), Pe = "";
        for (; he; ) {
          Pe += tt.substring(re, he.index);
          const Ye = ar.case_insensitive ? he[0].toLowerCase() : he[0], Ut = Xn(ke, Ye);
          if (Ut) {
            const [Ir, zv] = Ut;
            if (Bt.addText(Pe), Pe = "", Nt[Ye] = (Nt[Ye] || 0) + 1, Nt[Ye] <= Ev && (co += zv), Ir.startsWith("_"))
              Pe += he[0];
            else {
              const Vv = ar.classNameAliases[Ir] || Ir;
              ir(he[0], Vv);
            }
          } else
            Pe += he[0];
          re = ke.keywordPatternRe.lastIndex, he = ke.keywordPatternRe.exec(tt);
        }
        Pe += tt.substring(re), Bt.addText(Pe);
      }
      function oo() {
        if (tt === "") return;
        let re = null;
        if (typeof ke.subLanguage == "string") {
          if (!Z[ke.subLanguage]) {
            Bt.addText(tt);
            return;
          }
          re = Ba(ke.subLanguage, tt, !0, fp[ke.subLanguage]), fp[ke.subLanguage] = /** @type {CompiledMode} */
          re._top;
        } else
          re = Ec(tt, ke.subLanguage.length ? ke.subLanguage : null);
        ke.relevance > 0 && (co += re.relevance), Bt.__addSublanguage(re._emitter, re.language);
      }
      function Cn() {
        ke.subLanguage != null ? oo() : Xr(), tt = "";
      }
      function ir(re, he) {
        re !== "" && (Bt.startScope(he), Bt.addText(re), Bt.endScope());
      }
      function lp(re, he) {
        let Pe = 1;
        const Ye = he.length - 1;
        for (; Pe <= Ye; ) {
          if (!re._emit[Pe]) {
            Pe++;
            continue;
          }
          const Ut = ar.classNameAliases[re[Pe]] || re[Pe], Ir = he[Pe];
          Ut ? ir(Ir, Ut) : (tt = Ir, Xr(), tt = ""), Pe++;
        }
      }
      function cp(re, he) {
        return re.scope && typeof re.scope == "string" && Bt.openNode(ar.classNameAliases[re.scope] || re.scope), re.beginScope && (re.beginScope._wrap ? (ir(tt, ar.classNameAliases[re.beginScope._wrap] || re.beginScope._wrap), tt = "") : re.beginScope._multi && (lp(re.beginScope, he), tt = "")), ke = Object.create(re, { parent: { value: ke } }), ke;
      }
      function up(re, he, Pe) {
        let Ye = v(re.endRe, Pe);
        if (Ye) {
          if (re["on:end"]) {
            const Ut = new t(re);
            re["on:end"](he, Ut), Ut.isMatchIgnored && (Ye = !1);
          }
          if (Ye) {
            for (; re.endsParent && re.parent; )
              re = re.parent;
            return re;
          }
        }
        if (re.endsWithParent)
          return up(re.parent, he, Pe);
      }
      function Pv(re) {
        return ke.matcher.regexIndex === 0 ? (tt += re[0], 1) : (Sc = !0, 0);
      }
      function Dv(re) {
        const he = re[0], Pe = re.rule, Ye = new t(Pe), Ut = [Pe.__beforeBegin, Pe["on:begin"]];
        for (const Ir of Ut)
          if (Ir && (Ir(re, Ye), Ye.isMatchIgnored))
            return Pv(he);
        return Pe.skip ? tt += he : (Pe.excludeBegin && (tt += he), Cn(), !Pe.returnBegin && !Pe.excludeBegin && (tt = he)), cp(Pe, re), Pe.returnBegin ? 0 : he.length;
      }
      function Lv(re) {
        const he = re[0], Pe = be.substring(re.index), Ye = up(ke, re, Pe);
        if (!Ye)
          return rp;
        const Ut = ke;
        ke.endScope && ke.endScope._wrap ? (Cn(), ir(he, ke.endScope._wrap)) : ke.endScope && ke.endScope._multi ? (Cn(), lp(ke.endScope, re)) : Ut.skip ? tt += he : (Ut.returnEnd || Ut.excludeEnd || (tt += he), Cn(), Ut.excludeEnd && (tt = he));
        do
          ke.scope && Bt.closeNode(), !ke.skip && !ke.subLanguage && (co += ke.relevance), ke = ke.parent;
        while (ke !== Ye.parent);
        return Ye.starts && cp(Ye.starts, re), Ut.returnEnd ? 0 : he.length;
      }
      function Fv() {
        const re = [];
        for (let he = ke; he !== ar; he = he.parent)
          he.scope && re.unshift(he.scope);
        re.forEach((he) => Bt.openNode(he));
      }
      let lo = {};
      function dp(re, he) {
        const Pe = he && he[0];
        if (tt += re, Pe == null)
          return Cn(), 0;
        if (lo.type === "begin" && he.type === "end" && lo.index === he.index && Pe === "") {
          if (tt += be.slice(he.index, he.index + 1), !bt) {
            const Ye = new Error(`0 width match regex (${q})`);
            throw Ye.languageName = q, Ye.badRule = lo.rule, Ye;
          }
          return 1;
        }
        if (lo = he, he.type === "begin")
          return Dv(he);
        if (he.type === "illegal" && !ze) {
          const Ye = new Error('Illegal lexeme "' + Pe + '" for mode "' + (ke.scope || "<unnamed>") + '"');
          throw Ye.mode = ke, Ye;
        } else if (he.type === "end") {
          const Ye = Lv(he);
          if (Ye !== rp)
            return Ye;
        }
        if (he.type === "illegal" && Pe === "")
          return tt += `
`, 1;
        if (Ic > 1e5 && Ic > he.index * 3)
          throw new Error("potential infinite loop, way more iterations than matches");
        return tt += Pe, Pe.length;
      }
      const ar = $r(q);
      if (!ar)
        throw Y(yt.replace("{}", q)), new Error('Unknown language: "' + q + '"');
      const Bv = ot(ar);
      let Cc = "", ke = et || Bv;
      const fp = {}, Bt = new le.__emitter(le);
      Fv();
      let tt = "", co = 0, ci = 0, Ic = 0, Sc = !1;
      try {
        if (ar.__emitTokens)
          ar.__emitTokens(be, Bt);
        else {
          for (ke.matcher.considerAll(); ; ) {
            Ic++, Sc ? Sc = !1 : ke.matcher.considerAll(), ke.matcher.lastIndex = ci;
            const re = ke.matcher.exec(be);
            if (!re) break;
            const he = be.substring(ci, re.index), Pe = dp(he, re);
            ci = re.index + Pe;
          }
          dp(be.substring(ci));
        }
        return Bt.finalize(), Cc = Bt.toHTML(), {
          language: q,
          value: Cc,
          relevance: co,
          illegal: !1,
          _emitter: Bt,
          _top: ke
        };
      } catch (re) {
        if (re.message && re.message.includes("Illegal"))
          return {
            language: q,
            value: wn(be),
            illegal: !0,
            relevance: 0,
            _illegalBy: {
              message: re.message,
              index: ci,
              context: be.slice(ci - 100, ci + 100),
              mode: re.mode,
              resultSoFar: Cc
            },
            _emitter: Bt
          };
        if (bt)
          return {
            language: q,
            value: wn(be),
            illegal: !1,
            relevance: 0,
            errorRaised: re,
            _emitter: Bt,
            _top: ke
          };
        throw re;
      }
    }
    function xc(q) {
      const be = {
        value: wn(q),
        illegal: !1,
        relevance: 0,
        _top: ue,
        _emitter: new le.__emitter(le)
      };
      return be._emitter.addText(q), be;
    }
    function Ec(q, be) {
      be = be || le.languages || Object.keys(Z);
      const ze = xc(q), et = be.filter($r).filter(op).map(
        (Cn) => Ba(Cn, q, !1)
      );
      et.unshift(ze);
      const Nt = et.sort((Cn, ir) => {
        if (Cn.relevance !== ir.relevance) return ir.relevance - Cn.relevance;
        if (Cn.language && ir.language) {
          if ($r(Cn.language).supersetOf === ir.language)
            return 1;
          if ($r(ir.language).supersetOf === Cn.language)
            return -1;
        }
        return 0;
      }), [Xn, Xr] = Nt, oo = Xn;
      return oo.secondBest = Xr, oo;
    }
    function wv(q, be, ze) {
      const et = be && te[be] || ze;
      q.classList.add("hljs"), q.classList.add(`language-${et}`);
    }
    function wc(q) {
      let be = null;
      const ze = Mt(q);
      if (Se(ze)) return;
      if (so(
        "before:highlightElement",
        { el: q, language: ze }
      ), q.dataset.highlighted) {
        console.log("Element previously highlighted. To highlight again, first unset `dataset.highlighted`.", q);
        return;
      }
      if (q.children.length > 0 && (le.ignoreUnescapedHTML || (console.warn("One of your code blocks includes unescaped HTML. This is a potentially serious security risk."), console.warn("https://github.com/highlightjs/highlight.js/wiki/security"), console.warn("The element with unescaped HTML:"), console.warn(q)), le.throwUnescapedHTML))
        throw new Zr(
          "One of your code blocks includes unescaped HTML.",
          q.innerHTML
        );
      be = q;
      const et = be.textContent, Nt = ze ? It(et, { language: ze, ignoreIllegals: !0 }) : Ec(et);
      q.innerHTML = Nt.value, q.dataset.highlighted = "yes", wv(q, ze, Nt.language), q.result = {
        language: Nt.language,
        // TODO: remove with version 11.0
        re: Nt.relevance,
        relevance: Nt.relevance
      }, Nt.secondBest && (q.secondBest = {
        language: Nt.secondBest.language,
        relevance: Nt.secondBest.relevance
      }), so("after:highlightElement", { el: q, result: Nt, text: et });
    }
    function Cv(q) {
      le = np(le, q);
    }
    const Iv = () => {
      ao(), P("10.6.0", "initHighlighting() deprecated.  Use highlightAll() now.");
    };
    function Sv() {
      ao(), P("10.6.0", "initHighlightingOnLoad() deprecated.  Use highlightAll() now.");
    }
    let ap = !1;
    function ao() {
      function q() {
        ao();
      }
      if (document.readyState === "loading") {
        ap || window.addEventListener("DOMContentLoaded", q, !1), ap = !0;
        return;
      }
      document.querySelectorAll(le.cssSelector).forEach(wc);
    }
    function Av(q, be) {
      let ze = null;
      try {
        ze = be(N);
      } catch (et) {
        if (Y("Language definition for '{}' could not be registered.".replace("{}", q)), bt)
          Y(et);
        else
          throw et;
        ze = ue;
      }
      ze.name || (ze.name = q), Z[q] = ze, ze.rawDefinition = be.bind(null, N), ze.aliases && sp(ze.aliases, { languageName: q });
    }
    function kv(q) {
      delete Z[q];
      for (const be of Object.keys(te))
        te[be] === q && delete te[be];
    }
    function Tv() {
      return Object.keys(Z);
    }
    function $r(q) {
      return q = (q || "").toLowerCase(), Z[q] || Z[te[q]];
    }
    function sp(q, { languageName: be }) {
      typeof q == "string" && (q = [q]), q.forEach((ze) => {
        te[ze.toLowerCase()] = be;
      });
    }
    function op(q) {
      const be = $r(q);
      return be && !be.disableAutodetect;
    }
    function Rv(q) {
      q["before:highlightBlock"] && !q["before:highlightElement"] && (q["before:highlightElement"] = (be) => {
        q["before:highlightBlock"](
          Object.assign({ block: be.el }, be)
        );
      }), q["after:highlightBlock"] && !q["after:highlightElement"] && (q["after:highlightElement"] = (be) => {
        q["after:highlightBlock"](
          Object.assign({ block: be.el }, be)
        );
      });
    }
    function Nv(q) {
      Rv(q), Ae.push(q);
    }
    function Ov(q) {
      const be = Ae.indexOf(q);
      be !== -1 && Ae.splice(be, 1);
    }
    function so(q, be) {
      const ze = q;
      Ae.forEach(function(et) {
        et[ze] && et[ze](be);
      });
    }
    function Mv(q) {
      return P("10.7.0", "highlightBlock will be removed entirely in v12.0"), P("10.7.0", "Please use highlightElement now."), wc(q);
    }
    Object.assign(N, {
      highlight: It,
      highlightAuto: Ec,
      highlightAll: ao,
      highlightElement: wc,
      // TODO: Remove with v12 API
      highlightBlock: Mv,
      configure: Cv,
      initHighlighting: Iv,
      initHighlightingOnLoad: Sv,
      registerLanguage: Av,
      unregisterLanguage: kv,
      listLanguages: Tv,
      getLanguage: $r,
      registerAliases: sp,
      autoDetection: op,
      inherit: np,
      addPlugin: Nv,
      removePlugin: Ov
    }), N.debugMode = function() {
      bt = !1;
    }, N.safeMode = function() {
      bt = !0;
    }, N.versionString = nn, N.regex = {
      concat: g,
      lookahead: f,
      either: b,
      optional: h,
      anyNumberOfTimes: p
    };
    for (const q in at)
      typeof at[q] == "object" && e(at[q]);
    return Object.assign(N, at), N;
  }, Vi = ip({});
  return Vi.newInstance = () => ip({}), ou = Vi, Vi.HighlightJS = Vi, Vi.default = Vi, ou;
}
var wD = /* @__PURE__ */ ED();
const CD = /* @__PURE__ */ Dd(wD), hg = {}, ID = "hljs-";
function SD(e) {
  const t = CD.newInstance();
  return e && a(e), {
    highlight: n,
    highlightAuto: r,
    listLanguages: i,
    register: a,
    registerAlias: s,
    registered: o
  };
  function n(l, c, u) {
    const d = u || hg, f = typeof d.prefix == "string" ? d.prefix : ID;
    if (!t.getLanguage(l))
      throw new Error("Unknown language: `" + l + "` is not registered");
    t.configure({ __emitter: AD, classPrefix: f });
    const p = (
      /** @type {HighlightResult & {_emitter: HastEmitter}} */
      t.highlight(c, { ignoreIllegals: !0, language: l })
    );
    if (p.errorRaised)
      throw new Error("Could not highlight with `Highlight.js`", {
        cause: p.errorRaised
      });
    const h = p._emitter.root, g = (
      /** @type {RootData} */
      h.data
    );
    return g.language = p.language, g.relevance = p.relevance, h;
  }
  function r(l, c) {
    const d = (c || hg).subset || i();
    let f = -1, p = 0, h;
    for (; ++f < d.length; ) {
      const g = d[f];
      if (!t.getLanguage(g)) continue;
      const m = n(g, l, c);
      m.data && m.data.relevance !== void 0 && m.data.relevance > p && (p = m.data.relevance, h = m);
    }
    return h || {
      type: "root",
      children: [],
      data: { language: void 0, relevance: p }
    };
  }
  function i() {
    return t.listLanguages();
  }
  function a(l, c) {
    if (typeof l == "string")
      t.registerLanguage(l, c);
    else {
      let u;
      for (u in l)
        Object.hasOwn(l, u) && t.registerLanguage(u, l[u]);
    }
  }
  function s(l, c) {
    if (typeof l == "string")
      t.registerAliases(
        // Note: copy needed because hljs doesnt accept readonly arrays yet.
        typeof c == "string" ? c : [...c],
        { languageName: l }
      );
    else {
      let u;
      for (u in l)
        if (Object.hasOwn(l, u)) {
          const d = l[u];
          t.registerAliases(
            // Note: copy needed because hljs doesnt accept readonly arrays yet.
            typeof d == "string" ? d : [...d],
            { languageName: u }
          );
        }
    }
  }
  function o(l) {
    return !!t.getLanguage(l);
  }
}
class AD {
  /**
   * @param {Readonly<HljsOptions>} options
   *   Configuration.
   * @returns
   *   Instance.
   */
  constructor(t) {
    this.options = t, this.root = {
      type: "root",
      children: [],
      data: { language: void 0, relevance: 0 }
    }, this.stack = [this.root];
  }
  /**
   * @param {string} value
   *   Text to add.
   * @returns {undefined}
   *   Nothing.
   *
   */
  addText(t) {
    if (t === "") return;
    const n = this.stack[this.stack.length - 1], r = n.children[n.children.length - 1];
    r && r.type === "text" ? r.value += t : n.children.push({ type: "text", value: t });
  }
  /**
   *
   * @param {unknown} rawName
   *   Name to add.
   * @returns {undefined}
   *   Nothing.
   */
  startScope(t) {
    this.openNode(String(t));
  }
  /**
   * @returns {undefined}
   *   Nothing.
   */
  endScope() {
    this.closeNode();
  }
  /**
   * @param {HastEmitter} other
   *   Other emitter.
   * @param {string} name
   *   Name of the sublanguage.
   * @returns {undefined}
   *   Nothing.
   */
  __addSublanguage(t, n) {
    const r = this.stack[this.stack.length - 1], i = (
      /** @type {Array<ElementContent>} */
      t.root.children
    );
    n ? r.children.push({
      type: "element",
      tagName: "span",
      properties: { className: [n] },
      children: i
    }) : r.children.push(...i);
  }
  /**
   * @param {string} name
   *   Name to add.
   * @returns {undefined}
   *   Nothing.
   */
  openNode(t) {
    const n = this, r = t.split(".").map(function(s, o) {
      return o ? s + "_".repeat(o) : n.options.classPrefix + s;
    }), i = this.stack[this.stack.length - 1], a = {
      type: "element",
      tagName: "span",
      properties: { className: r },
      children: []
    };
    i.children.push(a), this.stack.push(a);
  }
  /**
   * @returns {undefined}
   *   Nothing.
   */
  closeNode() {
    this.stack.pop();
  }
  /**
   * @returns {undefined}
   *   Nothing.
   */
  finalize() {
  }
  /**
   * @returns {string}
   *   Nothing.
   */
  toHTML() {
    return "";
  }
}
const kD = {};
function TD(e) {
  const t = e || kD, n = t.aliases, r = t.detect || !1, i = t.languages || xD, a = t.plainText, s = t.prefix, o = t.subset;
  let l = "hljs";
  const c = SD(i);
  if (n && c.registerAlias(n), s) {
    const u = s.indexOf("-");
    l = u === -1 ? s : s.slice(0, u);
  }
  return function(u, d) {
    rc(u, "element", function(f, p, h) {
      if (f.tagName !== "code" || !h || h.type !== "element" || h.tagName !== "pre")
        return;
      const g = RD(f);
      if (g === !1 || !g && !r || g && a && a.includes(g))
        return;
      Array.isArray(f.properties.className) || (f.properties.className = []), f.properties.className.includes(l) || f.properties.className.unshift(l);
      const m = XM(f, { whitespace: "pre" });
      let b;
      try {
        b = g ? c.highlight(g, m, { prefix: s }) : c.highlightAuto(m, { prefix: s, subset: o });
      } catch (y) {
        const v = (
          /** @type {Error} */
          y
        );
        if (g && /Unknown language/.test(v.message)) {
          d.message(
            "Cannot highlight as `" + g + "`, its not registered",
            {
              ancestors: [h, f],
              cause: v,
              place: f.position,
              ruleId: "missing-language",
              source: "rehype-highlight"
            }
          );
          return;
        }
        throw v;
      }
      !g && b.data && b.data.language && f.properties.className.push("language-" + b.data.language), b.children.length > 0 && (f.children = /** @type {Array<ElementContent>} */
      b.children);
    });
  };
}
function RD(e) {
  const t = e.properties.className;
  let n = -1;
  if (!Array.isArray(t))
    return;
  let r;
  for (; ++n < t.length; ) {
    const i = String(t[n]);
    if (i === "no-highlight" || i === "nohighlight")
      return !1;
    !r && i.slice(0, 5) === "lang-" && (r = i.slice(5)), !r && i.slice(0, 9) === "language-" && (r = i.slice(9));
  }
  return r;
}
const ND = ({ content: e }) => /* @__PURE__ */ w.jsxs("div", { className: "markdown-container", children: [
  " ",
  /* @__PURE__ */ w.jsx(
    RN,
    {
      children: e,
      remarkPlugins: [GM],
      rehypePlugins: [TD]
    }
  )
] }), b4 = {
  DynamicForm: Jl,
  LiquidSearchForm: IS,
  LiquidTable: sA,
  LoginForm: oA,
  RegisterForm: lA,
  SectionCard: bA,
  SectionCardRow: yA,
  StyledMarkdown: ND
};
function OD(e) {
  return Bn({ attr: { viewBox: "0 0 24 24" }, child: [{ tag: "path", attr: { d: "M11.001 10h2v5h-2zM11 16h2v2h-2z" }, child: [] }, { tag: "path", attr: { d: "M13.768 4.2C13.42 3.545 12.742 3.138 12 3.138s-1.42.407-1.768 1.063L2.894 18.064a1.986 1.986 0 0 0 .054 1.968A1.984 1.984 0 0 0 4.661 21h14.678c.708 0 1.349-.362 1.714-.968a1.989 1.989 0 0 0 .054-1.968L13.768 4.2zM4.661 19 12 5.137 19.344 19H4.661z" }, child: [] }] })(e);
}
const MD = () => /* @__PURE__ */ w.jsx(
  pn,
  {
    position: "fixed",
    flexDirection: "column",
    justifyContent: "center",
    width: "100%",
    height: "100vh",
    children: /* @__PURE__ */ w.jsx(
      nf,
      {
        icon: /* @__PURE__ */ w.jsx(Pd, { as: OD, boxSize: 6 }),
        title: "ERROR",
        description: "An error occurred while running the application"
      }
    )
  }
);
function PD(e) {
  return Bn({ attr: { fill: "none", viewBox: "0 0 24 24", strokeWidth: "2", stroke: "currentColor", "aria-hidden": "true" }, child: [{ tag: "path", attr: { strokeLinecap: "round", strokeLinejoin: "round", d: "M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" }, child: [] }] })(e);
}
const DD = Ue(
  function(t, n) {
    const {
      showArrow: r,
      children: i,
      portalled: a = !0,
      content: s,
      portalRef: o,
      ...l
    } = t;
    return /* @__PURE__ */ w.jsxs(
      ji.Root,
      {
        ...l,
        positioning: { ...l.positioning, gutter: 4 },
        children: [
          /* @__PURE__ */ w.jsx(ji.Trigger, { asChild: !0, children: i }),
          /* @__PURE__ */ w.jsx(Vl, { disabled: !a, container: o, children: /* @__PURE__ */ w.jsx(ji.Positioner, { children: /* @__PURE__ */ w.jsxs(
            ji.Content,
            {
              width: "auto",
              px: "2",
              py: "1",
              textStyle: "xs",
              rounded: "sm",
              ref: n,
              children: [
                r && /* @__PURE__ */ w.jsx(ji.Arrow, { children: /* @__PURE__ */ w.jsx(ji.ArrowTip, {}) }),
                s
              ]
            }
          ) }) })
        ]
      }
    );
  }
), LD = Ue(function(t, n) {
  return /* @__PURE__ */ w.jsx(gs.Track, { ...t, ref: n, children: /* @__PURE__ */ w.jsx(gs.Range, {}) });
}), FD = gs.Root;
gs.ValueText;
Ue(
  function(t, n) {
    const { children: r, info: i, ...a } = t;
    return /* @__PURE__ */ w.jsxs(gs.Label, { ...a, ref: n, children: [
      r,
      i && /* @__PURE__ */ w.jsx(DD, { content: i, children: /* @__PURE__ */ w.jsx(Li, { variant: "ghost", "aria-label": "info", size: "2xs", ms: "1", children: /* @__PURE__ */ w.jsx(PD, {}) }) })
    ] });
  }
);
function BD(e) {
  return Bn({ attr: { viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", strokeLinecap: "round", strokeLinejoin: "round" }, child: [{ tag: "path", attr: { d: "M3 12a9 9 0 0 0 9 9a9 9 0 0 0 9 -9a9 9 0 0 0 -9 -9" }, child: [] }, { tag: "path", attr: { d: "M17 12a5 5 0 1 0 -5 5" }, child: [] }] })(e);
}
const zD = () => /* @__PURE__ */ w.jsx(
  pn,
  {
    position: "fixed",
    flexDirection: "column",
    justifyContent: "center",
    width: "100%",
    height: "100vh",
    children: /* @__PURE__ */ w.jsx(
      nf,
      {
        icon: /* @__PURE__ */ w.jsx(Pd, { as: BD, boxSize: 6 }),
        title: "Fetching...",
        description: "Wait please!",
        children: /* @__PURE__ */ w.jsx(FD, { width: "25vw", value: null, children: /* @__PURE__ */ w.jsx(LD, {}) })
      }
    )
  }
);
var Ja = {}, gg;
function VD() {
  if (gg) return Ja;
  gg = 1, Object.defineProperty(Ja, "__esModule", { value: !0 }), Ja.parse = s, Ja.serialize = c;
  const e = /^[\u0021-\u003A\u003C\u003E-\u007E]+$/, t = /^[\u0021-\u003A\u003C-\u007E]*$/, n = /^([.]?[a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)([.][a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)*$/i, r = /^[\u0020-\u003A\u003D-\u007E]*$/, i = Object.prototype.toString, a = /* @__PURE__ */ (() => {
    const f = function() {
    };
    return f.prototype = /* @__PURE__ */ Object.create(null), f;
  })();
  function s(f, p) {
    const h = new a(), g = f.length;
    if (g < 2)
      return h;
    const m = (p == null ? void 0 : p.decode) || u;
    let b = 0;
    do {
      const y = f.indexOf("=", b);
      if (y === -1)
        break;
      const v = f.indexOf(";", b), E = v === -1 ? g : v;
      if (y > E) {
        b = f.lastIndexOf(";", y - 1) + 1;
        continue;
      }
      const _ = o(f, b, y), x = l(f, y, _), I = f.slice(_, x);
      if (h[I] === void 0) {
        let T = o(f, y + 1, E), O = l(f, E, T);
        const k = m(f.slice(T, O));
        h[I] = k;
      }
      b = E + 1;
    } while (b < g);
    return h;
  }
  function o(f, p, h) {
    do {
      const g = f.charCodeAt(p);
      if (g !== 32 && g !== 9)
        return p;
    } while (++p < h);
    return h;
  }
  function l(f, p, h) {
    for (; p > h; ) {
      const g = f.charCodeAt(--p);
      if (g !== 32 && g !== 9)
        return p + 1;
    }
    return h;
  }
  function c(f, p, h) {
    const g = (h == null ? void 0 : h.encode) || encodeURIComponent;
    if (!e.test(f))
      throw new TypeError(`argument name is invalid: ${f}`);
    const m = g(p);
    if (!t.test(m))
      throw new TypeError(`argument val is invalid: ${p}`);
    let b = f + "=" + m;
    if (!h)
      return b;
    if (h.maxAge !== void 0) {
      if (!Number.isInteger(h.maxAge))
        throw new TypeError(`option maxAge is invalid: ${h.maxAge}`);
      b += "; Max-Age=" + h.maxAge;
    }
    if (h.domain) {
      if (!n.test(h.domain))
        throw new TypeError(`option domain is invalid: ${h.domain}`);
      b += "; Domain=" + h.domain;
    }
    if (h.path) {
      if (!r.test(h.path))
        throw new TypeError(`option path is invalid: ${h.path}`);
      b += "; Path=" + h.path;
    }
    if (h.expires) {
      if (!d(h.expires) || !Number.isFinite(h.expires.valueOf()))
        throw new TypeError(`option expires is invalid: ${h.expires}`);
      b += "; Expires=" + h.expires.toUTCString();
    }
    if (h.httpOnly && (b += "; HttpOnly"), h.secure && (b += "; Secure"), h.partitioned && (b += "; Partitioned"), h.priority)
      switch (typeof h.priority == "string" ? h.priority.toLowerCase() : void 0) {
        case "low":
          b += "; Priority=Low";
          break;
        case "medium":
          b += "; Priority=Medium";
          break;
        case "high":
          b += "; Priority=High";
          break;
        default:
          throw new TypeError(`option priority is invalid: ${h.priority}`);
      }
    if (h.sameSite)
      switch (typeof h.sameSite == "string" ? h.sameSite.toLowerCase() : h.sameSite) {
        case !0:
        case "strict":
          b += "; SameSite=Strict";
          break;
        case "lax":
          b += "; SameSite=Lax";
          break;
        case "none":
          b += "; SameSite=None";
          break;
        default:
          throw new TypeError(`option sameSite is invalid: ${h.sameSite}`);
      }
    return b;
  }
  function u(f) {
    if (f.indexOf("%") === -1)
      return f;
    try {
      return decodeURIComponent(f);
    } catch {
      return f;
    }
  }
  function d(f) {
    return i.call(f) === "[object Date]";
  }
  return Ja;
}
VD();
/**
 * react-router v7.1.5
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
function Vt(e, t) {
  if (e === !1 || e === null || typeof e > "u")
    throw new Error(t);
}
function Br(e, t) {
  if (!e) {
    typeof console < "u" && console.warn(t);
    try {
      throw new Error(t);
    } catch {
    }
  }
}
function td({
  pathname: e = "/",
  search: t = "",
  hash: n = ""
}) {
  return t && t !== "?" && (e += t.charAt(0) === "?" ? t : "?" + t), n && n !== "#" && (e += n.charAt(0) === "#" ? n : "#" + n), e;
}
function wf(e) {
  let t = {};
  if (e) {
    let n = e.indexOf("#");
    n >= 0 && (t.hash = e.substring(n), e = e.substring(0, n));
    let r = e.indexOf("?");
    r >= 0 && (t.search = e.substring(r), e = e.substring(0, r)), e && (t.pathname = e);
  }
  return t;
}
function m_(e, t, n = "/") {
  return GD(e, t, n, !1);
}
function GD(e, t, n, r) {
  let i = typeof t == "string" ? wf(t) : t, a = Ni(i.pathname || "/", n);
  if (a == null)
    return null;
  let s = b_(e);
  jD(s);
  let o = null;
  for (let l = 0; o == null && l < s.length; ++l) {
    let c = QD(a);
    o = qD(
      s[l],
      c,
      r
    );
  }
  return o;
}
function b_(e, t = [], n = [], r = "") {
  let i = (a, s, o) => {
    let l = {
      relativePath: o === void 0 ? a.path || "" : o,
      caseSensitive: a.caseSensitive === !0,
      childrenIndex: s,
      route: a
    };
    l.relativePath.startsWith("/") && (Vt(
      l.relativePath.startsWith(r),
      `Absolute route path "${l.relativePath}" nested under path "${r}" is not valid. An absolute child route path must start with the combined path of all its parent routes.`
    ), l.relativePath = l.relativePath.slice(r.length));
    let c = Or([r, l.relativePath]), u = n.concat(l);
    a.children && a.children.length > 0 && (Vt(
      // Our types know better, but runtime JS may not!
      // @ts-expect-error
      a.index !== !0,
      `Index routes must not have child routes. Please remove all child routes from route path "${c}".`
    ), b_(a.children, t, u, c)), !(a.path == null && !a.index) && t.push({
      path: c,
      score: YD(c, a.index),
      routesMeta: u
    });
  };
  return e.forEach((a, s) => {
    var o;
    if (a.path === "" || !((o = a.path) != null && o.includes("?")))
      i(a, s);
    else
      for (let l of y_(a.path))
        i(a, s, l);
  }), t;
}
function y_(e) {
  let t = e.split("/");
  if (t.length === 0) return [];
  let [n, ...r] = t, i = n.endsWith("?"), a = n.replace(/\?$/, "");
  if (r.length === 0)
    return i ? [a, ""] : [a];
  let s = y_(r.join("/")), o = [];
  return o.push(
    ...s.map(
      (l) => l === "" ? a : [a, l].join("/")
    )
  ), i && o.push(...s), o.map(
    (l) => e.startsWith("/") && l === "" ? "/" : l
  );
}
function jD(e) {
  e.sort(
    (t, n) => t.score !== n.score ? n.score - t.score : JD(
      t.routesMeta.map((r) => r.childrenIndex),
      n.routesMeta.map((r) => r.childrenIndex)
    )
  );
}
var UD = /^:[\w-]+$/, HD = 3, WD = 2, ZD = 1, $D = 10, XD = -2, mg = (e) => e === "*";
function YD(e, t) {
  let n = e.split("/"), r = n.length;
  return n.some(mg) && (r += XD), t && (r += WD), n.filter((i) => !mg(i)).reduce(
    (i, a) => i + (UD.test(a) ? HD : a === "" ? ZD : $D),
    r
  );
}
function JD(e, t) {
  return e.length === t.length && e.slice(0, -1).every((r, i) => r === t[i]) ? (
    // If two routes are siblings, we should try to match the earlier sibling
    // first. This allows people to have fine-grained control over the matching
    // behavior by simply putting routes with identical paths in the order they
    // want them tried.
    e[e.length - 1] - t[t.length - 1]
  ) : (
    // Otherwise, it doesn't really make sense to rank non-siblings by index,
    // so they sort equally.
    0
  );
}
function qD(e, t, n = !1) {
  let { routesMeta: r } = e, i = {}, a = "/", s = [];
  for (let o = 0; o < r.length; ++o) {
    let l = r[o], c = o === r.length - 1, u = a === "/" ? t : t.slice(a.length) || "/", d = Cl(
      { path: l.relativePath, caseSensitive: l.caseSensitive, end: c },
      u
    ), f = l.route;
    if (!d && c && n && !r[r.length - 1].route.index && (d = Cl(
      {
        path: l.relativePath,
        caseSensitive: l.caseSensitive,
        end: !1
      },
      u
    )), !d)
      return null;
    Object.assign(i, d.params), s.push({
      // TODO: Can this as be avoided?
      params: i,
      pathname: Or([a, d.pathname]),
      pathnameBase: r2(
        Or([a, d.pathnameBase])
      ),
      route: f
    }), d.pathnameBase !== "/" && (a = Or([a, d.pathnameBase]));
  }
  return s;
}
function Cl(e, t) {
  typeof e == "string" && (e = { path: e, caseSensitive: !1, end: !0 });
  let [n, r] = KD(
    e.path,
    e.caseSensitive,
    e.end
  ), i = t.match(n);
  if (!i) return null;
  let a = i[0], s = a.replace(/(.)\/+$/, "$1"), o = i.slice(1);
  return {
    params: r.reduce(
      (c, { paramName: u, isOptional: d }, f) => {
        if (u === "*") {
          let h = o[f] || "";
          s = a.slice(0, a.length - h.length).replace(/(.)\/+$/, "$1");
        }
        const p = o[f];
        return d && !p ? c[u] = void 0 : c[u] = (p || "").replace(/%2F/g, "/"), c;
      },
      {}
    ),
    pathname: a,
    pathnameBase: s,
    pattern: e
  };
}
function KD(e, t = !1, n = !0) {
  Br(
    e === "*" || !e.endsWith("*") || e.endsWith("/*"),
    `Route path "${e}" will be treated as if it were "${e.replace(/\*$/, "/*")}" because the \`*\` character must always follow a \`/\` in the pattern. To get rid of this warning, please change the route path to "${e.replace(/\*$/, "/*")}".`
  );
  let r = [], i = "^" + e.replace(/\/*\*?$/, "").replace(/^\/*/, "/").replace(/[\\.*+^${}|()[\]]/g, "\\$&").replace(
    /\/:([\w-]+)(\?)?/g,
    (s, o, l) => (r.push({ paramName: o, isOptional: l != null }), l ? "/?([^\\/]+)?" : "/([^\\/]+)")
  );
  return e.endsWith("*") ? (r.push({ paramName: "*" }), i += e === "*" || e === "/*" ? "(.*)$" : "(?:\\/(.+)|\\/*)$") : n ? i += "\\/*$" : e !== "" && e !== "/" && (i += "(?:(?=\\/|$))"), [new RegExp(i, t ? void 0 : "i"), r];
}
function QD(e) {
  try {
    return e.split("/").map((t) => decodeURIComponent(t).replace(/\//g, "%2F")).join("/");
  } catch (t) {
    return Br(
      !1,
      `The URL path "${e}" could not be decoded because it is a malformed URL segment. This is probably due to a bad percent encoding (${t}).`
    ), e;
  }
}
function Ni(e, t) {
  if (t === "/") return e;
  if (!e.toLowerCase().startsWith(t.toLowerCase()))
    return null;
  let n = t.endsWith("/") ? t.length - 1 : t.length, r = e.charAt(n);
  return r && r !== "/" ? null : e.slice(n) || "/";
}
function e2(e, t = "/") {
  let {
    pathname: n,
    search: r = "",
    hash: i = ""
  } = typeof e == "string" ? wf(e) : e;
  return {
    pathname: n ? n.startsWith("/") ? n : t2(n, t) : t,
    search: i2(r),
    hash: a2(i)
  };
}
function t2(e, t) {
  let n = t.replace(/\/+$/, "").split("/");
  return e.split("/").forEach((i) => {
    i === ".." ? n.length > 1 && n.pop() : i !== "." && n.push(i);
  }), n.length > 1 ? n.join("/") : "/";
}
function lu(e, t, n, r) {
  return `Cannot include a '${e}' character in a manually specified \`to.${t}\` field [${JSON.stringify(
    r
  )}].  Please separate it out to the \`to.${n}\` field. Alternatively you may provide the full path as a string in <Link to="..."> and the router will parse it for you.`;
}
function n2(e) {
  return e.filter(
    (t, n) => n === 0 || t.route.path && t.route.path.length > 0
  );
}
function __(e) {
  let t = n2(e);
  return t.map(
    (n, r) => r === t.length - 1 ? n.pathname : n.pathnameBase
  );
}
function v_(e, t, n, r = !1) {
  let i;
  typeof e == "string" ? i = wf(e) : (i = { ...e }, Vt(
    !i.pathname || !i.pathname.includes("?"),
    lu("?", "pathname", "search", i)
  ), Vt(
    !i.pathname || !i.pathname.includes("#"),
    lu("#", "pathname", "hash", i)
  ), Vt(
    !i.search || !i.search.includes("#"),
    lu("#", "search", "hash", i)
  ));
  let a = e === "" || i.pathname === "", s = a ? "/" : i.pathname, o;
  if (s == null)
    o = n;
  else {
    let d = t.length - 1;
    if (!r && s.startsWith("..")) {
      let f = s.split("/");
      for (; f[0] === ".."; )
        f.shift(), d -= 1;
      i.pathname = f.join("/");
    }
    o = d >= 0 ? t[d] : "/";
  }
  let l = e2(i, o), c = s && s !== "/" && s.endsWith("/"), u = (a || s === ".") && n.endsWith("/");
  return !l.pathname.endsWith("/") && (c || u) && (l.pathname += "/"), l;
}
var Or = (e) => e.join("/").replace(/\/\/+/g, "/"), r2 = (e) => e.replace(/\/+$/, "").replace(/^\/*/, "/"), i2 = (e) => !e || e === "?" ? "" : e.startsWith("?") ? e : "?" + e, a2 = (e) => !e || e === "#" ? "" : e.startsWith("#") ? e : "#" + e;
function s2(e) {
  return e != null && typeof e.status == "number" && typeof e.statusText == "string" && typeof e.internal == "boolean" && "data" in e;
}
var x_ = [
  "POST",
  "PUT",
  "PATCH",
  "DELETE"
];
new Set(
  x_
);
var o2 = [
  "GET",
  ...x_
];
new Set(o2);
var Ma = F.createContext(null);
Ma.displayName = "DataRouter";
var ic = F.createContext(null);
ic.displayName = "DataRouterState";
var E_ = F.createContext({
  isTransitioning: !1
});
E_.displayName = "ViewTransition";
var l2 = F.createContext(
  /* @__PURE__ */ new Map()
);
l2.displayName = "Fetchers";
var c2 = F.createContext(null);
c2.displayName = "Await";
var Hr = F.createContext(
  null
);
Hr.displayName = "Navigation";
var Cf = F.createContext(
  null
);
Cf.displayName = "Location";
var Wr = F.createContext({
  outlet: null,
  matches: [],
  isDataRoute: !1
});
Wr.displayName = "Route";
var If = F.createContext(null);
If.displayName = "RouteError";
function u2(e, { relative: t } = {}) {
  Vt(
    ac(),
    // TODO: This error is probably because they somehow have 2 versions of the
    // router loaded. We can help them understand how to avoid that.
    "useHref() may be used only in the context of a <Router> component."
  );
  let { basename: n, navigator: r } = F.useContext(Hr), { hash: i, pathname: a, search: s } = to(e, { relative: t }), o = a;
  return n !== "/" && (o = a === "/" ? n : Or([n, a])), r.createHref({ pathname: o, search: s, hash: i });
}
function ac() {
  return F.useContext(Cf) != null;
}
function nr() {
  return Vt(
    ac(),
    // TODO: This error is probably because they somehow have 2 versions of the
    // router loaded. We can help them understand how to avoid that.
    "useLocation() may be used only in the context of a <Router> component."
  ), F.useContext(Cf).location;
}
var w_ = "You should call navigate() in a React.useEffect(), not when your component is first rendered.";
function C_(e) {
  F.useContext(Hr).static || F.useLayoutEffect(e);
}
function sc() {
  let { isDataRoute: e } = F.useContext(Wr);
  return e ? w2() : d2();
}
function d2() {
  Vt(
    ac(),
    // TODO: This error is probably because they somehow have 2 versions of the
    // router loaded. We can help them understand how to avoid that.
    "useNavigate() may be used only in the context of a <Router> component."
  );
  let e = F.useContext(Ma), { basename: t, navigator: n } = F.useContext(Hr), { matches: r } = F.useContext(Wr), { pathname: i } = nr(), a = JSON.stringify(__(r)), s = F.useRef(!1);
  return C_(() => {
    s.current = !0;
  }), F.useCallback(
    (l, c = {}) => {
      if (Br(s.current, w_), !s.current) return;
      if (typeof l == "number") {
        n.go(l);
        return;
      }
      let u = v_(
        l,
        JSON.parse(a),
        i,
        c.relative === "path"
      );
      e == null && t !== "/" && (u.pathname = u.pathname === "/" ? t : Or([t, u.pathname])), (c.replace ? n.replace : n.push)(
        u,
        c.state,
        c
      );
    },
    [
      t,
      n,
      a,
      i,
      e
    ]
  );
}
F.createContext(null);
function to(e, { relative: t } = {}) {
  let { matches: n } = F.useContext(Wr), { pathname: r } = nr(), i = JSON.stringify(__(n));
  return F.useMemo(
    () => v_(
      e,
      JSON.parse(i),
      r,
      t === "path"
    ),
    [e, i, r, t]
  );
}
function f2(e, t, n, r) {
  Vt(
    ac(),
    // TODO: This error is probably because they somehow have 2 versions of the
    // router loaded. We can help them understand how to avoid that.
    "useRoutes() may be used only in the context of a <Router> component."
  );
  let { navigator: i, static: a } = F.useContext(Hr), { matches: s } = F.useContext(Wr), o = s[s.length - 1], l = o ? o.params : {}, c = o ? o.pathname : "/", u = o ? o.pathnameBase : "/", d = o && o.route;
  {
    let y = d && d.path || "";
    I_(
      c,
      !d || y.endsWith("*") || y.endsWith("*?"),
      `You rendered descendant <Routes> (or called \`useRoutes()\`) at "${c}" (under <Route path="${y}">) but the parent route path has no trailing "*". This means if you navigate deeper, the parent won't match anymore and therefore the child routes will never render.

Please change the parent <Route path="${y}"> to <Route path="${y === "/" ? "*" : `${y}/*`}">.`
    );
  }
  let f = nr(), p;
  p = f;
  let h = p.pathname || "/", g = h;
  if (u !== "/") {
    let y = u.replace(/^\//, "").split("/");
    g = "/" + h.replace(/^\//, "").split("/").slice(y.length).join("/");
  }
  let m = !a && n && n.matches && n.matches.length > 0 ? n.matches : m_(e, { pathname: g });
  return Br(
    d || m != null,
    `No routes matched location "${p.pathname}${p.search}${p.hash}" `
  ), Br(
    m == null || m[m.length - 1].route.element !== void 0 || m[m.length - 1].route.Component !== void 0 || m[m.length - 1].route.lazy !== void 0,
    `Matched leaf route at location "${p.pathname}${p.search}${p.hash}" does not have an element or Component. This means it will render an <Outlet /> with a null value by default resulting in an "empty" page.`
  ), b2(
    m && m.map(
      (y) => Object.assign({}, y, {
        params: Object.assign({}, l, y.params),
        pathname: Or([
          u,
          // Re-encode pathnames that were decoded inside matchRoutes
          i.encodeLocation ? i.encodeLocation(y.pathname).pathname : y.pathname
        ]),
        pathnameBase: y.pathnameBase === "/" ? u : Or([
          u,
          // Re-encode pathnames that were decoded inside matchRoutes
          i.encodeLocation ? i.encodeLocation(y.pathnameBase).pathname : y.pathnameBase
        ])
      })
    ),
    s,
    n,
    r
  );
}
function p2() {
  let e = E2(), t = s2(e) ? `${e.status} ${e.statusText}` : e instanceof Error ? e.message : JSON.stringify(e), n = e instanceof Error ? e.stack : null, r = "rgba(200,200,200, 0.5)", i = { padding: "0.5rem", backgroundColor: r }, a = { padding: "2px 4px", backgroundColor: r }, s = null;
  return console.error(
    "Error handled by React Router default ErrorBoundary:",
    e
  ), s = /* @__PURE__ */ F.createElement(F.Fragment, null, /* @__PURE__ */ F.createElement("p", null, " Hey developer "), /* @__PURE__ */ F.createElement("p", null, "You can provide a way better UX than this when your app throws errors by providing your own ", /* @__PURE__ */ F.createElement("code", { style: a }, "ErrorBoundary"), " or", " ", /* @__PURE__ */ F.createElement("code", { style: a }, "errorElement"), " prop on your route.")), /* @__PURE__ */ F.createElement(F.Fragment, null, /* @__PURE__ */ F.createElement("h2", null, "Unexpected Application Error!"), /* @__PURE__ */ F.createElement("h3", { style: { fontStyle: "italic" } }, t), n ? /* @__PURE__ */ F.createElement("pre", { style: i }, n) : null, s);
}
var h2 = /* @__PURE__ */ F.createElement(p2, null), g2 = class extends F.Component {
  constructor(e) {
    super(e), this.state = {
      location: e.location,
      revalidation: e.revalidation,
      error: e.error
    };
  }
  static getDerivedStateFromError(e) {
    return { error: e };
  }
  static getDerivedStateFromProps(e, t) {
    return t.location !== e.location || t.revalidation !== "idle" && e.revalidation === "idle" ? {
      error: e.error,
      location: e.location,
      revalidation: e.revalidation
    } : {
      error: e.error !== void 0 ? e.error : t.error,
      location: t.location,
      revalidation: e.revalidation || t.revalidation
    };
  }
  componentDidCatch(e, t) {
    console.error(
      "React Router caught the following error during render",
      e,
      t
    );
  }
  render() {
    return this.state.error !== void 0 ? /* @__PURE__ */ F.createElement(Wr.Provider, { value: this.props.routeContext }, /* @__PURE__ */ F.createElement(
      If.Provider,
      {
        value: this.state.error,
        children: this.props.component
      }
    )) : this.props.children;
  }
};
function m2({ routeContext: e, match: t, children: n }) {
  let r = F.useContext(Ma);
  return r && r.static && r.staticContext && (t.route.errorElement || t.route.ErrorBoundary) && (r.staticContext._deepestRenderedBoundaryId = t.route.id), /* @__PURE__ */ F.createElement(Wr.Provider, { value: e }, n);
}
function b2(e, t = [], n = null, r = null) {
  if (e == null) {
    if (!n)
      return null;
    if (n.errors)
      e = n.matches;
    else if (t.length === 0 && !n.initialized && n.matches.length > 0)
      e = n.matches;
    else
      return null;
  }
  let i = e, a = n == null ? void 0 : n.errors;
  if (a != null) {
    let l = i.findIndex(
      (c) => c.route.id && (a == null ? void 0 : a[c.route.id]) !== void 0
    );
    Vt(
      l >= 0,
      `Could not find a matching route for errors on route IDs: ${Object.keys(
        a
      ).join(",")}`
    ), i = i.slice(
      0,
      Math.min(i.length, l + 1)
    );
  }
  let s = !1, o = -1;
  if (n)
    for (let l = 0; l < i.length; l++) {
      let c = i[l];
      if ((c.route.HydrateFallback || c.route.hydrateFallbackElement) && (o = l), c.route.id) {
        let { loaderData: u, errors: d } = n, f = c.route.loader && !u.hasOwnProperty(c.route.id) && (!d || d[c.route.id] === void 0);
        if (c.route.lazy || f) {
          s = !0, o >= 0 ? i = i.slice(0, o + 1) : i = [i[0]];
          break;
        }
      }
    }
  return i.reduceRight((l, c, u) => {
    let d, f = !1, p = null, h = null;
    n && (d = a && c.route.id ? a[c.route.id] : void 0, p = c.route.errorElement || h2, s && (o < 0 && u === 0 ? (I_(
      "route-fallback",
      !1,
      "No `HydrateFallback` element provided to render during initial hydration"
    ), f = !0, h = null) : o === u && (f = !0, h = c.route.hydrateFallbackElement || null)));
    let g = t.concat(i.slice(0, u + 1)), m = () => {
      let b;
      return d ? b = p : f ? b = h : c.route.Component ? b = /* @__PURE__ */ F.createElement(c.route.Component, null) : c.route.element ? b = c.route.element : b = l, /* @__PURE__ */ F.createElement(
        m2,
        {
          match: c,
          routeContext: {
            outlet: l,
            matches: g,
            isDataRoute: n != null
          },
          children: b
        }
      );
    };
    return n && (c.route.ErrorBoundary || c.route.errorElement || u === 0) ? /* @__PURE__ */ F.createElement(
      g2,
      {
        location: n.location,
        revalidation: n.revalidation,
        component: p,
        error: d,
        children: m(),
        routeContext: { outlet: null, matches: g, isDataRoute: !0 }
      }
    ) : m();
  }, null);
}
function Sf(e) {
  return `${e} must be used within a data router.  See https://reactrouter.com/en/main/routers/picking-a-router.`;
}
function y2(e) {
  let t = F.useContext(Ma);
  return Vt(t, Sf(e)), t;
}
function _2(e) {
  let t = F.useContext(ic);
  return Vt(t, Sf(e)), t;
}
function v2(e) {
  let t = F.useContext(Wr);
  return Vt(t, Sf(e)), t;
}
function Af(e) {
  let t = v2(e), n = t.matches[t.matches.length - 1];
  return Vt(
    n.route.id,
    `${e} can only be used on routes that contain a unique "id"`
  ), n.route.id;
}
function x2() {
  return Af(
    "useRouteId"
    /* UseRouteId */
  );
}
function E2() {
  var r;
  let e = F.useContext(If), t = _2(
    "useRouteError"
    /* UseRouteError */
  ), n = Af(
    "useRouteError"
    /* UseRouteError */
  );
  return e !== void 0 ? e : (r = t.errors) == null ? void 0 : r[n];
}
function w2() {
  let { router: e } = y2(
    "useNavigate"
    /* UseNavigateStable */
  ), t = Af(
    "useNavigate"
    /* UseNavigateStable */
  ), n = F.useRef(!1);
  return C_(() => {
    n.current = !0;
  }), F.useCallback(
    async (i, a = {}) => {
      Br(n.current, w_), n.current && (typeof i == "number" ? e.navigate(i) : await e.navigate(i, { fromRouteId: t, ...a }));
    },
    [e, t]
  );
}
var bg = {};
function I_(e, t, n) {
  !t && !bg[e] && (bg[e] = !0, Br(!1, n));
}
F.memo(C2);
function C2({
  routes: e,
  future: t,
  state: n
}) {
  return f2(e, void 0, n, t);
}
var Fo = "get", Bo = "application/x-www-form-urlencoded";
function oc(e) {
  return e != null && typeof e.tagName == "string";
}
function I2(e) {
  return oc(e) && e.tagName.toLowerCase() === "button";
}
function S2(e) {
  return oc(e) && e.tagName.toLowerCase() === "form";
}
function A2(e) {
  return oc(e) && e.tagName.toLowerCase() === "input";
}
function k2(e) {
  return !!(e.metaKey || e.altKey || e.ctrlKey || e.shiftKey);
}
function T2(e, t) {
  return e.button === 0 && // Ignore everything but left clicks
  (!t || t === "_self") && // Let browser handle "target=_blank" etc.
  !k2(e);
}
var So = null;
function R2() {
  if (So === null)
    try {
      new FormData(
        document.createElement("form"),
        // @ts-expect-error if FormData supports the submitter parameter, this will throw
        0
      ), So = !1;
    } catch {
      So = !0;
    }
  return So;
}
var N2 = /* @__PURE__ */ new Set([
  "application/x-www-form-urlencoded",
  "multipart/form-data",
  "text/plain"
]);
function cu(e) {
  return e != null && !N2.has(e) ? (Br(
    !1,
    `"${e}" is not a valid \`encType\` for \`<Form>\`/\`<fetcher.Form>\` and will default to "${Bo}"`
  ), null) : e;
}
function O2(e, t) {
  let n, r, i, a, s;
  if (S2(e)) {
    let o = e.getAttribute("action");
    r = o ? Ni(o, t) : null, n = e.getAttribute("method") || Fo, i = cu(e.getAttribute("enctype")) || Bo, a = new FormData(e);
  } else if (I2(e) || A2(e) && (e.type === "submit" || e.type === "image")) {
    let o = e.form;
    if (o == null)
      throw new Error(
        'Cannot submit a <button> or <input type="submit"> without a <form>'
      );
    let l = e.getAttribute("formaction") || o.getAttribute("action");
    if (r = l ? Ni(l, t) : null, n = e.getAttribute("formmethod") || o.getAttribute("method") || Fo, i = cu(e.getAttribute("formenctype")) || cu(o.getAttribute("enctype")) || Bo, a = new FormData(o, e), !R2()) {
      let { name: c, type: u, value: d } = e;
      if (u === "image") {
        let f = c ? `${c}.` : "";
        a.append(`${f}x`, "0"), a.append(`${f}y`, "0");
      } else c && a.append(c, d);
    }
  } else {
    if (oc(e))
      throw new Error(
        'Cannot submit element that is not <form>, <button>, or <input type="submit|image">'
      );
    n = Fo, r = null, i = Bo, s = e;
  }
  return a && i === "text/plain" && (s = a, a = void 0), { action: r, method: n.toLowerCase(), encType: i, formData: a, body: s };
}
function kf(e, t) {
  if (e === !1 || e === null || typeof e > "u")
    throw new Error(t);
}
async function M2(e, t) {
  if (e.id in t)
    return t[e.id];
  try {
    let n = await import(
      /* @vite-ignore */
      /* webpackIgnore: true */
      e.module
    );
    return t[e.id] = n, n;
  } catch (n) {
    return console.error(
      `Error loading route module \`${e.module}\`, reloading page...`
    ), console.error(n), window.__reactRouterContext && window.__reactRouterContext.isSpaMode, window.location.reload(), new Promise(() => {
    });
  }
}
function P2(e) {
  return e == null ? !1 : e.href == null ? e.rel === "preload" && typeof e.imageSrcSet == "string" && typeof e.imageSizes == "string" : typeof e.rel == "string" && typeof e.href == "string";
}
async function D2(e, t, n) {
  let r = await Promise.all(
    e.map(async (i) => {
      let a = t.routes[i.route.id];
      if (a) {
        let s = await M2(a, n);
        return s.links ? s.links() : [];
      }
      return [];
    })
  );
  return z2(
    r.flat(1).filter(P2).filter((i) => i.rel === "stylesheet" || i.rel === "preload").map(
      (i) => i.rel === "stylesheet" ? { ...i, rel: "prefetch", as: "style" } : { ...i, rel: "prefetch" }
    )
  );
}
function yg(e, t, n, r, i, a) {
  let s = (l, c) => n[c] ? l.route.id !== n[c].route.id : !0, o = (l, c) => {
    var u;
    return (
      // param change, /users/123 -> /users/456
      n[c].pathname !== l.pathname || // splat param changed, which is not present in match.path
      // e.g. /files/images/avatar.jpg -> files/finances.xls
      ((u = n[c].route.path) == null ? void 0 : u.endsWith("*")) && n[c].params["*"] !== l.params["*"]
    );
  };
  return a === "assets" ? t.filter(
    (l, c) => s(l, c) || o(l, c)
  ) : a === "data" ? t.filter((l, c) => {
    var d;
    let u = r.routes[l.route.id];
    if (!u || !u.hasLoader)
      return !1;
    if (s(l, c) || o(l, c))
      return !0;
    if (l.route.shouldRevalidate) {
      let f = l.route.shouldRevalidate({
        currentUrl: new URL(
          i.pathname + i.search + i.hash,
          window.origin
        ),
        currentParams: ((d = n[0]) == null ? void 0 : d.params) || {},
        nextUrl: new URL(e, window.origin),
        nextParams: l.params,
        defaultShouldRevalidate: !0
      });
      if (typeof f == "boolean")
        return f;
    }
    return !0;
  }) : [];
}
function L2(e, t) {
  return F2(
    e.map((n) => {
      let r = t.routes[n.route.id];
      if (!r) return [];
      let i = [r.module];
      return r.imports && (i = i.concat(r.imports)), i;
    }).flat(1)
  );
}
function F2(e) {
  return [...new Set(e)];
}
function B2(e) {
  let t = {}, n = Object.keys(e).sort();
  for (let r of n)
    t[r] = e[r];
  return t;
}
function z2(e, t) {
  let n = /* @__PURE__ */ new Set();
  return new Set(t), e.reduce((r, i) => {
    let a = JSON.stringify(B2(i));
    return n.has(a) || (n.add(a), r.push({ key: a, link: i })), r;
  }, []);
}
function V2(e) {
  let t = typeof e == "string" ? new URL(
    e,
    // This can be called during the SSR flow via PrefetchPageLinksImpl so
    // don't assume window is available
    typeof window > "u" ? "server://singlefetch/" : window.location.origin
  ) : e;
  return t.pathname === "/" ? t.pathname = "_root.data" : t.pathname = `${t.pathname.replace(/\/$/, "")}.data`, t;
}
function G2() {
  let e = F.useContext(Ma);
  return kf(
    e,
    "You must render this element inside a <DataRouterContext.Provider> element"
  ), e;
}
function j2() {
  let e = F.useContext(ic);
  return kf(
    e,
    "You must render this element inside a <DataRouterStateContext.Provider> element"
  ), e;
}
var Tf = F.createContext(void 0);
Tf.displayName = "FrameworkContext";
function S_() {
  let e = F.useContext(Tf);
  return kf(
    e,
    "You must render this element inside a <HydratedRouter> element"
  ), e;
}
function U2(e, t) {
  let n = F.useContext(Tf), [r, i] = F.useState(!1), [a, s] = F.useState(!1), { onFocus: o, onBlur: l, onMouseEnter: c, onMouseLeave: u, onTouchStart: d } = t, f = F.useRef(null);
  F.useEffect(() => {
    if (e === "render" && s(!0), e === "viewport") {
      let g = (b) => {
        b.forEach((y) => {
          s(y.isIntersecting);
        });
      }, m = new IntersectionObserver(g, { threshold: 0.5 });
      return f.current && m.observe(f.current), () => {
        m.disconnect();
      };
    }
  }, [e]), F.useEffect(() => {
    if (r) {
      let g = setTimeout(() => {
        s(!0);
      }, 100);
      return () => {
        clearTimeout(g);
      };
    }
  }, [r]);
  let p = () => {
    i(!0);
  }, h = () => {
    i(!1), s(!1);
  };
  return n ? e !== "intent" ? [a, f, {}] : [
    a,
    f,
    {
      onFocus: qa(o, p),
      onBlur: qa(l, h),
      onMouseEnter: qa(c, p),
      onMouseLeave: qa(u, h),
      onTouchStart: qa(d, p)
    }
  ] : [!1, f, {}];
}
function qa(e, t) {
  return (n) => {
    e && e(n), n.defaultPrevented || t(n);
  };
}
function H2({
  page: e,
  ...t
}) {
  let { router: n } = G2(), r = F.useMemo(
    () => m_(n.routes, e, n.basename),
    [n.routes, e, n.basename]
  );
  return r ? /* @__PURE__ */ F.createElement(Z2, { page: e, matches: r, ...t }) : null;
}
function W2(e) {
  let { manifest: t, routeModules: n } = S_(), [r, i] = F.useState([]);
  return F.useEffect(() => {
    let a = !1;
    return D2(e, t, n).then(
      (s) => {
        a || i(s);
      }
    ), () => {
      a = !0;
    };
  }, [e, t, n]), r;
}
function Z2({
  page: e,
  matches: t,
  ...n
}) {
  let r = nr(), { manifest: i, routeModules: a } = S_(), { loaderData: s, matches: o } = j2(), l = F.useMemo(
    () => yg(
      e,
      t,
      o,
      i,
      r,
      "data"
    ),
    [e, t, o, i, r]
  ), c = F.useMemo(
    () => yg(
      e,
      t,
      o,
      i,
      r,
      "assets"
    ),
    [e, t, o, i, r]
  ), u = F.useMemo(() => {
    if (e === r.pathname + r.search + r.hash)
      return [];
    let p = /* @__PURE__ */ new Set(), h = !1;
    if (t.forEach((m) => {
      var y;
      let b = i.routes[m.route.id];
      !b || !b.hasLoader || (!l.some((v) => v.route.id === m.route.id) && m.route.id in s && ((y = a[m.route.id]) != null && y.shouldRevalidate) || b.hasClientLoader ? h = !0 : p.add(m.route.id));
    }), p.size === 0)
      return [];
    let g = V2(e);
    return h && p.size > 0 && g.searchParams.set(
      "_routes",
      t.filter((m) => p.has(m.route.id)).map((m) => m.route.id).join(",")
    ), [g.pathname + g.search];
  }, [
    s,
    r,
    i,
    l,
    t,
    e,
    a
  ]), d = F.useMemo(
    () => L2(c, i),
    [c, i]
  ), f = W2(c);
  return /* @__PURE__ */ F.createElement(F.Fragment, null, u.map((p) => /* @__PURE__ */ F.createElement("link", { key: p, rel: "prefetch", as: "fetch", href: p, ...n })), d.map((p) => /* @__PURE__ */ F.createElement("link", { key: p, rel: "modulepreload", href: p, ...n })), f.map(({ key: p, link: h }) => (
    // these don't spread `linkProps` because they are full link descriptors
    // already with their own props
    /* @__PURE__ */ F.createElement("link", { key: p, ...h })
  )));
}
function $2(...e) {
  return (t) => {
    e.forEach((n) => {
      typeof n == "function" ? n(t) : n != null && (n.current = t);
    });
  };
}
var A_ = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u";
try {
  A_ && (window.__reactRouterVersion = "7.1.5");
} catch {
}
var k_ = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i, T_ = F.forwardRef(
  function({
    onClick: t,
    discover: n = "render",
    prefetch: r = "none",
    relative: i,
    reloadDocument: a,
    replace: s,
    state: o,
    target: l,
    to: c,
    preventScrollReset: u,
    viewTransition: d,
    ...f
  }, p) {
    let { basename: h } = F.useContext(Hr), g = typeof c == "string" && k_.test(c), m, b = !1;
    if (typeof c == "string" && g && (m = c, A_))
      try {
        let O = new URL(window.location.href), k = c.startsWith("//") ? new URL(O.protocol + c) : new URL(c), W = Ni(k.pathname, h);
        k.origin === O.origin && W != null ? c = W + k.search + k.hash : b = !0;
      } catch {
        Br(
          !1,
          `<Link to="${c}"> contains an invalid URL which will probably break when clicked - please update to a valid URL path.`
        );
      }
    let y = u2(c, { relative: i }), [v, E, _] = U2(
      r,
      f
    ), x = J2(c, {
      replace: s,
      state: o,
      target: l,
      preventScrollReset: u,
      relative: i,
      viewTransition: d
    });
    function I(O) {
      t && t(O), O.defaultPrevented || x(O);
    }
    let T = (
      // eslint-disable-next-line jsx-a11y/anchor-has-content
      /* @__PURE__ */ F.createElement(
        "a",
        {
          ...f,
          ..._,
          href: m || y,
          onClick: b || a ? t : I,
          ref: $2(p, E),
          target: l,
          "data-discover": !g && n === "render" ? "true" : void 0
        }
      )
    );
    return v && !g ? /* @__PURE__ */ F.createElement(F.Fragment, null, T, /* @__PURE__ */ F.createElement(H2, { page: y })) : T;
  }
);
T_.displayName = "Link";
var R_ = F.forwardRef(
  function({
    "aria-current": t = "page",
    caseSensitive: n = !1,
    className: r = "",
    end: i = !1,
    style: a,
    to: s,
    viewTransition: o,
    children: l,
    ...c
  }, u) {
    let d = to(s, { relative: c.relative }), f = nr(), p = F.useContext(ic), { navigator: h, basename: g } = F.useContext(Hr), m = p != null && // Conditional usage is OK here because the usage of a data router is static
    // eslint-disable-next-line react-hooks/rules-of-hooks
    tL(d) && o === !0, b = h.encodeLocation ? h.encodeLocation(d).pathname : d.pathname, y = f.pathname, v = p && p.navigation && p.navigation.location ? p.navigation.location.pathname : null;
    n || (y = y.toLowerCase(), v = v ? v.toLowerCase() : null, b = b.toLowerCase()), v && g && (v = Ni(v, g) || v);
    const E = b !== "/" && b.endsWith("/") ? b.length - 1 : b.length;
    let _ = y === b || !i && y.startsWith(b) && y.charAt(E) === "/", x = v != null && (v === b || !i && v.startsWith(b) && v.charAt(b.length) === "/"), I = {
      isActive: _,
      isPending: x,
      isTransitioning: m
    }, T = _ ? t : void 0, O;
    typeof r == "function" ? O = r(I) : O = [
      r,
      _ ? "active" : null,
      x ? "pending" : null,
      m ? "transitioning" : null
    ].filter(Boolean).join(" ");
    let k = typeof a == "function" ? a(I) : a;
    return /* @__PURE__ */ F.createElement(
      T_,
      {
        ...c,
        "aria-current": T,
        className: O,
        ref: u,
        style: k,
        to: s,
        viewTransition: o
      },
      typeof l == "function" ? l(I) : l
    );
  }
);
R_.displayName = "NavLink";
var X2 = F.forwardRef(
  ({
    discover: e = "render",
    fetcherKey: t,
    navigate: n,
    reloadDocument: r,
    replace: i,
    state: a,
    method: s = Fo,
    action: o,
    onSubmit: l,
    relative: c,
    preventScrollReset: u,
    viewTransition: d,
    ...f
  }, p) => {
    let h = Q2(), g = eL(o, { relative: c }), m = s.toLowerCase() === "get" ? "get" : "post", b = typeof o == "string" && k_.test(o), y = (v) => {
      if (l && l(v), v.defaultPrevented) return;
      v.preventDefault();
      let E = v.nativeEvent.submitter, _ = (E == null ? void 0 : E.getAttribute("formmethod")) || s;
      h(E || v.currentTarget, {
        fetcherKey: t,
        method: _,
        navigate: n,
        replace: i,
        state: a,
        relative: c,
        preventScrollReset: u,
        viewTransition: d
      });
    };
    return /* @__PURE__ */ F.createElement(
      "form",
      {
        ref: p,
        method: m,
        action: g,
        onSubmit: r ? l : y,
        ...f,
        "data-discover": !b && e === "render" ? "true" : void 0
      }
    );
  }
);
X2.displayName = "Form";
function Y2(e) {
  return `${e} must be used within a data router.  See https://reactrouter.com/en/main/routers/picking-a-router.`;
}
function N_(e) {
  let t = F.useContext(Ma);
  return Vt(t, Y2(e)), t;
}
function J2(e, {
  target: t,
  replace: n,
  state: r,
  preventScrollReset: i,
  relative: a,
  viewTransition: s
} = {}) {
  let o = sc(), l = nr(), c = to(e, { relative: a });
  return F.useCallback(
    (u) => {
      if (T2(u, t)) {
        u.preventDefault();
        let d = n !== void 0 ? n : td(l) === td(c);
        o(e, {
          replace: d,
          state: r,
          preventScrollReset: i,
          relative: a,
          viewTransition: s
        });
      }
    },
    [
      l,
      o,
      c,
      n,
      r,
      t,
      e,
      i,
      a,
      s
    ]
  );
}
var q2 = 0, K2 = () => `__${String(++q2)}__`;
function Q2() {
  let { router: e } = N_(
    "useSubmit"
    /* UseSubmit */
  ), { basename: t } = F.useContext(Hr), n = x2();
  return F.useCallback(
    async (r, i = {}) => {
      let { action: a, method: s, encType: o, formData: l, body: c } = O2(
        r,
        t
      );
      if (i.navigate === !1) {
        let u = i.fetcherKey || K2();
        await e.fetch(u, n, i.action || a, {
          preventScrollReset: i.preventScrollReset,
          formData: l,
          body: c,
          formMethod: i.method || s,
          formEncType: i.encType || o,
          flushSync: i.flushSync
        });
      } else
        await e.navigate(i.action || a, {
          preventScrollReset: i.preventScrollReset,
          formData: l,
          body: c,
          formMethod: i.method || s,
          formEncType: i.encType || o,
          replace: i.replace,
          state: i.state,
          fromRouteId: n,
          flushSync: i.flushSync,
          viewTransition: i.viewTransition
        });
    },
    [e, t, n]
  );
}
function eL(e, { relative: t } = {}) {
  let { basename: n } = F.useContext(Hr), r = F.useContext(Wr);
  Vt(r, "useFormAction must be used inside a RouteContext");
  let [i] = r.matches.slice(-1), a = { ...to(e || ".", { relative: t }) }, s = nr();
  if (e == null) {
    a.search = s.search;
    let o = new URLSearchParams(a.search), l = o.getAll("index");
    if (l.some((u) => u === "")) {
      o.delete("index"), l.filter((d) => d).forEach((d) => o.append("index", d));
      let u = o.toString();
      a.search = u ? `?${u}` : "";
    }
  }
  return (!e || e === ".") && i.route.index && (a.search = a.search ? a.search.replace(/^\?/, "?index&") : "?index"), n !== "/" && (a.pathname = a.pathname === "/" ? n : Or([n, a.pathname])), td(a);
}
function tL(e, t = {}) {
  let n = F.useContext(E_);
  Vt(
    n != null,
    "`useViewTransitionState` must be used within `react-router-dom`'s `RouterProvider`.  Did you accidentally import `RouterProvider` from `react-router`?"
  );
  let { basename: r } = N_(
    "useViewTransitionState"
    /* useViewTransitionState */
  ), i = to(e, { relative: t.relative });
  if (!n.isTransitioning)
    return !1;
  let a = Ni(n.currentLocation.pathname, r) || n.currentLocation.pathname, s = Ni(n.nextLocation.pathname, r) || n.nextLocation.pathname;
  return Cl(i.pathname, s) != null || Cl(i.pathname, a) != null;
}
new TextEncoder();
const nL = tx({
  placement: "bottom-end",
  pauseOnPageIdle: !0
}), rL = () => /* @__PURE__ */ w.jsx(Vl, { children: /* @__PURE__ */ w.jsx(nx, { toaster: nL, insetInline: { mdDown: "4" }, children: (e) => {
  var t;
  return /* @__PURE__ */ w.jsxs(Ui.Root, { width: { md: "sm" }, children: [
    e.type === "loading" ? /* @__PURE__ */ w.jsx(Yo, { size: "sm", color: "blue.solid" }) : /* @__PURE__ */ w.jsx(Ui.Indicator, {}),
    /* @__PURE__ */ w.jsxs(Ws, { gap: "1", flex: "1", maxWidth: "100%", children: [
      e.title && /* @__PURE__ */ w.jsx(Ui.Title, { children: e.title }),
      e.description && /* @__PURE__ */ w.jsx(Ui.Description, { children: e.description })
    ] }),
    e.action && /* @__PURE__ */ w.jsx(Ui.ActionTrigger, { children: e.action.label }),
    ((t = e.meta) == null ? void 0 : t.closable) && /* @__PURE__ */ w.jsx(Ui.CloseTrigger, {})
  ] });
} }) }), O_ = Bl(void 0);
function iL(e) {
  const t = (n) => {
    const r = nr(), [i, a] = _t(n.background);
    return er(() => {
      a(n.background);
    }, [r.pathname]), /* @__PURE__ */ w.jsxs(O_.Provider, { value: { props: { ...n, background: i }, setBackground: a }, children: [
      /* @__PURE__ */ w.jsx(e, { ...n }),
      /* @__PURE__ */ w.jsx(rL, {})
    ] });
  };
  return t.displayName = `withTransformerLayout(${e.displayName || e.name || "Component"})`, t;
}
function kr(e) {
  if (e === void 0)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e;
}
function M_(e, t) {
  e.prototype = Object.create(t.prototype), e.prototype.constructor = e, e.__proto__ = t;
}
/*!
 * GSAP 3.12.7
 * https://gsap.com
 *
 * @license Copyright 2008-2025, GreenSock. All rights reserved.
 * Subject to the terms at https://gsap.com/standard-license or for
 * Club GSAP members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*/
var On = {
  autoSleep: 120,
  force3D: "auto",
  nullTargetWarn: 1,
  units: {
    lineHeight: ""
  }
}, Ea = {
  duration: 0.5,
  overwrite: !1,
  delay: 0
}, Rf, Gt, st, _r = 1e8, Jt = 1 / _r, nd = Math.PI * 2, aL = nd / 4, sL = 0, P_ = Math.sqrt, oL = Math.cos, lL = Math.sin, Lt = function(t) {
  return typeof t == "string";
}, ht = function(t) {
  return typeof t == "function";
}, zr = function(t) {
  return typeof t == "number";
}, Nf = function(t) {
  return typeof t > "u";
}, wr = function(t) {
  return typeof t == "object";
}, mn = function(t) {
  return t !== !1;
}, Of = function() {
  return typeof window < "u";
}, Ao = function(t) {
  return ht(t) || Lt(t);
}, D_ = typeof ArrayBuffer == "function" && ArrayBuffer.isView || function() {
}, qt = Array.isArray, rd = /(?:-?\.?\d|\.)+/gi, L_ = /[-+=.]*\d+[.e\-+]*\d*[e\-+]*\d*/g, ta = /[-+=.]*\d+[.e-]*\d*[a-z%]*/g, uu = /[-+=.]*\d+\.?\d*(?:e-|e\+)?\d*/gi, F_ = /[+-]=-?[.\d]+/, B_ = /[^,'"\[\]\s]+/gi, cL = /^[+\-=e\s\d]*\d+[.\d]*([a-z]*|%)\s*$/i, ct, cr, id, Mf, Pn = {}, Il = {}, z_, V_ = function(t) {
  return (Il = wa(t, Pn)) && En;
}, Pf = function(t, n) {
  return console.warn("Invalid property", t, "set to", n, "Missing plugin? gsap.registerPlugin()");
}, Ms = function(t, n) {
  return !n && console.warn(t);
}, G_ = function(t, n) {
  return t && (Pn[t] = n) && Il && (Il[t] = n) || Pn;
}, Ps = function() {
  return 0;
}, uL = {
  suppressEvents: !0,
  isStart: !0,
  kill: !1
}, zo = {
  suppressEvents: !0,
  kill: !1
}, dL = {
  suppressEvents: !0
}, Df = {}, ei = [], ad = {}, j_, Sn = {}, du = {}, _g = 30, Vo = [], Lf = "", Ff = function(t) {
  var n = t[0], r, i;
  if (wr(n) || ht(n) || (t = [t]), !(r = (n._gsap || {}).harness)) {
    for (i = Vo.length; i-- && !Vo[i].targetTest(n); )
      ;
    r = Vo[i];
  }
  for (i = t.length; i--; )
    t[i] && (t[i]._gsap || (t[i]._gsap = new f0(t[i], r))) || t.splice(i, 1);
  return t;
}, xi = function(t) {
  return t._gsap || Ff(Un(t))[0]._gsap;
}, U_ = function(t, n, r) {
  return (r = t[n]) && ht(r) ? t[n]() : Nf(r) && t.getAttribute && t.getAttribute(n) || r;
}, bn = function(t, n) {
  return (t = t.split(",")).forEach(n) || t;
}, xt = function(t) {
  return Math.round(t * 1e5) / 1e5 || 0;
}, kt = function(t) {
  return Math.round(t * 1e7) / 1e7 || 0;
}, ca = function(t, n) {
  var r = n.charAt(0), i = parseFloat(n.substr(2));
  return t = parseFloat(t), r === "+" ? t + i : r === "-" ? t - i : r === "*" ? t * i : t / i;
}, fL = function(t, n) {
  for (var r = n.length, i = 0; t.indexOf(n[i]) < 0 && ++i < r; )
    ;
  return i < r;
}, Sl = function() {
  var t = ei.length, n = ei.slice(0), r, i;
  for (ad = {}, ei.length = 0, r = 0; r < t; r++)
    i = n[r], i && i._lazy && (i.render(i._lazy[0], i._lazy[1], !0)._lazy = 0);
}, H_ = function(t, n, r, i) {
  ei.length && !Gt && Sl(), t.render(n, r, Gt && n < 0 && (t._initted || t._startAt)), ei.length && !Gt && Sl();
}, W_ = function(t) {
  var n = parseFloat(t);
  return (n || n === 0) && (t + "").match(B_).length < 2 ? n : Lt(t) ? t.trim() : t;
}, Z_ = function(t) {
  return t;
}, Dn = function(t, n) {
  for (var r in n)
    r in t || (t[r] = n[r]);
  return t;
}, pL = function(t) {
  return function(n, r) {
    for (var i in r)
      i in n || i === "duration" && t || i === "ease" || (n[i] = r[i]);
  };
}, wa = function(t, n) {
  for (var r in n)
    t[r] = n[r];
  return t;
}, vg = function e(t, n) {
  for (var r in n)
    r !== "__proto__" && r !== "constructor" && r !== "prototype" && (t[r] = wr(n[r]) ? e(t[r] || (t[r] = {}), n[r]) : n[r]);
  return t;
}, Al = function(t, n) {
  var r = {}, i;
  for (i in t)
    i in n || (r[i] = t[i]);
  return r;
}, us = function(t) {
  var n = t.parent || ct, r = t.keyframes ? pL(qt(t.keyframes)) : Dn;
  if (mn(t.inherit))
    for (; n; )
      r(t, n.vars.defaults), n = n.parent || n._dp;
  return t;
}, hL = function(t, n) {
  for (var r = t.length, i = r === n.length; i && r-- && t[r] === n[r]; )
    ;
  return r < 0;
}, $_ = function(t, n, r, i, a) {
  var s = t[i], o;
  if (a)
    for (o = n[a]; s && s[a] > o; )
      s = s._prev;
  return s ? (n._next = s._next, s._next = n) : (n._next = t[r], t[r] = n), n._next ? n._next._prev = n : t[i] = n, n._prev = s, n.parent = n._dp = t, n;
}, lc = function(t, n, r, i) {
  r === void 0 && (r = "_first"), i === void 0 && (i = "_last");
  var a = n._prev, s = n._next;
  a ? a._next = s : t[r] === n && (t[r] = s), s ? s._prev = a : t[i] === n && (t[i] = a), n._next = n._prev = n.parent = null;
}, ai = function(t, n) {
  t.parent && (!n || t.parent.autoRemoveChildren) && t.parent.remove && t.parent.remove(t), t._act = 0;
}, Ei = function(t, n) {
  if (t && (!n || n._end > t._dur || n._start < 0))
    for (var r = t; r; )
      r._dirty = 1, r = r.parent;
  return t;
}, gL = function(t) {
  for (var n = t.parent; n && n.parent; )
    n._dirty = 1, n.totalDuration(), n = n.parent;
  return t;
}, sd = function(t, n, r, i) {
  return t._startAt && (Gt ? t._startAt.revert(zo) : t.vars.immediateRender && !t.vars.autoRevert || t._startAt.render(n, !0, i));
}, mL = function e(t) {
  return !t || t._ts && e(t.parent);
}, xg = function(t) {
  return t._repeat ? Ca(t._tTime, t = t.duration() + t._rDelay) * t : 0;
}, Ca = function(t, n) {
  var r = Math.floor(t = kt(t / n));
  return t && r === t ? r - 1 : r;
}, kl = function(t, n) {
  return (t - n._start) * n._ts + (n._ts >= 0 ? 0 : n._dirty ? n.totalDuration() : n._tDur);
}, cc = function(t) {
  return t._end = kt(t._start + (t._tDur / Math.abs(t._ts || t._rts || Jt) || 0));
}, uc = function(t, n) {
  var r = t._dp;
  return r && r.smoothChildTiming && t._ts && (t._start = kt(r._time - (t._ts > 0 ? n / t._ts : ((t._dirty ? t.totalDuration() : t._tDur) - n) / -t._ts)), cc(t), r._dirty || Ei(r, t)), t;
}, X_ = function(t, n) {
  var r;
  if ((n._time || !n._dur && n._initted || n._start < t._time && (n._dur || !n.add)) && (r = kl(t.rawTime(), n), (!n._dur || no(0, n.totalDuration(), r) - n._tTime > Jt) && n.render(r, !0)), Ei(t, n)._dp && t._initted && t._time >= t._dur && t._ts) {
    if (t._dur < t.duration())
      for (r = t; r._dp; )
        r.rawTime() >= 0 && r.totalTime(r._tTime), r = r._dp;
    t._zTime = -1e-8;
  }
}, pr = function(t, n, r, i) {
  return n.parent && ai(n), n._start = kt((zr(r) ? r : r || t !== ct ? zn(t, r, n) : t._time) + n._delay), n._end = kt(n._start + (n.totalDuration() / Math.abs(n.timeScale()) || 0)), $_(t, n, "_first", "_last", t._sort ? "_start" : 0), od(n) || (t._recent = n), i || X_(t, n), t._ts < 0 && uc(t, t._tTime), t;
}, Y_ = function(t, n) {
  return (Pn.ScrollTrigger || Pf("scrollTrigger", n)) && Pn.ScrollTrigger.create(n, t);
}, J_ = function(t, n, r, i, a) {
  if (zf(t, n, a), !t._initted)
    return 1;
  if (!r && t._pt && !Gt && (t._dur && t.vars.lazy !== !1 || !t._dur && t.vars.lazy) && j_ !== An.frame)
    return ei.push(t), t._lazy = [a, i], 1;
}, bL = function e(t) {
  var n = t.parent;
  return n && n._ts && n._initted && !n._lock && (n.rawTime() < 0 || e(n));
}, od = function(t) {
  var n = t.data;
  return n === "isFromStart" || n === "isStart";
}, yL = function(t, n, r, i) {
  var a = t.ratio, s = n < 0 || !n && (!t._start && bL(t) && !(!t._initted && od(t)) || (t._ts < 0 || t._dp._ts < 0) && !od(t)) ? 0 : 1, o = t._rDelay, l = 0, c, u, d;
  if (o && t._repeat && (l = no(0, t._tDur, n), u = Ca(l, o), t._yoyo && u & 1 && (s = 1 - s), u !== Ca(t._tTime, o) && (a = 1 - s, t.vars.repeatRefresh && t._initted && t.invalidate())), s !== a || Gt || i || t._zTime === Jt || !n && t._zTime) {
    if (!t._initted && J_(t, n, i, r, l))
      return;
    for (d = t._zTime, t._zTime = n || (r ? Jt : 0), r || (r = n && !d), t.ratio = s, t._from && (s = 1 - s), t._time = 0, t._tTime = l, c = t._pt; c; )
      c.r(s, c.d), c = c._next;
    n < 0 && sd(t, n, r, !0), t._onUpdate && !r && kn(t, "onUpdate"), l && t._repeat && !r && t.parent && kn(t, "onRepeat"), (n >= t._tDur || n < 0) && t.ratio === s && (s && ai(t, 1), !r && !Gt && (kn(t, s ? "onComplete" : "onReverseComplete", !0), t._prom && t._prom()));
  } else t._zTime || (t._zTime = n);
}, _L = function(t, n, r) {
  var i;
  if (r > n)
    for (i = t._first; i && i._start <= r; ) {
      if (i.data === "isPause" && i._start > n)
        return i;
      i = i._next;
    }
  else
    for (i = t._last; i && i._start >= r; ) {
      if (i.data === "isPause" && i._start < n)
        return i;
      i = i._prev;
    }
}, Ia = function(t, n, r, i) {
  var a = t._repeat, s = kt(n) || 0, o = t._tTime / t._tDur;
  return o && !i && (t._time *= s / t._dur), t._dur = s, t._tDur = a ? a < 0 ? 1e10 : kt(s * (a + 1) + t._rDelay * a) : s, o > 0 && !i && uc(t, t._tTime = t._tDur * o), t.parent && cc(t), r || Ei(t.parent, t), t;
}, Eg = function(t) {
  return t instanceof ln ? Ei(t) : Ia(t, t._dur);
}, vL = {
  _start: 0,
  endTime: Ps,
  totalDuration: Ps
}, zn = function e(t, n, r) {
  var i = t.labels, a = t._recent || vL, s = t.duration() >= _r ? a.endTime(!1) : t._dur, o, l, c;
  return Lt(n) && (isNaN(n) || n in i) ? (l = n.charAt(0), c = n.substr(-1) === "%", o = n.indexOf("="), l === "<" || l === ">" ? (o >= 0 && (n = n.replace(/=/, "")), (l === "<" ? a._start : a.endTime(a._repeat >= 0)) + (parseFloat(n.substr(1)) || 0) * (c ? (o < 0 ? a : r).totalDuration() / 100 : 1)) : o < 0 ? (n in i || (i[n] = s), i[n]) : (l = parseFloat(n.charAt(o - 1) + n.substr(o + 1)), c && r && (l = l / 100 * (qt(r) ? r[0] : r).totalDuration()), o > 1 ? e(t, n.substr(0, o - 1), r) + l : s + l)) : n == null ? s : +n;
}, ds = function(t, n, r) {
  var i = zr(n[1]), a = (i ? 2 : 1) + (t < 2 ? 0 : 1), s = n[a], o, l;
  if (i && (s.duration = n[1]), s.parent = r, t) {
    for (o = s, l = r; l && !("immediateRender" in o); )
      o = l.vars.defaults || {}, l = mn(l.vars.inherit) && l.parent;
    s.immediateRender = mn(o.immediateRender), t < 2 ? s.runBackwards = 1 : s.startAt = n[a - 1];
  }
  return new At(n[0], s, n[a + 1]);
}, li = function(t, n) {
  return t || t === 0 ? n(t) : n;
}, no = function(t, n, r) {
  return r < t ? t : r > n ? n : r;
}, Zt = function(t, n) {
  return !Lt(t) || !(n = cL.exec(t)) ? "" : n[1];
}, xL = function(t, n, r) {
  return li(r, function(i) {
    return no(t, n, i);
  });
}, ld = [].slice, q_ = function(t, n) {
  return t && wr(t) && "length" in t && (!n && !t.length || t.length - 1 in t && wr(t[0])) && !t.nodeType && t !== cr;
}, EL = function(t, n, r) {
  return r === void 0 && (r = []), t.forEach(function(i) {
    var a;
    return Lt(i) && !n || q_(i, 1) ? (a = r).push.apply(a, Un(i)) : r.push(i);
  }) || r;
}, Un = function(t, n, r) {
  return st && !n && st.selector ? st.selector(t) : Lt(t) && !r && (id || !Sa()) ? ld.call((n || Mf).querySelectorAll(t), 0) : qt(t) ? EL(t, r) : q_(t) ? ld.call(t, 0) : t ? [t] : [];
}, cd = function(t) {
  return t = Un(t)[0] || Ms("Invalid scope") || {}, function(n) {
    var r = t.current || t.nativeElement || t;
    return Un(n, r.querySelectorAll ? r : r === t ? Ms("Invalid scope") || Mf.createElement("div") : t);
  };
}, K_ = function(t) {
  return t.sort(function() {
    return 0.5 - Math.random();
  });
}, Q_ = function(t) {
  if (ht(t))
    return t;
  var n = wr(t) ? t : {
    each: t
  }, r = wi(n.ease), i = n.from || 0, a = parseFloat(n.base) || 0, s = {}, o = i > 0 && i < 1, l = isNaN(i) || o, c = n.axis, u = i, d = i;
  return Lt(i) ? u = d = {
    center: 0.5,
    edges: 0.5,
    end: 1
  }[i] || 0 : !o && l && (u = i[0], d = i[1]), function(f, p, h) {
    var g = (h || n).length, m = s[g], b, y, v, E, _, x, I, T, O;
    if (!m) {
      if (O = n.grid === "auto" ? 0 : (n.grid || [1, _r])[1], !O) {
        for (I = -1e8; I < (I = h[O++].getBoundingClientRect().left) && O < g; )
          ;
        O < g && O--;
      }
      for (m = s[g] = [], b = l ? Math.min(O, g) * u - 0.5 : i % O, y = O === _r ? 0 : l ? g * d / O - 0.5 : i / O | 0, I = 0, T = _r, x = 0; x < g; x++)
        v = x % O - b, E = y - (x / O | 0), m[x] = _ = c ? Math.abs(c === "y" ? E : v) : P_(v * v + E * E), _ > I && (I = _), _ < T && (T = _);
      i === "random" && K_(m), m.max = I - T, m.min = T, m.v = g = (parseFloat(n.amount) || parseFloat(n.each) * (O > g ? g - 1 : c ? c === "y" ? g / O : O : Math.max(O, g / O)) || 0) * (i === "edges" ? -1 : 1), m.b = g < 0 ? a - g : a, m.u = Zt(n.amount || n.each) || 0, r = r && g < 0 ? c0(r) : r;
    }
    return g = (m[f] - m.min) / m.max || 0, kt(m.b + (r ? r(g) : g) * m.v) + m.u;
  };
}, ud = function(t) {
  var n = Math.pow(10, ((t + "").split(".")[1] || "").length);
  return function(r) {
    var i = kt(Math.round(parseFloat(r) / t) * t * n);
    return (i - i % 1) / n + (zr(r) ? 0 : Zt(r));
  };
}, e0 = function(t, n) {
  var r = qt(t), i, a;
  return !r && wr(t) && (i = r = t.radius || _r, t.values ? (t = Un(t.values), (a = !zr(t[0])) && (i *= i)) : t = ud(t.increment)), li(n, r ? ht(t) ? function(s) {
    return a = t(s), Math.abs(a - s) <= i ? a : s;
  } : function(s) {
    for (var o = parseFloat(a ? s.x : s), l = parseFloat(a ? s.y : 0), c = _r, u = 0, d = t.length, f, p; d--; )
      a ? (f = t[d].x - o, p = t[d].y - l, f = f * f + p * p) : f = Math.abs(t[d] - o), f < c && (c = f, u = d);
    return u = !i || c <= i ? t[u] : s, a || u === s || zr(s) ? u : u + Zt(s);
  } : ud(t));
}, t0 = function(t, n, r, i) {
  return li(qt(t) ? !n : r === !0 ? !!(r = 0) : !i, function() {
    return qt(t) ? t[~~(Math.random() * t.length)] : (r = r || 1e-5) && (i = r < 1 ? Math.pow(10, (r + "").length - 2) : 1) && Math.floor(Math.round((t - r / 2 + Math.random() * (n - t + r * 0.99)) / r) * r * i) / i;
  });
}, wL = function() {
  for (var t = arguments.length, n = new Array(t), r = 0; r < t; r++)
    n[r] = arguments[r];
  return function(i) {
    return n.reduce(function(a, s) {
      return s(a);
    }, i);
  };
}, CL = function(t, n) {
  return function(r) {
    return t(parseFloat(r)) + (n || Zt(r));
  };
}, IL = function(t, n, r) {
  return r0(t, n, 0, 1, r);
}, n0 = function(t, n, r) {
  return li(r, function(i) {
    return t[~~n(i)];
  });
}, SL = function e(t, n, r) {
  var i = n - t;
  return qt(t) ? n0(t, e(0, t.length), n) : li(r, function(a) {
    return (i + (a - t) % i) % i + t;
  });
}, AL = function e(t, n, r) {
  var i = n - t, a = i * 2;
  return qt(t) ? n0(t, e(0, t.length - 1), n) : li(r, function(s) {
    return s = (a + (s - t) % a) % a || 0, t + (s > i ? a - s : s);
  });
}, Ds = function(t) {
  for (var n = 0, r = "", i, a, s, o; ~(i = t.indexOf("random(", n)); )
    s = t.indexOf(")", i), o = t.charAt(i + 7) === "[", a = t.substr(i + 7, s - i - 7).match(o ? B_ : rd), r += t.substr(n, i - n) + t0(o ? a : +a[0], o ? 0 : +a[1], +a[2] || 1e-5), n = s + 1;
  return r + t.substr(n, t.length - n);
}, r0 = function(t, n, r, i, a) {
  var s = n - t, o = i - r;
  return li(a, function(l) {
    return r + ((l - t) / s * o || 0);
  });
}, kL = function e(t, n, r, i) {
  var a = isNaN(t + n) ? 0 : function(p) {
    return (1 - p) * t + p * n;
  };
  if (!a) {
    var s = Lt(t), o = {}, l, c, u, d, f;
    if (r === !0 && (i = 1) && (r = null), s)
      t = {
        p: t
      }, n = {
        p: n
      };
    else if (qt(t) && !qt(n)) {
      for (u = [], d = t.length, f = d - 2, c = 1; c < d; c++)
        u.push(e(t[c - 1], t[c]));
      d--, a = function(h) {
        h *= d;
        var g = Math.min(f, ~~h);
        return u[g](h - g);
      }, r = n;
    } else i || (t = wa(qt(t) ? [] : {}, t));
    if (!u) {
      for (l in n)
        Bf.call(o, t, l, "get", n[l]);
      a = function(h) {
        return jf(h, o) || (s ? t.p : t);
      };
    }
  }
  return li(r, a);
}, wg = function(t, n, r) {
  var i = t.labels, a = _r, s, o, l;
  for (s in i)
    o = i[s] - n, o < 0 == !!r && o && a > (o = Math.abs(o)) && (l = s, a = o);
  return l;
}, kn = function(t, n, r) {
  var i = t.vars, a = i[n], s = st, o = t._ctx, l, c, u;
  if (a)
    return l = i[n + "Params"], c = i.callbackScope || t, r && ei.length && Sl(), o && (st = o), u = l ? a.apply(c, l) : a.call(c), st = s, u;
}, rs = function(t) {
  return ai(t), t.scrollTrigger && t.scrollTrigger.kill(!!Gt), t.progress() < 1 && kn(t, "onInterrupt"), t;
}, na, i0 = [], a0 = function(t) {
  if (t)
    if (t = !t.name && t.default || t, Of() || t.headless) {
      var n = t.name, r = ht(t), i = n && !r && t.init ? function() {
        this._props = [];
      } : t, a = {
        init: Ps,
        render: jf,
        add: Bf,
        kill: HL,
        modifier: UL,
        rawVars: 0
      }, s = {
        targetTest: 0,
        get: 0,
        getSetter: Gf,
        aliases: {},
        register: 0
      };
      if (Sa(), t !== i) {
        if (Sn[n])
          return;
        Dn(i, Dn(Al(t, a), s)), wa(i.prototype, wa(a, Al(t, s))), Sn[i.prop = n] = i, t.targetTest && (Vo.push(i), Df[n] = 1), n = (n === "css" ? "CSS" : n.charAt(0).toUpperCase() + n.substr(1)) + "Plugin";
      }
      G_(n, i), t.register && t.register(En, i, yn);
    } else
      i0.push(t);
}, Ke = 255, is = {
  aqua: [0, Ke, Ke],
  lime: [0, Ke, 0],
  silver: [192, 192, 192],
  black: [0, 0, 0],
  maroon: [128, 0, 0],
  teal: [0, 128, 128],
  blue: [0, 0, Ke],
  navy: [0, 0, 128],
  white: [Ke, Ke, Ke],
  olive: [128, 128, 0],
  yellow: [Ke, Ke, 0],
  orange: [Ke, 165, 0],
  gray: [128, 128, 128],
  purple: [128, 0, 128],
  green: [0, 128, 0],
  red: [Ke, 0, 0],
  pink: [Ke, 192, 203],
  cyan: [0, Ke, Ke],
  transparent: [Ke, Ke, Ke, 0]
}, fu = function(t, n, r) {
  return t += t < 0 ? 1 : t > 1 ? -1 : 0, (t * 6 < 1 ? n + (r - n) * t * 6 : t < 0.5 ? r : t * 3 < 2 ? n + (r - n) * (2 / 3 - t) * 6 : n) * Ke + 0.5 | 0;
}, s0 = function(t, n, r) {
  var i = t ? zr(t) ? [t >> 16, t >> 8 & Ke, t & Ke] : 0 : is.black, a, s, o, l, c, u, d, f, p, h;
  if (!i) {
    if (t.substr(-1) === "," && (t = t.substr(0, t.length - 1)), is[t])
      i = is[t];
    else if (t.charAt(0) === "#") {
      if (t.length < 6 && (a = t.charAt(1), s = t.charAt(2), o = t.charAt(3), t = "#" + a + a + s + s + o + o + (t.length === 5 ? t.charAt(4) + t.charAt(4) : "")), t.length === 9)
        return i = parseInt(t.substr(1, 6), 16), [i >> 16, i >> 8 & Ke, i & Ke, parseInt(t.substr(7), 16) / 255];
      t = parseInt(t.substr(1), 16), i = [t >> 16, t >> 8 & Ke, t & Ke];
    } else if (t.substr(0, 3) === "hsl") {
      if (i = h = t.match(rd), !n)
        l = +i[0] % 360 / 360, c = +i[1] / 100, u = +i[2] / 100, s = u <= 0.5 ? u * (c + 1) : u + c - u * c, a = u * 2 - s, i.length > 3 && (i[3] *= 1), i[0] = fu(l + 1 / 3, a, s), i[1] = fu(l, a, s), i[2] = fu(l - 1 / 3, a, s);
      else if (~t.indexOf("="))
        return i = t.match(L_), r && i.length < 4 && (i[3] = 1), i;
    } else
      i = t.match(rd) || is.transparent;
    i = i.map(Number);
  }
  return n && !h && (a = i[0] / Ke, s = i[1] / Ke, o = i[2] / Ke, d = Math.max(a, s, o), f = Math.min(a, s, o), u = (d + f) / 2, d === f ? l = c = 0 : (p = d - f, c = u > 0.5 ? p / (2 - d - f) : p / (d + f), l = d === a ? (s - o) / p + (s < o ? 6 : 0) : d === s ? (o - a) / p + 2 : (a - s) / p + 4, l *= 60), i[0] = ~~(l + 0.5), i[1] = ~~(c * 100 + 0.5), i[2] = ~~(u * 100 + 0.5)), r && i.length < 4 && (i[3] = 1), i;
}, o0 = function(t) {
  var n = [], r = [], i = -1;
  return t.split(ti).forEach(function(a) {
    var s = a.match(ta) || [];
    n.push.apply(n, s), r.push(i += s.length + 1);
  }), n.c = r, n;
}, Cg = function(t, n, r) {
  var i = "", a = (t + i).match(ti), s = n ? "hsla(" : "rgba(", o = 0, l, c, u, d;
  if (!a)
    return t;
  if (a = a.map(function(f) {
    return (f = s0(f, n, 1)) && s + (n ? f[0] + "," + f[1] + "%," + f[2] + "%," + f[3] : f.join(",")) + ")";
  }), r && (u = o0(t), l = r.c, l.join(i) !== u.c.join(i)))
    for (c = t.replace(ti, "1").split(ta), d = c.length - 1; o < d; o++)
      i += c[o] + (~l.indexOf(o) ? a.shift() || s + "0,0,0,0)" : (u.length ? u : a.length ? a : r).shift());
  if (!c)
    for (c = t.split(ti), d = c.length - 1; o < d; o++)
      i += c[o] + a[o];
  return i + c[d];
}, ti = function() {
  var e = "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3,4}){1,2}\\b", t;
  for (t in is)
    e += "|" + t + "\\b";
  return new RegExp(e + ")", "gi");
}(), TL = /hsl[a]?\(/, l0 = function(t) {
  var n = t.join(" "), r;
  if (ti.lastIndex = 0, ti.test(n))
    return r = TL.test(n), t[1] = Cg(t[1], r), t[0] = Cg(t[0], r, o0(t[1])), !0;
}, Ls, An = function() {
  var e = Date.now, t = 500, n = 33, r = e(), i = r, a = 1e3 / 240, s = a, o = [], l, c, u, d, f, p, h = function g(m) {
    var b = e() - i, y = m === !0, v, E, _, x;
    if ((b > t || b < 0) && (r += b - n), i += b, _ = i - r, v = _ - s, (v > 0 || y) && (x = ++d.frame, f = _ - d.time * 1e3, d.time = _ = _ / 1e3, s += v + (v >= a ? 4 : a - v), E = 1), y || (l = c(g)), E)
      for (p = 0; p < o.length; p++)
        o[p](_, f, x, m);
  };
  return d = {
    time: 0,
    frame: 0,
    tick: function() {
      h(!0);
    },
    deltaRatio: function(m) {
      return f / (1e3 / (m || 60));
    },
    wake: function() {
      z_ && (!id && Of() && (cr = id = window, Mf = cr.document || {}, Pn.gsap = En, (cr.gsapVersions || (cr.gsapVersions = [])).push(En.version), V_(Il || cr.GreenSockGlobals || !cr.gsap && cr || {}), i0.forEach(a0)), u = typeof requestAnimationFrame < "u" && requestAnimationFrame, l && d.sleep(), c = u || function(m) {
        return setTimeout(m, s - d.time * 1e3 + 1 | 0);
      }, Ls = 1, h(2));
    },
    sleep: function() {
      (u ? cancelAnimationFrame : clearTimeout)(l), Ls = 0, c = Ps;
    },
    lagSmoothing: function(m, b) {
      t = m || 1 / 0, n = Math.min(b || 33, t);
    },
    fps: function(m) {
      a = 1e3 / (m || 240), s = d.time * 1e3 + a;
    },
    add: function(m, b, y) {
      var v = b ? function(E, _, x, I) {
        m(E, _, x, I), d.remove(v);
      } : m;
      return d.remove(m), o[y ? "unshift" : "push"](v), Sa(), v;
    },
    remove: function(m, b) {
      ~(b = o.indexOf(m)) && o.splice(b, 1) && p >= b && p--;
    },
    _listeners: o
  }, d;
}(), Sa = function() {
  return !Ls && An.wake();
}, Ve = {}, RL = /^[\d.\-M][\d.\-,\s]/, NL = /["']/g, OL = function(t) {
  for (var n = {}, r = t.substr(1, t.length - 3).split(":"), i = r[0], a = 1, s = r.length, o, l, c; a < s; a++)
    l = r[a], o = a !== s - 1 ? l.lastIndexOf(",") : l.length, c = l.substr(0, o), n[i] = isNaN(c) ? c.replace(NL, "").trim() : +c, i = l.substr(o + 1).trim();
  return n;
}, ML = function(t) {
  var n = t.indexOf("(") + 1, r = t.indexOf(")"), i = t.indexOf("(", n);
  return t.substring(n, ~i && i < r ? t.indexOf(")", r + 1) : r);
}, PL = function(t) {
  var n = (t + "").split("("), r = Ve[n[0]];
  return r && n.length > 1 && r.config ? r.config.apply(null, ~t.indexOf("{") ? [OL(n[1])] : ML(t).split(",").map(W_)) : Ve._CE && RL.test(t) ? Ve._CE("", t) : r;
}, c0 = function(t) {
  return function(n) {
    return 1 - t(1 - n);
  };
}, u0 = function e(t, n) {
  for (var r = t._first, i; r; )
    r instanceof ln ? e(r, n) : r.vars.yoyoEase && (!r._yoyo || !r._repeat) && r._yoyo !== n && (r.timeline ? e(r.timeline, n) : (i = r._ease, r._ease = r._yEase, r._yEase = i, r._yoyo = n)), r = r._next;
}, wi = function(t, n) {
  return t && (ht(t) ? t : Ve[t] || PL(t)) || n;
}, zi = function(t, n, r, i) {
  r === void 0 && (r = function(l) {
    return 1 - n(1 - l);
  }), i === void 0 && (i = function(l) {
    return l < 0.5 ? n(l * 2) / 2 : 1 - n((1 - l) * 2) / 2;
  });
  var a = {
    easeIn: n,
    easeOut: r,
    easeInOut: i
  }, s;
  return bn(t, function(o) {
    Ve[o] = Pn[o] = a, Ve[s = o.toLowerCase()] = r;
    for (var l in a)
      Ve[s + (l === "easeIn" ? ".in" : l === "easeOut" ? ".out" : ".inOut")] = Ve[o + "." + l] = a[l];
  }), a;
}, d0 = function(t) {
  return function(n) {
    return n < 0.5 ? (1 - t(1 - n * 2)) / 2 : 0.5 + t((n - 0.5) * 2) / 2;
  };
}, pu = function e(t, n, r) {
  var i = n >= 1 ? n : 1, a = (r || (t ? 0.3 : 0.45)) / (n < 1 ? n : 1), s = a / nd * (Math.asin(1 / i) || 0), o = function(u) {
    return u === 1 ? 1 : i * Math.pow(2, -10 * u) * lL((u - s) * a) + 1;
  }, l = t === "out" ? o : t === "in" ? function(c) {
    return 1 - o(1 - c);
  } : d0(o);
  return a = nd / a, l.config = function(c, u) {
    return e(t, c, u);
  }, l;
}, hu = function e(t, n) {
  n === void 0 && (n = 1.70158);
  var r = function(s) {
    return s ? --s * s * ((n + 1) * s + n) + 1 : 0;
  }, i = t === "out" ? r : t === "in" ? function(a) {
    return 1 - r(1 - a);
  } : d0(r);
  return i.config = function(a) {
    return e(t, a);
  }, i;
};
bn("Linear,Quad,Cubic,Quart,Quint,Strong", function(e, t) {
  var n = t < 5 ? t + 1 : t;
  zi(e + ",Power" + (n - 1), t ? function(r) {
    return Math.pow(r, n);
  } : function(r) {
    return r;
  }, function(r) {
    return 1 - Math.pow(1 - r, n);
  }, function(r) {
    return r < 0.5 ? Math.pow(r * 2, n) / 2 : 1 - Math.pow((1 - r) * 2, n) / 2;
  });
});
Ve.Linear.easeNone = Ve.none = Ve.Linear.easeIn;
zi("Elastic", pu("in"), pu("out"), pu());
(function(e, t) {
  var n = 1 / t, r = 2 * n, i = 2.5 * n, a = function(o) {
    return o < n ? e * o * o : o < r ? e * Math.pow(o - 1.5 / t, 2) + 0.75 : o < i ? e * (o -= 2.25 / t) * o + 0.9375 : e * Math.pow(o - 2.625 / t, 2) + 0.984375;
  };
  zi("Bounce", function(s) {
    return 1 - a(1 - s);
  }, a);
})(7.5625, 2.75);
zi("Expo", function(e) {
  return Math.pow(2, 10 * (e - 1)) * e + e * e * e * e * e * e * (1 - e);
});
zi("Circ", function(e) {
  return -(P_(1 - e * e) - 1);
});
zi("Sine", function(e) {
  return e === 1 ? 1 : -oL(e * aL) + 1;
});
zi("Back", hu("in"), hu("out"), hu());
Ve.SteppedEase = Ve.steps = Pn.SteppedEase = {
  config: function(t, n) {
    t === void 0 && (t = 1);
    var r = 1 / t, i = t + (n ? 0 : 1), a = n ? 1 : 0, s = 1 - Jt;
    return function(o) {
      return ((i * no(0, s, o) | 0) + a) * r;
    };
  }
};
Ea.ease = Ve["quad.out"];
bn("onComplete,onUpdate,onStart,onRepeat,onReverseComplete,onInterrupt", function(e) {
  return Lf += e + "," + e + "Params,";
});
var f0 = function(t, n) {
  this.id = sL++, t._gsap = this, this.target = t, this.harness = n, this.get = n ? n.get : U_, this.set = n ? n.getSetter : Gf;
}, Fs = /* @__PURE__ */ function() {
  function e(n) {
    this.vars = n, this._delay = +n.delay || 0, (this._repeat = n.repeat === 1 / 0 ? -2 : n.repeat || 0) && (this._rDelay = n.repeatDelay || 0, this._yoyo = !!n.yoyo || !!n.yoyoEase), this._ts = 1, Ia(this, +n.duration, 1, 1), this.data = n.data, st && (this._ctx = st, st.data.push(this)), Ls || An.wake();
  }
  var t = e.prototype;
  return t.delay = function(r) {
    return r || r === 0 ? (this.parent && this.parent.smoothChildTiming && this.startTime(this._start + r - this._delay), this._delay = r, this) : this._delay;
  }, t.duration = function(r) {
    return arguments.length ? this.totalDuration(this._repeat > 0 ? r + (r + this._rDelay) * this._repeat : r) : this.totalDuration() && this._dur;
  }, t.totalDuration = function(r) {
    return arguments.length ? (this._dirty = 0, Ia(this, this._repeat < 0 ? r : (r - this._repeat * this._rDelay) / (this._repeat + 1))) : this._tDur;
  }, t.totalTime = function(r, i) {
    if (Sa(), !arguments.length)
      return this._tTime;
    var a = this._dp;
    if (a && a.smoothChildTiming && this._ts) {
      for (uc(this, r), !a._dp || a.parent || X_(a, this); a && a.parent; )
        a.parent._time !== a._start + (a._ts >= 0 ? a._tTime / a._ts : (a.totalDuration() - a._tTime) / -a._ts) && a.totalTime(a._tTime, !0), a = a.parent;
      !this.parent && this._dp.autoRemoveChildren && (this._ts > 0 && r < this._tDur || this._ts < 0 && r > 0 || !this._tDur && !r) && pr(this._dp, this, this._start - this._delay);
    }
    return (this._tTime !== r || !this._dur && !i || this._initted && Math.abs(this._zTime) === Jt || !r && !this._initted && (this.add || this._ptLookup)) && (this._ts || (this._pTime = r), H_(this, r, i)), this;
  }, t.time = function(r, i) {
    return arguments.length ? this.totalTime(Math.min(this.totalDuration(), r + xg(this)) % (this._dur + this._rDelay) || (r ? this._dur : 0), i) : this._time;
  }, t.totalProgress = function(r, i) {
    return arguments.length ? this.totalTime(this.totalDuration() * r, i) : this.totalDuration() ? Math.min(1, this._tTime / this._tDur) : this.rawTime() >= 0 && this._initted ? 1 : 0;
  }, t.progress = function(r, i) {
    return arguments.length ? this.totalTime(this.duration() * (this._yoyo && !(this.iteration() & 1) ? 1 - r : r) + xg(this), i) : this.duration() ? Math.min(1, this._time / this._dur) : this.rawTime() > 0 ? 1 : 0;
  }, t.iteration = function(r, i) {
    var a = this.duration() + this._rDelay;
    return arguments.length ? this.totalTime(this._time + (r - 1) * a, i) : this._repeat ? Ca(this._tTime, a) + 1 : 1;
  }, t.timeScale = function(r, i) {
    if (!arguments.length)
      return this._rts === -1e-8 ? 0 : this._rts;
    if (this._rts === r)
      return this;
    var a = this.parent && this._ts ? kl(this.parent._time, this) : this._tTime;
    return this._rts = +r || 0, this._ts = this._ps || r === -1e-8 ? 0 : this._rts, this.totalTime(no(-Math.abs(this._delay), this._tDur, a), i !== !1), cc(this), gL(this);
  }, t.paused = function(r) {
    return arguments.length ? (this._ps !== r && (this._ps = r, r ? (this._pTime = this._tTime || Math.max(-this._delay, this.rawTime()), this._ts = this._act = 0) : (Sa(), this._ts = this._rts, this.totalTime(this.parent && !this.parent.smoothChildTiming ? this.rawTime() : this._tTime || this._pTime, this.progress() === 1 && Math.abs(this._zTime) !== Jt && (this._tTime -= Jt)))), this) : this._ps;
  }, t.startTime = function(r) {
    if (arguments.length) {
      this._start = r;
      var i = this.parent || this._dp;
      return i && (i._sort || !this.parent) && pr(i, this, r - this._delay), this;
    }
    return this._start;
  }, t.endTime = function(r) {
    return this._start + (mn(r) ? this.totalDuration() : this.duration()) / Math.abs(this._ts || 1);
  }, t.rawTime = function(r) {
    var i = this.parent || this._dp;
    return i ? r && (!this._ts || this._repeat && this._time && this.totalProgress() < 1) ? this._tTime % (this._dur + this._rDelay) : this._ts ? kl(i.rawTime(r), this) : this._tTime : this._tTime;
  }, t.revert = function(r) {
    r === void 0 && (r = dL);
    var i = Gt;
    return Gt = r, (this._initted || this._startAt) && (this.timeline && this.timeline.revert(r), this.totalTime(-0.01, r.suppressEvents)), this.data !== "nested" && r.kill !== !1 && this.kill(), Gt = i, this;
  }, t.globalTime = function(r) {
    for (var i = this, a = arguments.length ? r : i.rawTime(); i; )
      a = i._start + a / (Math.abs(i._ts) || 1), i = i._dp;
    return !this.parent && this._sat ? this._sat.globalTime(r) : a;
  }, t.repeat = function(r) {
    return arguments.length ? (this._repeat = r === 1 / 0 ? -2 : r, Eg(this)) : this._repeat === -2 ? 1 / 0 : this._repeat;
  }, t.repeatDelay = function(r) {
    if (arguments.length) {
      var i = this._time;
      return this._rDelay = r, Eg(this), i ? this.time(i) : this;
    }
    return this._rDelay;
  }, t.yoyo = function(r) {
    return arguments.length ? (this._yoyo = r, this) : this._yoyo;
  }, t.seek = function(r, i) {
    return this.totalTime(zn(this, r), mn(i));
  }, t.restart = function(r, i) {
    return this.play().totalTime(r ? -this._delay : 0, mn(i)), this._dur || (this._zTime = -1e-8), this;
  }, t.play = function(r, i) {
    return r != null && this.seek(r, i), this.reversed(!1).paused(!1);
  }, t.reverse = function(r, i) {
    return r != null && this.seek(r || this.totalDuration(), i), this.reversed(!0).paused(!1);
  }, t.pause = function(r, i) {
    return r != null && this.seek(r, i), this.paused(!0);
  }, t.resume = function() {
    return this.paused(!1);
  }, t.reversed = function(r) {
    return arguments.length ? (!!r !== this.reversed() && this.timeScale(-this._rts || (r ? -1e-8 : 0)), this) : this._rts < 0;
  }, t.invalidate = function() {
    return this._initted = this._act = 0, this._zTime = -1e-8, this;
  }, t.isActive = function() {
    var r = this.parent || this._dp, i = this._start, a;
    return !!(!r || this._ts && this._initted && r.isActive() && (a = r.rawTime(!0)) >= i && a < this.endTime(!0) - Jt);
  }, t.eventCallback = function(r, i, a) {
    var s = this.vars;
    return arguments.length > 1 ? (i ? (s[r] = i, a && (s[r + "Params"] = a), r === "onUpdate" && (this._onUpdate = i)) : delete s[r], this) : s[r];
  }, t.then = function(r) {
    var i = this;
    return new Promise(function(a) {
      var s = ht(r) ? r : Z_, o = function() {
        var c = i.then;
        i.then = null, ht(s) && (s = s(i)) && (s.then || s === i) && (i.then = c), a(s), i.then = c;
      };
      i._initted && i.totalProgress() === 1 && i._ts >= 0 || !i._tTime && i._ts < 0 ? o() : i._prom = o;
    });
  }, t.kill = function() {
    rs(this);
  }, e;
}();
Dn(Fs.prototype, {
  _time: 0,
  _start: 0,
  _end: 0,
  _tTime: 0,
  _tDur: 0,
  _dirty: 0,
  _repeat: 0,
  _yoyo: !1,
  parent: null,
  _initted: !1,
  _rDelay: 0,
  _ts: 1,
  _dp: 0,
  ratio: 0,
  _zTime: -1e-8,
  _prom: 0,
  _ps: !1,
  _rts: 1
});
var ln = /* @__PURE__ */ function(e) {
  M_(t, e);
  function t(r, i) {
    var a;
    return r === void 0 && (r = {}), a = e.call(this, r) || this, a.labels = {}, a.smoothChildTiming = !!r.smoothChildTiming, a.autoRemoveChildren = !!r.autoRemoveChildren, a._sort = mn(r.sortChildren), ct && pr(r.parent || ct, kr(a), i), r.reversed && a.reverse(), r.paused && a.paused(!0), r.scrollTrigger && Y_(kr(a), r.scrollTrigger), a;
  }
  var n = t.prototype;
  return n.to = function(i, a, s) {
    return ds(0, arguments, this), this;
  }, n.from = function(i, a, s) {
    return ds(1, arguments, this), this;
  }, n.fromTo = function(i, a, s, o) {
    return ds(2, arguments, this), this;
  }, n.set = function(i, a, s) {
    return a.duration = 0, a.parent = this, us(a).repeatDelay || (a.repeat = 0), a.immediateRender = !!a.immediateRender, new At(i, a, zn(this, s), 1), this;
  }, n.call = function(i, a, s) {
    return pr(this, At.delayedCall(0, i, a), s);
  }, n.staggerTo = function(i, a, s, o, l, c, u) {
    return s.duration = a, s.stagger = s.stagger || o, s.onComplete = c, s.onCompleteParams = u, s.parent = this, new At(i, s, zn(this, l)), this;
  }, n.staggerFrom = function(i, a, s, o, l, c, u) {
    return s.runBackwards = 1, us(s).immediateRender = mn(s.immediateRender), this.staggerTo(i, a, s, o, l, c, u);
  }, n.staggerFromTo = function(i, a, s, o, l, c, u, d) {
    return o.startAt = s, us(o).immediateRender = mn(o.immediateRender), this.staggerTo(i, a, o, l, c, u, d);
  }, n.render = function(i, a, s) {
    var o = this._time, l = this._dirty ? this.totalDuration() : this._tDur, c = this._dur, u = i <= 0 ? 0 : kt(i), d = this._zTime < 0 != i < 0 && (this._initted || !c), f, p, h, g, m, b, y, v, E, _, x, I;
    if (this !== ct && u > l && i >= 0 && (u = l), u !== this._tTime || s || d) {
      if (o !== this._time && c && (u += this._time - o, i += this._time - o), f = u, E = this._start, v = this._ts, b = !v, d && (c || (o = this._zTime), (i || !a) && (this._zTime = i)), this._repeat) {
        if (x = this._yoyo, m = c + this._rDelay, this._repeat < -1 && i < 0)
          return this.totalTime(m * 100 + i, a, s);
        if (f = kt(u % m), u === l ? (g = this._repeat, f = c) : (_ = kt(u / m), g = ~~_, g && g === _ && (f = c, g--), f > c && (f = c)), _ = Ca(this._tTime, m), !o && this._tTime && _ !== g && this._tTime - _ * m - this._dur <= 0 && (_ = g), x && g & 1 && (f = c - f, I = 1), g !== _ && !this._lock) {
          var T = x && _ & 1, O = T === (x && g & 1);
          if (g < _ && (T = !T), o = T ? 0 : u % c ? c : u, this._lock = 1, this.render(o || (I ? 0 : kt(g * m)), a, !c)._lock = 0, this._tTime = u, !a && this.parent && kn(this, "onRepeat"), this.vars.repeatRefresh && !I && (this.invalidate()._lock = 1), o && o !== this._time || b !== !this._ts || this.vars.onRepeat && !this.parent && !this._act)
            return this;
          if (c = this._dur, l = this._tDur, O && (this._lock = 2, o = T ? c : -1e-4, this.render(o, !0), this.vars.repeatRefresh && !I && this.invalidate()), this._lock = 0, !this._ts && !b)
            return this;
          u0(this, I);
        }
      }
      if (this._hasPause && !this._forcing && this._lock < 2 && (y = _L(this, kt(o), kt(f)), y && (u -= f - (f = y._start))), this._tTime = u, this._time = f, this._act = !v, this._initted || (this._onUpdate = this.vars.onUpdate, this._initted = 1, this._zTime = i, o = 0), !o && f && !a && !g && (kn(this, "onStart"), this._tTime !== u))
        return this;
      if (f >= o && i >= 0)
        for (p = this._first; p; ) {
          if (h = p._next, (p._act || f >= p._start) && p._ts && y !== p) {
            if (p.parent !== this)
              return this.render(i, a, s);
            if (p.render(p._ts > 0 ? (f - p._start) * p._ts : (p._dirty ? p.totalDuration() : p._tDur) + (f - p._start) * p._ts, a, s), f !== this._time || !this._ts && !b) {
              y = 0, h && (u += this._zTime = -1e-8);
              break;
            }
          }
          p = h;
        }
      else {
        p = this._last;
        for (var k = i < 0 ? i : f; p; ) {
          if (h = p._prev, (p._act || k <= p._end) && p._ts && y !== p) {
            if (p.parent !== this)
              return this.render(i, a, s);
            if (p.render(p._ts > 0 ? (k - p._start) * p._ts : (p._dirty ? p.totalDuration() : p._tDur) + (k - p._start) * p._ts, a, s || Gt && (p._initted || p._startAt)), f !== this._time || !this._ts && !b) {
              y = 0, h && (u += this._zTime = k ? -1e-8 : Jt);
              break;
            }
          }
          p = h;
        }
      }
      if (y && !a && (this.pause(), y.render(f >= o ? 0 : -1e-8)._zTime = f >= o ? 1 : -1, this._ts))
        return this._start = E, cc(this), this.render(i, a, s);
      this._onUpdate && !a && kn(this, "onUpdate", !0), (u === l && this._tTime >= this.totalDuration() || !u && o) && (E === this._start || Math.abs(v) !== Math.abs(this._ts)) && (this._lock || ((i || !c) && (u === l && this._ts > 0 || !u && this._ts < 0) && ai(this, 1), !a && !(i < 0 && !o) && (u || o || !l) && (kn(this, u === l && i >= 0 ? "onComplete" : "onReverseComplete", !0), this._prom && !(u < l && this.timeScale() > 0) && this._prom())));
    }
    return this;
  }, n.add = function(i, a) {
    var s = this;
    if (zr(a) || (a = zn(this, a, i)), !(i instanceof Fs)) {
      if (qt(i))
        return i.forEach(function(o) {
          return s.add(o, a);
        }), this;
      if (Lt(i))
        return this.addLabel(i, a);
      if (ht(i))
        i = At.delayedCall(0, i);
      else
        return this;
    }
    return this !== i ? pr(this, i, a) : this;
  }, n.getChildren = function(i, a, s, o) {
    i === void 0 && (i = !0), a === void 0 && (a = !0), s === void 0 && (s = !0), o === void 0 && (o = -1e8);
    for (var l = [], c = this._first; c; )
      c._start >= o && (c instanceof At ? a && l.push(c) : (s && l.push(c), i && l.push.apply(l, c.getChildren(!0, a, s)))), c = c._next;
    return l;
  }, n.getById = function(i) {
    for (var a = this.getChildren(1, 1, 1), s = a.length; s--; )
      if (a[s].vars.id === i)
        return a[s];
  }, n.remove = function(i) {
    return Lt(i) ? this.removeLabel(i) : ht(i) ? this.killTweensOf(i) : (i.parent === this && lc(this, i), i === this._recent && (this._recent = this._last), Ei(this));
  }, n.totalTime = function(i, a) {
    return arguments.length ? (this._forcing = 1, !this._dp && this._ts && (this._start = kt(An.time - (this._ts > 0 ? i / this._ts : (this.totalDuration() - i) / -this._ts))), e.prototype.totalTime.call(this, i, a), this._forcing = 0, this) : this._tTime;
  }, n.addLabel = function(i, a) {
    return this.labels[i] = zn(this, a), this;
  }, n.removeLabel = function(i) {
    return delete this.labels[i], this;
  }, n.addPause = function(i, a, s) {
    var o = At.delayedCall(0, a || Ps, s);
    return o.data = "isPause", this._hasPause = 1, pr(this, o, zn(this, i));
  }, n.removePause = function(i) {
    var a = this._first;
    for (i = zn(this, i); a; )
      a._start === i && a.data === "isPause" && ai(a), a = a._next;
  }, n.killTweensOf = function(i, a, s) {
    for (var o = this.getTweensOf(i, s), l = o.length; l--; )
      qr !== o[l] && o[l].kill(i, a);
    return this;
  }, n.getTweensOf = function(i, a) {
    for (var s = [], o = Un(i), l = this._first, c = zr(a), u; l; )
      l instanceof At ? fL(l._targets, o) && (c ? (!qr || l._initted && l._ts) && l.globalTime(0) <= a && l.globalTime(l.totalDuration()) > a : !a || l.isActive()) && s.push(l) : (u = l.getTweensOf(o, a)).length && s.push.apply(s, u), l = l._next;
    return s;
  }, n.tweenTo = function(i, a) {
    a = a || {};
    var s = this, o = zn(s, i), l = a, c = l.startAt, u = l.onStart, d = l.onStartParams, f = l.immediateRender, p, h = At.to(s, Dn({
      ease: a.ease || "none",
      lazy: !1,
      immediateRender: !1,
      time: o,
      overwrite: "auto",
      duration: a.duration || Math.abs((o - (c && "time" in c ? c.time : s._time)) / s.timeScale()) || Jt,
      onStart: function() {
        if (s.pause(), !p) {
          var m = a.duration || Math.abs((o - (c && "time" in c ? c.time : s._time)) / s.timeScale());
          h._dur !== m && Ia(h, m, 0, 1).render(h._time, !0, !0), p = 1;
        }
        u && u.apply(h, d || []);
      }
    }, a));
    return f ? h.render(0) : h;
  }, n.tweenFromTo = function(i, a, s) {
    return this.tweenTo(a, Dn({
      startAt: {
        time: zn(this, i)
      }
    }, s));
  }, n.recent = function() {
    return this._recent;
  }, n.nextLabel = function(i) {
    return i === void 0 && (i = this._time), wg(this, zn(this, i));
  }, n.previousLabel = function(i) {
    return i === void 0 && (i = this._time), wg(this, zn(this, i), 1);
  }, n.currentLabel = function(i) {
    return arguments.length ? this.seek(i, !0) : this.previousLabel(this._time + Jt);
  }, n.shiftChildren = function(i, a, s) {
    s === void 0 && (s = 0);
    for (var o = this._first, l = this.labels, c; o; )
      o._start >= s && (o._start += i, o._end += i), o = o._next;
    if (a)
      for (c in l)
        l[c] >= s && (l[c] += i);
    return Ei(this);
  }, n.invalidate = function(i) {
    var a = this._first;
    for (this._lock = 0; a; )
      a.invalidate(i), a = a._next;
    return e.prototype.invalidate.call(this, i);
  }, n.clear = function(i) {
    i === void 0 && (i = !0);
    for (var a = this._first, s; a; )
      s = a._next, this.remove(a), a = s;
    return this._dp && (this._time = this._tTime = this._pTime = 0), i && (this.labels = {}), Ei(this);
  }, n.totalDuration = function(i) {
    var a = 0, s = this, o = s._last, l = _r, c, u, d;
    if (arguments.length)
      return s.timeScale((s._repeat < 0 ? s.duration() : s.totalDuration()) / (s.reversed() ? -i : i));
    if (s._dirty) {
      for (d = s.parent; o; )
        c = o._prev, o._dirty && o.totalDuration(), u = o._start, u > l && s._sort && o._ts && !s._lock ? (s._lock = 1, pr(s, o, u - o._delay, 1)._lock = 0) : l = u, u < 0 && o._ts && (a -= u, (!d && !s._dp || d && d.smoothChildTiming) && (s._start += u / s._ts, s._time -= u, s._tTime -= u), s.shiftChildren(-u, !1, -1 / 0), l = 0), o._end > a && o._ts && (a = o._end), o = c;
      Ia(s, s === ct && s._time > a ? s._time : a, 1, 1), s._dirty = 0;
    }
    return s._tDur;
  }, t.updateRoot = function(i) {
    if (ct._ts && (H_(ct, kl(i, ct)), j_ = An.frame), An.frame >= _g) {
      _g += On.autoSleep || 120;
      var a = ct._first;
      if ((!a || !a._ts) && On.autoSleep && An._listeners.length < 2) {
        for (; a && !a._ts; )
          a = a._next;
        a || An.sleep();
      }
    }
  }, t;
}(Fs);
Dn(ln.prototype, {
  _lock: 0,
  _hasPause: 0,
  _forcing: 0
});
var DL = function(t, n, r, i, a, s, o) {
  var l = new yn(this._pt, t, n, 0, 1, y0, null, a), c = 0, u = 0, d, f, p, h, g, m, b, y;
  for (l.b = r, l.e = i, r += "", i += "", (b = ~i.indexOf("random(")) && (i = Ds(i)), s && (y = [r, i], s(y, t, n), r = y[0], i = y[1]), f = r.match(uu) || []; d = uu.exec(i); )
    h = d[0], g = i.substring(c, d.index), p ? p = (p + 1) % 5 : g.substr(-5) === "rgba(" && (p = 1), h !== f[u++] && (m = parseFloat(f[u - 1]) || 0, l._pt = {
      _next: l._pt,
      p: g || u === 1 ? g : ",",
      //note: SVG spec allows omission of comma/space when a negative sign is wedged between two numbers, like 2.5-5.3 instead of 2.5,-5.3 but when tweening, the negative value may switch to positive, so we insert the comma just in case.
      s: m,
      c: h.charAt(1) === "=" ? ca(m, h) - m : parseFloat(h) - m,
      m: p && p < 4 ? Math.round : 0
    }, c = uu.lastIndex);
  return l.c = c < i.length ? i.substring(c, i.length) : "", l.fp = o, (F_.test(i) || b) && (l.e = 0), this._pt = l, l;
}, Bf = function(t, n, r, i, a, s, o, l, c, u) {
  ht(i) && (i = i(a || 0, t, s));
  var d = t[n], f = r !== "get" ? r : ht(d) ? c ? t[n.indexOf("set") || !ht(t["get" + n.substr(3)]) ? n : "get" + n.substr(3)](c) : t[n]() : d, p = ht(d) ? c ? VL : m0 : Vf, h;
  if (Lt(i) && (~i.indexOf("random(") && (i = Ds(i)), i.charAt(1) === "=" && (h = ca(f, i) + (Zt(f) || 0), (h || h === 0) && (i = h))), !u || f !== i || dd)
    return !isNaN(f * i) && i !== "" ? (h = new yn(this._pt, t, n, +f || 0, i - (f || 0), typeof d == "boolean" ? jL : b0, 0, p), c && (h.fp = c), o && h.modifier(o, this, t), this._pt = h) : (!d && !(n in t) && Pf(n, i), DL.call(this, t, n, f, i, p, l || On.stringFilter, c));
}, LL = function(t, n, r, i, a) {
  if (ht(t) && (t = fs(t, a, n, r, i)), !wr(t) || t.style && t.nodeType || qt(t) || D_(t))
    return Lt(t) ? fs(t, a, n, r, i) : t;
  var s = {}, o;
  for (o in t)
    s[o] = fs(t[o], a, n, r, i);
  return s;
}, p0 = function(t, n, r, i, a, s) {
  var o, l, c, u;
  if (Sn[t] && (o = new Sn[t]()).init(a, o.rawVars ? n[t] : LL(n[t], i, a, s, r), r, i, s) !== !1 && (r._pt = l = new yn(r._pt, a, t, 0, 1, o.render, o, 0, o.priority), r !== na))
    for (c = r._ptLookup[r._targets.indexOf(a)], u = o._props.length; u--; )
      c[o._props[u]] = l;
  return o;
}, qr, dd, zf = function e(t, n, r) {
  var i = t.vars, a = i.ease, s = i.startAt, o = i.immediateRender, l = i.lazy, c = i.onUpdate, u = i.runBackwards, d = i.yoyoEase, f = i.keyframes, p = i.autoRevert, h = t._dur, g = t._startAt, m = t._targets, b = t.parent, y = b && b.data === "nested" ? b.vars.targets : m, v = t._overwrite === "auto" && !Rf, E = t.timeline, _, x, I, T, O, k, W, M, L, z, U, $, Q;
  if (E && (!f || !a) && (a = "none"), t._ease = wi(a, Ea.ease), t._yEase = d ? c0(wi(d === !0 ? a : d, Ea.ease)) : 0, d && t._yoyo && !t._repeat && (d = t._yEase, t._yEase = t._ease, t._ease = d), t._from = !E && !!i.runBackwards, !E || f && !i.stagger) {
    if (M = m[0] ? xi(m[0]).harness : 0, $ = M && i[M.prop], _ = Al(i, Df), g && (g._zTime < 0 && g.progress(1), n < 0 && u && o && !p ? g.render(-1, !0) : g.revert(u && h ? zo : uL), g._lazy = 0), s) {
      if (ai(t._startAt = At.set(m, Dn({
        data: "isStart",
        overwrite: !1,
        parent: b,
        immediateRender: !0,
        lazy: !g && mn(l),
        startAt: null,
        delay: 0,
        onUpdate: c && function() {
          return kn(t, "onUpdate");
        },
        stagger: 0
      }, s))), t._startAt._dp = 0, t._startAt._sat = t, n < 0 && (Gt || !o && !p) && t._startAt.revert(zo), o && h && n <= 0 && r <= 0) {
        n && (t._zTime = n);
        return;
      }
    } else if (u && h && !g) {
      if (n && (o = !1), I = Dn({
        overwrite: !1,
        data: "isFromStart",
        //we tag the tween with as "isFromStart" so that if [inside a plugin] we need to only do something at the very END of a tween, we have a way of identifying this tween as merely the one that's setting the beginning values for a "from()" tween. For example, clearProps in CSSPlugin should only get applied at the very END of a tween and without this tag, from(...{height:100, clearProps:"height", delay:1}) would wipe the height at the beginning of the tween and after 1 second, it'd kick back in.
        lazy: o && !g && mn(l),
        immediateRender: o,
        //zero-duration tweens render immediately by default, but if we're not specifically instructed to render this tween immediately, we should skip this and merely _init() to record the starting values (rendering them immediately would push them to completion which is wasteful in that case - we'd have to render(-1) immediately after)
        stagger: 0,
        parent: b
        //ensures that nested tweens that had a stagger are handled properly, like gsap.from(".class", {y: gsap.utils.wrap([-100,100]), stagger: 0.5})
      }, _), $ && (I[M.prop] = $), ai(t._startAt = At.set(m, I)), t._startAt._dp = 0, t._startAt._sat = t, n < 0 && (Gt ? t._startAt.revert(zo) : t._startAt.render(-1, !0)), t._zTime = n, !o)
        e(t._startAt, Jt, Jt);
      else if (!n)
        return;
    }
    for (t._pt = t._ptCache = 0, l = h && mn(l) || l && !h, x = 0; x < m.length; x++) {
      if (O = m[x], W = O._gsap || Ff(m)[x]._gsap, t._ptLookup[x] = z = {}, ad[W.id] && ei.length && Sl(), U = y === m ? x : y.indexOf(O), M && (L = new M()).init(O, $ || _, t, U, y) !== !1 && (t._pt = T = new yn(t._pt, O, L.name, 0, 1, L.render, L, 0, L.priority), L._props.forEach(function(K) {
        z[K] = T;
      }), L.priority && (k = 1)), !M || $)
        for (I in _)
          Sn[I] && (L = p0(I, _, t, U, O, y)) ? L.priority && (k = 1) : z[I] = T = Bf.call(t, O, I, "get", _[I], U, y, 0, i.stringFilter);
      t._op && t._op[x] && t.kill(O, t._op[x]), v && t._pt && (qr = t, ct.killTweensOf(O, z, t.globalTime(n)), Q = !t.parent, qr = 0), t._pt && l && (ad[W.id] = 1);
    }
    k && _0(t), t._onInit && t._onInit(t);
  }
  t._onUpdate = c, t._initted = (!t._op || t._pt) && !Q, f && n <= 0 && E.render(_r, !0, !0);
}, FL = function(t, n, r, i, a, s, o, l) {
  var c = (t._pt && t._ptCache || (t._ptCache = {}))[n], u, d, f, p;
  if (!c)
    for (c = t._ptCache[n] = [], f = t._ptLookup, p = t._targets.length; p--; ) {
      if (u = f[p][n], u && u.d && u.d._pt)
        for (u = u.d._pt; u && u.p !== n && u.fp !== n; )
          u = u._next;
      if (!u)
        return dd = 1, t.vars[n] = "+=0", zf(t, o), dd = 0, l ? Ms(n + " not eligible for reset") : 1;
      c.push(u);
    }
  for (p = c.length; p--; )
    d = c[p], u = d._pt || d, u.s = (i || i === 0) && !a ? i : u.s + (i || 0) + s * u.c, u.c = r - u.s, d.e && (d.e = xt(r) + Zt(d.e)), d.b && (d.b = u.s + Zt(d.b));
}, BL = function(t, n) {
  var r = t[0] ? xi(t[0]).harness : 0, i = r && r.aliases, a, s, o, l;
  if (!i)
    return n;
  a = wa({}, n);
  for (s in i)
    if (s in a)
      for (l = i[s].split(","), o = l.length; o--; )
        a[l[o]] = a[s];
  return a;
}, zL = function(t, n, r, i) {
  var a = n.ease || i || "power1.inOut", s, o;
  if (qt(n))
    o = r[t] || (r[t] = []), n.forEach(function(l, c) {
      return o.push({
        t: c / (n.length - 1) * 100,
        v: l,
        e: a
      });
    });
  else
    for (s in n)
      o = r[s] || (r[s] = []), s === "ease" || o.push({
        t: parseFloat(t),
        v: n[s],
        e: a
      });
}, fs = function(t, n, r, i, a) {
  return ht(t) ? t.call(n, r, i, a) : Lt(t) && ~t.indexOf("random(") ? Ds(t) : t;
}, h0 = Lf + "repeat,repeatDelay,yoyo,repeatRefresh,yoyoEase,autoRevert", g0 = {};
bn(h0 + ",id,stagger,delay,duration,paused,scrollTrigger", function(e) {
  return g0[e] = 1;
});
var At = /* @__PURE__ */ function(e) {
  M_(t, e);
  function t(r, i, a, s) {
    var o;
    typeof i == "number" && (a.duration = i, i = a, a = null), o = e.call(this, s ? i : us(i)) || this;
    var l = o.vars, c = l.duration, u = l.delay, d = l.immediateRender, f = l.stagger, p = l.overwrite, h = l.keyframes, g = l.defaults, m = l.scrollTrigger, b = l.yoyoEase, y = i.parent || ct, v = (qt(r) || D_(r) ? zr(r[0]) : "length" in i) ? [r] : Un(r), E, _, x, I, T, O, k, W;
    if (o._targets = v.length ? Ff(v) : Ms("GSAP target " + r + " not found. https://gsap.com", !On.nullTargetWarn) || [], o._ptLookup = [], o._overwrite = p, h || f || Ao(c) || Ao(u)) {
      if (i = o.vars, E = o.timeline = new ln({
        data: "nested",
        defaults: g || {},
        targets: y && y.data === "nested" ? y.vars.targets : v
      }), E.kill(), E.parent = E._dp = kr(o), E._start = 0, f || Ao(c) || Ao(u)) {
        if (I = v.length, k = f && Q_(f), wr(f))
          for (T in f)
            ~h0.indexOf(T) && (W || (W = {}), W[T] = f[T]);
        for (_ = 0; _ < I; _++)
          x = Al(i, g0), x.stagger = 0, b && (x.yoyoEase = b), W && wa(x, W), O = v[_], x.duration = +fs(c, kr(o), _, O, v), x.delay = (+fs(u, kr(o), _, O, v) || 0) - o._delay, !f && I === 1 && x.delay && (o._delay = u = x.delay, o._start += u, x.delay = 0), E.to(O, x, k ? k(_, O, v) : 0), E._ease = Ve.none;
        E.duration() ? c = u = 0 : o.timeline = 0;
      } else if (h) {
        us(Dn(E.vars.defaults, {
          ease: "none"
        })), E._ease = wi(h.ease || i.ease || "none");
        var M = 0, L, z, U;
        if (qt(h))
          h.forEach(function($) {
            return E.to(v, $, ">");
          }), E.duration();
        else {
          x = {};
          for (T in h)
            T === "ease" || T === "easeEach" || zL(T, h[T], x, h.easeEach);
          for (T in x)
            for (L = x[T].sort(function($, Q) {
              return $.t - Q.t;
            }), M = 0, _ = 0; _ < L.length; _++)
              z = L[_], U = {
                ease: z.e,
                duration: (z.t - (_ ? L[_ - 1].t : 0)) / 100 * c
              }, U[T] = z.v, E.to(v, U, M), M += U.duration;
          E.duration() < c && E.to({}, {
            duration: c - E.duration()
          });
        }
      }
      c || o.duration(c = E.duration());
    } else
      o.timeline = 0;
    return p === !0 && !Rf && (qr = kr(o), ct.killTweensOf(v), qr = 0), pr(y, kr(o), a), i.reversed && o.reverse(), i.paused && o.paused(!0), (d || !c && !h && o._start === kt(y._time) && mn(d) && mL(kr(o)) && y.data !== "nested") && (o._tTime = -1e-8, o.render(Math.max(0, -u) || 0)), m && Y_(kr(o), m), o;
  }
  var n = t.prototype;
  return n.render = function(i, a, s) {
    var o = this._time, l = this._tDur, c = this._dur, u = i < 0, d = i > l - Jt && !u ? l : i < Jt ? 0 : i, f, p, h, g, m, b, y, v, E;
    if (!c)
      yL(this, i, a, s);
    else if (d !== this._tTime || !i || s || !this._initted && this._tTime || this._startAt && this._zTime < 0 !== u || this._lazy) {
      if (f = d, v = this.timeline, this._repeat) {
        if (g = c + this._rDelay, this._repeat < -1 && u)
          return this.totalTime(g * 100 + i, a, s);
        if (f = kt(d % g), d === l ? (h = this._repeat, f = c) : (m = kt(d / g), h = ~~m, h && h === m ? (f = c, h--) : f > c && (f = c)), b = this._yoyo && h & 1, b && (E = this._yEase, f = c - f), m = Ca(this._tTime, g), f === o && !s && this._initted && h === m)
          return this._tTime = d, this;
        h !== m && (v && this._yEase && u0(v, b), this.vars.repeatRefresh && !b && !this._lock && f !== g && this._initted && (this._lock = s = 1, this.render(kt(g * h), !0).invalidate()._lock = 0));
      }
      if (!this._initted) {
        if (J_(this, u ? i : f, s, a, d))
          return this._tTime = 0, this;
        if (o !== this._time && !(s && this.vars.repeatRefresh && h !== m))
          return this;
        if (c !== this._dur)
          return this.render(i, a, s);
      }
      if (this._tTime = d, this._time = f, !this._act && this._ts && (this._act = 1, this._lazy = 0), this.ratio = y = (E || this._ease)(f / c), this._from && (this.ratio = y = 1 - y), f && !o && !a && !h && (kn(this, "onStart"), this._tTime !== d))
        return this;
      for (p = this._pt; p; )
        p.r(y, p.d), p = p._next;
      v && v.render(i < 0 ? i : v._dur * v._ease(f / this._dur), a, s) || this._startAt && (this._zTime = i), this._onUpdate && !a && (u && sd(this, i, a, s), kn(this, "onUpdate")), this._repeat && h !== m && this.vars.onRepeat && !a && this.parent && kn(this, "onRepeat"), (d === this._tDur || !d) && this._tTime === d && (u && !this._onUpdate && sd(this, i, !0, !0), (i || !c) && (d === this._tDur && this._ts > 0 || !d && this._ts < 0) && ai(this, 1), !a && !(u && !o) && (d || o || b) && (kn(this, d === l ? "onComplete" : "onReverseComplete", !0), this._prom && !(d < l && this.timeScale() > 0) && this._prom()));
    }
    return this;
  }, n.targets = function() {
    return this._targets;
  }, n.invalidate = function(i) {
    return (!i || !this.vars.runBackwards) && (this._startAt = 0), this._pt = this._op = this._onUpdate = this._lazy = this.ratio = 0, this._ptLookup = [], this.timeline && this.timeline.invalidate(i), e.prototype.invalidate.call(this, i);
  }, n.resetTo = function(i, a, s, o, l) {
    Ls || An.wake(), this._ts || this.play();
    var c = Math.min(this._dur, (this._dp._time - this._start) * this._ts), u;
    return this._initted || zf(this, c), u = this._ease(c / this._dur), FL(this, i, a, s, o, u, c, l) ? this.resetTo(i, a, s, o, 1) : (uc(this, 0), this.parent || $_(this._dp, this, "_first", "_last", this._dp._sort ? "_start" : 0), this.render(0));
  }, n.kill = function(i, a) {
    if (a === void 0 && (a = "all"), !i && (!a || a === "all"))
      return this._lazy = this._pt = 0, this.parent ? rs(this) : this.scrollTrigger && this.scrollTrigger.kill(!!Gt), this;
    if (this.timeline) {
      var s = this.timeline.totalDuration();
      return this.timeline.killTweensOf(i, a, qr && qr.vars.overwrite !== !0)._first || rs(this), this.parent && s !== this.timeline.totalDuration() && Ia(this, this._dur * this.timeline._tDur / s, 0, 1), this;
    }
    var o = this._targets, l = i ? Un(i) : o, c = this._ptLookup, u = this._pt, d, f, p, h, g, m, b;
    if ((!a || a === "all") && hL(o, l))
      return a === "all" && (this._pt = 0), rs(this);
    for (d = this._op = this._op || [], a !== "all" && (Lt(a) && (g = {}, bn(a, function(y) {
      return g[y] = 1;
    }), a = g), a = BL(o, a)), b = o.length; b--; )
      if (~l.indexOf(o[b])) {
        f = c[b], a === "all" ? (d[b] = a, h = f, p = {}) : (p = d[b] = d[b] || {}, h = a);
        for (g in h)
          m = f && f[g], m && ((!("kill" in m.d) || m.d.kill(g) === !0) && lc(this, m, "_pt"), delete f[g]), p !== "all" && (p[g] = 1);
      }
    return this._initted && !this._pt && u && rs(this), this;
  }, t.to = function(i, a) {
    return new t(i, a, arguments[2]);
  }, t.from = function(i, a) {
    return ds(1, arguments);
  }, t.delayedCall = function(i, a, s, o) {
    return new t(a, 0, {
      immediateRender: !1,
      lazy: !1,
      overwrite: !1,
      delay: i,
      onComplete: a,
      onReverseComplete: a,
      onCompleteParams: s,
      onReverseCompleteParams: s,
      callbackScope: o
    });
  }, t.fromTo = function(i, a, s) {
    return ds(2, arguments);
  }, t.set = function(i, a) {
    return a.duration = 0, a.repeatDelay || (a.repeat = 0), new t(i, a);
  }, t.killTweensOf = function(i, a, s) {
    return ct.killTweensOf(i, a, s);
  }, t;
}(Fs);
Dn(At.prototype, {
  _targets: [],
  _lazy: 0,
  _startAt: 0,
  _op: 0,
  _onInit: 0
});
bn("staggerTo,staggerFrom,staggerFromTo", function(e) {
  At[e] = function() {
    var t = new ln(), n = ld.call(arguments, 0);
    return n.splice(e === "staggerFromTo" ? 5 : 4, 0, 0), t[e].apply(t, n);
  };
});
var Vf = function(t, n, r) {
  return t[n] = r;
}, m0 = function(t, n, r) {
  return t[n](r);
}, VL = function(t, n, r, i) {
  return t[n](i.fp, r);
}, GL = function(t, n, r) {
  return t.setAttribute(n, r);
}, Gf = function(t, n) {
  return ht(t[n]) ? m0 : Nf(t[n]) && t.setAttribute ? GL : Vf;
}, b0 = function(t, n) {
  return n.set(n.t, n.p, Math.round((n.s + n.c * t) * 1e6) / 1e6, n);
}, jL = function(t, n) {
  return n.set(n.t, n.p, !!(n.s + n.c * t), n);
}, y0 = function(t, n) {
  var r = n._pt, i = "";
  if (!t && n.b)
    i = n.b;
  else if (t === 1 && n.e)
    i = n.e;
  else {
    for (; r; )
      i = r.p + (r.m ? r.m(r.s + r.c * t) : Math.round((r.s + r.c * t) * 1e4) / 1e4) + i, r = r._next;
    i += n.c;
  }
  n.set(n.t, n.p, i, n);
}, jf = function(t, n) {
  for (var r = n._pt; r; )
    r.r(t, r.d), r = r._next;
}, UL = function(t, n, r, i) {
  for (var a = this._pt, s; a; )
    s = a._next, a.p === i && a.modifier(t, n, r), a = s;
}, HL = function(t) {
  for (var n = this._pt, r, i; n; )
    i = n._next, n.p === t && !n.op || n.op === t ? lc(this, n, "_pt") : n.dep || (r = 1), n = i;
  return !r;
}, WL = function(t, n, r, i) {
  i.mSet(t, n, i.m.call(i.tween, r, i.mt), i);
}, _0 = function(t) {
  for (var n = t._pt, r, i, a, s; n; ) {
    for (r = n._next, i = a; i && i.pr > n.pr; )
      i = i._next;
    (n._prev = i ? i._prev : s) ? n._prev._next = n : a = n, (n._next = i) ? i._prev = n : s = n, n = r;
  }
  t._pt = a;
}, yn = /* @__PURE__ */ function() {
  function e(n, r, i, a, s, o, l, c, u) {
    this.t = r, this.s = a, this.c = s, this.p = i, this.r = o || b0, this.d = l || this, this.set = c || Vf, this.pr = u || 0, this._next = n, n && (n._prev = this);
  }
  var t = e.prototype;
  return t.modifier = function(r, i, a) {
    this.mSet = this.mSet || this.set, this.set = WL, this.m = r, this.mt = a, this.tween = i;
  }, e;
}();
bn(Lf + "parent,duration,ease,delay,overwrite,runBackwards,startAt,yoyo,immediateRender,repeat,repeatDelay,data,paused,reversed,lazy,callbackScope,stringFilter,id,yoyoEase,stagger,inherit,repeatRefresh,keyframes,autoRevert,scrollTrigger", function(e) {
  return Df[e] = 1;
});
Pn.TweenMax = Pn.TweenLite = At;
Pn.TimelineLite = Pn.TimelineMax = ln;
ct = new ln({
  sortChildren: !1,
  defaults: Ea,
  autoRemoveChildren: !0,
  id: "root",
  smoothChildTiming: !0
});
On.stringFilter = l0;
var Ci = [], Go = {}, ZL = [], Ig = 0, $L = 0, gu = function(t) {
  return (Go[t] || ZL).map(function(n) {
    return n();
  });
}, fd = function() {
  var t = Date.now(), n = [];
  t - Ig > 2 && (gu("matchMediaInit"), Ci.forEach(function(r) {
    var i = r.queries, a = r.conditions, s, o, l, c;
    for (o in i)
      s = cr.matchMedia(i[o]).matches, s && (l = 1), s !== a[o] && (a[o] = s, c = 1);
    c && (r.revert(), l && n.push(r));
  }), gu("matchMediaRevert"), n.forEach(function(r) {
    return r.onMatch(r, function(i) {
      return r.add(null, i);
    });
  }), Ig = t, gu("matchMedia"));
}, v0 = /* @__PURE__ */ function() {
  function e(n, r) {
    this.selector = r && cd(r), this.data = [], this._r = [], this.isReverted = !1, this.id = $L++, n && this.add(n);
  }
  var t = e.prototype;
  return t.add = function(r, i, a) {
    ht(r) && (a = i, i = r, r = ht);
    var s = this, o = function() {
      var c = st, u = s.selector, d;
      return c && c !== s && c.data.push(s), a && (s.selector = cd(a)), st = s, d = i.apply(s, arguments), ht(d) && s._r.push(d), st = c, s.selector = u, s.isReverted = !1, d;
    };
    return s.last = o, r === ht ? o(s, function(l) {
      return s.add(null, l);
    }) : r ? s[r] = o : o;
  }, t.ignore = function(r) {
    var i = st;
    st = null, r(this), st = i;
  }, t.getTweens = function() {
    var r = [];
    return this.data.forEach(function(i) {
      return i instanceof e ? r.push.apply(r, i.getTweens()) : i instanceof At && !(i.parent && i.parent.data === "nested") && r.push(i);
    }), r;
  }, t.clear = function() {
    this._r.length = this.data.length = 0;
  }, t.kill = function(r, i) {
    var a = this;
    if (r ? function() {
      for (var o = a.getTweens(), l = a.data.length, c; l--; )
        c = a.data[l], c.data === "isFlip" && (c.revert(), c.getChildren(!0, !0, !1).forEach(function(u) {
          return o.splice(o.indexOf(u), 1);
        }));
      for (o.map(function(u) {
        return {
          g: u._dur || u._delay || u._sat && !u._sat.vars.immediateRender ? u.globalTime(0) : -1 / 0,
          t: u
        };
      }).sort(function(u, d) {
        return d.g - u.g || -1 / 0;
      }).forEach(function(u) {
        return u.t.revert(r);
      }), l = a.data.length; l--; )
        c = a.data[l], c instanceof ln ? c.data !== "nested" && (c.scrollTrigger && c.scrollTrigger.revert(), c.kill()) : !(c instanceof At) && c.revert && c.revert(r);
      a._r.forEach(function(u) {
        return u(r, a);
      }), a.isReverted = !0;
    }() : this.data.forEach(function(o) {
      return o.kill && o.kill();
    }), this.clear(), i)
      for (var s = Ci.length; s--; )
        Ci[s].id === this.id && Ci.splice(s, 1);
  }, t.revert = function(r) {
    this.kill(r || {});
  }, e;
}(), XL = /* @__PURE__ */ function() {
  function e(n) {
    this.contexts = [], this.scope = n, st && st.data.push(this);
  }
  var t = e.prototype;
  return t.add = function(r, i, a) {
    wr(r) || (r = {
      matches: r
    });
    var s = new v0(0, a || this.scope), o = s.conditions = {}, l, c, u;
    st && !s.selector && (s.selector = st.selector), this.contexts.push(s), i = s.add("onMatch", i), s.queries = r;
    for (c in r)
      c === "all" ? u = 1 : (l = cr.matchMedia(r[c]), l && (Ci.indexOf(s) < 0 && Ci.push(s), (o[c] = l.matches) && (u = 1), l.addListener ? l.addListener(fd) : l.addEventListener("change", fd)));
    return u && i(s, function(d) {
      return s.add(null, d);
    }), this;
  }, t.revert = function(r) {
    this.kill(r || {});
  }, t.kill = function(r) {
    this.contexts.forEach(function(i) {
      return i.kill(r, !0);
    });
  }, e;
}(), Tl = {
  registerPlugin: function() {
    for (var t = arguments.length, n = new Array(t), r = 0; r < t; r++)
      n[r] = arguments[r];
    n.forEach(function(i) {
      return a0(i);
    });
  },
  timeline: function(t) {
    return new ln(t);
  },
  getTweensOf: function(t, n) {
    return ct.getTweensOf(t, n);
  },
  getProperty: function(t, n, r, i) {
    Lt(t) && (t = Un(t)[0]);
    var a = xi(t || {}).get, s = r ? Z_ : W_;
    return r === "native" && (r = ""), t && (n ? s((Sn[n] && Sn[n].get || a)(t, n, r, i)) : function(o, l, c) {
      return s((Sn[o] && Sn[o].get || a)(t, o, l, c));
    });
  },
  quickSetter: function(t, n, r) {
    if (t = Un(t), t.length > 1) {
      var i = t.map(function(u) {
        return En.quickSetter(u, n, r);
      }), a = i.length;
      return function(u) {
        for (var d = a; d--; )
          i[d](u);
      };
    }
    t = t[0] || {};
    var s = Sn[n], o = xi(t), l = o.harness && (o.harness.aliases || {})[n] || n, c = s ? function(u) {
      var d = new s();
      na._pt = 0, d.init(t, r ? u + r : u, na, 0, [t]), d.render(1, d), na._pt && jf(1, na);
    } : o.set(t, l);
    return s ? c : function(u) {
      return c(t, l, r ? u + r : u, o, 1);
    };
  },
  quickTo: function(t, n, r) {
    var i, a = En.to(t, Dn((i = {}, i[n] = "+=0.1", i.paused = !0, i.stagger = 0, i), r || {})), s = function(l, c, u) {
      return a.resetTo(n, l, c, u);
    };
    return s.tween = a, s;
  },
  isTweening: function(t) {
    return ct.getTweensOf(t, !0).length > 0;
  },
  defaults: function(t) {
    return t && t.ease && (t.ease = wi(t.ease, Ea.ease)), vg(Ea, t || {});
  },
  config: function(t) {
    return vg(On, t || {});
  },
  registerEffect: function(t) {
    var n = t.name, r = t.effect, i = t.plugins, a = t.defaults, s = t.extendTimeline;
    (i || "").split(",").forEach(function(o) {
      return o && !Sn[o] && !Pn[o] && Ms(n + " effect requires " + o + " plugin.");
    }), du[n] = function(o, l, c) {
      return r(Un(o), Dn(l || {}, a), c);
    }, s && (ln.prototype[n] = function(o, l, c) {
      return this.add(du[n](o, wr(l) ? l : (c = l) && {}, this), c);
    });
  },
  registerEase: function(t, n) {
    Ve[t] = wi(n);
  },
  parseEase: function(t, n) {
    return arguments.length ? wi(t, n) : Ve;
  },
  getById: function(t) {
    return ct.getById(t);
  },
  exportRoot: function(t, n) {
    t === void 0 && (t = {});
    var r = new ln(t), i, a;
    for (r.smoothChildTiming = mn(t.smoothChildTiming), ct.remove(r), r._dp = 0, r._time = r._tTime = ct._time, i = ct._first; i; )
      a = i._next, (n || !(!i._dur && i instanceof At && i.vars.onComplete === i._targets[0])) && pr(r, i, i._start - i._delay), i = a;
    return pr(ct, r, 0), r;
  },
  context: function(t, n) {
    return t ? new v0(t, n) : st;
  },
  matchMedia: function(t) {
    return new XL(t);
  },
  matchMediaRefresh: function() {
    return Ci.forEach(function(t) {
      var n = t.conditions, r, i;
      for (i in n)
        n[i] && (n[i] = !1, r = 1);
      r && t.revert();
    }) || fd();
  },
  addEventListener: function(t, n) {
    var r = Go[t] || (Go[t] = []);
    ~r.indexOf(n) || r.push(n);
  },
  removeEventListener: function(t, n) {
    var r = Go[t], i = r && r.indexOf(n);
    i >= 0 && r.splice(i, 1);
  },
  utils: {
    wrap: SL,
    wrapYoyo: AL,
    distribute: Q_,
    random: t0,
    snap: e0,
    normalize: IL,
    getUnit: Zt,
    clamp: xL,
    splitColor: s0,
    toArray: Un,
    selector: cd,
    mapRange: r0,
    pipe: wL,
    unitize: CL,
    interpolate: kL,
    shuffle: K_
  },
  install: V_,
  effects: du,
  ticker: An,
  updateRoot: ln.updateRoot,
  plugins: Sn,
  globalTimeline: ct,
  core: {
    PropTween: yn,
    globals: G_,
    Tween: At,
    Timeline: ln,
    Animation: Fs,
    getCache: xi,
    _removeLinkedListItem: lc,
    reverting: function() {
      return Gt;
    },
    context: function(t) {
      return t && st && (st.data.push(t), t._ctx = st), st;
    },
    suppressOverwrites: function(t) {
      return Rf = t;
    }
  }
};
bn("to,from,fromTo,delayedCall,set,killTweensOf", function(e) {
  return Tl[e] = At[e];
});
An.add(ln.updateRoot);
na = Tl.to({}, {
  duration: 0
});
var YL = function(t, n) {
  for (var r = t._pt; r && r.p !== n && r.op !== n && r.fp !== n; )
    r = r._next;
  return r;
}, JL = function(t, n) {
  var r = t._targets, i, a, s;
  for (i in n)
    for (a = r.length; a--; )
      s = t._ptLookup[a][i], s && (s = s.d) && (s._pt && (s = YL(s, i)), s && s.modifier && s.modifier(n[i], t, r[a], i));
}, mu = function(t, n) {
  return {
    name: t,
    rawVars: 1,
    //don't pre-process function-based values or "random()" strings.
    init: function(i, a, s) {
      s._onInit = function(o) {
        var l, c;
        if (Lt(a) && (l = {}, bn(a, function(u) {
          return l[u] = 1;
        }), a = l), n) {
          l = {};
          for (c in a)
            l[c] = n(a[c]);
          a = l;
        }
        JL(o, a);
      };
    }
  };
}, En = Tl.registerPlugin({
  name: "attr",
  init: function(t, n, r, i, a) {
    var s, o, l;
    this.tween = r;
    for (s in n)
      l = t.getAttribute(s) || "", o = this.add(t, "setAttribute", (l || 0) + "", n[s], i, a, 0, 0, s), o.op = s, o.b = l, this._props.push(s);
  },
  render: function(t, n) {
    for (var r = n._pt; r; )
      Gt ? r.set(r.t, r.p, r.b, r) : r.r(t, r.d), r = r._next;
  }
}, {
  name: "endArray",
  init: function(t, n) {
    for (var r = n.length; r--; )
      this.add(t, r, t[r] || 0, n[r], 0, 0, 0, 0, 0, 1);
  }
}, mu("roundProps", ud), mu("modifiers"), mu("snap", e0)) || Tl;
At.version = ln.version = En.version = "3.12.7";
z_ = 1;
Of() && Sa();
Ve.Power0;
Ve.Power1;
Ve.Power2;
Ve.Power3;
Ve.Power4;
Ve.Linear;
Ve.Quad;
Ve.Cubic;
Ve.Quart;
Ve.Quint;
Ve.Strong;
Ve.Elastic;
Ve.Back;
Ve.SteppedEase;
Ve.Bounce;
Ve.Sine;
Ve.Expo;
Ve.Circ;
/*!
 * CSSPlugin 3.12.7
 * https://gsap.com
 *
 * Copyright 2008-2025, GreenSock. All rights reserved.
 * Subject to the terms at https://gsap.com/standard-license or for
 * Club GSAP members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*/
var Sg, Kr, ua, Uf, bi, Ag, Hf, qL = function() {
  return typeof window < "u";
}, Vr = {}, pi = 180 / Math.PI, da = Math.PI / 180, Xi = Math.atan2, kg = 1e8, Wf = /([A-Z])/g, KL = /(left|right|width|margin|padding|x)/i, QL = /[\s,\(]\S/, mr = {
  autoAlpha: "opacity,visibility",
  scale: "scaleX,scaleY",
  alpha: "opacity"
}, pd = function(t, n) {
  return n.set(n.t, n.p, Math.round((n.s + n.c * t) * 1e4) / 1e4 + n.u, n);
}, eF = function(t, n) {
  return n.set(n.t, n.p, t === 1 ? n.e : Math.round((n.s + n.c * t) * 1e4) / 1e4 + n.u, n);
}, tF = function(t, n) {
  return n.set(n.t, n.p, t ? Math.round((n.s + n.c * t) * 1e4) / 1e4 + n.u : n.b, n);
}, nF = function(t, n) {
  var r = n.s + n.c * t;
  n.set(n.t, n.p, ~~(r + (r < 0 ? -0.5 : 0.5)) + n.u, n);
}, x0 = function(t, n) {
  return n.set(n.t, n.p, t ? n.e : n.b, n);
}, E0 = function(t, n) {
  return n.set(n.t, n.p, t !== 1 ? n.b : n.e, n);
}, rF = function(t, n, r) {
  return t.style[n] = r;
}, iF = function(t, n, r) {
  return t.style.setProperty(n, r);
}, aF = function(t, n, r) {
  return t._gsap[n] = r;
}, sF = function(t, n, r) {
  return t._gsap.scaleX = t._gsap.scaleY = r;
}, oF = function(t, n, r, i, a) {
  var s = t._gsap;
  s.scaleX = s.scaleY = r, s.renderTransform(a, s);
}, lF = function(t, n, r, i, a) {
  var s = t._gsap;
  s[n] = r, s.renderTransform(a, s);
}, ut = "transform", _n = ut + "Origin", cF = function e(t, n) {
  var r = this, i = this.target, a = i.style, s = i._gsap;
  if (t in Vr && a) {
    if (this.tfm = this.tfm || {}, t !== "transform")
      t = mr[t] || t, ~t.indexOf(",") ? t.split(",").forEach(function(o) {
        return r.tfm[o] = Rr(i, o);
      }) : this.tfm[t] = s.x ? s[t] : Rr(i, t), t === _n && (this.tfm.zOrigin = s.zOrigin);
    else
      return mr.transform.split(",").forEach(function(o) {
        return e.call(r, o, n);
      });
    if (this.props.indexOf(ut) >= 0)
      return;
    s.svg && (this.svgo = i.getAttribute("data-svg-origin"), this.props.push(_n, n, "")), t = ut;
  }
  (a || n) && this.props.push(t, n, a[t]);
}, w0 = function(t) {
  t.translate && (t.removeProperty("translate"), t.removeProperty("scale"), t.removeProperty("rotate"));
}, uF = function() {
  var t = this.props, n = this.target, r = n.style, i = n._gsap, a, s;
  for (a = 0; a < t.length; a += 3)
    t[a + 1] ? t[a + 1] === 2 ? n[t[a]](t[a + 2]) : n[t[a]] = t[a + 2] : t[a + 2] ? r[t[a]] = t[a + 2] : r.removeProperty(t[a].substr(0, 2) === "--" ? t[a] : t[a].replace(Wf, "-$1").toLowerCase());
  if (this.tfm) {
    for (s in this.tfm)
      i[s] = this.tfm[s];
    i.svg && (i.renderTransform(), n.setAttribute("data-svg-origin", this.svgo || "")), a = Hf(), (!a || !a.isStart) && !r[ut] && (w0(r), i.zOrigin && r[_n] && (r[_n] += " " + i.zOrigin + "px", i.zOrigin = 0, i.renderTransform()), i.uncache = 1);
  }
}, C0 = function(t, n) {
  var r = {
    target: t,
    props: [],
    revert: uF,
    save: cF
  };
  return t._gsap || En.core.getCache(t), n && t.style && t.nodeType && n.split(",").forEach(function(i) {
    return r.save(i);
  }), r;
}, I0, hd = function(t, n) {
  var r = Kr.createElementNS ? Kr.createElementNS((n || "http://www.w3.org/1999/xhtml").replace(/^https/, "http"), t) : Kr.createElement(t);
  return r && r.style ? r : Kr.createElement(t);
}, vr = function e(t, n, r) {
  var i = getComputedStyle(t);
  return i[n] || i.getPropertyValue(n.replace(Wf, "-$1").toLowerCase()) || i.getPropertyValue(n) || !r && e(t, Aa(n) || n, 1) || "";
}, Tg = "O,Moz,ms,Ms,Webkit".split(","), Aa = function(t, n, r) {
  var i = n || bi, a = i.style, s = 5;
  if (t in a && !r)
    return t;
  for (t = t.charAt(0).toUpperCase() + t.substr(1); s-- && !(Tg[s] + t in a); )
    ;
  return s < 0 ? null : (s === 3 ? "ms" : s >= 0 ? Tg[s] : "") + t;
}, gd = function() {
  qL() && window.document && (Sg = window, Kr = Sg.document, ua = Kr.documentElement, bi = hd("div") || {
    style: {}
  }, hd("div"), ut = Aa(ut), _n = ut + "Origin", bi.style.cssText = "border-width:0;line-height:0;position:absolute;padding:0", I0 = !!Aa("perspective"), Hf = En.core.reverting, Uf = 1);
}, Rg = function(t) {
  var n = t.ownerSVGElement, r = hd("svg", n && n.getAttribute("xmlns") || "http://www.w3.org/2000/svg"), i = t.cloneNode(!0), a;
  i.style.display = "block", r.appendChild(i), ua.appendChild(r);
  try {
    a = i.getBBox();
  } catch {
  }
  return r.removeChild(i), ua.removeChild(r), a;
}, Ng = function(t, n) {
  for (var r = n.length; r--; )
    if (t.hasAttribute(n[r]))
      return t.getAttribute(n[r]);
}, S0 = function(t) {
  var n, r;
  try {
    n = t.getBBox();
  } catch {
    n = Rg(t), r = 1;
  }
  return n && (n.width || n.height) || r || (n = Rg(t)), n && !n.width && !n.x && !n.y ? {
    x: +Ng(t, ["x", "cx", "x1"]) || 0,
    y: +Ng(t, ["y", "cy", "y1"]) || 0,
    width: 0,
    height: 0
  } : n;
}, A0 = function(t) {
  return !!(t.getCTM && (!t.parentNode || t.ownerSVGElement) && S0(t));
}, Oi = function(t, n) {
  if (n) {
    var r = t.style, i;
    n in Vr && n !== _n && (n = ut), r.removeProperty ? (i = n.substr(0, 2), (i === "ms" || n.substr(0, 6) === "webkit") && (n = "-" + n), r.removeProperty(i === "--" ? n : n.replace(Wf, "-$1").toLowerCase())) : r.removeAttribute(n);
  }
}, Qr = function(t, n, r, i, a, s) {
  var o = new yn(t._pt, n, r, 0, 1, s ? E0 : x0);
  return t._pt = o, o.b = i, o.e = a, t._props.push(r), o;
}, Og = {
  deg: 1,
  rad: 1,
  turn: 1
}, dF = {
  grid: 1,
  flex: 1
}, si = function e(t, n, r, i) {
  var a = parseFloat(r) || 0, s = (r + "").trim().substr((a + "").length) || "px", o = bi.style, l = KL.test(n), c = t.tagName.toLowerCase() === "svg", u = (c ? "client" : "offset") + (l ? "Width" : "Height"), d = 100, f = i === "px", p = i === "%", h, g, m, b;
  if (i === s || !a || Og[i] || Og[s])
    return a;
  if (s !== "px" && !f && (a = e(t, n, r, "px")), b = t.getCTM && A0(t), (p || s === "%") && (Vr[n] || ~n.indexOf("adius")))
    return h = b ? t.getBBox()[l ? "width" : "height"] : t[u], xt(p ? a / h * d : a / 100 * h);
  if (o[l ? "width" : "height"] = d + (f ? s : i), g = i !== "rem" && ~n.indexOf("adius") || i === "em" && t.appendChild && !c ? t : t.parentNode, b && (g = (t.ownerSVGElement || {}).parentNode), (!g || g === Kr || !g.appendChild) && (g = Kr.body), m = g._gsap, m && p && m.width && l && m.time === An.time && !m.uncache)
    return xt(a / m.width * d);
  if (p && (n === "height" || n === "width")) {
    var y = t.style[n];
    t.style[n] = d + i, h = t[u], y ? t.style[n] = y : Oi(t, n);
  } else
    (p || s === "%") && !dF[vr(g, "display")] && (o.position = vr(t, "position")), g === t && (o.position = "static"), g.appendChild(bi), h = bi[u], g.removeChild(bi), o.position = "absolute";
  return l && p && (m = xi(g), m.time = An.time, m.width = g[u]), xt(f ? h * a / d : h && a ? d / h * a : 0);
}, Rr = function(t, n, r, i) {
  var a;
  return Uf || gd(), n in mr && n !== "transform" && (n = mr[n], ~n.indexOf(",") && (n = n.split(",")[0])), Vr[n] && n !== "transform" ? (a = zs(t, i), a = n !== "transformOrigin" ? a[n] : a.svg ? a.origin : Nl(vr(t, _n)) + " " + a.zOrigin + "px") : (a = t.style[n], (!a || a === "auto" || i || ~(a + "").indexOf("calc(")) && (a = Rl[n] && Rl[n](t, n, r) || vr(t, n) || U_(t, n) || (n === "opacity" ? 1 : 0))), r && !~(a + "").trim().indexOf(" ") ? si(t, n, a, r) + r : a;
}, fF = function(t, n, r, i) {
  if (!r || r === "none") {
    var a = Aa(n, t, 1), s = a && vr(t, a, 1);
    s && s !== r ? (n = a, r = s) : n === "borderColor" && (r = vr(t, "borderTopColor"));
  }
  var o = new yn(this._pt, t.style, n, 0, 1, y0), l = 0, c = 0, u, d, f, p, h, g, m, b, y, v, E, _;
  if (o.b = r, o.e = i, r += "", i += "", i === "auto" && (g = t.style[n], t.style[n] = i, i = vr(t, n) || i, g ? t.style[n] = g : Oi(t, n)), u = [r, i], l0(u), r = u[0], i = u[1], f = r.match(ta) || [], _ = i.match(ta) || [], _.length) {
    for (; d = ta.exec(i); )
      m = d[0], y = i.substring(l, d.index), h ? h = (h + 1) % 5 : (y.substr(-5) === "rgba(" || y.substr(-5) === "hsla(") && (h = 1), m !== (g = f[c++] || "") && (p = parseFloat(g) || 0, E = g.substr((p + "").length), m.charAt(1) === "=" && (m = ca(p, m) + E), b = parseFloat(m), v = m.substr((b + "").length), l = ta.lastIndex - v.length, v || (v = v || On.units[n] || E, l === i.length && (i += v, o.e += v)), E !== v && (p = si(t, n, g, v) || 0), o._pt = {
        _next: o._pt,
        p: y || c === 1 ? y : ",",
        //note: SVG spec allows omission of comma/space when a negative sign is wedged between two numbers, like 2.5-5.3 instead of 2.5,-5.3 but when tweening, the negative value may switch to positive, so we insert the comma just in case.
        s: p,
        c: b - p,
        m: h && h < 4 || n === "zIndex" ? Math.round : 0
      });
    o.c = l < i.length ? i.substring(l, i.length) : "";
  } else
    o.r = n === "display" && i === "none" ? E0 : x0;
  return F_.test(i) && (o.e = 0), this._pt = o, o;
}, Mg = {
  top: "0%",
  bottom: "100%",
  left: "0%",
  right: "100%",
  center: "50%"
}, pF = function(t) {
  var n = t.split(" "), r = n[0], i = n[1] || "50%";
  return (r === "top" || r === "bottom" || i === "left" || i === "right") && (t = r, r = i, i = t), n[0] = Mg[r] || r, n[1] = Mg[i] || i, n.join(" ");
}, hF = function(t, n) {
  if (n.tween && n.tween._time === n.tween._dur) {
    var r = n.t, i = r.style, a = n.u, s = r._gsap, o, l, c;
    if (a === "all" || a === !0)
      i.cssText = "", l = 1;
    else
      for (a = a.split(","), c = a.length; --c > -1; )
        o = a[c], Vr[o] && (l = 1, o = o === "transformOrigin" ? _n : ut), Oi(r, o);
    l && (Oi(r, ut), s && (s.svg && r.removeAttribute("transform"), i.scale = i.rotate = i.translate = "none", zs(r, 1), s.uncache = 1, w0(i)));
  }
}, Rl = {
  clearProps: function(t, n, r, i, a) {
    if (a.data !== "isFromStart") {
      var s = t._pt = new yn(t._pt, n, r, 0, 0, hF);
      return s.u = i, s.pr = -10, s.tween = a, t._props.push(r), 1;
    }
  }
  /* className feature (about 0.4kb gzipped).
  , className(plugin, target, property, endValue, tween) {
  	let _renderClassName = (ratio, data) => {
  			data.css.render(ratio, data.css);
  			if (!ratio || ratio === 1) {
  				let inline = data.rmv,
  					target = data.t,
  					p;
  				target.setAttribute("class", ratio ? data.e : data.b);
  				for (p in inline) {
  					_removeProperty(target, p);
  				}
  			}
  		},
  		_getAllStyles = (target) => {
  			let styles = {},
  				computed = getComputedStyle(target),
  				p;
  			for (p in computed) {
  				if (isNaN(p) && p !== "cssText" && p !== "length") {
  					styles[p] = computed[p];
  				}
  			}
  			_setDefaults(styles, _parseTransform(target, 1));
  			return styles;
  		},
  		startClassList = target.getAttribute("class"),
  		style = target.style,
  		cssText = style.cssText,
  		cache = target._gsap,
  		classPT = cache.classPT,
  		inlineToRemoveAtEnd = {},
  		data = {t:target, plugin:plugin, rmv:inlineToRemoveAtEnd, b:startClassList, e:(endValue.charAt(1) !== "=") ? endValue : startClassList.replace(new RegExp("(?:\\s|^)" + endValue.substr(2) + "(?![\\w-])"), "") + ((endValue.charAt(0) === "+") ? " " + endValue.substr(2) : "")},
  		changingVars = {},
  		startVars = _getAllStyles(target),
  		transformRelated = /(transform|perspective)/i,
  		endVars, p;
  	if (classPT) {
  		classPT.r(1, classPT.d);
  		_removeLinkedListItem(classPT.d.plugin, classPT, "_pt");
  	}
  	target.setAttribute("class", data.e);
  	endVars = _getAllStyles(target, true);
  	target.setAttribute("class", startClassList);
  	for (p in endVars) {
  		if (endVars[p] !== startVars[p] && !transformRelated.test(p)) {
  			changingVars[p] = endVars[p];
  			if (!style[p] && style[p] !== "0") {
  				inlineToRemoveAtEnd[p] = 1;
  			}
  		}
  	}
  	cache.classPT = plugin._pt = new PropTween(plugin._pt, target, "className", 0, 0, _renderClassName, data, 0, -11);
  	if (style.cssText !== cssText) { //only apply if things change. Otherwise, in cases like a background-image that's pulled dynamically, it could cause a refresh. See https://gsap.com/forums/topic/20368-possible-gsap-bug-switching-classnames-in-chrome/.
  		style.cssText = cssText; //we recorded cssText before we swapped classes and ran _getAllStyles() because in cases when a className tween is overwritten, we remove all the related tweening properties from that class change (otherwise class-specific stuff can't override properties we've directly set on the target's style object due to specificity).
  	}
  	_parseTransform(target, true); //to clear the caching of transforms
  	data.css = new gsap.plugins.css();
  	data.css.init(target, changingVars, tween);
  	plugin._props.push(...data.css._props);
  	return 1;
  }
  */
}, Bs = [1, 0, 0, 1, 0, 0], k0 = {}, T0 = function(t) {
  return t === "matrix(1, 0, 0, 1, 0, 0)" || t === "none" || !t;
}, Pg = function(t) {
  var n = vr(t, ut);
  return T0(n) ? Bs : n.substr(7).match(L_).map(xt);
}, Zf = function(t, n) {
  var r = t._gsap || xi(t), i = t.style, a = Pg(t), s, o, l, c;
  return r.svg && t.getAttribute("transform") ? (l = t.transform.baseVal.consolidate().matrix, a = [l.a, l.b, l.c, l.d, l.e, l.f], a.join(",") === "1,0,0,1,0,0" ? Bs : a) : (a === Bs && !t.offsetParent && t !== ua && !r.svg && (l = i.display, i.display = "block", s = t.parentNode, (!s || !t.offsetParent && !t.getBoundingClientRect().width) && (c = 1, o = t.nextElementSibling, ua.appendChild(t)), a = Pg(t), l ? i.display = l : Oi(t, "display"), c && (o ? s.insertBefore(t, o) : s ? s.appendChild(t) : ua.removeChild(t))), n && a.length > 6 ? [a[0], a[1], a[4], a[5], a[12], a[13]] : a);
}, md = function(t, n, r, i, a, s) {
  var o = t._gsap, l = a || Zf(t, !0), c = o.xOrigin || 0, u = o.yOrigin || 0, d = o.xOffset || 0, f = o.yOffset || 0, p = l[0], h = l[1], g = l[2], m = l[3], b = l[4], y = l[5], v = n.split(" "), E = parseFloat(v[0]) || 0, _ = parseFloat(v[1]) || 0, x, I, T, O;
  r ? l !== Bs && (I = p * m - h * g) && (T = E * (m / I) + _ * (-g / I) + (g * y - m * b) / I, O = E * (-h / I) + _ * (p / I) - (p * y - h * b) / I, E = T, _ = O) : (x = S0(t), E = x.x + (~v[0].indexOf("%") ? E / 100 * x.width : E), _ = x.y + (~(v[1] || v[0]).indexOf("%") ? _ / 100 * x.height : _)), i || i !== !1 && o.smooth ? (b = E - c, y = _ - u, o.xOffset = d + (b * p + y * g) - b, o.yOffset = f + (b * h + y * m) - y) : o.xOffset = o.yOffset = 0, o.xOrigin = E, o.yOrigin = _, o.smooth = !!i, o.origin = n, o.originIsAbsolute = !!r, t.style[_n] = "0px 0px", s && (Qr(s, o, "xOrigin", c, E), Qr(s, o, "yOrigin", u, _), Qr(s, o, "xOffset", d, o.xOffset), Qr(s, o, "yOffset", f, o.yOffset)), t.setAttribute("data-svg-origin", E + " " + _);
}, zs = function(t, n) {
  var r = t._gsap || new f0(t);
  if ("x" in r && !n && !r.uncache)
    return r;
  var i = t.style, a = r.scaleX < 0, s = "px", o = "deg", l = getComputedStyle(t), c = vr(t, _n) || "0", u, d, f, p, h, g, m, b, y, v, E, _, x, I, T, O, k, W, M, L, z, U, $, Q, K, fe, S, me, se, A, ve, Te;
  return u = d = f = g = m = b = y = v = E = 0, p = h = 1, r.svg = !!(t.getCTM && A0(t)), l.translate && ((l.translate !== "none" || l.scale !== "none" || l.rotate !== "none") && (i[ut] = (l.translate !== "none" ? "translate3d(" + (l.translate + " 0 0").split(" ").slice(0, 3).join(", ") + ") " : "") + (l.rotate !== "none" ? "rotate(" + l.rotate + ") " : "") + (l.scale !== "none" ? "scale(" + l.scale.split(" ").join(",") + ") " : "") + (l[ut] !== "none" ? l[ut] : "")), i.scale = i.rotate = i.translate = "none"), I = Zf(t, r.svg), r.svg && (r.uncache ? (K = t.getBBox(), c = r.xOrigin - K.x + "px " + (r.yOrigin - K.y) + "px", Q = "") : Q = !n && t.getAttribute("data-svg-origin"), md(t, Q || c, !!Q || r.originIsAbsolute, r.smooth !== !1, I)), _ = r.xOrigin || 0, x = r.yOrigin || 0, I !== Bs && (W = I[0], M = I[1], L = I[2], z = I[3], u = U = I[4], d = $ = I[5], I.length === 6 ? (p = Math.sqrt(W * W + M * M), h = Math.sqrt(z * z + L * L), g = W || M ? Xi(M, W) * pi : 0, y = L || z ? Xi(L, z) * pi + g : 0, y && (h *= Math.abs(Math.cos(y * da))), r.svg && (u -= _ - (_ * W + x * L), d -= x - (_ * M + x * z))) : (Te = I[6], A = I[7], S = I[8], me = I[9], se = I[10], ve = I[11], u = I[12], d = I[13], f = I[14], T = Xi(Te, se), m = T * pi, T && (O = Math.cos(-T), k = Math.sin(-T), Q = U * O + S * k, K = $ * O + me * k, fe = Te * O + se * k, S = U * -k + S * O, me = $ * -k + me * O, se = Te * -k + se * O, ve = A * -k + ve * O, U = Q, $ = K, Te = fe), T = Xi(-L, se), b = T * pi, T && (O = Math.cos(-T), k = Math.sin(-T), Q = W * O - S * k, K = M * O - me * k, fe = L * O - se * k, ve = z * k + ve * O, W = Q, M = K, L = fe), T = Xi(M, W), g = T * pi, T && (O = Math.cos(T), k = Math.sin(T), Q = W * O + M * k, K = U * O + $ * k, M = M * O - W * k, $ = $ * O - U * k, W = Q, U = K), m && Math.abs(m) + Math.abs(g) > 359.9 && (m = g = 0, b = 180 - b), p = xt(Math.sqrt(W * W + M * M + L * L)), h = xt(Math.sqrt($ * $ + Te * Te)), T = Xi(U, $), y = Math.abs(T) > 2e-4 ? T * pi : 0, E = ve ? 1 / (ve < 0 ? -ve : ve) : 0), r.svg && (Q = t.getAttribute("transform"), r.forceCSS = t.setAttribute("transform", "") || !T0(vr(t, ut)), Q && t.setAttribute("transform", Q))), Math.abs(y) > 90 && Math.abs(y) < 270 && (a ? (p *= -1, y += g <= 0 ? 180 : -180, g += g <= 0 ? 180 : -180) : (h *= -1, y += y <= 0 ? 180 : -180)), n = n || r.uncache, r.x = u - ((r.xPercent = u && (!n && r.xPercent || (Math.round(t.offsetWidth / 2) === Math.round(-u) ? -50 : 0))) ? t.offsetWidth * r.xPercent / 100 : 0) + s, r.y = d - ((r.yPercent = d && (!n && r.yPercent || (Math.round(t.offsetHeight / 2) === Math.round(-d) ? -50 : 0))) ? t.offsetHeight * r.yPercent / 100 : 0) + s, r.z = f + s, r.scaleX = xt(p), r.scaleY = xt(h), r.rotation = xt(g) + o, r.rotationX = xt(m) + o, r.rotationY = xt(b) + o, r.skewX = y + o, r.skewY = v + o, r.transformPerspective = E + s, (r.zOrigin = parseFloat(c.split(" ")[2]) || !n && r.zOrigin || 0) && (i[_n] = Nl(c)), r.xOffset = r.yOffset = 0, r.force3D = On.force3D, r.renderTransform = r.svg ? mF : I0 ? R0 : gF, r.uncache = 0, r;
}, Nl = function(t) {
  return (t = t.split(" "))[0] + " " + t[1];
}, bu = function(t, n, r) {
  var i = Zt(n);
  return xt(parseFloat(n) + parseFloat(si(t, "x", r + "px", i))) + i;
}, gF = function(t, n) {
  n.z = "0px", n.rotationY = n.rotationX = "0deg", n.force3D = 0, R0(t, n);
}, di = "0deg", Ka = "0px", fi = ") ", R0 = function(t, n) {
  var r = n || this, i = r.xPercent, a = r.yPercent, s = r.x, o = r.y, l = r.z, c = r.rotation, u = r.rotationY, d = r.rotationX, f = r.skewX, p = r.skewY, h = r.scaleX, g = r.scaleY, m = r.transformPerspective, b = r.force3D, y = r.target, v = r.zOrigin, E = "", _ = b === "auto" && t && t !== 1 || b === !0;
  if (v && (d !== di || u !== di)) {
    var x = parseFloat(u) * da, I = Math.sin(x), T = Math.cos(x), O;
    x = parseFloat(d) * da, O = Math.cos(x), s = bu(y, s, I * O * -v), o = bu(y, o, -Math.sin(x) * -v), l = bu(y, l, T * O * -v + v);
  }
  m !== Ka && (E += "perspective(" + m + fi), (i || a) && (E += "translate(" + i + "%, " + a + "%) "), (_ || s !== Ka || o !== Ka || l !== Ka) && (E += l !== Ka || _ ? "translate3d(" + s + ", " + o + ", " + l + ") " : "translate(" + s + ", " + o + fi), c !== di && (E += "rotate(" + c + fi), u !== di && (E += "rotateY(" + u + fi), d !== di && (E += "rotateX(" + d + fi), (f !== di || p !== di) && (E += "skew(" + f + ", " + p + fi), (h !== 1 || g !== 1) && (E += "scale(" + h + ", " + g + fi), y.style[ut] = E || "translate(0, 0)";
}, mF = function(t, n) {
  var r = n || this, i = r.xPercent, a = r.yPercent, s = r.x, o = r.y, l = r.rotation, c = r.skewX, u = r.skewY, d = r.scaleX, f = r.scaleY, p = r.target, h = r.xOrigin, g = r.yOrigin, m = r.xOffset, b = r.yOffset, y = r.forceCSS, v = parseFloat(s), E = parseFloat(o), _, x, I, T, O;
  l = parseFloat(l), c = parseFloat(c), u = parseFloat(u), u && (u = parseFloat(u), c += u, l += u), l || c ? (l *= da, c *= da, _ = Math.cos(l) * d, x = Math.sin(l) * d, I = Math.sin(l - c) * -f, T = Math.cos(l - c) * f, c && (u *= da, O = Math.tan(c - u), O = Math.sqrt(1 + O * O), I *= O, T *= O, u && (O = Math.tan(u), O = Math.sqrt(1 + O * O), _ *= O, x *= O)), _ = xt(_), x = xt(x), I = xt(I), T = xt(T)) : (_ = d, T = f, x = I = 0), (v && !~(s + "").indexOf("px") || E && !~(o + "").indexOf("px")) && (v = si(p, "x", s, "px"), E = si(p, "y", o, "px")), (h || g || m || b) && (v = xt(v + h - (h * _ + g * I) + m), E = xt(E + g - (h * x + g * T) + b)), (i || a) && (O = p.getBBox(), v = xt(v + i / 100 * O.width), E = xt(E + a / 100 * O.height)), O = "matrix(" + _ + "," + x + "," + I + "," + T + "," + v + "," + E + ")", p.setAttribute("transform", O), y && (p.style[ut] = O);
}, bF = function(t, n, r, i, a) {
  var s = 360, o = Lt(a), l = parseFloat(a) * (o && ~a.indexOf("rad") ? pi : 1), c = l - i, u = i + c + "deg", d, f;
  return o && (d = a.split("_")[1], d === "short" && (c %= s, c !== c % (s / 2) && (c += c < 0 ? s : -360)), d === "cw" && c < 0 ? c = (c + s * kg) % s - ~~(c / s) * s : d === "ccw" && c > 0 && (c = (c - s * kg) % s - ~~(c / s) * s)), t._pt = f = new yn(t._pt, n, r, i, c, eF), f.e = u, f.u = "deg", t._props.push(r), f;
}, Dg = function(t, n) {
  for (var r in n)
    t[r] = n[r];
  return t;
}, yF = function(t, n, r) {
  var i = Dg({}, r._gsap), a = "perspective,force3D,transformOrigin,svgOrigin", s = r.style, o, l, c, u, d, f, p, h;
  i.svg ? (c = r.getAttribute("transform"), r.setAttribute("transform", ""), s[ut] = n, o = zs(r, 1), Oi(r, ut), r.setAttribute("transform", c)) : (c = getComputedStyle(r)[ut], s[ut] = n, o = zs(r, 1), s[ut] = c);
  for (l in Vr)
    c = i[l], u = o[l], c !== u && a.indexOf(l) < 0 && (p = Zt(c), h = Zt(u), d = p !== h ? si(r, l, c, h) : parseFloat(c), f = parseFloat(u), t._pt = new yn(t._pt, o, l, d, f - d, pd), t._pt.u = h || 0, t._props.push(l));
  Dg(o, i);
};
bn("padding,margin,Width,Radius", function(e, t) {
  var n = "Top", r = "Right", i = "Bottom", a = "Left", s = (t < 3 ? [n, r, i, a] : [n + a, n + r, i + r, i + a]).map(function(o) {
    return t < 2 ? e + o : "border" + o + e;
  });
  Rl[t > 1 ? "border" + e : e] = function(o, l, c, u, d) {
    var f, p;
    if (arguments.length < 4)
      return f = s.map(function(h) {
        return Rr(o, h, c);
      }), p = f.join(" "), p.split(f[0]).length === 5 ? f[0] : p;
    f = (u + "").split(" "), p = {}, s.forEach(function(h, g) {
      return p[h] = f[g] = f[g] || f[(g - 1) / 2 | 0];
    }), o.init(l, p, d);
  };
});
var N0 = {
  name: "css",
  register: gd,
  targetTest: function(t) {
    return t.style && t.nodeType;
  },
  init: function(t, n, r, i, a) {
    var s = this._props, o = t.style, l = r.vars.startAt, c, u, d, f, p, h, g, m, b, y, v, E, _, x, I, T;
    Uf || gd(), this.styles = this.styles || C0(t), T = this.styles.props, this.tween = r;
    for (g in n)
      if (g !== "autoRound" && (u = n[g], !(Sn[g] && p0(g, n, r, i, t, a)))) {
        if (p = typeof u, h = Rl[g], p === "function" && (u = u.call(r, i, t, a), p = typeof u), p === "string" && ~u.indexOf("random(") && (u = Ds(u)), h)
          h(this, t, g, u, r) && (I = 1);
        else if (g.substr(0, 2) === "--")
          c = (getComputedStyle(t).getPropertyValue(g) + "").trim(), u += "", ti.lastIndex = 0, ti.test(c) || (m = Zt(c), b = Zt(u)), b ? m !== b && (c = si(t, g, c, b) + b) : m && (u += m), this.add(o, "setProperty", c, u, i, a, 0, 0, g), s.push(g), T.push(g, 0, o[g]);
        else if (p !== "undefined") {
          if (l && g in l ? (c = typeof l[g] == "function" ? l[g].call(r, i, t, a) : l[g], Lt(c) && ~c.indexOf("random(") && (c = Ds(c)), Zt(c + "") || c === "auto" || (c += On.units[g] || Zt(Rr(t, g)) || ""), (c + "").charAt(1) === "=" && (c = Rr(t, g))) : c = Rr(t, g), f = parseFloat(c), y = p === "string" && u.charAt(1) === "=" && u.substr(0, 2), y && (u = u.substr(2)), d = parseFloat(u), g in mr && (g === "autoAlpha" && (f === 1 && Rr(t, "visibility") === "hidden" && d && (f = 0), T.push("visibility", 0, o.visibility), Qr(this, o, "visibility", f ? "inherit" : "hidden", d ? "inherit" : "hidden", !d)), g !== "scale" && g !== "transform" && (g = mr[g], ~g.indexOf(",") && (g = g.split(",")[0]))), v = g in Vr, v) {
            if (this.styles.save(g), E || (_ = t._gsap, _.renderTransform && !n.parseTransform || zs(t, n.parseTransform), x = n.smoothOrigin !== !1 && _.smooth, E = this._pt = new yn(this._pt, o, ut, 0, 1, _.renderTransform, _, 0, -1), E.dep = 1), g === "scale")
              this._pt = new yn(this._pt, _, "scaleY", _.scaleY, (y ? ca(_.scaleY, y + d) : d) - _.scaleY || 0, pd), this._pt.u = 0, s.push("scaleY", g), g += "X";
            else if (g === "transformOrigin") {
              T.push(_n, 0, o[_n]), u = pF(u), _.svg ? md(t, u, 0, x, 0, this) : (b = parseFloat(u.split(" ")[2]) || 0, b !== _.zOrigin && Qr(this, _, "zOrigin", _.zOrigin, b), Qr(this, o, g, Nl(c), Nl(u)));
              continue;
            } else if (g === "svgOrigin") {
              md(t, u, 1, x, 0, this);
              continue;
            } else if (g in k0) {
              bF(this, _, g, f, y ? ca(f, y + u) : u);
              continue;
            } else if (g === "smoothOrigin") {
              Qr(this, _, "smooth", _.smooth, u);
              continue;
            } else if (g === "force3D") {
              _[g] = u;
              continue;
            } else if (g === "transform") {
              yF(this, u, t);
              continue;
            }
          } else g in o || (g = Aa(g) || g);
          if (v || (d || d === 0) && (f || f === 0) && !QL.test(u) && g in o)
            m = (c + "").substr((f + "").length), d || (d = 0), b = Zt(u) || (g in On.units ? On.units[g] : m), m !== b && (f = si(t, g, c, b)), this._pt = new yn(this._pt, v ? _ : o, g, f, (y ? ca(f, y + d) : d) - f, !v && (b === "px" || g === "zIndex") && n.autoRound !== !1 ? nF : pd), this._pt.u = b || 0, m !== b && b !== "%" && (this._pt.b = c, this._pt.r = tF);
          else if (g in o)
            fF.call(this, t, g, c, y ? y + u : u);
          else if (g in t)
            this.add(t, g, c || t[g], y ? y + u : u, i, a);
          else if (g !== "parseTransform") {
            Pf(g, u);
            continue;
          }
          v || (g in o ? T.push(g, 0, o[g]) : typeof t[g] == "function" ? T.push(g, 2, t[g]()) : T.push(g, 1, c || t[g])), s.push(g);
        }
      }
    I && _0(this);
  },
  render: function(t, n) {
    if (n.tween._time || !Hf())
      for (var r = n._pt; r; )
        r.r(t, r.d), r = r._next;
    else
      n.styles.revert();
  },
  get: Rr,
  aliases: mr,
  getSetter: function(t, n, r) {
    var i = mr[n];
    return i && i.indexOf(",") < 0 && (n = i), n in Vr && n !== _n && (t._gsap.x || Rr(t, "x")) ? r && Ag === r ? n === "scale" ? sF : aF : (Ag = r || {}) && (n === "scale" ? oF : lF) : t.style && !Nf(t.style[n]) ? rF : ~n.indexOf("-") ? iF : Gf(t, n);
  },
  core: {
    _removeProperty: Oi,
    _getMatrix: Zf
  }
};
En.utils.checkPrefix = Aa;
En.core.getStyleSaver = C0;
(function(e, t, n, r) {
  var i = bn(e + "," + t + "," + n, function(a) {
    Vr[a] = 1;
  });
  bn(t, function(a) {
    On.units[a] = "deg", k0[a] = 1;
  }), mr[i[13]] = e + "," + t, bn(r, function(a) {
    var s = a.split(":");
    mr[s[1]] = i[s[0]];
  });
})("x,y,z,scale,scaleX,scaleY,xPercent,yPercent", "rotation,rotationX,rotationY,skewX,skewY", "transform,transformOrigin,svgOrigin,force3D,smoothOrigin,transformPerspective", "0:translateX,1:translateY,2:translateZ,8:rotate,8:rotationZ,8:rotateZ,9:rotateX,10:rotateY");
bn("x,y,z,top,right,bottom,left,width,height,fontSize,padding,margin,perspective", function(e) {
  On.units[e] = "px";
});
En.registerPlugin(N0);
var Pa = En.registerPlugin(N0) || En;
Pa.core.Tween;
/*!
 * ScrollToPlugin 3.12.7
 * https://gsap.com
 *
 * @license Copyright 2008-2025, GreenSock. All rights reserved.
 * Subject to the terms at https://gsap.com/standard-license or for
 * Club GSAP members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*/
var $t, O0, Mr, br, ni, M0, fa, ko, P0 = function() {
  return typeof window < "u";
}, D0 = function() {
  return $t || P0() && ($t = window.gsap) && $t.registerPlugin && $t;
}, L0 = function(t) {
  return typeof t == "string";
}, Lg = function(t) {
  return typeof t == "function";
}, Vs = function(t, n) {
  var r = n === "x" ? "Width" : "Height", i = "scroll" + r, a = "client" + r;
  return t === Mr || t === br || t === ni ? Math.max(br[i], ni[i]) - (Mr["inner" + r] || br[a] || ni[a]) : t[i] - t["offset" + r];
}, Gs = function(t, n) {
  var r = "scroll" + (n === "x" ? "Left" : "Top");
  return t === Mr && (t.pageXOffset != null ? r = "page" + n.toUpperCase() + "Offset" : t = br[r] != null ? br : ni), function() {
    return t[r];
  };
}, _F = function(t, n, r, i) {
  if (Lg(t) && (t = t(n, r, i)), typeof t != "object")
    return L0(t) && t !== "max" && t.charAt(1) !== "=" ? {
      x: t,
      y: t
    } : {
      y: t
    };
  if (t.nodeType)
    return {
      y: t,
      x: t
    };
  var a = {}, s;
  for (s in t)
    a[s] = s !== "onAutoKill" && Lg(t[s]) ? t[s](n, r, i) : t[s];
  return a;
}, F0 = function(t, n) {
  if (t = M0(t)[0], !t || !t.getBoundingClientRect)
    return console.warn("scrollTo target doesn't exist. Using 0") || {
      x: 0,
      y: 0
    };
  var r = t.getBoundingClientRect(), i = !n || n === Mr || n === ni, a = i ? {
    top: br.clientTop - (Mr.pageYOffset || br.scrollTop || ni.scrollTop || 0),
    left: br.clientLeft - (Mr.pageXOffset || br.scrollLeft || ni.scrollLeft || 0)
  } : n.getBoundingClientRect(), s = {
    x: r.left - a.left,
    y: r.top - a.top
  };
  return !i && n && (s.x += Gs(n, "x")(), s.y += Gs(n, "y")()), s;
}, Fg = function(t, n, r, i, a) {
  return !isNaN(t) && typeof t != "object" ? parseFloat(t) - a : L0(t) && t.charAt(1) === "=" ? parseFloat(t.substr(2)) * (t.charAt(0) === "-" ? -1 : 1) + i - a : t === "max" ? Vs(n, r) - a : Math.min(Vs(n, r), F0(t, n)[r] - a);
}, bd = function() {
  $t = D0(), P0() && $t && typeof document < "u" && document.body && (Mr = window, ni = document.body, br = document.documentElement, M0 = $t.utils.toArray, $t.config({
    autoKillThreshold: 7
  }), fa = $t.config(), O0 = 1);
}, Da = {
  version: "3.12.7",
  name: "scrollTo",
  rawVars: 1,
  register: function(t) {
    $t = t, bd();
  },
  init: function(t, n, r, i, a) {
    O0 || bd();
    var s = this, o = $t.getProperty(t, "scrollSnapType");
    s.isWin = t === Mr, s.target = t, s.tween = r, n = _F(n, i, t, a), s.vars = n, s.autoKill = !!("autoKill" in n ? n : fa).autoKill, s.getX = Gs(t, "x"), s.getY = Gs(t, "y"), s.x = s.xPrev = s.getX(), s.y = s.yPrev = s.getY(), ko || (ko = $t.core.globals().ScrollTrigger), $t.getProperty(t, "scrollBehavior") === "smooth" && $t.set(t, {
      scrollBehavior: "auto"
    }), o && o !== "none" && (s.snap = 1, s.snapInline = t.style.scrollSnapType, t.style.scrollSnapType = "none"), n.x != null ? (s.add(s, "x", s.x, Fg(n.x, t, "x", s.x, n.offsetX || 0), i, a), s._props.push("scrollTo_x")) : s.skipX = 1, n.y != null ? (s.add(s, "y", s.y, Fg(n.y, t, "y", s.y, n.offsetY || 0), i, a), s._props.push("scrollTo_y")) : s.skipY = 1;
  },
  render: function(t, n) {
    for (var r = n._pt, i = n.target, a = n.tween, s = n.autoKill, o = n.xPrev, l = n.yPrev, c = n.isWin, u = n.snap, d = n.snapInline, f, p, h, g, m; r; )
      r.r(t, r.d), r = r._next;
    f = c || !n.skipX ? n.getX() : o, p = c || !n.skipY ? n.getY() : l, h = p - l, g = f - o, m = fa.autoKillThreshold, n.x < 0 && (n.x = 0), n.y < 0 && (n.y = 0), s && (!n.skipX && (g > m || g < -m) && f < Vs(i, "x") && (n.skipX = 1), !n.skipY && (h > m || h < -m) && p < Vs(i, "y") && (n.skipY = 1), n.skipX && n.skipY && (a.kill(), n.vars.onAutoKill && n.vars.onAutoKill.apply(a, n.vars.onAutoKillParams || []))), c ? Mr.scrollTo(n.skipX ? f : n.x, n.skipY ? p : n.y) : (n.skipY || (i.scrollTop = n.y), n.skipX || (i.scrollLeft = n.x)), u && (t === 1 || t === 0) && (p = i.scrollTop, f = i.scrollLeft, d ? i.style.scrollSnapType = d : i.style.removeProperty("scroll-snap-type"), i.scrollTop = p + 1, i.scrollLeft = f + 1, i.scrollTop = p, i.scrollLeft = f), n.xPrev = n.x, n.yPrev = n.y, ko && ko.update();
  },
  kill: function(t) {
    var n = t === "scrollTo", r = this._props.indexOf(t);
    return (n || t === "scrollTo_x") && (this.skipX = 1), (n || t === "scrollTo_y") && (this.skipY = 1), r > -1 && this._props.splice(r, 1), !this._props.length;
  }
};
Da.max = Vs;
Da.getOffset = F0;
Da.buildGetter = Gs;
Da.config = function(e) {
  fa || bd() || (fa = $t.config());
  for (var t in e)
    fa[t] = e[t];
};
D0() && $t.registerPlugin(Da);
Pa.registerPlugin(Da);
function Bg(e) {
  const t = document.getElementById(e);
  t ? Pa.to(window, {
    scrollTo: {
      y: t.offsetTop - 50,
      autoKill: !1
    },
    duration: 1,
    ease: "power1.inOut"
  }) : console.warn(`Elemento con ID '${e}' non trovato.`);
}
function vF(e, t, n) {
  if (!t || !n)
    return null;
  const r = t.find(
    (a) => e.startsWith(a.value)
  );
  if (!r || !r.group)
    return null;
  const i = n.find(
    (a) => a.group.includes(r.group) && e.startsWith(a.value)
  );
  return i ? i.value : null;
}
function xF(e) {
  const [t, n] = _t(!1);
  return er(() => {
    const r = window.matchMedia(e);
    n(r.matches);
    const i = (a) => n(a.matches);
    return r.addEventListener("change", i), () => r.removeEventListener("change", i);
  }, [e]), t;
}
function B0() {
  const e = nr(), t = sc(), n = gn(null), r = xF("(max-width: 519px)");
  function i(s) {
    n.current && Pa.to(n.current, {
      x: s.clientX - 50,
      y: s.clientY - 50,
      duration: 0.1,
      ease: "power1.out"
    });
  }
  function a(s, o) {
    o ? (t(s.replace("/", "").split("/").pop() || ""), Bg(s.replace("/", "").split("/").pop() || "")) : t(s, { replace: !0 });
  }
  return er(() => {
    setTimeout(() => {
      Bg(e.pathname.split("/").pop() || "");
    }, 500);
  }, []), er(() => {
    if (!r)
      return document.addEventListener("mousemove", i), () => document.removeEventListener("mousemove", i);
  }, [r]), { handleNavigationAndScroll: a, isMobileRef: r, circleRef: n };
}
const $f = () => {
  const e = Fl(O_);
  if (!e)
    throw new Error("useDashboard must be used within Dashboard page");
  return e;
};
function Xf() {
  const { resolvedTheme: e, setTheme: t } = Nb();
  return {
    colorMode: e,
    setColorMode: t,
    toggleColorMode: () => {
      t(e === "light" ? "dark" : "light");
    }
  };
}
function EF() {
  const { colorMode: e } = Xf();
  return e === "light" ? /* @__PURE__ */ w.jsx(KS, {}) : /* @__PURE__ */ w.jsx(qS, {});
}
const zg = function(t) {
  const { toggleColorMode: n, colorMode: r } = Xf(), { variant: i, size: a } = t;
  return (
    // Usa ClientOnly per assicurarsi che il componente venga renderizzato solo sul client
    /* @__PURE__ */ w.jsx(hm, { fallback: /* @__PURE__ */ w.jsx(Zs, { boxSize: "8" }), children: /* @__PURE__ */ w.jsx(
      gi.Root,
      {
        defaultValue: r,
        variant: i,
        size: a,
        onValueChange: n,
        children: /* @__PURE__ */ w.jsxs(
          gi.List,
          {
            backgroundColor: "gray.100",
            _dark: { backgroundColor: "gray.950" },
            children: [
              /* @__PURE__ */ w.jsx(gi.Trigger, { value: "light", children: /* @__PURE__ */ w.jsx(zS, {}) }),
              /* @__PURE__ */ w.jsx(gi.Trigger, { value: "dark", children: /* @__PURE__ */ w.jsx(BS, {}) })
            ]
          }
        )
      },
      crypto.randomUUID()
    ) })
  );
};
Ue(function(t, n) {
  const { toggleColorMode: r } = Xf();
  return (
    // Usa ClientOnly per garantire che il bottone venga renderizzato solo sul client
    /* @__PURE__ */ w.jsx(hm, { fallback: /* @__PURE__ */ w.jsx(Zs, { boxSize: "8" }), children: /* @__PURE__ */ w.jsx(
      Li,
      {
        onClick: r,
        variant: "ghost",
        "aria-label": "Toggle color mode",
        size: "sm",
        ref: n,
        ...t,
        css: { _icon: { width: "5", height: "5" } },
        children: /* @__PURE__ */ w.jsx(EF, {})
      }
    ) })
  );
});
const wF = Ue(
  function(t, n) {
    const { children: r, portalled: i = !0, portalRef: a, offset: s, ...o } = t;
    return /* @__PURE__ */ w.jsx(Vl, { disabled: !i, container: a, children: /* @__PURE__ */ w.jsx(Wn.Positioner, { padding: s, children: /* @__PURE__ */ w.jsx(Wn.Content, { ref: n, ...o, asChild: !1, children: r }) }) });
  }
), CF = Ue(function(t, n) {
  return /* @__PURE__ */ w.jsx(
    Wn.CloseTrigger,
    {
      position: "absolute",
      top: "2",
      insetEnd: "2",
      ...t,
      asChild: !0,
      children: /* @__PURE__ */ w.jsx(jb, { size: "sm", ref: n })
    }
  );
}), IF = Wn.Trigger, SF = Wn.Root;
Wn.Footer;
Wn.Header;
const AF = Wn.Body, kF = Wn.Backdrop;
Wn.Description;
Wn.Title;
Wn.ActionTrigger;
const TF = () => {
  const { isMobileRef: e, handleNavigationAndScroll: t } = B0(), { props: n } = $f(), r = sc(), i = nr(), { navigationScroll: a, logo: s, navbarItems: o, navbarSubItems: l } = n, c = () => s && /* @__PURE__ */ w.jsx(Od, { src: s, width: "42px" });
  return /* @__PURE__ */ w.jsx(
    pn,
    {
      wrap: "wrap",
      position: "fixed",
      zIndex: 4,
      width: "100%",
      top: 0,
      backgroundColor: "white",
      _dark: { backgroundColor: "black" },
      children: e ? /* @__PURE__ */ w.jsx(
        pn,
        {
          wrap: "wrap",
          direction: "row",
          width: "100%",
          gapX: "1rem",
          justifyContent: "start",
          justifyItems: "center",
          alignContent: "center",
          alignItems: "center",
          paddingX: "5%",
          paddingY: "1rem",
          children: /* @__PURE__ */ w.jsxs(SF, { size: "full", children: [
            /* @__PURE__ */ w.jsx(kF, {}),
            /* @__PURE__ */ w.jsx(IF, { asChild: !0, children: /* @__PURE__ */ w.jsx(Li, { "aria-label": "", variant: "subtle", children: /* @__PURE__ */ w.jsx(uA, {}) }) }),
            /* @__PURE__ */ w.jsx(Ru, {}),
            /* @__PURE__ */ w.jsx(zg, { variant: "enclosed", size: "sm" }),
            /* @__PURE__ */ w.jsxs(wF, { children: [
              /* @__PURE__ */ w.jsx(AF, { children: /* @__PURE__ */ w.jsx(pn, { direction: "column", gap: "3rem", height: "100%", alignItems: "center", justifyContent: "center", children: o == null ? void 0 : o.map((u) => /* @__PURE__ */ w.jsx(R_, { to: u.value, end: !0, children: /* @__PURE__ */ w.jsx(ra, { textStyle: "3xl", fontWeight: "medium", children: u.label }) }, crypto.randomUUID())) }) }),
              /* @__PURE__ */ w.jsx(CF, {})
            ] })
          ] })
        }
      ) : /* @__PURE__ */ w.jsxs(w.Fragment, { children: [
        /* @__PURE__ */ w.jsxs(
          pn,
          {
            wrap: "wrap",
            direction: "row",
            width: "100%",
            gapX: "1rem",
            justifyContent: "center",
            justifyItems: "center",
            alignContent: "center",
            alignItems: "center",
            paddingX: "5%",
            paddingY: l ? "" : "1rem",
            paddingTop: l ? "1rem" : "",
            children: [
              /* @__PURE__ */ w.jsx(c, {}),
              o == null ? void 0 : o.map(
                (u) => /* @__PURE__ */ w.jsx(
                  ra,
                  {
                    onClick: () => t(u.value, a),
                    style: { cursor: "pointer" },
                    textStyle: "xl",
                    fontWeight: "medium",
                    children: u.label
                  },
                  u.value
                )
              ),
              /* @__PURE__ */ w.jsx(Ru, {}),
              /* @__PURE__ */ w.jsx(zg, { variant: "enclosed", size: "sm" })
            ]
          }
        ),
        l && /* @__PURE__ */ w.jsx(
          pn,
          {
            wrap: "wrap",
            direction: "row",
            width: "100%",
            gapX: "1rem",
            justifyContent: "start",
            justifyItems: "center",
            alignContent: "center",
            alignItems: "center",
            paddingX: "10%",
            children: /* @__PURE__ */ w.jsx(
              gi.Root,
              {
                defaultValue: vF(i.pathname, o, l),
                variant: "line",
                size: "sm",
                onValueChange: (u) => r(u.value),
                children: /* @__PURE__ */ w.jsx(gi.List, { children: l.filter(
                  (u) => {
                    var d, f;
                    return u.group ? (f = u.group) == null ? void 0 : f.includes(
                      ((d = o == null ? void 0 : o.find(
                        (p) => i.pathname.search(new RegExp(p.value, "g")) !== -1
                      )) == null ? void 0 : d.group) || ""
                    ) : !0;
                  }
                ).map((u) => /* @__PURE__ */ w.jsxs(gi.Trigger, { value: u.value, children: [
                  u.icon,
                  " ",
                  u.label
                ] }, crypto.randomUUID())) })
              },
              crypto.randomUUID()
            )
          }
        )
      ] })
    }
  );
}, RF = () => {
  const { props: e } = $f(), { children: t } = e, n = gn(null);
  return er(() => {
    n.current && Pa.fromTo(
      n.current,
      { y: -50, opacity: 0 },
      { y: 0, opacity: 1, duration: 1, ease: "bounce.out" }
    );
  }, []), /* @__PURE__ */ w.jsx(
    pn,
    {
      ref: n,
      zIndex: "3",
      minHeight: "100vh",
      wrap: "wrap",
      borderYWidth: "1px",
      paddingTop: "8rem",
      paddingBottom: "8rem",
      paddingX: { base: "5%", sm: "5%", md: "5%", lg: "5%", xl: "10%", "2xl": "10%" },
      gap: "8rem",
      justifyContent: "center",
      children: t
    }
  );
}, NF = () => {
  const { isMobileRef: e, circleRef: t } = B0(), { props: n } = $f(), { background: r } = n;
  return /* @__PURE__ */ w.jsxs(
    pn,
    {
      position: "relative",
      overflow: "hidden",
      direction: "column",
      width: "100%",
      minHeight: "100vh",
      children: [
        r && /* @__PURE__ */ w.jsx(
          Xo.div,
          {
            position: "absolute",
            zIndex: 1,
            top: 0,
            left: 0,
            right: 0,
            bottom: 0,
            backgroundAttachment: "fixed",
            backgroundPosition: "top",
            backgroundSize: "cover",
            filter: r.opacity ? `blur(${r.opacity}px)` : void 0,
            backgroundColor: "gray.100",
            backgroundImage: r.image ? "url(undefined/assets/background_white.png)" : void 0,
            _dark: {
              backgroundColor: "gray.950",
              backgroundImage: r.imageDark ? "url(undefined/assets/background_dark.png)" : void 0
            }
          }
        ),
        !e && /* @__PURE__ */ w.jsx(
          Xo.div,
          {
            ref: t,
            pointerEvents: "none",
            position: "fixed",
            zIndex: 2,
            top: 0,
            left: 0,
            width: "100px",
            height: "100px",
            borderRadius: "50%",
            background: "radial-gradient(circle, {colors.gray.100} 0%, transparent 70%)",
            _dark: {
              background: "radial-gradient(circle, {colors.gray.950} 0%, transparent 70%)"
            }
          }
        ),
        /* @__PURE__ */ w.jsxs(
          pn,
          {
            position: "relative",
            zIndex: 3,
            direction: "column",
            width: "100%",
            minHeight: "100vh",
            children: [
              /* @__PURE__ */ w.jsx(TF, {}),
              /* @__PURE__ */ w.jsx(RF, {})
            ]
          }
        )
      ]
    }
  );
}, OF = iL(NF), y4 = { Error: MD, Loading: zD, Transformer: OF };
var To = { exports: {} }, yu = {};
/**
 * @license React
 * use-sync-external-store-with-selector.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Vg;
function MF() {
  if (Vg) return yu;
  Vg = 1;
  var e = De;
  function t(l, c) {
    return l === c && (l !== 0 || 1 / l === 1 / c) || l !== l && c !== c;
  }
  var n = typeof Object.is == "function" ? Object.is : t, r = e.useSyncExternalStore, i = e.useRef, a = e.useEffect, s = e.useMemo, o = e.useDebugValue;
  return yu.useSyncExternalStoreWithSelector = function(l, c, u, d, f) {
    var p = i(null);
    if (p.current === null) {
      var h = { hasValue: !1, value: null };
      p.current = h;
    } else h = p.current;
    p = s(
      function() {
        function m(_) {
          if (!b) {
            if (b = !0, y = _, _ = d(_), f !== void 0 && h.hasValue) {
              var x = h.value;
              if (f(x, _))
                return v = x;
            }
            return v = _;
          }
          if (x = v, n(y, _)) return x;
          var I = d(_);
          return f !== void 0 && f(x, I) ? (y = _, x) : (y = _, v = I);
        }
        var b = !1, y, v, E = u === void 0 ? null : u;
        return [
          function() {
            return m(c());
          },
          E === null ? void 0 : function() {
            return m(E());
          }
        ];
      },
      [c, u, d, f]
    );
    var g = r(l, p[0], p[1]);
    return a(
      function() {
        h.hasValue = !0, h.value = g;
      },
      [g]
    ), o(g), g;
  }, yu;
}
var _u = {};
/**
 * @license React
 * use-sync-external-store-with-selector.development.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Gg;
function PF() {
  return Gg || (Gg = 1, process.env.NODE_ENV !== "production" && function() {
    function e(l, c) {
      return l === c && (l !== 0 || 1 / l === 1 / c) || l !== l && c !== c;
    }
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
    var t = De, n = typeof Object.is == "function" ? Object.is : e, r = t.useSyncExternalStore, i = t.useRef, a = t.useEffect, s = t.useMemo, o = t.useDebugValue;
    _u.useSyncExternalStoreWithSelector = function(l, c, u, d, f) {
      var p = i(null);
      if (p.current === null) {
        var h = { hasValue: !1, value: null };
        p.current = h;
      } else h = p.current;
      p = s(
        function() {
          function m(_) {
            if (!b) {
              if (b = !0, y = _, _ = d(_), f !== void 0 && h.hasValue) {
                var x = h.value;
                if (f(x, _))
                  return v = x;
              }
              return v = _;
            }
            if (x = v, n(y, _))
              return x;
            var I = d(_);
            return f !== void 0 && f(x, I) ? (y = _, x) : (y = _, v = I);
          }
          var b = !1, y, v, E = u === void 0 ? null : u;
          return [
            function() {
              return m(c());
            },
            E === null ? void 0 : function() {
              return m(E());
            }
          ];
        },
        [c, u, d, f]
      );
      var g = r(l, p[0], p[1]);
      return a(
        function() {
          h.hasValue = !0, h.value = g;
        },
        [g]
      ), o(g), g;
    }, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
  }()), _u;
}
var jg;
function DF() {
  return jg || (jg = 1, process.env.NODE_ENV === "production" ? To.exports = MF() : To.exports = PF()), To.exports;
}
var LF = DF(), vu = /* @__PURE__ */ Symbol.for("react-redux-context"), xu = typeof globalThis < "u" ? globalThis : (
  /* fall back to a per-module scope (pre-8.1 behaviour) if `globalThis` is not available */
  {}
);
function FF() {
  if (!F.createContext) return {};
  const e = xu[vu] ?? (xu[vu] = /* @__PURE__ */ new Map());
  let t = e.get(F.createContext);
  return t || (t = F.createContext(
    null
  ), process.env.NODE_ENV !== "production" && (t.displayName = "ReactRedux"), e.set(F.createContext, t)), t;
}
var yd = /* @__PURE__ */ FF();
function z0(e = yd) {
  return function() {
    const n = F.useContext(e);
    if (process.env.NODE_ENV !== "production" && !n)
      throw new Error(
        "could not find react-redux context value; please ensure the component is wrapped in a <Provider>"
      );
    return n;
  };
}
var BF = /* @__PURE__ */ z0(), zF = (e, t) => e === t;
function VF(e = yd) {
  const t = e === yd ? BF : z0(e), n = (r, i = {}) => {
    const { equalityFn: a = zF } = typeof i == "function" ? { equalityFn: i } : i;
    if (process.env.NODE_ENV !== "production") {
      if (!r)
        throw new Error("You must pass a selector to useSelector");
      if (typeof r != "function")
        throw new Error("You must pass a function as a selector to useSelector");
      if (typeof a != "function")
        throw new Error(
          "You must pass a function as an equality function to useSelector"
        );
    }
    const s = t(), { store: o, subscription: l, getServerState: c } = s, u = F.useRef(!0), d = F.useCallback(
      {
        [r.name](p) {
          const h = r(p);
          if (process.env.NODE_ENV !== "production") {
            const { devModeChecks: g = {} } = typeof i == "function" ? {} : i, { identityFunctionCheck: m, stabilityCheck: b } = s, {
              identityFunctionCheck: y,
              stabilityCheck: v
            } = {
              stabilityCheck: b,
              identityFunctionCheck: m,
              ...g
            };
            if (v === "always" || v === "once" && u.current) {
              const E = r(p);
              if (!a(h, E)) {
                let _;
                try {
                  throw new Error();
                } catch (x) {
                  ({ stack: _ } = x);
                }
                console.warn(
                  "Selector " + (r.name || "unknown") + ` returned a different result when called with the same parameters. This can lead to unnecessary rerenders.
Selectors that return a new reference (such as an object or an array) should be memoized: https://redux.js.org/usage/deriving-data-selectors#optimizing-selectors-with-memoization`,
                  {
                    state: p,
                    selected: h,
                    selected2: E,
                    stack: _
                  }
                );
              }
            }
            if ((y === "always" || y === "once" && u.current) && h === p) {
              let E;
              try {
                throw new Error();
              } catch (_) {
                ({ stack: E } = _);
              }
              console.warn(
                "Selector " + (r.name || "unknown") + ` returned the root state when called. This can lead to unnecessary rerenders.
Selectors that return the entire state are almost certainly a mistake, as they will cause a rerender whenever *anything* in state changes.`,
                { stack: E }
              );
            }
            u.current && (u.current = !1);
          }
          return h;
        }
      }[r.name],
      [r]
    ), f = LF.useSyncExternalStoreWithSelector(
      l.addNestedSub,
      o.getState,
      c || o.getState,
      d,
      a
    );
    return F.useDebugValue(f), f;
  };
  return Object.assign(n, {
    withTypes: () => n
  }), n;
}
var GF = /* @__PURE__ */ VF();
const jF = Bl(void 0), UF = ({ children: e }) => /* @__PURE__ */ w.jsx(
  jF.Provider,
  {
    value: {
      accessToken: GF((t) => t.authSlice.accessToken)
    },
    children: e
  }
), _4 = { Auth: UF }, V0 = (e, t, n) => {
  const r = e[t];
  return r ? typeof r == "function" ? r() : Promise.resolve(r) : new Promise((i, a) => {
    (typeof queueMicrotask == "function" ? queueMicrotask : setTimeout)(
      a.bind(
        null,
        new Error(
          "Unknown variable dynamic import: " + t + (t.split("/").length !== n ? ". Note that variables only represent file names one level deep." : "")
        )
      )
    );
  });
};
function G0(e) {
  return (n) => {
    const r = gn(null);
    return er(() => {
      r.current && Pa.fromTo(r.current, { opacity: 0 }, { opacity: 1, duration: 1 });
    }, []), /* @__PURE__ */ w.jsx("div", { ref: r, style: { width: "100%", display: "flex", justifyContent: "center" }, children: /* @__PURE__ */ w.jsx(e, { ...n }) });
  };
}
function HF(e, t) {
  const n = dm(async () => {
    await new Promise((o) => setTimeout(o, 500));
    const r = e.layoutName, i = r.charAt(0).toLowerCase() + r.slice(1), a = await V0(/* @__PURE__ */ Object.assign({}), `../layouts/${i}/${e.layoutName}Layout.ts`, 4);
    return { default: G0(a.default) };
  });
  return /* @__PURE__ */ w.jsx(fm, { fallback: e.loader, children: /* @__PURE__ */ w.jsx(n, { ...t }) });
}
function WF(e, t) {
  const n = dm(async () => {
    await new Promise((o) => setTimeout(o, 500));
    const r = e.pageName, i = r.charAt(0).toLowerCase() + r.slice(1), a = await V0(/* @__PURE__ */ Object.assign({}), `../pages/${i}/${e.pageName}Page.ts`, 4);
    return { default: G0(a.default) };
  });
  return /* @__PURE__ */ w.jsx(fm, { fallback: e.loader, children: /* @__PURE__ */ w.jsx(n, { ...t }) });
}
function ZF(e) {
  return (n) => {
    const r = nr(), i = sc();
    return /* @__PURE__ */ w.jsx(e, { ...n, router: { location: r, navigate: i } });
  };
}
const v4 = { withDynamicLayouts: HF, withDynamicPages: WF, withRouter: ZF };
function $F(e) {
  if (typeof e != "object" || e === null)
    return !1;
  let t = e;
  for (; Object.getPrototypeOf(t) !== null; )
    t = Object.getPrototypeOf(t);
  return Object.getPrototypeOf(e) === t || Object.getPrototypeOf(e) === null;
}
function XF(e) {
  return $F(e) && "type" in e && typeof e.type == "string";
}
var j0 = Symbol.for("immer-nothing"), Ug = Symbol.for("immer-draftable"), Ln = Symbol.for("immer-state"), YF = process.env.NODE_ENV !== "production" ? [
  // All error codes, starting by 0:
  function(e) {
    return `The plugin for '${e}' has not been loaded into Immer. To enable the plugin, import and call \`enable${e}()\` when initializing your application.`;
  },
  function(e) {
    return `produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '${e}'`;
  },
  "This object has been frozen and should not be mutated",
  function(e) {
    return "Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? " + e;
  },
  "An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.",
  "Immer forbids circular references",
  "The first or second argument to `produce` must be a function",
  "The third argument to `produce` must be a function or undefined",
  "First argument to `createDraft` must be a plain object, an array, or an immerable object",
  "First argument to `finishDraft` must be a draft returned by `createDraft`",
  function(e) {
    return `'current' expects a draft, got: ${e}`;
  },
  "Object.defineProperty() cannot be used on an Immer draft",
  "Object.setPrototypeOf() cannot be used on an Immer draft",
  "Immer only supports deleting array indices",
  "Immer only supports setting array indices and the 'length' property",
  function(e) {
    return `'original' expects a draft, got: ${e}`;
  }
  // Note: if more errors are added, the errorOffset in Patches.ts should be increased
  // See Patches.ts for additional errors
] : [];
function hn(e, ...t) {
  if (process.env.NODE_ENV !== "production") {
    const n = YF[e], r = typeof n == "function" ? n.apply(null, t) : n;
    throw new Error(`[Immer] ${r}`);
  }
  throw new Error(
    `[Immer] minified error nr: ${e}. Full error at: https://bit.ly/3cXEKWf`
  );
}
var ka = Object.getPrototypeOf;
function Mi(e) {
  return !!e && !!e[Ln];
}
function Gr(e) {
  var t;
  return e ? U0(e) || Array.isArray(e) || !!e[Ug] || !!((t = e.constructor) != null && t[Ug]) || fc(e) || pc(e) : !1;
}
var JF = Object.prototype.constructor.toString();
function U0(e) {
  if (!e || typeof e != "object")
    return !1;
  const t = ka(e);
  if (t === null)
    return !0;
  const n = Object.hasOwnProperty.call(t, "constructor") && t.constructor;
  return n === Object ? !0 : typeof n == "function" && Function.toString.call(n) === JF;
}
function Ol(e, t) {
  dc(e) === 0 ? Reflect.ownKeys(e).forEach((n) => {
    t(n, e[n], e);
  }) : e.forEach((n, r) => t(r, n, e));
}
function dc(e) {
  const t = e[Ln];
  return t ? t.type_ : Array.isArray(e) ? 1 : fc(e) ? 2 : pc(e) ? 3 : 0;
}
function _d(e, t) {
  return dc(e) === 2 ? e.has(t) : Object.prototype.hasOwnProperty.call(e, t);
}
function H0(e, t, n) {
  const r = dc(e);
  r === 2 ? e.set(t, n) : r === 3 ? e.add(n) : e[t] = n;
}
function qF(e, t) {
  return e === t ? e !== 0 || 1 / e === 1 / t : e !== e && t !== t;
}
function fc(e) {
  return e instanceof Map;
}
function pc(e) {
  return e instanceof Set;
}
function hi(e) {
  return e.copy_ || e.base_;
}
function vd(e, t) {
  if (fc(e))
    return new Map(e);
  if (pc(e))
    return new Set(e);
  if (Array.isArray(e))
    return Array.prototype.slice.call(e);
  const n = U0(e);
  if (t === !0 || t === "class_only" && !n) {
    const r = Object.getOwnPropertyDescriptors(e);
    delete r[Ln];
    let i = Reflect.ownKeys(r);
    for (let a = 0; a < i.length; a++) {
      const s = i[a], o = r[s];
      o.writable === !1 && (o.writable = !0, o.configurable = !0), (o.get || o.set) && (r[s] = {
        configurable: !0,
        writable: !0,
        // could live with !!desc.set as well here...
        enumerable: o.enumerable,
        value: e[s]
      });
    }
    return Object.create(ka(e), r);
  } else {
    const r = ka(e);
    if (r !== null && n)
      return { ...e };
    const i = Object.create(r);
    return Object.assign(i, e);
  }
}
function Yf(e, t = !1) {
  return hc(e) || Mi(e) || !Gr(e) || (dc(e) > 1 && (e.set = e.add = e.clear = e.delete = KF), Object.freeze(e), t && Object.entries(e).forEach(([n, r]) => Yf(r, !0))), e;
}
function KF() {
  hn(2);
}
function hc(e) {
  return Object.isFrozen(e);
}
var QF = {};
function Pi(e) {
  const t = QF[e];
  return t || hn(0, e), t;
}
var js;
function W0() {
  return js;
}
function eB(e, t) {
  return {
    drafts_: [],
    parent_: e,
    immer_: t,
    // Whenever the modified draft contains a draft from another scope, we
    // need to prevent auto-freezing so the unowned draft can be finalized.
    canAutoFreeze_: !0,
    unfinalizedDrafts_: 0
  };
}
function Hg(e, t) {
  t && (Pi("Patches"), e.patches_ = [], e.inversePatches_ = [], e.patchListener_ = t);
}
function xd(e) {
  Ed(e), e.drafts_.forEach(tB), e.drafts_ = null;
}
function Ed(e) {
  e === js && (js = e.parent_);
}
function Wg(e) {
  return js = eB(js, e);
}
function tB(e) {
  const t = e[Ln];
  t.type_ === 0 || t.type_ === 1 ? t.revoke_() : t.revoked_ = !0;
}
function Zg(e, t) {
  t.unfinalizedDrafts_ = t.drafts_.length;
  const n = t.drafts_[0];
  return e !== void 0 && e !== n ? (n[Ln].modified_ && (xd(t), hn(4)), Gr(e) && (e = Ml(t, e), t.parent_ || Pl(t, e)), t.patches_ && Pi("Patches").generateReplacementPatches_(
    n[Ln].base_,
    e,
    t.patches_,
    t.inversePatches_
  )) : e = Ml(t, n, []), xd(t), t.patches_ && t.patchListener_(t.patches_, t.inversePatches_), e !== j0 ? e : void 0;
}
function Ml(e, t, n) {
  if (hc(t))
    return t;
  const r = t[Ln];
  if (!r)
    return Ol(
      t,
      (i, a) => $g(e, r, t, i, a, n)
    ), t;
  if (r.scope_ !== e)
    return t;
  if (!r.modified_)
    return Pl(e, r.base_, !0), r.base_;
  if (!r.finalized_) {
    r.finalized_ = !0, r.scope_.unfinalizedDrafts_--;
    const i = r.copy_;
    let a = i, s = !1;
    r.type_ === 3 && (a = new Set(i), i.clear(), s = !0), Ol(
      a,
      (o, l) => $g(e, r, i, o, l, n, s)
    ), Pl(e, i, !1), n && e.patches_ && Pi("Patches").generatePatches_(
      r,
      n,
      e.patches_,
      e.inversePatches_
    );
  }
  return r.copy_;
}
function $g(e, t, n, r, i, a, s) {
  if (process.env.NODE_ENV !== "production" && i === n && hn(5), Mi(i)) {
    const o = a && t && t.type_ !== 3 && // Set objects are atomic since they have no keys.
    !_d(t.assigned_, r) ? a.concat(r) : void 0, l = Ml(e, i, o);
    if (H0(n, r, l), Mi(l))
      e.canAutoFreeze_ = !1;
    else
      return;
  } else s && n.add(i);
  if (Gr(i) && !hc(i)) {
    if (!e.immer_.autoFreeze_ && e.unfinalizedDrafts_ < 1)
      return;
    Ml(e, i), (!t || !t.scope_.parent_) && typeof r != "symbol" && Object.prototype.propertyIsEnumerable.call(n, r) && Pl(e, i);
  }
}
function Pl(e, t, n = !1) {
  !e.parent_ && e.immer_.autoFreeze_ && e.canAutoFreeze_ && Yf(t, n);
}
function nB(e, t) {
  const n = Array.isArray(e), r = {
    type_: n ? 1 : 0,
    // Track which produce call this is associated with.
    scope_: t ? t.scope_ : W0(),
    // True for both shallow and deep changes.
    modified_: !1,
    // Used during finalization.
    finalized_: !1,
    // Track which properties have been assigned (true) or deleted (false).
    assigned_: {},
    // The parent draft state.
    parent_: t,
    // The base state.
    base_: e,
    // The base proxy.
    draft_: null,
    // set below
    // The base copy with any updated values.
    copy_: null,
    // Called by the `produce` function.
    revoke_: null,
    isManual_: !1
  };
  let i = r, a = Jf;
  n && (i = [r], a = Us);
  const { revoke: s, proxy: o } = Proxy.revocable(i, a);
  return r.draft_ = o, r.revoke_ = s, o;
}
var Jf = {
  get(e, t) {
    if (t === Ln)
      return e;
    const n = hi(e);
    if (!_d(n, t))
      return rB(e, n, t);
    const r = n[t];
    return e.finalized_ || !Gr(r) ? r : r === Eu(e.base_, t) ? (wu(e), e.copy_[t] = Cd(r, e)) : r;
  },
  has(e, t) {
    return t in hi(e);
  },
  ownKeys(e) {
    return Reflect.ownKeys(hi(e));
  },
  set(e, t, n) {
    const r = Z0(hi(e), t);
    if (r != null && r.set)
      return r.set.call(e.draft_, n), !0;
    if (!e.modified_) {
      const i = Eu(hi(e), t), a = i == null ? void 0 : i[Ln];
      if (a && a.base_ === n)
        return e.copy_[t] = n, e.assigned_[t] = !1, !0;
      if (qF(n, i) && (n !== void 0 || _d(e.base_, t)))
        return !0;
      wu(e), wd(e);
    }
    return e.copy_[t] === n && // special case: handle new props with value 'undefined'
    (n !== void 0 || t in e.copy_) || // special case: NaN
    Number.isNaN(n) && Number.isNaN(e.copy_[t]) || (e.copy_[t] = n, e.assigned_[t] = !0), !0;
  },
  deleteProperty(e, t) {
    return Eu(e.base_, t) !== void 0 || t in e.base_ ? (e.assigned_[t] = !1, wu(e), wd(e)) : delete e.assigned_[t], e.copy_ && delete e.copy_[t], !0;
  },
  // Note: We never coerce `desc.value` into an Immer draft, because we can't make
  // the same guarantee in ES5 mode.
  getOwnPropertyDescriptor(e, t) {
    const n = hi(e), r = Reflect.getOwnPropertyDescriptor(n, t);
    return r && {
      writable: !0,
      configurable: e.type_ !== 1 || t !== "length",
      enumerable: r.enumerable,
      value: n[t]
    };
  },
  defineProperty() {
    hn(11);
  },
  getPrototypeOf(e) {
    return ka(e.base_);
  },
  setPrototypeOf() {
    hn(12);
  }
}, Us = {};
Ol(Jf, (e, t) => {
  Us[e] = function() {
    return arguments[0] = arguments[0][0], t.apply(this, arguments);
  };
});
Us.deleteProperty = function(e, t) {
  return process.env.NODE_ENV !== "production" && isNaN(parseInt(t)) && hn(13), Us.set.call(this, e, t, void 0);
};
Us.set = function(e, t, n) {
  return process.env.NODE_ENV !== "production" && t !== "length" && isNaN(parseInt(t)) && hn(14), Jf.set.call(this, e[0], t, n, e[0]);
};
function Eu(e, t) {
  const n = e[Ln];
  return (n ? hi(n) : e)[t];
}
function rB(e, t, n) {
  var i;
  const r = Z0(t, n);
  return r ? "value" in r ? r.value : (
    // This is a very special case, if the prop is a getter defined by the
    // prototype, we should invoke it with the draft as context!
    (i = r.get) == null ? void 0 : i.call(e.draft_)
  ) : void 0;
}
function Z0(e, t) {
  if (!(t in e))
    return;
  let n = ka(e);
  for (; n; ) {
    const r = Object.getOwnPropertyDescriptor(n, t);
    if (r)
      return r;
    n = ka(n);
  }
}
function wd(e) {
  e.modified_ || (e.modified_ = !0, e.parent_ && wd(e.parent_));
}
function wu(e) {
  e.copy_ || (e.copy_ = vd(
    e.base_,
    e.scope_.immer_.useStrictShallowCopy_
  ));
}
var iB = class {
  constructor(e) {
    this.autoFreeze_ = !0, this.useStrictShallowCopy_ = !1, this.produce = (t, n, r) => {
      if (typeof t == "function" && typeof n != "function") {
        const a = n;
        n = t;
        const s = this;
        return function(l = a, ...c) {
          return s.produce(l, (u) => n.call(this, u, ...c));
        };
      }
      typeof n != "function" && hn(6), r !== void 0 && typeof r != "function" && hn(7);
      let i;
      if (Gr(t)) {
        const a = Wg(this), s = Cd(t, void 0);
        let o = !0;
        try {
          i = n(s), o = !1;
        } finally {
          o ? xd(a) : Ed(a);
        }
        return Hg(a, r), Zg(i, a);
      } else if (!t || typeof t != "object") {
        if (i = n(t), i === void 0 && (i = t), i === j0 && (i = void 0), this.autoFreeze_ && Yf(i, !0), r) {
          const a = [], s = [];
          Pi("Patches").generateReplacementPatches_(t, i, a, s), r(a, s);
        }
        return i;
      } else
        hn(1, t);
    }, this.produceWithPatches = (t, n) => {
      if (typeof t == "function")
        return (s, ...o) => this.produceWithPatches(s, (l) => t(l, ...o));
      let r, i;
      return [this.produce(t, n, (s, o) => {
        r = s, i = o;
      }), r, i];
    }, typeof (e == null ? void 0 : e.autoFreeze) == "boolean" && this.setAutoFreeze(e.autoFreeze), typeof (e == null ? void 0 : e.useStrictShallowCopy) == "boolean" && this.setUseStrictShallowCopy(e.useStrictShallowCopy);
  }
  createDraft(e) {
    Gr(e) || hn(8), Mi(e) && (e = aB(e));
    const t = Wg(this), n = Cd(e, void 0);
    return n[Ln].isManual_ = !0, Ed(t), n;
  }
  finishDraft(e, t) {
    const n = e && e[Ln];
    (!n || !n.isManual_) && hn(9);
    const { scope_: r } = n;
    return Hg(r, t), Zg(void 0, r);
  }
  /**
   * Pass true to automatically freeze all copies created by Immer.
   *
   * By default, auto-freezing is enabled.
   */
  setAutoFreeze(e) {
    this.autoFreeze_ = e;
  }
  /**
   * Pass true to enable strict shallow copy.
   *
   * By default, immer does not copy the object descriptors such as getter, setter and non-enumrable properties.
   */
  setUseStrictShallowCopy(e) {
    this.useStrictShallowCopy_ = e;
  }
  applyPatches(e, t) {
    let n;
    for (n = t.length - 1; n >= 0; n--) {
      const i = t[n];
      if (i.path.length === 0 && i.op === "replace") {
        e = i.value;
        break;
      }
    }
    n > -1 && (t = t.slice(n + 1));
    const r = Pi("Patches").applyPatches_;
    return Mi(e) ? r(e, t) : this.produce(
      e,
      (i) => r(i, t)
    );
  }
};
function Cd(e, t) {
  const n = fc(e) ? Pi("MapSet").proxyMap_(e, t) : pc(e) ? Pi("MapSet").proxySet_(e, t) : nB(e, t);
  return (t ? t.scope_ : W0()).drafts_.push(n), n;
}
function aB(e) {
  return Mi(e) || hn(10, e), $0(e);
}
function $0(e) {
  if (!Gr(e) || hc(e))
    return e;
  const t = e[Ln];
  let n;
  if (t) {
    if (!t.modified_)
      return t.base_;
    t.finalized_ = !0, n = vd(e, t.scope_.immer_.useStrictShallowCopy_);
  } else
    n = vd(e, !0);
  return Ol(n, (r, i) => {
    H0(n, r, $0(i));
  }), t && (t.finalized_ = !1), n;
}
var Fn = new iB(), X0 = Fn.produce;
Fn.produceWithPatches.bind(
  Fn
);
Fn.setAutoFreeze.bind(Fn);
Fn.setUseStrictShallowCopy.bind(Fn);
Fn.applyPatches.bind(Fn);
Fn.createDraft.bind(Fn);
Fn.finishDraft.bind(Fn);
var sB = (e) => e && typeof e.match == "function";
function ps(e, t) {
  function n(...r) {
    if (t) {
      let i = t(...r);
      if (!i)
        throw new Error(process.env.NODE_ENV === "production" ? Wt(0) : "prepareAction did not return an object");
      return {
        type: e,
        payload: i.payload,
        ..."meta" in i && {
          meta: i.meta
        },
        ..."error" in i && {
          error: i.error
        }
      };
    }
    return {
      type: e,
      payload: r[0]
    };
  }
  return n.toString = () => `${e}`, n.type = e, n.match = (r) => XF(r) && r.type === e, n;
}
function Xg(e) {
  return Gr(e) ? X0(e, () => {
  }) : e;
}
function Yg(e, t, n) {
  return e.has(t) ? e.get(t) : e.set(t, n(t)).get(t);
}
function Y0(e) {
  const t = {}, n = [];
  let r;
  const i = {
    addCase(a, s) {
      if (process.env.NODE_ENV !== "production") {
        if (n.length > 0)
          throw new Error(process.env.NODE_ENV === "production" ? Wt(26) : "`builder.addCase` should only be called before calling `builder.addMatcher`");
        if (r)
          throw new Error(process.env.NODE_ENV === "production" ? Wt(27) : "`builder.addCase` should only be called before calling `builder.addDefaultCase`");
      }
      const o = typeof a == "string" ? a : a.type;
      if (!o)
        throw new Error(process.env.NODE_ENV === "production" ? Wt(28) : "`builder.addCase` cannot be called with an empty action type");
      if (o in t)
        throw new Error(process.env.NODE_ENV === "production" ? Wt(29) : `\`builder.addCase\` cannot be called with two reducers for the same action type '${o}'`);
      return t[o] = s, i;
    },
    addMatcher(a, s) {
      if (process.env.NODE_ENV !== "production" && r)
        throw new Error(process.env.NODE_ENV === "production" ? Wt(30) : "`builder.addMatcher` should only be called before calling `builder.addDefaultCase`");
      return n.push({
        matcher: a,
        reducer: s
      }), i;
    },
    addDefaultCase(a) {
      if (process.env.NODE_ENV !== "production" && r)
        throw new Error(process.env.NODE_ENV === "production" ? Wt(31) : "`builder.addDefaultCase` can only be called once");
      return r = a, i;
    }
  };
  return e(i), [t, n, r];
}
function oB(e) {
  return typeof e == "function";
}
function lB(e, t) {
  if (process.env.NODE_ENV !== "production" && typeof t == "object")
    throw new Error(process.env.NODE_ENV === "production" ? Wt(8) : "The object notation for `createReducer` has been removed. Please use the 'builder callback' notation instead: https://redux-toolkit.js.org/api/createReducer");
  let [n, r, i] = Y0(t), a;
  if (oB(e))
    a = () => Xg(e());
  else {
    const o = Xg(e);
    a = () => o;
  }
  function s(o = a(), l) {
    let c = [n[l.type], ...r.filter(({
      matcher: u
    }) => u(l)).map(({
      reducer: u
    }) => u)];
    return c.filter((u) => !!u).length === 0 && (c = [i]), c.reduce((u, d) => {
      if (d)
        if (Mi(u)) {
          const p = d(u, l);
          return p === void 0 ? u : p;
        } else {
          if (Gr(u))
            return X0(u, (f) => d(f, l));
          {
            const f = d(u, l);
            if (f === void 0) {
              if (u === null)
                return u;
              throw Error("A case reducer on a non-draftable value must not return undefined");
            }
            return f;
          }
        }
      return u;
    }, o);
  }
  return s.getInitialState = a, s;
}
var cB = (e, t) => sB(e) ? e.match(t) : e(t);
function uB(...e) {
  return (t) => e.some((n) => cB(n, t));
}
var dB = "ModuleSymbhasOwnPr-0123456789ABCDEFGHNRVfgctiUvz_KqYTJkLxpZXIjQW", fB = (e = 21) => {
  let t = "", n = e;
  for (; n--; )
    t += dB[Math.random() * 64 | 0];
  return t;
}, pB = ["name", "message", "stack", "code"], Cu = class {
  constructor(e, t) {
    /*
    type-only property to distinguish between RejectWithValue and FulfillWithMeta
    does not exist at runtime
    */
    Ac(this, "_type");
    this.payload = e, this.meta = t;
  }
}, Jg = class {
  constructor(e, t) {
    /*
    type-only property to distinguish between RejectWithValue and FulfillWithMeta
    does not exist at runtime
    */
    Ac(this, "_type");
    this.payload = e, this.meta = t;
  }
}, hB = (e) => {
  if (typeof e == "object" && e !== null) {
    const t = {};
    for (const n of pB)
      typeof e[n] == "string" && (t[n] = e[n]);
    return t;
  }
  return {
    message: String(e)
  };
}, qf = /* @__PURE__ */ (() => {
  function e(t, n, r) {
    const i = ps(t + "/fulfilled", (l, c, u, d) => ({
      payload: l,
      meta: {
        ...d || {},
        arg: u,
        requestId: c,
        requestStatus: "fulfilled"
      }
    })), a = ps(t + "/pending", (l, c, u) => ({
      payload: void 0,
      meta: {
        ...u || {},
        arg: c,
        requestId: l,
        requestStatus: "pending"
      }
    })), s = ps(t + "/rejected", (l, c, u, d, f) => ({
      payload: d,
      error: (r && r.serializeError || hB)(l || "Rejected"),
      meta: {
        ...f || {},
        arg: u,
        requestId: c,
        rejectedWithValue: !!d,
        requestStatus: "rejected",
        aborted: (l == null ? void 0 : l.name) === "AbortError",
        condition: (l == null ? void 0 : l.name) === "ConditionError"
      }
    }));
    function o(l) {
      return (c, u, d) => {
        const f = r != null && r.idGenerator ? r.idGenerator(l) : fB(), p = new AbortController();
        let h, g;
        function m(y) {
          g = y, p.abort();
        }
        const b = async function() {
          var E, _;
          let y;
          try {
            let x = (E = r == null ? void 0 : r.condition) == null ? void 0 : E.call(r, l, {
              getState: u,
              extra: d
            });
            if (mB(x) && (x = await x), x === !1 || p.signal.aborted)
              throw {
                name: "ConditionError",
                message: "Aborted due to condition callback returning false."
              };
            const I = new Promise((T, O) => {
              h = () => {
                O({
                  name: "AbortError",
                  message: g || "Aborted"
                });
              }, p.signal.addEventListener("abort", h);
            });
            c(a(f, l, (_ = r == null ? void 0 : r.getPendingMeta) == null ? void 0 : _.call(r, {
              requestId: f,
              arg: l
            }, {
              getState: u,
              extra: d
            }))), y = await Promise.race([I, Promise.resolve(n(l, {
              dispatch: c,
              getState: u,
              extra: d,
              requestId: f,
              signal: p.signal,
              abort: m,
              rejectWithValue: (T, O) => new Cu(T, O),
              fulfillWithValue: (T, O) => new Jg(T, O)
            })).then((T) => {
              if (T instanceof Cu)
                throw T;
              return T instanceof Jg ? i(T.payload, f, l, T.meta) : i(T, f, l);
            })]);
          } catch (x) {
            y = x instanceof Cu ? s(null, f, l, x.payload, x.meta) : s(x, f, l);
          } finally {
            h && p.signal.removeEventListener("abort", h);
          }
          return r && !r.dispatchConditionRejection && s.match(y) && y.meta.condition || c(y), y;
        }();
        return Object.assign(b, {
          abort: m,
          requestId: f,
          arg: l,
          unwrap() {
            return b.then(gB);
          }
        });
      };
    }
    return Object.assign(o, {
      pending: a,
      rejected: s,
      fulfilled: i,
      settled: uB(s, i),
      typePrefix: t
    });
  }
  return e.withTypes = () => e, e;
})();
function gB(e) {
  if (e.meta && e.meta.rejectedWithValue)
    throw e.payload;
  if (e.error)
    throw e.error;
  return e.payload;
}
function mB(e) {
  return e !== null && typeof e == "object" && typeof e.then == "function";
}
var bB = /* @__PURE__ */ Symbol.for("rtk-slice-createasyncthunk");
function yB(e, t) {
  return `${e}/${t}`;
}
function _B({
  creators: e
} = {}) {
  var n;
  const t = (n = e == null ? void 0 : e.asyncThunk) == null ? void 0 : n[bB];
  return function(i) {
    const {
      name: a,
      reducerPath: s = a
    } = i;
    if (!a)
      throw new Error(process.env.NODE_ENV === "production" ? Wt(11) : "`name` is a required option for createSlice");
    typeof process < "u" && process.env.NODE_ENV === "development" && i.initialState === void 0 && console.error("You must provide an `initialState` value that is not `undefined`. You may have misspelled `initialState`");
    const o = (typeof i.reducers == "function" ? i.reducers(EB()) : i.reducers) || {}, l = Object.keys(o), c = {
      sliceCaseReducersByName: {},
      sliceCaseReducersByType: {},
      actionCreators: {},
      sliceMatchers: []
    }, u = {
      addCase(v, E) {
        const _ = typeof v == "string" ? v : v.type;
        if (!_)
          throw new Error(process.env.NODE_ENV === "production" ? Wt(12) : "`context.addCase` cannot be called with an empty action type");
        if (_ in c.sliceCaseReducersByType)
          throw new Error(process.env.NODE_ENV === "production" ? Wt(13) : "`context.addCase` cannot be called with two reducers for the same action type: " + _);
        return c.sliceCaseReducersByType[_] = E, u;
      },
      addMatcher(v, E) {
        return c.sliceMatchers.push({
          matcher: v,
          reducer: E
        }), u;
      },
      exposeAction(v, E) {
        return c.actionCreators[v] = E, u;
      },
      exposeCaseReducer(v, E) {
        return c.sliceCaseReducersByName[v] = E, u;
      }
    };
    l.forEach((v) => {
      const E = o[v], _ = {
        reducerName: v,
        type: yB(a, v),
        createNotation: typeof i.reducers == "function"
      };
      CB(E) ? SB(_, E, u, t) : wB(_, E, u);
    });
    function d() {
      if (process.env.NODE_ENV !== "production" && typeof i.extraReducers == "object")
        throw new Error(process.env.NODE_ENV === "production" ? Wt(14) : "The object notation for `createSlice.extraReducers` has been removed. Please use the 'builder callback' notation instead: https://redux-toolkit.js.org/api/createSlice");
      const [v = {}, E = [], _ = void 0] = typeof i.extraReducers == "function" ? Y0(i.extraReducers) : [i.extraReducers], x = {
        ...v,
        ...c.sliceCaseReducersByType
      };
      return lB(i.initialState, (I) => {
        for (let T in x)
          I.addCase(T, x[T]);
        for (let T of c.sliceMatchers)
          I.addMatcher(T.matcher, T.reducer);
        for (let T of E)
          I.addMatcher(T.matcher, T.reducer);
        _ && I.addDefaultCase(_);
      });
    }
    const f = (v) => v, p = /* @__PURE__ */ new Map();
    let h;
    function g(v, E) {
      return h || (h = d()), h(v, E);
    }
    function m() {
      return h || (h = d()), h.getInitialState();
    }
    function b(v, E = !1) {
      function _(I) {
        let T = I[v];
        if (typeof T > "u") {
          if (E)
            T = m();
          else if (process.env.NODE_ENV !== "production")
            throw new Error(process.env.NODE_ENV === "production" ? Wt(15) : "selectSlice returned undefined for an uninjected slice reducer");
        }
        return T;
      }
      function x(I = f) {
        const T = Yg(p, E, () => /* @__PURE__ */ new WeakMap());
        return Yg(T, I, () => {
          const O = {};
          for (const [k, W] of Object.entries(i.selectors ?? {}))
            O[k] = vB(W, I, m, E);
          return O;
        });
      }
      return {
        reducerPath: v,
        getSelectors: x,
        get selectors() {
          return x(_);
        },
        selectSlice: _
      };
    }
    const y = {
      name: a,
      reducer: g,
      actions: c.actionCreators,
      caseReducers: c.sliceCaseReducersByName,
      getInitialState: m,
      ...b(s),
      injectInto(v, {
        reducerPath: E,
        ..._
      } = {}) {
        const x = E ?? s;
        return v.inject({
          reducerPath: x,
          reducer: g
        }, _), {
          ...y,
          ...b(x, !0)
        };
      }
    };
    return y;
  };
}
function vB(e, t, n, r) {
  function i(a, ...s) {
    let o = t(a);
    if (typeof o > "u") {
      if (r)
        o = n();
      else if (process.env.NODE_ENV !== "production")
        throw new Error(process.env.NODE_ENV === "production" ? Wt(16) : "selectState returned undefined for an uninjected slice reducer");
    }
    return e(o, ...s);
  }
  return i.unwrapped = e, i;
}
var xB = /* @__PURE__ */ _B();
function EB() {
  function e(t, n) {
    return {
      _reducerDefinitionType: "asyncThunk",
      payloadCreator: t,
      ...n
    };
  }
  return e.withTypes = () => e, {
    reducer(t) {
      return Object.assign({
        // hack so the wrapping function has the same name as the original
        // we need to create a wrapper so the `reducerDefinitionType` is not assigned to the original
        [t.name](...n) {
          return t(...n);
        }
      }[t.name], {
        _reducerDefinitionType: "reducer"
        /* reducer */
      });
    },
    preparedReducer(t, n) {
      return {
        _reducerDefinitionType: "reducerWithPrepare",
        prepare: t,
        reducer: n
      };
    },
    asyncThunk: e
  };
}
function wB({
  type: e,
  reducerName: t,
  createNotation: n
}, r, i) {
  let a, s;
  if ("reducer" in r) {
    if (n && !IB(r))
      throw new Error(process.env.NODE_ENV === "production" ? Wt(17) : "Please use the `create.preparedReducer` notation for prepared action creators with the `create` notation.");
    a = r.reducer, s = r.prepare;
  } else
    a = r;
  i.addCase(e, a).exposeCaseReducer(t, a).exposeAction(t, s ? ps(e, s) : ps(e));
}
function CB(e) {
  return e._reducerDefinitionType === "asyncThunk";
}
function IB(e) {
  return e._reducerDefinitionType === "reducerWithPrepare";
}
function SB({
  type: e,
  reducerName: t
}, n, r, i) {
  if (!i)
    throw new Error(process.env.NODE_ENV === "production" ? Wt(18) : "Cannot use `create.asyncThunk` in the built-in `createSlice`. Use `buildCreateSlice({ creators: { asyncThunk: asyncThunkCreator } })` to create a customised version of `createSlice`.");
  const {
    payloadCreator: a,
    fulfilled: s,
    pending: o,
    rejected: l,
    settled: c,
    options: u
  } = n, d = i(e, a, u);
  r.exposeAction(t, d), s && r.addCase(d.fulfilled, s), o && r.addCase(d.pending, o), l && r.addCase(d.rejected, l), c && r.addMatcher(d.settled, c), r.exposeCaseReducer(t, {
    fulfilled: s || Ro,
    pending: o || Ro,
    rejected: l || Ro,
    settled: c || Ro
  });
}
function Ro() {
}
function Wt(e) {
  return `Minified Redux Toolkit error #${e}; visit https://redux-toolkit.js.org/Errors?code=${e} for the full message or use the non-minified dev environment for full errors. `;
}
function J0(e, t) {
  return function() {
    return e.apply(t, arguments);
  };
}
const { toString: AB } = Object.prototype, { getPrototypeOf: Kf } = Object, gc = /* @__PURE__ */ ((e) => (t) => {
  const n = AB.call(t);
  return e[n] || (e[n] = n.slice(8, -1).toLowerCase());
})(/* @__PURE__ */ Object.create(null)), rr = (e) => (e = e.toLowerCase(), (t) => gc(t) === e), mc = (e) => (t) => typeof t === e, { isArray: La } = Array, Hs = mc("undefined");
function kB(e) {
  return e !== null && !Hs(e) && e.constructor !== null && !Hs(e.constructor) && Mn(e.constructor.isBuffer) && e.constructor.isBuffer(e);
}
const q0 = rr("ArrayBuffer");
function TB(e) {
  let t;
  return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? t = ArrayBuffer.isView(e) : t = e && e.buffer && q0(e.buffer), t;
}
const RB = mc("string"), Mn = mc("function"), K0 = mc("number"), bc = (e) => e !== null && typeof e == "object", NB = (e) => e === !0 || e === !1, jo = (e) => {
  if (gc(e) !== "object")
    return !1;
  const t = Kf(e);
  return (t === null || t === Object.prototype || Object.getPrototypeOf(t) === null) && !(Symbol.toStringTag in e) && !(Symbol.iterator in e);
}, OB = rr("Date"), MB = rr("File"), PB = rr("Blob"), DB = rr("FileList"), LB = (e) => bc(e) && Mn(e.pipe), FB = (e) => {
  let t;
  return e && (typeof FormData == "function" && e instanceof FormData || Mn(e.append) && ((t = gc(e)) === "formdata" || // detect form-data instance
  t === "object" && Mn(e.toString) && e.toString() === "[object FormData]"));
}, BB = rr("URLSearchParams"), [zB, VB, GB, jB] = ["ReadableStream", "Request", "Response", "Headers"].map(rr), UB = (e) => e.trim ? e.trim() : e.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
function ro(e, t, { allOwnKeys: n = !1 } = {}) {
  if (e === null || typeof e > "u")
    return;
  let r, i;
  if (typeof e != "object" && (e = [e]), La(e))
    for (r = 0, i = e.length; r < i; r++)
      t.call(null, e[r], r, e);
  else {
    const a = n ? Object.getOwnPropertyNames(e) : Object.keys(e), s = a.length;
    let o;
    for (r = 0; r < s; r++)
      o = a[r], t.call(null, e[o], o, e);
  }
}
function Q0(e, t) {
  t = t.toLowerCase();
  const n = Object.keys(e);
  let r = n.length, i;
  for (; r-- > 0; )
    if (i = n[r], t === i.toLowerCase())
      return i;
  return null;
}
const yi = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : global, ev = (e) => !Hs(e) && e !== yi;
function Id() {
  const { caseless: e } = ev(this) && this || {}, t = {}, n = (r, i) => {
    const a = e && Q0(t, i) || i;
    jo(t[a]) && jo(r) ? t[a] = Id(t[a], r) : jo(r) ? t[a] = Id({}, r) : La(r) ? t[a] = r.slice() : t[a] = r;
  };
  for (let r = 0, i = arguments.length; r < i; r++)
    arguments[r] && ro(arguments[r], n);
  return t;
}
const HB = (e, t, n, { allOwnKeys: r } = {}) => (ro(t, (i, a) => {
  n && Mn(i) ? e[a] = J0(i, n) : e[a] = i;
}, { allOwnKeys: r }), e), WB = (e) => (e.charCodeAt(0) === 65279 && (e = e.slice(1)), e), ZB = (e, t, n, r) => {
  e.prototype = Object.create(t.prototype, r), e.prototype.constructor = e, Object.defineProperty(e, "super", {
    value: t.prototype
  }), n && Object.assign(e.prototype, n);
}, $B = (e, t, n, r) => {
  let i, a, s;
  const o = {};
  if (t = t || {}, e == null) return t;
  do {
    for (i = Object.getOwnPropertyNames(e), a = i.length; a-- > 0; )
      s = i[a], (!r || r(s, e, t)) && !o[s] && (t[s] = e[s], o[s] = !0);
    e = n !== !1 && Kf(e);
  } while (e && (!n || n(e, t)) && e !== Object.prototype);
  return t;
}, XB = (e, t, n) => {
  e = String(e), (n === void 0 || n > e.length) && (n = e.length), n -= t.length;
  const r = e.indexOf(t, n);
  return r !== -1 && r === n;
}, YB = (e) => {
  if (!e) return null;
  if (La(e)) return e;
  let t = e.length;
  if (!K0(t)) return null;
  const n = new Array(t);
  for (; t-- > 0; )
    n[t] = e[t];
  return n;
}, JB = /* @__PURE__ */ ((e) => (t) => e && t instanceof e)(typeof Uint8Array < "u" && Kf(Uint8Array)), qB = (e, t) => {
  const r = (e && e[Symbol.iterator]).call(e);
  let i;
  for (; (i = r.next()) && !i.done; ) {
    const a = i.value;
    t.call(e, a[0], a[1]);
  }
}, KB = (e, t) => {
  let n;
  const r = [];
  for (; (n = e.exec(t)) !== null; )
    r.push(n);
  return r;
}, QB = rr("HTMLFormElement"), e9 = (e) => e.toLowerCase().replace(
  /[-_\s]([a-z\d])(\w*)/g,
  function(n, r, i) {
    return r.toUpperCase() + i;
  }
), qg = (({ hasOwnProperty: e }) => (t, n) => e.call(t, n))(Object.prototype), t9 = rr("RegExp"), tv = (e, t) => {
  const n = Object.getOwnPropertyDescriptors(e), r = {};
  ro(n, (i, a) => {
    let s;
    (s = t(i, a, e)) !== !1 && (r[a] = s || i);
  }), Object.defineProperties(e, r);
}, n9 = (e) => {
  tv(e, (t, n) => {
    if (Mn(e) && ["arguments", "caller", "callee"].indexOf(n) !== -1)
      return !1;
    const r = e[n];
    if (Mn(r)) {
      if (t.enumerable = !1, "writable" in t) {
        t.writable = !1;
        return;
      }
      t.set || (t.set = () => {
        throw Error("Can not rewrite read-only method '" + n + "'");
      });
    }
  });
}, r9 = (e, t) => {
  const n = {}, r = (i) => {
    i.forEach((a) => {
      n[a] = !0;
    });
  };
  return La(e) ? r(e) : r(String(e).split(t)), n;
}, i9 = () => {
}, a9 = (e, t) => e != null && Number.isFinite(e = +e) ? e : t, Iu = "abcdefghijklmnopqrstuvwxyz", Kg = "0123456789", nv = {
  DIGIT: Kg,
  ALPHA: Iu,
  ALPHA_DIGIT: Iu + Iu.toUpperCase() + Kg
}, s9 = (e = 16, t = nv.ALPHA_DIGIT) => {
  let n = "";
  const { length: r } = t;
  for (; e--; )
    n += t[Math.random() * r | 0];
  return n;
};
function o9(e) {
  return !!(e && Mn(e.append) && e[Symbol.toStringTag] === "FormData" && e[Symbol.iterator]);
}
const l9 = (e) => {
  const t = new Array(10), n = (r, i) => {
    if (bc(r)) {
      if (t.indexOf(r) >= 0)
        return;
      if (!("toJSON" in r)) {
        t[i] = r;
        const a = La(r) ? [] : {};
        return ro(r, (s, o) => {
          const l = n(s, i + 1);
          !Hs(l) && (a[o] = l);
        }), t[i] = void 0, a;
      }
    }
    return r;
  };
  return n(e, 0);
}, c9 = rr("AsyncFunction"), u9 = (e) => e && (bc(e) || Mn(e)) && Mn(e.then) && Mn(e.catch), rv = ((e, t) => e ? setImmediate : t ? ((n, r) => (yi.addEventListener("message", ({ source: i, data: a }) => {
  i === yi && a === n && r.length && r.shift()();
}, !1), (i) => {
  r.push(i), yi.postMessage(n, "*");
}))(`axios@${Math.random()}`, []) : (n) => setTimeout(n))(
  typeof setImmediate == "function",
  Mn(yi.postMessage)
), d9 = typeof queueMicrotask < "u" ? queueMicrotask.bind(yi) : typeof process < "u" && process.nextTick || rv, H = {
  isArray: La,
  isArrayBuffer: q0,
  isBuffer: kB,
  isFormData: FB,
  isArrayBufferView: TB,
  isString: RB,
  isNumber: K0,
  isBoolean: NB,
  isObject: bc,
  isPlainObject: jo,
  isReadableStream: zB,
  isRequest: VB,
  isResponse: GB,
  isHeaders: jB,
  isUndefined: Hs,
  isDate: OB,
  isFile: MB,
  isBlob: PB,
  isRegExp: t9,
  isFunction: Mn,
  isStream: LB,
  isURLSearchParams: BB,
  isTypedArray: JB,
  isFileList: DB,
  forEach: ro,
  merge: Id,
  extend: HB,
  trim: UB,
  stripBOM: WB,
  inherits: ZB,
  toFlatObject: $B,
  kindOf: gc,
  kindOfTest: rr,
  endsWith: XB,
  toArray: YB,
  forEachEntry: qB,
  matchAll: KB,
  isHTMLForm: QB,
  hasOwnProperty: qg,
  hasOwnProp: qg,
  // an alias to avoid ESLint no-prototype-builtins detection
  reduceDescriptors: tv,
  freezeMethods: n9,
  toObjectSet: r9,
  toCamelCase: e9,
  noop: i9,
  toFiniteNumber: a9,
  findKey: Q0,
  global: yi,
  isContextDefined: ev,
  ALPHABET: nv,
  generateString: s9,
  isSpecCompliantForm: o9,
  toJSONObject: l9,
  isAsyncFn: c9,
  isThenable: u9,
  setImmediate: rv,
  asap: d9
};
function Ne(e, t, n, r, i) {
  Error.call(this), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error().stack, this.message = e, this.name = "AxiosError", t && (this.code = t), n && (this.config = n), r && (this.request = r), i && (this.response = i, this.status = i.status ? i.status : null);
}
H.inherits(Ne, Error, {
  toJSON: function() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: H.toJSONObject(this.config),
      code: this.code,
      status: this.status
    };
  }
});
const iv = Ne.prototype, av = {};
[
  "ERR_BAD_OPTION_VALUE",
  "ERR_BAD_OPTION",
  "ECONNABORTED",
  "ETIMEDOUT",
  "ERR_NETWORK",
  "ERR_FR_TOO_MANY_REDIRECTS",
  "ERR_DEPRECATED",
  "ERR_BAD_RESPONSE",
  "ERR_BAD_REQUEST",
  "ERR_CANCELED",
  "ERR_NOT_SUPPORT",
  "ERR_INVALID_URL"
  // eslint-disable-next-line func-names
].forEach((e) => {
  av[e] = { value: e };
});
Object.defineProperties(Ne, av);
Object.defineProperty(iv, "isAxiosError", { value: !0 });
Ne.from = (e, t, n, r, i, a) => {
  const s = Object.create(iv);
  return H.toFlatObject(e, s, function(l) {
    return l !== Error.prototype;
  }, (o) => o !== "isAxiosError"), Ne.call(s, e.message, t, n, r, i), s.cause = e, s.name = e.name, a && Object.assign(s, a), s;
};
const f9 = null;
function Sd(e) {
  return H.isPlainObject(e) || H.isArray(e);
}
function sv(e) {
  return H.endsWith(e, "[]") ? e.slice(0, -2) : e;
}
function Qg(e, t, n) {
  return e ? e.concat(t).map(function(i, a) {
    return i = sv(i), !n && a ? "[" + i + "]" : i;
  }).join(n ? "." : "") : t;
}
function p9(e) {
  return H.isArray(e) && !e.some(Sd);
}
const h9 = H.toFlatObject(H, {}, null, function(t) {
  return /^is[A-Z]/.test(t);
});
function yc(e, t, n) {
  if (!H.isObject(e))
    throw new TypeError("target must be an object");
  t = t || new FormData(), n = H.toFlatObject(n, {
    metaTokens: !0,
    dots: !1,
    indexes: !1
  }, !1, function(g, m) {
    return !H.isUndefined(m[g]);
  });
  const r = n.metaTokens, i = n.visitor || u, a = n.dots, s = n.indexes, l = (n.Blob || typeof Blob < "u" && Blob) && H.isSpecCompliantForm(t);
  if (!H.isFunction(i))
    throw new TypeError("visitor must be a function");
  function c(h) {
    if (h === null) return "";
    if (H.isDate(h))
      return h.toISOString();
    if (!l && H.isBlob(h))
      throw new Ne("Blob is not supported. Use a Buffer instead.");
    return H.isArrayBuffer(h) || H.isTypedArray(h) ? l && typeof Blob == "function" ? new Blob([h]) : Buffer.from(h) : h;
  }
  function u(h, g, m) {
    let b = h;
    if (h && !m && typeof h == "object") {
      if (H.endsWith(g, "{}"))
        g = r ? g : g.slice(0, -2), h = JSON.stringify(h);
      else if (H.isArray(h) && p9(h) || (H.isFileList(h) || H.endsWith(g, "[]")) && (b = H.toArray(h)))
        return g = sv(g), b.forEach(function(v, E) {
          !(H.isUndefined(v) || v === null) && t.append(
            // eslint-disable-next-line no-nested-ternary
            s === !0 ? Qg([g], E, a) : s === null ? g : g + "[]",
            c(v)
          );
        }), !1;
    }
    return Sd(h) ? !0 : (t.append(Qg(m, g, a), c(h)), !1);
  }
  const d = [], f = Object.assign(h9, {
    defaultVisitor: u,
    convertValue: c,
    isVisitable: Sd
  });
  function p(h, g) {
    if (!H.isUndefined(h)) {
      if (d.indexOf(h) !== -1)
        throw Error("Circular reference detected in " + g.join("."));
      d.push(h), H.forEach(h, function(b, y) {
        (!(H.isUndefined(b) || b === null) && i.call(
          t,
          b,
          H.isString(y) ? y.trim() : y,
          g,
          f
        )) === !0 && p(b, g ? g.concat(y) : [y]);
      }), d.pop();
    }
  }
  if (!H.isObject(e))
    throw new TypeError("data must be an object");
  return p(e), t;
}
function em(e) {
  const t = {
    "!": "%21",
    "'": "%27",
    "(": "%28",
    ")": "%29",
    "~": "%7E",
    "%20": "+",
    "%00": "\0"
  };
  return encodeURIComponent(e).replace(/[!'()~]|%20|%00/g, function(r) {
    return t[r];
  });
}
function Qf(e, t) {
  this._pairs = [], e && yc(e, this, t);
}
const ov = Qf.prototype;
ov.append = function(t, n) {
  this._pairs.push([t, n]);
};
ov.toString = function(t) {
  const n = t ? function(r) {
    return t.call(this, r, em);
  } : em;
  return this._pairs.map(function(i) {
    return n(i[0]) + "=" + n(i[1]);
  }, "").join("&");
};
function g9(e) {
  return encodeURIComponent(e).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
}
function lv(e, t, n) {
  if (!t)
    return e;
  const r = n && n.encode || g9;
  H.isFunction(n) && (n = {
    serialize: n
  });
  const i = n && n.serialize;
  let a;
  if (i ? a = i(t, n) : a = H.isURLSearchParams(t) ? t.toString() : new Qf(t, n).toString(r), a) {
    const s = e.indexOf("#");
    s !== -1 && (e = e.slice(0, s)), e += (e.indexOf("?") === -1 ? "?" : "&") + a;
  }
  return e;
}
class tm {
  constructor() {
    this.handlers = [];
  }
  /**
   * Add a new interceptor to the stack
   *
   * @param {Function} fulfilled The function to handle `then` for a `Promise`
   * @param {Function} rejected The function to handle `reject` for a `Promise`
   *
   * @return {Number} An ID used to remove interceptor later
   */
  use(t, n, r) {
    return this.handlers.push({
      fulfilled: t,
      rejected: n,
      synchronous: r ? r.synchronous : !1,
      runWhen: r ? r.runWhen : null
    }), this.handlers.length - 1;
  }
  /**
   * Remove an interceptor from the stack
   *
   * @param {Number} id The ID that was returned by `use`
   *
   * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
   */
  eject(t) {
    this.handlers[t] && (this.handlers[t] = null);
  }
  /**
   * Clear all interceptors from the stack
   *
   * @returns {void}
   */
  clear() {
    this.handlers && (this.handlers = []);
  }
  /**
   * Iterate over all the registered interceptors
   *
   * This method is particularly useful for skipping over any
   * interceptors that may have become `null` calling `eject`.
   *
   * @param {Function} fn The function to call for each interceptor
   *
   * @returns {void}
   */
  forEach(t) {
    H.forEach(this.handlers, function(r) {
      r !== null && t(r);
    });
  }
}
const cv = {
  silentJSONParsing: !0,
  forcedJSONParsing: !0,
  clarifyTimeoutError: !1
}, m9 = typeof URLSearchParams < "u" ? URLSearchParams : Qf, b9 = typeof FormData < "u" ? FormData : null, y9 = typeof Blob < "u" ? Blob : null, _9 = {
  isBrowser: !0,
  classes: {
    URLSearchParams: m9,
    FormData: b9,
    Blob: y9
  },
  protocols: ["http", "https", "file", "blob", "url", "data"]
}, ep = typeof window < "u" && typeof document < "u", Ad = typeof navigator == "object" && navigator || void 0, v9 = ep && (!Ad || ["ReactNative", "NativeScript", "NS"].indexOf(Ad.product) < 0), x9 = typeof WorkerGlobalScope < "u" && // eslint-disable-next-line no-undef
self instanceof WorkerGlobalScope && typeof self.importScripts == "function", E9 = ep && window.location.href || "http://localhost", w9 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  hasBrowserEnv: ep,
  hasStandardBrowserEnv: v9,
  hasStandardBrowserWebWorkerEnv: x9,
  navigator: Ad,
  origin: E9
}, Symbol.toStringTag, { value: "Module" })), Xt = {
  ...w9,
  ..._9
};
function C9(e, t) {
  return yc(e, new Xt.classes.URLSearchParams(), Object.assign({
    visitor: function(n, r, i, a) {
      return Xt.isNode && H.isBuffer(n) ? (this.append(r, n.toString("base64")), !1) : a.defaultVisitor.apply(this, arguments);
    }
  }, t));
}
function I9(e) {
  return H.matchAll(/\w+|\[(\w*)]/g, e).map((t) => t[0] === "[]" ? "" : t[1] || t[0]);
}
function S9(e) {
  const t = {}, n = Object.keys(e);
  let r;
  const i = n.length;
  let a;
  for (r = 0; r < i; r++)
    a = n[r], t[a] = e[a];
  return t;
}
function uv(e) {
  function t(n, r, i, a) {
    let s = n[a++];
    if (s === "__proto__") return !0;
    const o = Number.isFinite(+s), l = a >= n.length;
    return s = !s && H.isArray(i) ? i.length : s, l ? (H.hasOwnProp(i, s) ? i[s] = [i[s], r] : i[s] = r, !o) : ((!i[s] || !H.isObject(i[s])) && (i[s] = []), t(n, r, i[s], a) && H.isArray(i[s]) && (i[s] = S9(i[s])), !o);
  }
  if (H.isFormData(e) && H.isFunction(e.entries)) {
    const n = {};
    return H.forEachEntry(e, (r, i) => {
      t(I9(r), i, n, 0);
    }), n;
  }
  return null;
}
function A9(e, t, n) {
  if (H.isString(e))
    try {
      return (t || JSON.parse)(e), H.trim(e);
    } catch (r) {
      if (r.name !== "SyntaxError")
        throw r;
    }
  return (n || JSON.stringify)(e);
}
const io = {
  transitional: cv,
  adapter: ["xhr", "http", "fetch"],
  transformRequest: [function(t, n) {
    const r = n.getContentType() || "", i = r.indexOf("application/json") > -1, a = H.isObject(t);
    if (a && H.isHTMLForm(t) && (t = new FormData(t)), H.isFormData(t))
      return i ? JSON.stringify(uv(t)) : t;
    if (H.isArrayBuffer(t) || H.isBuffer(t) || H.isStream(t) || H.isFile(t) || H.isBlob(t) || H.isReadableStream(t))
      return t;
    if (H.isArrayBufferView(t))
      return t.buffer;
    if (H.isURLSearchParams(t))
      return n.setContentType("application/x-www-form-urlencoded;charset=utf-8", !1), t.toString();
    let o;
    if (a) {
      if (r.indexOf("application/x-www-form-urlencoded") > -1)
        return C9(t, this.formSerializer).toString();
      if ((o = H.isFileList(t)) || r.indexOf("multipart/form-data") > -1) {
        const l = this.env && this.env.FormData;
        return yc(
          o ? { "files[]": t } : t,
          l && new l(),
          this.formSerializer
        );
      }
    }
    return a || i ? (n.setContentType("application/json", !1), A9(t)) : t;
  }],
  transformResponse: [function(t) {
    const n = this.transitional || io.transitional, r = n && n.forcedJSONParsing, i = this.responseType === "json";
    if (H.isResponse(t) || H.isReadableStream(t))
      return t;
    if (t && H.isString(t) && (r && !this.responseType || i)) {
      const s = !(n && n.silentJSONParsing) && i;
      try {
        return JSON.parse(t);
      } catch (o) {
        if (s)
          throw o.name === "SyntaxError" ? Ne.from(o, Ne.ERR_BAD_RESPONSE, this, null, this.response) : o;
      }
    }
    return t;
  }],
  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,
  xsrfCookieName: "XSRF-TOKEN",
  xsrfHeaderName: "X-XSRF-TOKEN",
  maxContentLength: -1,
  maxBodyLength: -1,
  env: {
    FormData: Xt.classes.FormData,
    Blob: Xt.classes.Blob
  },
  validateStatus: function(t) {
    return t >= 200 && t < 300;
  },
  headers: {
    common: {
      Accept: "application/json, text/plain, */*",
      "Content-Type": void 0
    }
  }
};
H.forEach(["delete", "get", "head", "post", "put", "patch"], (e) => {
  io.headers[e] = {};
});
const k9 = H.toObjectSet([
  "age",
  "authorization",
  "content-length",
  "content-type",
  "etag",
  "expires",
  "from",
  "host",
  "if-modified-since",
  "if-unmodified-since",
  "last-modified",
  "location",
  "max-forwards",
  "proxy-authorization",
  "referer",
  "retry-after",
  "user-agent"
]), T9 = (e) => {
  const t = {};
  let n, r, i;
  return e && e.split(`
`).forEach(function(s) {
    i = s.indexOf(":"), n = s.substring(0, i).trim().toLowerCase(), r = s.substring(i + 1).trim(), !(!n || t[n] && k9[n]) && (n === "set-cookie" ? t[n] ? t[n].push(r) : t[n] = [r] : t[n] = t[n] ? t[n] + ", " + r : r);
  }), t;
}, nm = Symbol("internals");
function Qa(e) {
  return e && String(e).trim().toLowerCase();
}
function Uo(e) {
  return e === !1 || e == null ? e : H.isArray(e) ? e.map(Uo) : String(e);
}
function R9(e) {
  const t = /* @__PURE__ */ Object.create(null), n = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
  let r;
  for (; r = n.exec(e); )
    t[r[1]] = r[2];
  return t;
}
const N9 = (e) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(e.trim());
function Su(e, t, n, r, i) {
  if (H.isFunction(r))
    return r.call(this, t, n);
  if (i && (t = n), !!H.isString(t)) {
    if (H.isString(r))
      return t.indexOf(r) !== -1;
    if (H.isRegExp(r))
      return r.test(t);
  }
}
function O9(e) {
  return e.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (t, n, r) => n.toUpperCase() + r);
}
function M9(e, t) {
  const n = H.toCamelCase(" " + t);
  ["get", "set", "has"].forEach((r) => {
    Object.defineProperty(e, r + n, {
      value: function(i, a, s) {
        return this[r].call(this, t, i, a, s);
      },
      configurable: !0
    });
  });
}
let vn = class {
  constructor(t) {
    t && this.set(t);
  }
  set(t, n, r) {
    const i = this;
    function a(o, l, c) {
      const u = Qa(l);
      if (!u)
        throw new Error("header name must be a non-empty string");
      const d = H.findKey(i, u);
      (!d || i[d] === void 0 || c === !0 || c === void 0 && i[d] !== !1) && (i[d || l] = Uo(o));
    }
    const s = (o, l) => H.forEach(o, (c, u) => a(c, u, l));
    if (H.isPlainObject(t) || t instanceof this.constructor)
      s(t, n);
    else if (H.isString(t) && (t = t.trim()) && !N9(t))
      s(T9(t), n);
    else if (H.isHeaders(t))
      for (const [o, l] of t.entries())
        a(l, o, r);
    else
      t != null && a(n, t, r);
    return this;
  }
  get(t, n) {
    if (t = Qa(t), t) {
      const r = H.findKey(this, t);
      if (r) {
        const i = this[r];
        if (!n)
          return i;
        if (n === !0)
          return R9(i);
        if (H.isFunction(n))
          return n.call(this, i, r);
        if (H.isRegExp(n))
          return n.exec(i);
        throw new TypeError("parser must be boolean|regexp|function");
      }
    }
  }
  has(t, n) {
    if (t = Qa(t), t) {
      const r = H.findKey(this, t);
      return !!(r && this[r] !== void 0 && (!n || Su(this, this[r], r, n)));
    }
    return !1;
  }
  delete(t, n) {
    const r = this;
    let i = !1;
    function a(s) {
      if (s = Qa(s), s) {
        const o = H.findKey(r, s);
        o && (!n || Su(r, r[o], o, n)) && (delete r[o], i = !0);
      }
    }
    return H.isArray(t) ? t.forEach(a) : a(t), i;
  }
  clear(t) {
    const n = Object.keys(this);
    let r = n.length, i = !1;
    for (; r--; ) {
      const a = n[r];
      (!t || Su(this, this[a], a, t, !0)) && (delete this[a], i = !0);
    }
    return i;
  }
  normalize(t) {
    const n = this, r = {};
    return H.forEach(this, (i, a) => {
      const s = H.findKey(r, a);
      if (s) {
        n[s] = Uo(i), delete n[a];
        return;
      }
      const o = t ? O9(a) : String(a).trim();
      o !== a && delete n[a], n[o] = Uo(i), r[o] = !0;
    }), this;
  }
  concat(...t) {
    return this.constructor.concat(this, ...t);
  }
  toJSON(t) {
    const n = /* @__PURE__ */ Object.create(null);
    return H.forEach(this, (r, i) => {
      r != null && r !== !1 && (n[i] = t && H.isArray(r) ? r.join(", ") : r);
    }), n;
  }
  [Symbol.iterator]() {
    return Object.entries(this.toJSON())[Symbol.iterator]();
  }
  toString() {
    return Object.entries(this.toJSON()).map(([t, n]) => t + ": " + n).join(`
`);
  }
  get [Symbol.toStringTag]() {
    return "AxiosHeaders";
  }
  static from(t) {
    return t instanceof this ? t : new this(t);
  }
  static concat(t, ...n) {
    const r = new this(t);
    return n.forEach((i) => r.set(i)), r;
  }
  static accessor(t) {
    const r = (this[nm] = this[nm] = {
      accessors: {}
    }).accessors, i = this.prototype;
    function a(s) {
      const o = Qa(s);
      r[o] || (M9(i, s), r[o] = !0);
    }
    return H.isArray(t) ? t.forEach(a) : a(t), this;
  }
};
vn.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
H.reduceDescriptors(vn.prototype, ({ value: e }, t) => {
  let n = t[0].toUpperCase() + t.slice(1);
  return {
    get: () => e,
    set(r) {
      this[n] = r;
    }
  };
});
H.freezeMethods(vn);
function Au(e, t) {
  const n = this || io, r = t || n, i = vn.from(r.headers);
  let a = r.data;
  return H.forEach(e, function(o) {
    a = o.call(n, a, i.normalize(), t ? t.status : void 0);
  }), i.normalize(), a;
}
function dv(e) {
  return !!(e && e.__CANCEL__);
}
function Fa(e, t, n) {
  Ne.call(this, e ?? "canceled", Ne.ERR_CANCELED, t, n), this.name = "CanceledError";
}
H.inherits(Fa, Ne, {
  __CANCEL__: !0
});
function fv(e, t, n) {
  const r = n.config.validateStatus;
  !n.status || !r || r(n.status) ? e(n) : t(new Ne(
    "Request failed with status code " + n.status,
    [Ne.ERR_BAD_REQUEST, Ne.ERR_BAD_RESPONSE][Math.floor(n.status / 100) - 4],
    n.config,
    n.request,
    n
  ));
}
function P9(e) {
  const t = /^([-+\w]{1,25})(:?\/\/|:)/.exec(e);
  return t && t[1] || "";
}
function D9(e, t) {
  e = e || 10;
  const n = new Array(e), r = new Array(e);
  let i = 0, a = 0, s;
  return t = t !== void 0 ? t : 1e3, function(l) {
    const c = Date.now(), u = r[a];
    s || (s = c), n[i] = l, r[i] = c;
    let d = a, f = 0;
    for (; d !== i; )
      f += n[d++], d = d % e;
    if (i = (i + 1) % e, i === a && (a = (a + 1) % e), c - s < t)
      return;
    const p = u && c - u;
    return p ? Math.round(f * 1e3 / p) : void 0;
  };
}
function L9(e, t) {
  let n = 0, r = 1e3 / t, i, a;
  const s = (c, u = Date.now()) => {
    n = u, i = null, a && (clearTimeout(a), a = null), e.apply(null, c);
  };
  return [(...c) => {
    const u = Date.now(), d = u - n;
    d >= r ? s(c, u) : (i = c, a || (a = setTimeout(() => {
      a = null, s(i);
    }, r - d)));
  }, () => i && s(i)];
}
const Dl = (e, t, n = 3) => {
  let r = 0;
  const i = D9(50, 250);
  return L9((a) => {
    const s = a.loaded, o = a.lengthComputable ? a.total : void 0, l = s - r, c = i(l), u = s <= o;
    r = s;
    const d = {
      loaded: s,
      total: o,
      progress: o ? s / o : void 0,
      bytes: l,
      rate: c || void 0,
      estimated: c && o && u ? (o - s) / c : void 0,
      event: a,
      lengthComputable: o != null,
      [t ? "download" : "upload"]: !0
    };
    e(d);
  }, n);
}, rm = (e, t) => {
  const n = e != null;
  return [(r) => t[0]({
    lengthComputable: n,
    total: e,
    loaded: r
  }), t[1]];
}, im = (e) => (...t) => H.asap(() => e(...t)), F9 = Xt.hasStandardBrowserEnv ? /* @__PURE__ */ ((e, t) => (n) => (n = new URL(n, Xt.origin), e.protocol === n.protocol && e.host === n.host && (t || e.port === n.port)))(
  new URL(Xt.origin),
  Xt.navigator && /(msie|trident)/i.test(Xt.navigator.userAgent)
) : () => !0, B9 = Xt.hasStandardBrowserEnv ? (
  // Standard browser envs support document.cookie
  {
    write(e, t, n, r, i, a) {
      const s = [e + "=" + encodeURIComponent(t)];
      H.isNumber(n) && s.push("expires=" + new Date(n).toGMTString()), H.isString(r) && s.push("path=" + r), H.isString(i) && s.push("domain=" + i), a === !0 && s.push("secure"), document.cookie = s.join("; ");
    },
    read(e) {
      const t = document.cookie.match(new RegExp("(^|;\\s*)(" + e + ")=([^;]*)"));
      return t ? decodeURIComponent(t[3]) : null;
    },
    remove(e) {
      this.write(e, "", Date.now() - 864e5);
    }
  }
) : (
  // Non-standard browser env (web workers, react-native) lack needed support.
  {
    write() {
    },
    read() {
      return null;
    },
    remove() {
    }
  }
);
function z9(e) {
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(e);
}
function V9(e, t) {
  return t ? e.replace(/\/?\/$/, "") + "/" + t.replace(/^\/+/, "") : e;
}
function pv(e, t) {
  return e && !z9(t) ? V9(e, t) : t;
}
const am = (e) => e instanceof vn ? { ...e } : e;
function Di(e, t) {
  t = t || {};
  const n = {};
  function r(c, u, d, f) {
    return H.isPlainObject(c) && H.isPlainObject(u) ? H.merge.call({ caseless: f }, c, u) : H.isPlainObject(u) ? H.merge({}, u) : H.isArray(u) ? u.slice() : u;
  }
  function i(c, u, d, f) {
    if (H.isUndefined(u)) {
      if (!H.isUndefined(c))
        return r(void 0, c, d, f);
    } else return r(c, u, d, f);
  }
  function a(c, u) {
    if (!H.isUndefined(u))
      return r(void 0, u);
  }
  function s(c, u) {
    if (H.isUndefined(u)) {
      if (!H.isUndefined(c))
        return r(void 0, c);
    } else return r(void 0, u);
  }
  function o(c, u, d) {
    if (d in t)
      return r(c, u);
    if (d in e)
      return r(void 0, c);
  }
  const l = {
    url: a,
    method: a,
    data: a,
    baseURL: s,
    transformRequest: s,
    transformResponse: s,
    paramsSerializer: s,
    timeout: s,
    timeoutMessage: s,
    withCredentials: s,
    withXSRFToken: s,
    adapter: s,
    responseType: s,
    xsrfCookieName: s,
    xsrfHeaderName: s,
    onUploadProgress: s,
    onDownloadProgress: s,
    decompress: s,
    maxContentLength: s,
    maxBodyLength: s,
    beforeRedirect: s,
    transport: s,
    httpAgent: s,
    httpsAgent: s,
    cancelToken: s,
    socketPath: s,
    responseEncoding: s,
    validateStatus: o,
    headers: (c, u, d) => i(am(c), am(u), d, !0)
  };
  return H.forEach(Object.keys(Object.assign({}, e, t)), function(u) {
    const d = l[u] || i, f = d(e[u], t[u], u);
    H.isUndefined(f) && d !== o || (n[u] = f);
  }), n;
}
const hv = (e) => {
  const t = Di({}, e);
  let { data: n, withXSRFToken: r, xsrfHeaderName: i, xsrfCookieName: a, headers: s, auth: o } = t;
  t.headers = s = vn.from(s), t.url = lv(pv(t.baseURL, t.url), e.params, e.paramsSerializer), o && s.set(
    "Authorization",
    "Basic " + btoa((o.username || "") + ":" + (o.password ? unescape(encodeURIComponent(o.password)) : ""))
  );
  let l;
  if (H.isFormData(n)) {
    if (Xt.hasStandardBrowserEnv || Xt.hasStandardBrowserWebWorkerEnv)
      s.setContentType(void 0);
    else if ((l = s.getContentType()) !== !1) {
      const [c, ...u] = l ? l.split(";").map((d) => d.trim()).filter(Boolean) : [];
      s.setContentType([c || "multipart/form-data", ...u].join("; "));
    }
  }
  if (Xt.hasStandardBrowserEnv && (r && H.isFunction(r) && (r = r(t)), r || r !== !1 && F9(t.url))) {
    const c = i && a && B9.read(a);
    c && s.set(i, c);
  }
  return t;
}, G9 = typeof XMLHttpRequest < "u", j9 = G9 && function(e) {
  return new Promise(function(n, r) {
    const i = hv(e);
    let a = i.data;
    const s = vn.from(i.headers).normalize();
    let { responseType: o, onUploadProgress: l, onDownloadProgress: c } = i, u, d, f, p, h;
    function g() {
      p && p(), h && h(), i.cancelToken && i.cancelToken.unsubscribe(u), i.signal && i.signal.removeEventListener("abort", u);
    }
    let m = new XMLHttpRequest();
    m.open(i.method.toUpperCase(), i.url, !0), m.timeout = i.timeout;
    function b() {
      if (!m)
        return;
      const v = vn.from(
        "getAllResponseHeaders" in m && m.getAllResponseHeaders()
      ), _ = {
        data: !o || o === "text" || o === "json" ? m.responseText : m.response,
        status: m.status,
        statusText: m.statusText,
        headers: v,
        config: e,
        request: m
      };
      fv(function(I) {
        n(I), g();
      }, function(I) {
        r(I), g();
      }, _), m = null;
    }
    "onloadend" in m ? m.onloadend = b : m.onreadystatechange = function() {
      !m || m.readyState !== 4 || m.status === 0 && !(m.responseURL && m.responseURL.indexOf("file:") === 0) || setTimeout(b);
    }, m.onabort = function() {
      m && (r(new Ne("Request aborted", Ne.ECONNABORTED, e, m)), m = null);
    }, m.onerror = function() {
      r(new Ne("Network Error", Ne.ERR_NETWORK, e, m)), m = null;
    }, m.ontimeout = function() {
      let E = i.timeout ? "timeout of " + i.timeout + "ms exceeded" : "timeout exceeded";
      const _ = i.transitional || cv;
      i.timeoutErrorMessage && (E = i.timeoutErrorMessage), r(new Ne(
        E,
        _.clarifyTimeoutError ? Ne.ETIMEDOUT : Ne.ECONNABORTED,
        e,
        m
      )), m = null;
    }, a === void 0 && s.setContentType(null), "setRequestHeader" in m && H.forEach(s.toJSON(), function(E, _) {
      m.setRequestHeader(_, E);
    }), H.isUndefined(i.withCredentials) || (m.withCredentials = !!i.withCredentials), o && o !== "json" && (m.responseType = i.responseType), c && ([f, h] = Dl(c, !0), m.addEventListener("progress", f)), l && m.upload && ([d, p] = Dl(l), m.upload.addEventListener("progress", d), m.upload.addEventListener("loadend", p)), (i.cancelToken || i.signal) && (u = (v) => {
      m && (r(!v || v.type ? new Fa(null, e, m) : v), m.abort(), m = null);
    }, i.cancelToken && i.cancelToken.subscribe(u), i.signal && (i.signal.aborted ? u() : i.signal.addEventListener("abort", u)));
    const y = P9(i.url);
    if (y && Xt.protocols.indexOf(y) === -1) {
      r(new Ne("Unsupported protocol " + y + ":", Ne.ERR_BAD_REQUEST, e));
      return;
    }
    m.send(a || null);
  });
}, U9 = (e, t) => {
  const { length: n } = e = e ? e.filter(Boolean) : [];
  if (t || n) {
    let r = new AbortController(), i;
    const a = function(c) {
      if (!i) {
        i = !0, o();
        const u = c instanceof Error ? c : this.reason;
        r.abort(u instanceof Ne ? u : new Fa(u instanceof Error ? u.message : u));
      }
    };
    let s = t && setTimeout(() => {
      s = null, a(new Ne(`timeout ${t} of ms exceeded`, Ne.ETIMEDOUT));
    }, t);
    const o = () => {
      e && (s && clearTimeout(s), s = null, e.forEach((c) => {
        c.unsubscribe ? c.unsubscribe(a) : c.removeEventListener("abort", a);
      }), e = null);
    };
    e.forEach((c) => c.addEventListener("abort", a));
    const { signal: l } = r;
    return l.unsubscribe = () => H.asap(o), l;
  }
}, H9 = function* (e, t) {
  let n = e.byteLength;
  if (n < t) {
    yield e;
    return;
  }
  let r = 0, i;
  for (; r < n; )
    i = r + t, yield e.slice(r, i), r = i;
}, W9 = async function* (e, t) {
  for await (const n of Z9(e))
    yield* H9(n, t);
}, Z9 = async function* (e) {
  if (e[Symbol.asyncIterator]) {
    yield* e;
    return;
  }
  const t = e.getReader();
  try {
    for (; ; ) {
      const { done: n, value: r } = await t.read();
      if (n)
        break;
      yield r;
    }
  } finally {
    await t.cancel();
  }
}, sm = (e, t, n, r) => {
  const i = W9(e, t);
  let a = 0, s, o = (l) => {
    s || (s = !0, r && r(l));
  };
  return new ReadableStream({
    async pull(l) {
      try {
        const { done: c, value: u } = await i.next();
        if (c) {
          o(), l.close();
          return;
        }
        let d = u.byteLength;
        if (n) {
          let f = a += d;
          n(f);
        }
        l.enqueue(new Uint8Array(u));
      } catch (c) {
        throw o(c), c;
      }
    },
    cancel(l) {
      return o(l), i.return();
    }
  }, {
    highWaterMark: 2
  });
}, _c = typeof fetch == "function" && typeof Request == "function" && typeof Response == "function", gv = _c && typeof ReadableStream == "function", $9 = _c && (typeof TextEncoder == "function" ? /* @__PURE__ */ ((e) => (t) => e.encode(t))(new TextEncoder()) : async (e) => new Uint8Array(await new Response(e).arrayBuffer())), mv = (e, ...t) => {
  try {
    return !!e(...t);
  } catch {
    return !1;
  }
}, X9 = gv && mv(() => {
  let e = !1;
  const t = new Request(Xt.origin, {
    body: new ReadableStream(),
    method: "POST",
    get duplex() {
      return e = !0, "half";
    }
  }).headers.has("Content-Type");
  return e && !t;
}), om = 64 * 1024, kd = gv && mv(() => H.isReadableStream(new Response("").body)), Ll = {
  stream: kd && ((e) => e.body)
};
_c && ((e) => {
  ["text", "arrayBuffer", "blob", "formData", "stream"].forEach((t) => {
    !Ll[t] && (Ll[t] = H.isFunction(e[t]) ? (n) => n[t]() : (n, r) => {
      throw new Ne(`Response type '${t}' is not supported`, Ne.ERR_NOT_SUPPORT, r);
    });
  });
})(new Response());
const Y9 = async (e) => {
  if (e == null)
    return 0;
  if (H.isBlob(e))
    return e.size;
  if (H.isSpecCompliantForm(e))
    return (await new Request(Xt.origin, {
      method: "POST",
      body: e
    }).arrayBuffer()).byteLength;
  if (H.isArrayBufferView(e) || H.isArrayBuffer(e))
    return e.byteLength;
  if (H.isURLSearchParams(e) && (e = e + ""), H.isString(e))
    return (await $9(e)).byteLength;
}, J9 = async (e, t) => {
  const n = H.toFiniteNumber(e.getContentLength());
  return n ?? Y9(t);
}, q9 = _c && (async (e) => {
  let {
    url: t,
    method: n,
    data: r,
    signal: i,
    cancelToken: a,
    timeout: s,
    onDownloadProgress: o,
    onUploadProgress: l,
    responseType: c,
    headers: u,
    withCredentials: d = "same-origin",
    fetchOptions: f
  } = hv(e);
  c = c ? (c + "").toLowerCase() : "text";
  let p = U9([i, a && a.toAbortSignal()], s), h;
  const g = p && p.unsubscribe && (() => {
    p.unsubscribe();
  });
  let m;
  try {
    if (l && X9 && n !== "get" && n !== "head" && (m = await J9(u, r)) !== 0) {
      let _ = new Request(t, {
        method: "POST",
        body: r,
        duplex: "half"
      }), x;
      if (H.isFormData(r) && (x = _.headers.get("content-type")) && u.setContentType(x), _.body) {
        const [I, T] = rm(
          m,
          Dl(im(l))
        );
        r = sm(_.body, om, I, T);
      }
    }
    H.isString(d) || (d = d ? "include" : "omit");
    const b = "credentials" in Request.prototype;
    h = new Request(t, {
      ...f,
      signal: p,
      method: n.toUpperCase(),
      headers: u.normalize().toJSON(),
      body: r,
      duplex: "half",
      credentials: b ? d : void 0
    });
    let y = await fetch(h);
    const v = kd && (c === "stream" || c === "response");
    if (kd && (o || v && g)) {
      const _ = {};
      ["status", "statusText", "headers"].forEach((O) => {
        _[O] = y[O];
      });
      const x = H.toFiniteNumber(y.headers.get("content-length")), [I, T] = o && rm(
        x,
        Dl(im(o), !0)
      ) || [];
      y = new Response(
        sm(y.body, om, I, () => {
          T && T(), g && g();
        }),
        _
      );
    }
    c = c || "text";
    let E = await Ll[H.findKey(Ll, c) || "text"](y, e);
    return !v && g && g(), await new Promise((_, x) => {
      fv(_, x, {
        data: E,
        headers: vn.from(y.headers),
        status: y.status,
        statusText: y.statusText,
        config: e,
        request: h
      });
    });
  } catch (b) {
    throw g && g(), b && b.name === "TypeError" && /fetch/i.test(b.message) ? Object.assign(
      new Ne("Network Error", Ne.ERR_NETWORK, e, h),
      {
        cause: b.cause || b
      }
    ) : Ne.from(b, b && b.code, e, h);
  }
}), Td = {
  http: f9,
  xhr: j9,
  fetch: q9
};
H.forEach(Td, (e, t) => {
  if (e) {
    try {
      Object.defineProperty(e, "name", { value: t });
    } catch {
    }
    Object.defineProperty(e, "adapterName", { value: t });
  }
});
const lm = (e) => `- ${e}`, K9 = (e) => H.isFunction(e) || e === null || e === !1, bv = {
  getAdapter: (e) => {
    e = H.isArray(e) ? e : [e];
    const { length: t } = e;
    let n, r;
    const i = {};
    for (let a = 0; a < t; a++) {
      n = e[a];
      let s;
      if (r = n, !K9(n) && (r = Td[(s = String(n)).toLowerCase()], r === void 0))
        throw new Ne(`Unknown adapter '${s}'`);
      if (r)
        break;
      i[s || "#" + a] = r;
    }
    if (!r) {
      const a = Object.entries(i).map(
        ([o, l]) => `adapter ${o} ` + (l === !1 ? "is not supported by the environment" : "is not available in the build")
      );
      let s = t ? a.length > 1 ? `since :
` + a.map(lm).join(`
`) : " " + lm(a[0]) : "as no adapter specified";
      throw new Ne(
        "There is no suitable adapter to dispatch the request " + s,
        "ERR_NOT_SUPPORT"
      );
    }
    return r;
  },
  adapters: Td
};
function ku(e) {
  if (e.cancelToken && e.cancelToken.throwIfRequested(), e.signal && e.signal.aborted)
    throw new Fa(null, e);
}
function cm(e) {
  return ku(e), e.headers = vn.from(e.headers), e.data = Au.call(
    e,
    e.transformRequest
  ), ["post", "put", "patch"].indexOf(e.method) !== -1 && e.headers.setContentType("application/x-www-form-urlencoded", !1), bv.getAdapter(e.adapter || io.adapter)(e).then(function(r) {
    return ku(e), r.data = Au.call(
      e,
      e.transformResponse,
      r
    ), r.headers = vn.from(r.headers), r;
  }, function(r) {
    return dv(r) || (ku(e), r && r.response && (r.response.data = Au.call(
      e,
      e.transformResponse,
      r.response
    ), r.response.headers = vn.from(r.response.headers))), Promise.reject(r);
  });
}
const yv = "1.7.9", vc = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach((e, t) => {
  vc[e] = function(r) {
    return typeof r === e || "a" + (t < 1 ? "n " : " ") + e;
  };
});
const um = {};
vc.transitional = function(t, n, r) {
  function i(a, s) {
    return "[Axios v" + yv + "] Transitional option '" + a + "'" + s + (r ? ". " + r : "");
  }
  return (a, s, o) => {
    if (t === !1)
      throw new Ne(
        i(s, " has been removed" + (n ? " in " + n : "")),
        Ne.ERR_DEPRECATED
      );
    return n && !um[s] && (um[s] = !0, console.warn(
      i(
        s,
        " has been deprecated since v" + n + " and will be removed in the near future"
      )
    )), t ? t(a, s, o) : !0;
  };
};
vc.spelling = function(t) {
  return (n, r) => (console.warn(`${r} is likely a misspelling of ${t}`), !0);
};
function Q9(e, t, n) {
  if (typeof e != "object")
    throw new Ne("options must be an object", Ne.ERR_BAD_OPTION_VALUE);
  const r = Object.keys(e);
  let i = r.length;
  for (; i-- > 0; ) {
    const a = r[i], s = t[a];
    if (s) {
      const o = e[a], l = o === void 0 || s(o, a, e);
      if (l !== !0)
        throw new Ne("option " + a + " must be " + l, Ne.ERR_BAD_OPTION_VALUE);
      continue;
    }
    if (n !== !0)
      throw new Ne("Unknown option " + a, Ne.ERR_BAD_OPTION);
  }
}
const Ho = {
  assertOptions: Q9,
  validators: vc
}, sr = Ho.validators;
let Ii = class {
  constructor(t) {
    this.defaults = t, this.interceptors = {
      request: new tm(),
      response: new tm()
    };
  }
  /**
   * Dispatch a request
   *
   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
   * @param {?Object} config
   *
   * @returns {Promise} The Promise to be fulfilled
   */
  async request(t, n) {
    try {
      return await this._request(t, n);
    } catch (r) {
      if (r instanceof Error) {
        let i = {};
        Error.captureStackTrace ? Error.captureStackTrace(i) : i = new Error();
        const a = i.stack ? i.stack.replace(/^.+\n/, "") : "";
        try {
          r.stack ? a && !String(r.stack).endsWith(a.replace(/^.+\n.+\n/, "")) && (r.stack += `
` + a) : r.stack = a;
        } catch {
        }
      }
      throw r;
    }
  }
  _request(t, n) {
    typeof t == "string" ? (n = n || {}, n.url = t) : n = t || {}, n = Di(this.defaults, n);
    const { transitional: r, paramsSerializer: i, headers: a } = n;
    r !== void 0 && Ho.assertOptions(r, {
      silentJSONParsing: sr.transitional(sr.boolean),
      forcedJSONParsing: sr.transitional(sr.boolean),
      clarifyTimeoutError: sr.transitional(sr.boolean)
    }, !1), i != null && (H.isFunction(i) ? n.paramsSerializer = {
      serialize: i
    } : Ho.assertOptions(i, {
      encode: sr.function,
      serialize: sr.function
    }, !0)), Ho.assertOptions(n, {
      baseUrl: sr.spelling("baseURL"),
      withXsrfToken: sr.spelling("withXSRFToken")
    }, !0), n.method = (n.method || this.defaults.method || "get").toLowerCase();
    let s = a && H.merge(
      a.common,
      a[n.method]
    );
    a && H.forEach(
      ["delete", "get", "head", "post", "put", "patch", "common"],
      (h) => {
        delete a[h];
      }
    ), n.headers = vn.concat(s, a);
    const o = [];
    let l = !0;
    this.interceptors.request.forEach(function(g) {
      typeof g.runWhen == "function" && g.runWhen(n) === !1 || (l = l && g.synchronous, o.unshift(g.fulfilled, g.rejected));
    });
    const c = [];
    this.interceptors.response.forEach(function(g) {
      c.push(g.fulfilled, g.rejected);
    });
    let u, d = 0, f;
    if (!l) {
      const h = [cm.bind(this), void 0];
      for (h.unshift.apply(h, o), h.push.apply(h, c), f = h.length, u = Promise.resolve(n); d < f; )
        u = u.then(h[d++], h[d++]);
      return u;
    }
    f = o.length;
    let p = n;
    for (d = 0; d < f; ) {
      const h = o[d++], g = o[d++];
      try {
        p = h(p);
      } catch (m) {
        g.call(this, m);
        break;
      }
    }
    try {
      u = cm.call(this, p);
    } catch (h) {
      return Promise.reject(h);
    }
    for (d = 0, f = c.length; d < f; )
      u = u.then(c[d++], c[d++]);
    return u;
  }
  getUri(t) {
    t = Di(this.defaults, t);
    const n = pv(t.baseURL, t.url);
    return lv(n, t.params, t.paramsSerializer);
  }
};
H.forEach(["delete", "get", "head", "options"], function(t) {
  Ii.prototype[t] = function(n, r) {
    return this.request(Di(r || {}, {
      method: t,
      url: n,
      data: (r || {}).data
    }));
  };
});
H.forEach(["post", "put", "patch"], function(t) {
  function n(r) {
    return function(a, s, o) {
      return this.request(Di(o || {}, {
        method: t,
        headers: r ? {
          "Content-Type": "multipart/form-data"
        } : {},
        url: a,
        data: s
      }));
    };
  }
  Ii.prototype[t] = n(), Ii.prototype[t + "Form"] = n(!0);
});
let e4 = class _v {
  constructor(t) {
    if (typeof t != "function")
      throw new TypeError("executor must be a function.");
    let n;
    this.promise = new Promise(function(a) {
      n = a;
    });
    const r = this;
    this.promise.then((i) => {
      if (!r._listeners) return;
      let a = r._listeners.length;
      for (; a-- > 0; )
        r._listeners[a](i);
      r._listeners = null;
    }), this.promise.then = (i) => {
      let a;
      const s = new Promise((o) => {
        r.subscribe(o), a = o;
      }).then(i);
      return s.cancel = function() {
        r.unsubscribe(a);
      }, s;
    }, t(function(a, s, o) {
      r.reason || (r.reason = new Fa(a, s, o), n(r.reason));
    });
  }
  /**
   * Throws a `CanceledError` if cancellation has been requested.
   */
  throwIfRequested() {
    if (this.reason)
      throw this.reason;
  }
  /**
   * Subscribe to the cancel signal
   */
  subscribe(t) {
    if (this.reason) {
      t(this.reason);
      return;
    }
    this._listeners ? this._listeners.push(t) : this._listeners = [t];
  }
  /**
   * Unsubscribe from the cancel signal
   */
  unsubscribe(t) {
    if (!this._listeners)
      return;
    const n = this._listeners.indexOf(t);
    n !== -1 && this._listeners.splice(n, 1);
  }
  toAbortSignal() {
    const t = new AbortController(), n = (r) => {
      t.abort(r);
    };
    return this.subscribe(n), t.signal.unsubscribe = () => this.unsubscribe(n), t.signal;
  }
  /**
   * Returns an object that contains a new `CancelToken` and a function that, when called,
   * cancels the `CancelToken`.
   */
  static source() {
    let t;
    return {
      token: new _v(function(i) {
        t = i;
      }),
      cancel: t
    };
  }
};
function t4(e) {
  return function(n) {
    return e.apply(null, n);
  };
}
function n4(e) {
  return H.isObject(e) && e.isAxiosError === !0;
}
const Rd = {
  Continue: 100,
  SwitchingProtocols: 101,
  Processing: 102,
  EarlyHints: 103,
  Ok: 200,
  Created: 201,
  Accepted: 202,
  NonAuthoritativeInformation: 203,
  NoContent: 204,
  ResetContent: 205,
  PartialContent: 206,
  MultiStatus: 207,
  AlreadyReported: 208,
  ImUsed: 226,
  MultipleChoices: 300,
  MovedPermanently: 301,
  Found: 302,
  SeeOther: 303,
  NotModified: 304,
  UseProxy: 305,
  Unused: 306,
  TemporaryRedirect: 307,
  PermanentRedirect: 308,
  BadRequest: 400,
  Unauthorized: 401,
  PaymentRequired: 402,
  Forbidden: 403,
  NotFound: 404,
  MethodNotAllowed: 405,
  NotAcceptable: 406,
  ProxyAuthenticationRequired: 407,
  RequestTimeout: 408,
  Conflict: 409,
  Gone: 410,
  LengthRequired: 411,
  PreconditionFailed: 412,
  PayloadTooLarge: 413,
  UriTooLong: 414,
  UnsupportedMediaType: 415,
  RangeNotSatisfiable: 416,
  ExpectationFailed: 417,
  ImATeapot: 418,
  MisdirectedRequest: 421,
  UnprocessableEntity: 422,
  Locked: 423,
  FailedDependency: 424,
  TooEarly: 425,
  UpgradeRequired: 426,
  PreconditionRequired: 428,
  TooManyRequests: 429,
  RequestHeaderFieldsTooLarge: 431,
  UnavailableForLegalReasons: 451,
  InternalServerError: 500,
  NotImplemented: 501,
  BadGateway: 502,
  ServiceUnavailable: 503,
  GatewayTimeout: 504,
  HttpVersionNotSupported: 505,
  VariantAlsoNegotiates: 506,
  InsufficientStorage: 507,
  LoopDetected: 508,
  NotExtended: 510,
  NetworkAuthenticationRequired: 511
};
Object.entries(Rd).forEach(([e, t]) => {
  Rd[t] = e;
});
function vv(e) {
  const t = new Ii(e), n = J0(Ii.prototype.request, t);
  return H.extend(n, Ii.prototype, t, { allOwnKeys: !0 }), H.extend(n, t, null, { allOwnKeys: !0 }), n.create = function(i) {
    return vv(Di(e, i));
  }, n;
}
const dt = vv(io);
dt.Axios = Ii;
dt.CanceledError = Fa;
dt.CancelToken = e4;
dt.isCancel = dv;
dt.VERSION = yv;
dt.toFormData = yc;
dt.AxiosError = Ne;
dt.Cancel = dt.CanceledError;
dt.all = function(t) {
  return Promise.all(t);
};
dt.spread = t4;
dt.isAxiosError = n4;
dt.mergeConfig = Di;
dt.AxiosHeaders = vn;
dt.formToJSON = (e) => uv(H.isHTMLForm(e) ? new FormData(e) : e);
dt.getAdapter = bv.getAdapter;
dt.HttpStatusCode = Rd;
dt.default = dt;
const {
  Axios: w4,
  AxiosError: C4,
  CanceledError: I4,
  isCancel: S4,
  CancelToken: A4,
  VERSION: k4,
  all: T4,
  Cancel: R4,
  isAxiosError: N4,
  spread: O4,
  toFormData: M4,
  AxiosHeaders: P4,
  HttpStatusCode: D4,
  formToJSON: L4,
  getAdapter: F4,
  mergeConfig: B4
} = dt;
async function tp(e) {
  var t, n;
  try {
    return await e();
  } catch (r) {
    const i = r;
    throw (t = i.response) != null && t.data ? {
      status: i.response.data.status,
      message: i.response.data.message
    } : i.status === 500 && !((n = i.response) != null && n.data) ? i.name === "AxiosError" ? {
      status: "Errore",
      message: "Servizi non raggiungibili"
    } : {
      status: "Errore",
      message: "Errore sconosciuto"
    } : {
      status: i.status,
      message: i.message
    };
  }
}
async function r4(e) {
  return await tp(
    async () => (await dt.post(
      "undefined/auth/register",
      e
    )).data
  );
}
async function i4(e) {
  return await tp(
    async () => (await dt.post("undefined/auth/login", e)).data
  );
}
async function a4(e) {
  return await tp(
    async () => (await dt.post("undefined/auth/refresh", e)).data
  );
}
const Wo = qf(
  "slice/auth/doRegister",
  async (e, { rejectWithValue: t }) => r4(e).then((n) => n).catch((n) => t(n))
), Zo = qf(
  "slice/auth/doLogin",
  async (e, { rejectWithValue: t }) => i4(e).then((n) => n).catch((n) => t(n))
), $o = qf(
  "slice/auth/doRefresh",
  async (e, { rejectWithValue: t }) => a4(e).then((n) => n).catch((n) => t(n))
);
var an = /* @__PURE__ */ ((e) => (e[e.IDLE = 0] = "IDLE", e[e.LOADING = 1] = "LOADING", e[e.SUCCESS = 2] = "SUCCESS", e[e.FAILED = 3] = "FAILED", e))(an || {});
const s4 = {
  accessToken: localStorage.getItem("accessToken") || void 0,
  refreshToken: localStorage.getItem("refreshToken") || void 0,
  login: {
    status: an.IDLE,
    error: void 0
  },
  register: {
    status: an.IDLE,
    error: void 0
  }
}, o4 = {
  clearErrorsRegister: (e) => {
    e.register.status = an.IDLE, e.register.error = void 0;
  },
  clearErrorsLogin: (e) => {
    e.login.status = an.IDLE, e.login.error = void 0;
  }
}, l4 = (e) => e.addCase(Zo.pending, (t) => {
  t.login.status = an.LOADING;
}).addCase(Zo.fulfilled, (t, n) => {
  t.login.status = an.SUCCESS;
  const { accessToken: r, refreshToken: i } = n.payload;
  t.accessToken = r, t.refreshToken = i, localStorage.setItem("accessToken", r), localStorage.setItem("refreshToken", i);
}).addCase(Zo.rejected, (t, n) => {
  t.login.status = an.FAILED, t.login.error = n.payload;
}).addCase(Wo.pending, (t) => {
  t.register.status = an.LOADING;
}).addCase(Wo.fulfilled, (t, n) => {
  t.register.status = an.SUCCESS;
  const { accessToken: r, refreshToken: i } = n.payload;
  t.accessToken = r, t.refreshToken = i, localStorage.setItem("accessToken", r), localStorage.setItem("refreshToken", i);
}).addCase(Wo.rejected, (t, n) => {
  t.register.status = an.FAILED, t.register.error = n.payload;
}).addCase($o.pending, (t) => {
  t.register.status = an.LOADING;
}).addCase($o.fulfilled, (t, n) => {
  t.register.status = an.SUCCESS;
  const { accessToken: r, refreshToken: i } = n.payload;
  t.accessToken = r, t.refreshToken = i, localStorage.setItem("accessToken", r), localStorage.setItem("refreshToken", i);
}).addCase($o.rejected, (t, n) => {
  t.register.status = an.FAILED, t.register.error = n.payload;
}), xv = xB({
  name: "slice/auth",
  initialState: s4,
  reducers: o4,
  extraReducers: l4
}), c4 = xv.actions, u4 = {
  doRegister: Wo,
  doLogin: Zo,
  doRefresh: $o
}, d4 = xv.reducer, f4 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  authActions: c4,
  authAsyncActions: u4,
  authSlice: d4
}, Symbol.toStringTag, { value: "Module" })), z4 = { auth: f4, STATUS: an };
export {
  b4 as components,
  v4 as hocs,
  y4 as layouts,
  _4 as providers,
  z4 as store
};
//# sourceMappingURL=react-goblin-system.es.js.map
